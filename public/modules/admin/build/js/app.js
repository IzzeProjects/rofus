/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js?!./src/js/components/LoginForm.vue?vue&type=script&lang=js&":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/LoginForm.vue?vue&type=script&lang=js& ***!
  \****************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: \"LoginForm\",\n  props: ['method', 'route', 'serverErrors', 'inputs'],\n  data: function data() {\n    return {\n      email: null,\n      password: null,\n      token: document.querySelector('meta[name=\"csrf-token\"]').getAttribute('content')\n    };\n  },\n  mounted: function mounted() {\n    this.email = this.inputsJsonParse.email;\n    this.$validator.pause();\n  },\n  methods: {\n    checkForm: function checkForm(e) {\n      this.$validator.resume();\n      this.$validator.validateAll().then(function (result) {\n        if (result) {\n          return;\n        }\n\n        e.preventDefault();\n      });\n    }\n  },\n  computed: {\n    errorsJsonParse: function errorsJsonParse() {\n      return JSON.parse(this.serverErrors);\n    },\n    inputsJsonParse: function inputsJsonParse() {\n      return JSON.parse(this.inputs);\n    }\n  }\n});\n\n//# sourceURL=webpack:///./src/js/components/LoginForm.vue?./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js?!./src/js/components/form/File.vue?vue&type=script&lang=js&":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/form/File.vue?vue&type=script&lang=js& ***!
  \****************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n//\n//\n//\n//\n//\n//\n//\n//\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: \"File\",\n  props: ['name', 'default'],\n  data: function data() {\n    return {\n      fileUrl: this[\"default\"] ? this[\"default\"] : '',\n      fileName: ''\n    };\n  },\n  methods: {\n    lfm: function lfm(options, cb) {\n      var route_prefix = options && options.prefix ? options.prefix : '/laravel-filemanager';\n      window.open(route_prefix + '?type=' + options.type || 'file', 'FileManager', 'width=1200,height=900');\n      window.SetUrl = cb;\n    },\n    openManager: function openManager() {\n      var _this = this;\n\n      this.lfm({\n        type: 'image'\n      }, function (url, path) {\n        _this.fileUrl = url[0].url;\n        _this.fileName = url[0].name;\n      });\n    }\n  },\n  computed: {\n    url: function url() {\n      return this.fileUrl ? this.fileUrl.replace(/^.*\\/\\/[^\\/]+/, '') : '';\n    }\n  }\n});\n\n//# sourceURL=webpack:///./src/js/components/form/File.vue?./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js?!./src/js/components/form/ImageIterator.vue?vue&type=script&lang=js&":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/form/ImageIterator.vue?vue&type=script&lang=js& ***!
  \*************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _File__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./File */ \"./src/js/components/form/File.vue\");\n/* harmony import */ var vuedraggable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vuedraggable */ \"./node_modules/vuedraggable/dist/vuedraggable.common.js\");\n/* harmony import */ var vuedraggable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(vuedraggable__WEBPACK_IMPORTED_MODULE_1__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  components: {\n    File: _File__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n    draggable: vuedraggable__WEBPACK_IMPORTED_MODULE_1___default.a\n  },\n  props: ['default'],\n  data: function data() {\n    return {\n      images: JSON.parse(this[\"default\"]),\n      currentIndex: 1\n    };\n  },\n  methods: {\n    addIterate: function addIterate() {\n      this.currentIndex++;\n      this.images.push({\n        id: this.currentIndex\n      });\n    },\n    removeIterate: function removeIterate(index) {\n      this.images.splice(index, 1);\n    }\n  },\n  mounted: function mounted() {\n    if (this.images.length > 0) this.currentIndex = Math.max.apply(Math, this.images.map(function (o) {\n      return o.id;\n    }));\n  },\n  name: \"ImageIterator\"\n});\n\n//# sourceURL=webpack:///./src/js/components/form/ImageIterator.vue?./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js?!./src/js/components/form/MultiSelect.vue?vue&type=script&lang=js&":
/*!***********************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/form/MultiSelect.vue?vue&type=script&lang=js& ***!
  \***********************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue_search_select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue-search-select */ \"./node_modules/vue-search-select/publish/vue-search-select.js\");\n/* harmony import */ var vue_search_select__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue_search_select__WEBPACK_IMPORTED_MODULE_0__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  props: ['items', 'value', 'text', 'name', 'default'],\n  data: function data() {\n    return {\n      data: JSON.parse(this.items),\n      searchText: '',\n      selectedItems: [],\n      lastSelectItem: {}\n    };\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    if (this[\"default\"]) {\n      (function () {\n        var def = JSON.parse(_this[\"default\"]);\n\n        if (Array.isArray(def)) {\n          var _loop = function _loop(key) {\n            console.log(def[key]);\n\n            var found = _this.data.filter(function (obj) {\n              return obj[_this.value] == def[key];\n            })[0];\n\n            if (found) {\n              _this.selectedItems.push(found);\n            }\n          };\n\n          for (var key in def) {\n            _loop(key);\n          }\n        } else {\n          _this.selectedItems.push(def);\n        }\n      })();\n    }\n  },\n  methods: {\n    onSelect: function onSelect(items, lastSelectItem) {\n      this.selectedItems = items;\n      this.lastSelectItem = lastSelectItem;\n    }\n  },\n  components: {\n    MultiListSelect: vue_search_select__WEBPACK_IMPORTED_MODULE_0__[\"MultiListSelect\"]\n  }\n});\n\n//# sourceURL=webpack:///./src/js/components/form/MultiSelect.vue?./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js?!./src/js/components/form/Select.vue?vue&type=script&lang=js&":
/*!******************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/form/Select.vue?vue&type=script&lang=js& ***!
  \******************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue_search_select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue-search-select */ \"./node_modules/vue-search-select/publish/vue-search-select.js\");\n/* harmony import */ var vue_search_select__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue_search_select__WEBPACK_IMPORTED_MODULE_0__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  props: ['items', 'value', 'text', 'name', 'default'],\n  data: function data() {\n    return {\n      data: JSON.parse(this.items),\n      objectItem: {}\n    };\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    this.objectItem = this.data[0];\n\n    if (this[\"default\"]) {\n      this.objectItem = this.data.filter(function (obj) {\n        return obj[_this.value] == _this[\"default\"];\n      })[0];\n    }\n  },\n  components: {\n    ModelListSelect: vue_search_select__WEBPACK_IMPORTED_MODULE_0__[\"ModelListSelect\"]\n  }\n});\n\n//# sourceURL=webpack:///./src/js/components/form/Select.vue?./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : undefined\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n\n\n//# sourceURL=webpack:///./node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/sortablejs/Sortable.js":
/*!*********************************************!*\
  !*** ./node_modules/sortablejs/Sortable.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**!\n * Sortable\n * @author\tRubaXa   <trash@rubaxa.org>\n * @author\towenm    <owen23355@gmail.com>\n * @license MIT\n */\n\n(function sortableModule(factory) {\n\t\"use strict\";\n\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse {}\n})(function sortableFactory() {\n\t\"use strict\";\n\n\tif (typeof window === \"undefined\" || !window.document) {\n\t\treturn function sortableError() {\n\t\t\tthrow new Error(\"Sortable.js requires a window with a document\");\n\t\t};\n\t}\n\n\tvar dragEl,\n\t\tparentEl,\n\t\tghostEl,\n\t\tcloneEl,\n\t\trootEl,\n\t\tnextEl,\n\t\tlastDownEl,\n\n\t\tscrollEl,\n\t\tscrollParentEl,\n\t\tscrollCustomFn,\n\n\t\toldIndex,\n\t\tnewIndex,\n\t\toldDraggableIndex,\n\t\tnewDraggableIndex,\n\n\t\tactiveGroup,\n\t\tputSortable,\n\n\t\tautoScrolls = [],\n\t\tscrolling = false,\n\n\t\tawaitingDragStarted = false,\n\t\tignoreNextClick = false,\n\t\tsortables = [],\n\n\t\tpointerElemChangedInterval,\n\t\tlastPointerElemX,\n\t\tlastPointerElemY,\n\n\t\ttapEvt,\n\t\ttouchEvt,\n\n\t\tmoved,\n\n\n\t\tlastTarget,\n\t\tlastDirection,\n\t\tpastFirstInvertThresh = false,\n\t\tisCircumstantialInvert = false,\n\t\tlastMode, // 'swap' or 'insert'\n\n\t\ttargetMoveDistance,\n\n\t\t// For positioning ghost absolutely\n\t\tghostRelativeParent,\n\t\tghostRelativeParentInitialScroll = [], // (left, top)\n\n\t\trealDragElRect, // dragEl rect after current animation\n\n\t\t/** @const */\n\t\tR_SPACE = /\\s+/g,\n\n\t\texpando = 'Sortable' + (new Date).getTime(),\n\n\t\twin = window,\n\t\tdocument = win.document,\n\t\tparseInt = win.parseInt,\n\t\tsetTimeout = win.setTimeout,\n\n\t\t$ = win.jQuery || win.Zepto,\n\t\tPolymer = win.Polymer,\n\n\t\tcaptureMode = {\n\t\t\tcapture: false,\n\t\t\tpassive: false\n\t\t},\n\n\t\tIE11OrLess = !!navigator.userAgent.match(/(?:Trident.*rv[ :]?11\\.|msie|iemobile)/i),\n\t\tEdge = !!navigator.userAgent.match(/Edge/i),\n\t\tFireFox = !!navigator.userAgent.match(/firefox/i),\n\t\tSafari = !!(navigator.userAgent.match(/safari/i) && !navigator.userAgent.match(/chrome/i) && !navigator.userAgent.match(/android/i)),\n\t\tIOS = !!(navigator.userAgent.match(/iP(ad|od|hone)/i)),\n\n\t\tPositionGhostAbsolutely = IOS,\n\n\t\tCSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',\n\n\t\t// This will not pass for IE9, because IE9 DnD only works on anchors\n\t\tsupportDraggable = ('draggable' in document.createElement('div')),\n\n\t\tsupportCssPointerEvents = (function() {\n\t\t\t// false when <= IE11\n\t\t\tif (IE11OrLess) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar el = document.createElement('x');\n\t\t\tel.style.cssText = 'pointer-events:auto';\n\t\t\treturn el.style.pointerEvents === 'auto';\n\t\t})(),\n\n\t\t_silent = false,\n\t\t_alignedSilent = false,\n\n\t\tabs = Math.abs,\n\t\tmin = Math.min,\n\t\tmax = Math.max,\n\n\t\tsavedInputChecked = [],\n\n\t\t_detectDirection = function(el, options) {\n\t\t\tvar elCSS = _css(el),\n\t\t\t\telWidth = parseInt(elCSS.width)\n\t\t\t\t\t- parseInt(elCSS.paddingLeft)\n\t\t\t\t\t- parseInt(elCSS.paddingRight)\n\t\t\t\t\t- parseInt(elCSS.borderLeftWidth)\n\t\t\t\t\t- parseInt(elCSS.borderRightWidth),\n\t\t\t\tchild1 = _getChild(el, 0, options),\n\t\t\t\tchild2 = _getChild(el, 1, options),\n\t\t\t\tfirstChildCSS = child1 && _css(child1),\n\t\t\t\tsecondChildCSS = child2 && _css(child2),\n\t\t\t\tfirstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + _getRect(child1).width,\n\t\t\t\tsecondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + _getRect(child2).width;\n\n\t\t\tif (elCSS.display === 'flex') {\n\t\t\t\treturn elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse'\n\t\t\t\t? 'vertical' : 'horizontal';\n\t\t\t}\n\n\t\t\tif (elCSS.display === 'grid') {\n\t\t\t\treturn elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';\n\t\t\t}\n\n\t\t\tif (child1 && firstChildCSS.float !== 'none') {\n\t\t\t\tvar touchingSideChild2 = firstChildCSS.float === 'left' ? 'left' : 'right';\n\n\t\t\t\treturn child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ?\n\t\t\t\t\t'vertical' : 'horizontal';\n\t\t\t}\n\n\t\t\treturn (child1 &&\n\t\t\t\t(\n\t\t\t\t\tfirstChildCSS.display === 'block' ||\n\t\t\t\t\tfirstChildCSS.display === 'flex' ||\n\t\t\t\t\tfirstChildCSS.display === 'table' ||\n\t\t\t\t\tfirstChildCSS.display === 'grid' ||\n\t\t\t\t\tfirstChildWidth >= elWidth &&\n\t\t\t\t\telCSS[CSSFloatProperty] === 'none' ||\n\t\t\t\t\tchild2 &&\n\t\t\t\t\telCSS[CSSFloatProperty] === 'none' &&\n\t\t\t\t\tfirstChildWidth + secondChildWidth > elWidth\n\t\t\t\t) ?\n\t\t\t\t'vertical' : 'horizontal'\n\t\t\t);\n\t\t},\n\n\t\t/**\n\t\t * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\n\t\t * @param  {Number} x      X position\n\t\t * @param  {Number} y      Y position\n\t\t * @return {HTMLElement}   Element of the first found nearest Sortable\n\t\t */\n\t\t_detectNearestEmptySortable = function(x, y) {\n\t\t\tfor (var i = 0; i < sortables.length; i++) {\n\t\t\t\tif (_lastChild(sortables[i])) continue;\n\n\t\t\t\tvar rect = _getRect(sortables[i]),\n\t\t\t\t\tthreshold = sortables[i][expando].options.emptyInsertThreshold,\n\t\t\t\t\tinsideHorizontally = x >= (rect.left - threshold) && x <= (rect.right + threshold),\n\t\t\t\t\tinsideVertically = y >= (rect.top - threshold) && y <= (rect.bottom + threshold);\n\n\t\t\t\tif (threshold && insideHorizontally && insideVertically) {\n\t\t\t\t\treturn sortables[i];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_isClientInRowColumn = function(x, y, el, axis, options) {\n\t\t\tvar targetRect = _getRect(el),\n\t\t\t\ttargetS1Opp = axis === 'vertical' ? targetRect.left : targetRect.top,\n\t\t\t\ttargetS2Opp = axis === 'vertical' ? targetRect.right : targetRect.bottom,\n\t\t\t\tmouseOnOppAxis = axis === 'vertical' ? x : y;\n\n\t\t\treturn targetS1Opp < mouseOnOppAxis && mouseOnOppAxis < targetS2Opp;\n\t\t},\n\n\t\t_isElInRowColumn = function(el1, el2, axis) {\n\t\t\tvar el1Rect = el1 === dragEl && realDragElRect || _getRect(el1),\n\t\t\t\tel2Rect = el2 === dragEl && realDragElRect || _getRect(el2),\n\t\t\t\tel1S1Opp = axis === 'vertical' ? el1Rect.left : el1Rect.top,\n\t\t\t\tel1S2Opp = axis === 'vertical' ? el1Rect.right : el1Rect.bottom,\n\t\t\t\tel1OppLength = axis === 'vertical' ? el1Rect.width : el1Rect.height,\n\t\t\t\tel2S1Opp = axis === 'vertical' ? el2Rect.left : el2Rect.top,\n\t\t\t\tel2S2Opp = axis === 'vertical' ? el2Rect.right : el2Rect.bottom,\n\t\t\t\tel2OppLength = axis === 'vertical' ? el2Rect.width : el2Rect.height;\n\n\t\t\treturn (\n\t\t\t\tel1S1Opp === el2S1Opp ||\n\t\t\t\tel1S2Opp === el2S2Opp ||\n\t\t\t\t(el1S1Opp + el1OppLength / 2) === (el2S1Opp + el2OppLength / 2)\n\t\t\t);\n\t\t},\n\n\t\t_getParentAutoScrollElement = function(el, includeSelf) {\n\t\t\t// skip to window\n\t\t\tif (!el || !el.getBoundingClientRect) return _getWindowScrollingElement();\n\n\t\t\tvar elem = el;\n\t\t\tvar gotSelf = false;\n\t\t\tdo {\n\t\t\t\t// we don't need to get elem css if it isn't even overflowing in the first place (performance)\n\t\t\t\tif (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {\n\t\t\t\t\tvar elemCSS = _css(elem);\n\t\t\t\t\tif (\n\t\t\t\t\t\telem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') ||\n\t\t\t\t\t\telem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!elem || !elem.getBoundingClientRect || elem === document.body) return _getWindowScrollingElement();\n\n\t\t\t\t\t\tif (gotSelf || includeSelf) return elem;\n\t\t\t\t\t\tgotSelf = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t/* jshint boss:true */\n\t\t\t} while (elem = elem.parentNode);\n\n\t\t\treturn _getWindowScrollingElement();\n\t\t},\n\n\t\t_getWindowScrollingElement = function() {\n\t\t\tif (IE11OrLess) {\n\t\t\t\treturn document.documentElement;\n\t\t\t} else {\n\t\t\t\treturn document.scrollingElement;\n\t\t\t}\n\t\t},\n\n\t\t_scrollBy = function(el, x, y) {\n\t\t\tel.scrollLeft += x;\n\t\t\tel.scrollTop += y;\n\t\t},\n\n\t\t_autoScroll = _throttle(function (/**Event*/evt, /**Object*/options, /**HTMLElement*/rootEl, /**Boolean*/isFallback) {\n\t\t\t// Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\n\t\t\tif (options.scroll) {\n\t\t\t\tvar _this = rootEl ? rootEl[expando] : window,\n\t\t\t\t\tsens = options.scrollSensitivity,\n\t\t\t\t\tspeed = options.scrollSpeed,\n\n\t\t\t\t\tx = evt.clientX,\n\t\t\t\t\ty = evt.clientY,\n\n\t\t\t\t\twinScroller = _getWindowScrollingElement(),\n\n\t\t\t\t\tscrollThisInstance = false;\n\n\t\t\t\t// Detect scrollEl\n\t\t\t\tif (scrollParentEl !== rootEl) {\n\t\t\t\t\t_clearAutoScrolls();\n\n\t\t\t\t\tscrollEl = options.scroll;\n\t\t\t\t\tscrollCustomFn = options.scrollFn;\n\n\t\t\t\t\tif (scrollEl === true) {\n\t\t\t\t\t\tscrollEl = _getParentAutoScrollElement(rootEl, true);\n\t\t\t\t\t\tscrollParentEl = scrollEl;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tvar layersOut = 0;\n\t\t\t\tvar currentParent = scrollEl;\n\t\t\t\tdo {\n\t\t\t\t\tvar\tel = currentParent,\n\t\t\t\t\t\trect = _getRect(el),\n\n\t\t\t\t\t\ttop = rect.top,\n\t\t\t\t\t\tbottom = rect.bottom,\n\t\t\t\t\t\tleft = rect.left,\n\t\t\t\t\t\tright = rect.right,\n\n\t\t\t\t\t\twidth = rect.width,\n\t\t\t\t\t\theight = rect.height,\n\n\t\t\t\t\t\tscrollWidth,\n\t\t\t\t\t\tscrollHeight,\n\n\t\t\t\t\t\tcss,\n\n\t\t\t\t\t\tvx,\n\t\t\t\t\t\tvy,\n\n\t\t\t\t\t\tcanScrollX,\n\t\t\t\t\t\tcanScrollY,\n\n\t\t\t\t\t\tscrollPosX,\n\t\t\t\t\t\tscrollPosY;\n\n\n\t\t\t\t\tscrollWidth = el.scrollWidth;\n\t\t\t\t\tscrollHeight = el.scrollHeight;\n\n\t\t\t\t\tcss = _css(el);\n\n\t\t\t\t\tscrollPosX = el.scrollLeft;\n\t\t\t\t\tscrollPosY = el.scrollTop;\n\n\t\t\t\t\tif (el === winScroller) {\n\t\t\t\t\t\tcanScrollX = width < scrollWidth && (css.overflowX === 'auto' || css.overflowX === 'scroll' || css.overflowX === 'visible');\n\t\t\t\t\t\tcanScrollY = height < scrollHeight && (css.overflowY === 'auto' || css.overflowY === 'scroll' || css.overflowY === 'visible');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcanScrollX = width < scrollWidth && (css.overflowX === 'auto' || css.overflowX === 'scroll');\n\t\t\t\t\t\tcanScrollY = height < scrollHeight && (css.overflowY === 'auto' || css.overflowY === 'scroll');\n\t\t\t\t\t}\n\n\t\t\t\t\tvx = canScrollX && (abs(right - x) <= sens && (scrollPosX + width) < scrollWidth) - (abs(left - x) <= sens && !!scrollPosX);\n\n\t\t\t\t\tvy = canScrollY && (abs(bottom - y) <= sens && (scrollPosY + height) < scrollHeight) - (abs(top - y) <= sens && !!scrollPosY);\n\n\n\t\t\t\t\tif (!autoScrolls[layersOut]) {\n\t\t\t\t\t\tfor (var i = 0; i <= layersOut; i++) {\n\t\t\t\t\t\t\tif (!autoScrolls[i]) {\n\t\t\t\t\t\t\t\tautoScrolls[i] = {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {\n\t\t\t\t\t\tautoScrolls[layersOut].el = el;\n\t\t\t\t\t\tautoScrolls[layersOut].vx = vx;\n\t\t\t\t\t\tautoScrolls[layersOut].vy = vy;\n\n\t\t\t\t\t\tclearInterval(autoScrolls[layersOut].pid);\n\n\t\t\t\t\t\tif (el && (vx != 0 || vy != 0)) {\n\t\t\t\t\t\t\tscrollThisInstance = true;\n\t\t\t\t\t\t\t/* jshint loopfunc:true */\n\t\t\t\t\t\t\tautoScrolls[layersOut].pid = setInterval((function () {\n\t\t\t\t\t\t\t\t// emulate drag over during autoscroll (fallback), emulating native DnD behaviour\n\t\t\t\t\t\t\t\tif (isFallback && this.layer === 0) {\n\t\t\t\t\t\t\t\t\tSortable.active._emulateDragOver(true);\n\t\t\t\t\t\t\t\t\tSortable.active._onTouchMove(touchEvt, true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvar scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;\n\t\t\t\t\t\t\t\tvar scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;\n\n\t\t\t\t\t\t\t\tif ('function' === typeof(scrollCustomFn)) {\n\t\t\t\t\t\t\t\t\tif (scrollCustomFn.call(_this, scrollOffsetX, scrollOffsetY, evt, touchEvt, autoScrolls[this.layer].el) !== 'continue') {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t_scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);\n\t\t\t\t\t\t\t}).bind({layer: layersOut}), 24);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlayersOut++;\n\t\t\t\t} while (options.bubbleScroll && currentParent !== winScroller && (currentParent = _getParentAutoScrollElement(currentParent, false)));\n\t\t\t\tscrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not\n\t\t\t}\n\t\t}, 30),\n\n\t\t_clearAutoScrolls = function () {\n\t\t\tautoScrolls.forEach(function(autoScroll) {\n\t\t\t\tclearInterval(autoScroll.pid);\n\t\t\t});\n\t\t\tautoScrolls = [];\n\t\t},\n\n\t\t_prepareGroup = function (options) {\n\t\t\tfunction toFn(value, pull) {\n\t\t\t\treturn function(to, from, dragEl, evt) {\n\t\t\t\t\tvar sameGroup = to.options.group.name &&\n\t\t\t\t\t\t\t\t\tfrom.options.group.name &&\n\t\t\t\t\t\t\t\t\tto.options.group.name === from.options.group.name;\n\n\t\t\t\t\tif (value == null && (pull || sameGroup)) {\n\t\t\t\t\t\t// Default pull value\n\t\t\t\t\t\t// Default pull and put value if same group\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (value == null || value === false) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else if (pull && value === 'clone') {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t} else if (typeof value === 'function') {\n\t\t\t\t\t\treturn toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar otherGroup = (pull ? to : from).options.group.name;\n\n\t\t\t\t\t\treturn (value === true ||\n\t\t\t\t\t\t(typeof value === 'string' && value === otherGroup) ||\n\t\t\t\t\t\t(value.join && value.indexOf(otherGroup) > -1));\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar group = {};\n\t\t\tvar originalGroup = options.group;\n\n\t\t\tif (!originalGroup || typeof originalGroup != 'object') {\n\t\t\t\toriginalGroup = {name: originalGroup};\n\t\t\t}\n\n\t\t\tgroup.name = originalGroup.name;\n\t\t\tgroup.checkPull = toFn(originalGroup.pull, true);\n\t\t\tgroup.checkPut = toFn(originalGroup.put);\n\t\t\tgroup.revertClone = originalGroup.revertClone;\n\n\t\t\toptions.group = group;\n\t\t},\n\n\t\t_checkAlignment = function(evt) {\n\t\t\tif (!dragEl || !dragEl.parentNode) return;\n\t\t\tdragEl.parentNode[expando] && dragEl.parentNode[expando]._computeIsAligned(evt);\n\t\t},\n\n\t\t_hideGhostForTarget = function() {\n\t\t\tif (!supportCssPointerEvents && ghostEl) {\n\t\t\t\t_css(ghostEl, 'display', 'none');\n\t\t\t}\n\t\t},\n\n\t\t_unhideGhostForTarget = function() {\n\t\t\tif (!supportCssPointerEvents && ghostEl) {\n\t\t\t\t_css(ghostEl, 'display', '');\n\t\t\t}\n\t\t};\n\n\n\t// #1184 fix - Prevent click event on fallback if dragged but item not changed position\n\tdocument.addEventListener('click', function(evt) {\n\t\tif (ignoreNextClick) {\n\t\t\tevt.preventDefault();\n\t\t\tevt.stopPropagation && evt.stopPropagation();\n\t\t\tevt.stopImmediatePropagation && evt.stopImmediatePropagation();\n\t\t\tignoreNextClick = false;\n\t\t\treturn false;\n\t\t}\n\t}, true);\n\n\tvar nearestEmptyInsertDetectEvent = function(evt) {\n\t\tif (dragEl) {\n\t\t\tevt = evt.touches ? evt.touches[0] : evt;\n\t\t\tvar nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);\n\n\t\t\tif (nearest) {\n\t\t\t\t// Create imitation event\n\t\t\t\tvar event = {};\n\t\t\t\tfor (var i in evt) {\n\t\t\t\t\tevent[i] = evt[i];\n\t\t\t\t}\n\t\t\t\tevent.target = event.rootEl = nearest;\n\t\t\t\tevent.preventDefault = void 0;\n\t\t\t\tevent.stopPropagation = void 0;\n\t\t\t\tnearest[expando]._onDragOver(event);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @class  Sortable\n\t * @param  {HTMLElement}  el\n\t * @param  {Object}       [options]\n\t */\n\tfunction Sortable(el, options) {\n\t\tif (!(el && el.nodeType && el.nodeType === 1)) {\n\t\t\tthrow 'Sortable: `el` must be HTMLElement, not ' + {}.toString.call(el);\n\t\t}\n\n\t\tthis.el = el; // root element\n\t\tthis.options = options = _extend({}, options);\n\n\n\t\t// Export instance\n\t\tel[expando] = this;\n\n\t\t// Default options\n\t\tvar defaults = {\n\t\t\tgroup: null,\n\t\t\tsort: true,\n\t\t\tdisabled: false,\n\t\t\tstore: null,\n\t\t\thandle: null,\n\t\t\tscroll: true,\n\t\t\tscrollSensitivity: 30,\n\t\t\tscrollSpeed: 10,\n\t\t\tbubbleScroll: true,\n\t\t\tdraggable: /[uo]l/i.test(el.nodeName) ? '>li' : '>*',\n\t\t\tswapThreshold: 1, // percentage; 0 <= x <= 1\n\t\t\tinvertSwap: false, // invert always\n\t\t\tinvertedSwapThreshold: null, // will be set to same as swapThreshold if default\n\t\t\tremoveCloneOnHide: true,\n\t\t\tdirection: function() {\n\t\t\t\treturn _detectDirection(el, this.options);\n\t\t\t},\n\t\t\tghostClass: 'sortable-ghost',\n\t\t\tchosenClass: 'sortable-chosen',\n\t\t\tdragClass: 'sortable-drag',\n\t\t\tignore: 'a, img',\n\t\t\tfilter: null,\n\t\t\tpreventOnFilter: true,\n\t\t\tanimation: 0,\n\t\t\teasing: null,\n\t\t\tsetData: function (dataTransfer, dragEl) {\n\t\t\t\tdataTransfer.setData('Text', dragEl.textContent);\n\t\t\t},\n\t\t\tdropBubble: false,\n\t\t\tdragoverBubble: false,\n\t\t\tdataIdAttr: 'data-id',\n\t\t\tdelay: 0,\n\t\t\tdelayOnTouchOnly: false,\n\t\t\ttouchStartThreshold: parseInt(window.devicePixelRatio, 10) || 1,\n\t\t\tforceFallback: false,\n\t\t\tfallbackClass: 'sortable-fallback',\n\t\t\tfallbackOnBody: false,\n\t\t\tfallbackTolerance: 0,\n\t\t\tfallbackOffset: {x: 0, y: 0},\n\t\t\tsupportPointer: Sortable.supportPointer !== false && ('PointerEvent' in window),\n\t\t\temptyInsertThreshold: 5\n\t\t};\n\n\n\t\t// Set default options\n\t\tfor (var name in defaults) {\n\t\t\t!(name in options) && (options[name] = defaults[name]);\n\t\t}\n\n\t\t_prepareGroup(options);\n\n\t\t// Bind all private methods\n\t\tfor (var fn in this) {\n\t\t\tif (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n\t\t\t\tthis[fn] = this[fn].bind(this);\n\t\t\t}\n\t\t}\n\n\t\t// Setup drag mode\n\t\tthis.nativeDraggable = options.forceFallback ? false : supportDraggable;\n\n\t\tif (this.nativeDraggable) {\n\t\t\t// Touch start threshold cannot be greater than the native dragstart threshold\n\t\t\tthis.options.touchStartThreshold = 1;\n\t\t}\n\n\t\t// Bind events\n\t\tif (options.supportPointer) {\n\t\t\t_on(el, 'pointerdown', this._onTapStart);\n\t\t} else {\n\t\t\t_on(el, 'mousedown', this._onTapStart);\n\t\t\t_on(el, 'touchstart', this._onTapStart);\n\t\t}\n\n\t\tif (this.nativeDraggable) {\n\t\t\t_on(el, 'dragover', this);\n\t\t\t_on(el, 'dragenter', this);\n\t\t}\n\n\t\tsortables.push(this.el);\n\n\t\t// Restore sorting\n\t\toptions.store && options.store.get && this.sort(options.store.get(this) || []);\n\t}\n\n\tSortable.prototype = /** @lends Sortable.prototype */ {\n\t\tconstructor: Sortable,\n\n\t\t_computeIsAligned: function(evt) {\n\t\t\tvar target;\n\n\t\t\tif (ghostEl && !supportCssPointerEvents) {\n\t\t\t\t_hideGhostForTarget();\n\t\t\t\ttarget = document.elementFromPoint(evt.clientX, evt.clientY);\n\t\t\t\t_unhideGhostForTarget();\n\t\t\t} else {\n\t\t\t\ttarget = evt.target;\n\t\t\t}\n\n\t\t\ttarget = _closest(target, this.options.draggable, this.el, false);\n\t\t\tif (_alignedSilent) return;\n\t\t\tif (!dragEl || dragEl.parentNode !== this.el) return;\n\n\t\t\tvar children = this.el.children;\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t// Don't change for target in case it is changed to aligned before onDragOver is fired\n\t\t\t\tif (_closest(children[i], this.options.draggable, this.el, false) && children[i] !== target) {\n\t\t\t\t\tchildren[i].sortableMouseAligned = _isClientInRowColumn(evt.clientX, evt.clientY, children[i], this._getDirection(evt, null), this.options);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Used for nulling last target when not in element, nothing to do with checking if aligned\n\t\t\tif (!_closest(target, this.options.draggable, this.el, true)) {\n\t\t\t\tlastTarget = null;\n\t\t\t}\n\n\t\t\t_alignedSilent = true;\n\t\t\tsetTimeout(function() {\n\t\t\t\t_alignedSilent = false;\n\t\t\t}, 30);\n\n\t\t},\n\n\t\t_getDirection: function(evt, target) {\n\t\t\treturn (typeof this.options.direction === 'function') ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;\n\t\t},\n\n\t\t_onTapStart: function (/** Event|TouchEvent */evt) {\n\t\t\tif (!evt.cancelable) return;\n\t\t\tvar _this = this,\n\t\t\t\tel = this.el,\n\t\t\t\toptions = this.options,\n\t\t\t\tpreventOnFilter = options.preventOnFilter,\n\t\t\t\ttype = evt.type,\n\t\t\t\ttouch = evt.touches && evt.touches[0],\n\t\t\t\ttarget = (touch || evt).target,\n\t\t\t\toriginalTarget = evt.target.shadowRoot && ((evt.path && evt.path[0]) || (evt.composedPath && evt.composedPath()[0])) || target,\n\t\t\t\tfilter = options.filter,\n\t\t\t\tstartIndex,\n\t\t\t\tstartDraggableIndex;\n\n\t\t\t_saveInputCheckedState(el);\n\n\t\t\t// Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\n\t\t\tif (dragEl) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {\n\t\t\t\treturn; // only left button and enabled\n\t\t\t}\n\n\t\t\t// cancel dnd if original target is content editable\n\t\t\tif (originalTarget.isContentEditable) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttarget = _closest(target, options.draggable, el, false);\n\n\n\t\t\tif (lastDownEl === target) {\n\t\t\t\t// Ignoring duplicate `down`\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get the index of the dragged element within its parent\n\t\t\tstartIndex = _index(target);\n\t\t\tstartDraggableIndex = _index(target, options.draggable);\n\n\t\t\t// Check filter\n\t\t\tif (typeof filter === 'function') {\n\t\t\t\tif (filter.call(this, evt, target, this)) {\n\t\t\t\t\t_dispatchEvent(_this, originalTarget, 'filter', target, el, el, startIndex, undefined, startDraggableIndex);\n\t\t\t\t\tpreventOnFilter && evt.cancelable && evt.preventDefault();\n\t\t\t\t\treturn; // cancel dnd\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (filter) {\n\t\t\t\tfilter = filter.split(',').some(function (criteria) {\n\t\t\t\t\tcriteria = _closest(originalTarget, criteria.trim(), el, false);\n\n\t\t\t\t\tif (criteria) {\n\t\t\t\t\t\t_dispatchEvent(_this, criteria, 'filter', target, el, el, startIndex, undefined, startDraggableIndex);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (filter) {\n\t\t\t\t\tpreventOnFilter && evt.cancelable && evt.preventDefault();\n\t\t\t\t\treturn; // cancel dnd\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (options.handle && !_closest(originalTarget, options.handle, el, false)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Prepare `dragstart`\n\t\t\tthis._prepareDragStart(evt, touch, target, startIndex, startDraggableIndex);\n\t\t},\n\n\n\t\t_handleAutoScroll: function(evt, fallback) {\n\t\t\tif (!dragEl || !this.options.scroll) return;\n\t\t\tvar x = evt.clientX,\n\t\t\t\ty = evt.clientY,\n\n\t\t\t\telem = document.elementFromPoint(x, y),\n\t\t\t\t_this = this;\n\n\t\t\t// IE does not seem to have native autoscroll,\n\t\t\t// Edge's autoscroll seems too conditional,\n\t\t\t// MACOS Safari does not have autoscroll,\n\t\t\t// Firefox and Chrome are good\n\t\t\tif (fallback || Edge || IE11OrLess || Safari) {\n\t\t\t\t_autoScroll(evt, _this.options, elem, fallback);\n\n\t\t\t\t// Listener for pointer element change\n\t\t\t\tvar ogElemScroller = _getParentAutoScrollElement(elem, true);\n\t\t\t\tif (\n\t\t\t\t\tscrolling &&\n\t\t\t\t\t(\n\t\t\t\t\t\t!pointerElemChangedInterval ||\n\t\t\t\t\t\tx !== lastPointerElemX ||\n\t\t\t\t\t\ty !== lastPointerElemY\n\t\t\t\t\t)\n\t\t\t\t) {\n\n\t\t\t\t\tpointerElemChangedInterval && clearInterval(pointerElemChangedInterval);\n\t\t\t\t\t// Detect for pointer elem change, emulating native DnD behaviour\n\t\t\t\t\tpointerElemChangedInterval = setInterval(function() {\n\t\t\t\t\t\tif (!dragEl) return;\n\t\t\t\t\t\t// could also check if scroll direction on newElem changes due to parent autoscrolling\n\t\t\t\t\t\tvar newElem = _getParentAutoScrollElement(document.elementFromPoint(x, y), true);\n\t\t\t\t\t\tif (newElem !== ogElemScroller) {\n\t\t\t\t\t\t\togElemScroller = newElem;\n\t\t\t\t\t\t\t_clearAutoScrolls();\n\t\t\t\t\t\t\t_autoScroll(evt, _this.options, ogElemScroller, fallback);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 10);\n\t\t\t\t\tlastPointerElemX = x;\n\t\t\t\t\tlastPointerElemY = y;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll\n\t\t\t\tif (!_this.options.bubbleScroll || _getParentAutoScrollElement(elem, true) === _getWindowScrollingElement()) {\n\t\t\t\t\t_clearAutoScrolls();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t_autoScroll(evt, _this.options, _getParentAutoScrollElement(elem, false), false);\n\t\t\t}\n\t\t},\n\n\t\t_prepareDragStart: function (/** Event */evt, /** Touch */touch, /** HTMLElement */target, /** Number */startIndex, /** Number */startDraggableIndex) {\n\t\t\tvar _this = this,\n\t\t\t\tel = _this.el,\n\t\t\t\toptions = _this.options,\n\t\t\t\townerDocument = el.ownerDocument,\n\t\t\t\tdragStartFn;\n\n\t\t\tif (target && !dragEl && (target.parentNode === el)) {\n\t\t\t\trootEl = el;\n\t\t\t\tdragEl = target;\n\t\t\t\tparentEl = dragEl.parentNode;\n\t\t\t\tnextEl = dragEl.nextSibling;\n\t\t\t\tlastDownEl = target;\n\t\t\t\tactiveGroup = options.group;\n\t\t\t\toldIndex = startIndex;\n\t\t\t\toldDraggableIndex = startDraggableIndex;\n\n\t\t\t\ttapEvt = {\n\t\t\t\t\ttarget: dragEl,\n\t\t\t\t\tclientX: (touch || evt).clientX,\n\t\t\t\t\tclientY: (touch || evt).clientY\n\t\t\t\t};\n\n\t\t\t\tthis._lastX = (touch || evt).clientX;\n\t\t\t\tthis._lastY = (touch || evt).clientY;\n\n\t\t\t\tdragEl.style['will-change'] = 'all';\n\t\t\t\t// undo animation if needed\n\t\t\t\tdragEl.style.transition = '';\n\t\t\t\tdragEl.style.transform = '';\n\n\t\t\t\tdragStartFn = function () {\n\t\t\t\t\t// Delayed drag has been triggered\n\t\t\t\t\t// we can re-enable the events: touchmove/mousemove\n\t\t\t\t\t_this._disableDelayedDragEvents();\n\n\t\t\t\t\tif (!FireFox && _this.nativeDraggable) {\n\t\t\t\t\t\tdragEl.draggable = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Bind the events: dragstart/dragend\n\t\t\t\t\t_this._triggerDragStart(evt, touch);\n\n\t\t\t\t\t// Drag start event\n\t\t\t\t\t_dispatchEvent(_this, rootEl, 'choose', dragEl, rootEl, rootEl, oldIndex, undefined, oldDraggableIndex);\n\n\t\t\t\t\t// Chosen item\n\t\t\t\t\t_toggleClass(dragEl, options.chosenClass, true);\n\t\t\t\t};\n\n\t\t\t\t// Disable \"draggable\"\n\t\t\t\toptions.ignore.split(',').forEach(function (criteria) {\n\t\t\t\t\t_find(dragEl, criteria.trim(), _disableDraggable);\n\t\t\t\t});\n\n\t\t\t\t_on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);\n\t\t\t\t_on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);\n\t\t\t\t_on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);\n\n\t\t\t\t_on(ownerDocument, 'mouseup', _this._onDrop);\n\t\t\t\t_on(ownerDocument, 'touchend', _this._onDrop);\n\t\t\t\t_on(ownerDocument, 'touchcancel', _this._onDrop);\n\n\t\t\t\t// Make dragEl draggable (must be before delay for FireFox)\n\t\t\t\tif (FireFox && this.nativeDraggable) {\n\t\t\t\t\tthis.options.touchStartThreshold = 4;\n\t\t\t\t\tdragEl.draggable = true;\n\t\t\t\t}\n\n\t\t\t\t// Delay is impossible for native DnD in Edge or IE\n\t\t\t\tif (options.delay && (options.delayOnTouchOnly ? touch : true) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {\n\t\t\t\t\t// If the user moves the pointer or let go the click or touch\n\t\t\t\t\t// before the delay has been reached:\n\t\t\t\t\t// disable the delayed drag\n\t\t\t\t\t_on(ownerDocument, 'mouseup', _this._disableDelayedDrag);\n\t\t\t\t\t_on(ownerDocument, 'touchend', _this._disableDelayedDrag);\n\t\t\t\t\t_on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);\n\t\t\t\t\t_on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);\n\t\t\t\t\t_on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);\n\t\t\t\t\toptions.supportPointer && _on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);\n\n\t\t\t\t\t_this._dragStartTimer = setTimeout(dragStartFn, options.delay);\n\t\t\t\t} else {\n\t\t\t\t\tdragStartFn();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_delayedDragTouchMoveHandler: function (/** TouchEvent|PointerEvent **/e) {\n\t\t\tvar touch = e.touches ? e.touches[0] : e;\n\t\t\tif (max(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY))\n\t\t\t\t\t>= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))\n\t\t\t) {\n\t\t\t\tthis._disableDelayedDrag();\n\t\t\t}\n\t\t},\n\n\t\t_disableDelayedDrag: function () {\n\t\t\tdragEl && _disableDraggable(dragEl);\n\t\t\tclearTimeout(this._dragStartTimer);\n\n\t\t\tthis._disableDelayedDragEvents();\n\t\t},\n\n\t\t_disableDelayedDragEvents: function () {\n\t\t\tvar ownerDocument = this.el.ownerDocument;\n\t\t\t_off(ownerDocument, 'mouseup', this._disableDelayedDrag);\n\t\t\t_off(ownerDocument, 'touchend', this._disableDelayedDrag);\n\t\t\t_off(ownerDocument, 'touchcancel', this._disableDelayedDrag);\n\t\t\t_off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);\n\t\t\t_off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);\n\t\t\t_off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);\n\t\t},\n\n\t\t_triggerDragStart: function (/** Event */evt, /** Touch */touch) {\n\t\t\ttouch = touch || (evt.pointerType == 'touch' ? evt : null);\n\n\t\t\tif (!this.nativeDraggable || touch) {\n\t\t\t\tif (this.options.supportPointer) {\n\t\t\t\t\t_on(document, 'pointermove', this._onTouchMove);\n\t\t\t\t} else if (touch) {\n\t\t\t\t\t_on(document, 'touchmove', this._onTouchMove);\n\t\t\t\t} else {\n\t\t\t\t\t_on(document, 'mousemove', this._onTouchMove);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_on(dragEl, 'dragend', this);\n\t\t\t\t_on(rootEl, 'dragstart', this._onDragStart);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (document.selection) {\n\t\t\t\t\t// Timeout neccessary for IE9\n\t\t\t\t\t_nextTick(function () {\n\t\t\t\t\t\tdocument.selection.empty();\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\twindow.getSelection().removeAllRanges();\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t}\n\t\t},\n\n\t\t_dragStarted: function (fallback, evt) {\n\t\t\tawaitingDragStarted = false;\n\t\t\tif (rootEl && dragEl) {\n\t\t\t\tif (this.nativeDraggable) {\n\t\t\t\t\t_on(document, 'dragover', this._handleAutoScroll);\n\t\t\t\t\t_on(document, 'dragover', _checkAlignment);\n\t\t\t\t}\n\t\t\t\tvar options = this.options;\n\n\t\t\t\t// Apply effect\n\t\t\t\t!fallback && _toggleClass(dragEl, options.dragClass, false);\n\t\t\t\t_toggleClass(dragEl, options.ghostClass, true);\n\n\t\t\t\t// In case dragging an animated element\n\t\t\t\t_css(dragEl, 'transform', '');\n\n\t\t\t\tSortable.active = this;\n\n\t\t\t\tfallback && this._appendGhost();\n\n\t\t\t\t// Drag start event\n\t\t\t\t_dispatchEvent(this, rootEl, 'start', dragEl, rootEl, rootEl, oldIndex, undefined, oldDraggableIndex, undefined, evt);\n\t\t\t} else {\n\t\t\t\tthis._nulling();\n\t\t\t}\n\t\t},\n\n\t\t_emulateDragOver: function (forAutoScroll) {\n\t\t\tif (touchEvt) {\n\t\t\t\tif (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY && !forAutoScroll) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._lastX = touchEvt.clientX;\n\t\t\t\tthis._lastY = touchEvt.clientY;\n\n\t\t\t\t_hideGhostForTarget();\n\n\t\t\t\tvar target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n\t\t\t\tvar parent = target;\n\n\t\t\t\twhile (target && target.shadowRoot) {\n\t\t\t\t\ttarget = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n\t\t\t\t\tif (target === parent) break;\n\t\t\t\t\tparent = target;\n\t\t\t\t}\n\n\t\t\t\tif (parent) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (parent[expando]) {\n\t\t\t\t\t\t\tvar inserted;\n\n\t\t\t\t\t\t\tinserted = parent[expando]._onDragOver({\n\t\t\t\t\t\t\t\tclientX: touchEvt.clientX,\n\t\t\t\t\t\t\t\tclientY: touchEvt.clientY,\n\t\t\t\t\t\t\t\ttarget: target,\n\t\t\t\t\t\t\t\trootEl: parent\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tif (inserted && !this.options.dragoverBubble) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttarget = parent; // store last element\n\t\t\t\t\t}\n\t\t\t\t\t/* jshint boss:true */\n\t\t\t\t\twhile (parent = parent.parentNode);\n\t\t\t\t}\n\t\t\t\tdragEl.parentNode[expando]._computeIsAligned(touchEvt);\n\n\t\t\t\t_unhideGhostForTarget();\n\t\t\t}\n\t\t},\n\n\n\t\t_onTouchMove: function (/**TouchEvent*/evt, forAutoScroll) {\n\t\t\tif (tapEvt) {\n\t\t\t\tvar\toptions = this.options,\n\t\t\t\t\tfallbackTolerance = options.fallbackTolerance,\n\t\t\t\t\tfallbackOffset = options.fallbackOffset,\n\t\t\t\t\ttouch = evt.touches ? evt.touches[0] : evt,\n\t\t\t\t\tmatrix = ghostEl && _matrix(ghostEl),\n\t\t\t\t\tscaleX = ghostEl && matrix && matrix.a,\n\t\t\t\t\tscaleY = ghostEl && matrix && matrix.d,\n\t\t\t\t\trelativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && _getRelativeScrollOffset(ghostRelativeParent),\n\t\t\t\t\tdx = ((touch.clientX - tapEvt.clientX)\n\t\t\t\t\t\t\t+ fallbackOffset.x) / (scaleX || 1)\n\t\t\t\t\t\t\t+ (relativeScrollOffset ? (relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0]) : 0) / (scaleX || 1),\n\t\t\t\t\tdy = ((touch.clientY - tapEvt.clientY)\n\t\t\t\t\t\t\t+ fallbackOffset.y) / (scaleY || 1)\n\t\t\t\t\t\t\t+ (relativeScrollOffset ? (relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1]) : 0) / (scaleY || 1),\n\t\t\t\t\ttranslate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';\n\n\t\t\t\t// only set the status to dragging, when we are actually dragging\n\t\t\t\tif (!Sortable.active && !awaitingDragStarted) {\n\t\t\t\t\tif (fallbackTolerance &&\n\t\t\t\t\t\tmin(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY)) < fallbackTolerance\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis._onDragStart(evt, true);\n\t\t\t\t}\n\n\t\t\t\t!forAutoScroll && this._handleAutoScroll(touch, true);\n\n\t\t\t\tmoved = true;\n\t\t\t\ttouchEvt = touch;\n\n\t\t\t\t_css(ghostEl, 'webkitTransform', translate3d);\n\t\t\t\t_css(ghostEl, 'mozTransform', translate3d);\n\t\t\t\t_css(ghostEl, 'msTransform', translate3d);\n\t\t\t\t_css(ghostEl, 'transform', translate3d);\n\n\t\t\t\tevt.cancelable && evt.preventDefault();\n\t\t\t}\n\t\t},\n\n\t\t_appendGhost: function () {\n\t\t\t// Bug if using scale(): https://stackoverflow.com/questions/2637058\n\t\t\t// Not being adjusted for\n\t\t\tif (!ghostEl) {\n\t\t\t\tvar container = this.options.fallbackOnBody ? document.body : rootEl,\n\t\t\t\t\trect = _getRect(dragEl, true, container, !PositionGhostAbsolutely),\n\t\t\t\t\tcss = _css(dragEl),\n\t\t\t\t\toptions = this.options;\n\n\t\t\t\t// Position absolutely\n\t\t\t\tif (PositionGhostAbsolutely) {\n\t\t\t\t\t// Get relatively positioned parent\n\t\t\t\t\tghostRelativeParent = container;\n\n\t\t\t\t\twhile (\n\t\t\t\t\t\t_css(ghostRelativeParent, 'position') === 'static' &&\n\t\t\t\t\t\t_css(ghostRelativeParent, 'transform') === 'none' &&\n\t\t\t\t\t\tghostRelativeParent !== document\n\t\t\t\t\t) {\n\t\t\t\t\t\tghostRelativeParent = ghostRelativeParent.parentNode;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ghostRelativeParent !== document) {\n\t\t\t\t\t\tvar ghostRelativeParentRect = _getRect(ghostRelativeParent, true);\n\n\t\t\t\t\t\trect.top -= ghostRelativeParentRect.top;\n\t\t\t\t\t\trect.left -= ghostRelativeParentRect.left;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {\n\t\t\t\t\t\tif (ghostRelativeParent === document) ghostRelativeParent = _getWindowScrollingElement();\n\n\t\t\t\t\t\trect.top += ghostRelativeParent.scrollTop;\n\t\t\t\t\t\trect.left += ghostRelativeParent.scrollLeft;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tghostRelativeParent = _getWindowScrollingElement();\n\t\t\t\t\t}\n\t\t\t\t\tghostRelativeParentInitialScroll = _getRelativeScrollOffset(ghostRelativeParent);\n\t\t\t\t}\n\n\n\t\t\t\tghostEl = dragEl.cloneNode(true);\n\n\t\t\t\t_toggleClass(ghostEl, options.ghostClass, false);\n\t\t\t\t_toggleClass(ghostEl, options.fallbackClass, true);\n\t\t\t\t_toggleClass(ghostEl, options.dragClass, true);\n\n\t\t\t\t_css(ghostEl, 'box-sizing', 'border-box');\n\t\t\t\t_css(ghostEl, 'margin', 0);\n\t\t\t\t_css(ghostEl, 'top', rect.top);\n\t\t\t\t_css(ghostEl, 'left', rect.left);\n\t\t\t\t_css(ghostEl, 'width', rect.width);\n\t\t\t\t_css(ghostEl, 'height', rect.height);\n\t\t\t\t_css(ghostEl, 'opacity', '0.8');\n\t\t\t\t_css(ghostEl, 'position', (PositionGhostAbsolutely ? 'absolute' : 'fixed'));\n\t\t\t\t_css(ghostEl, 'zIndex', '100000');\n\t\t\t\t_css(ghostEl, 'pointerEvents', 'none');\n\n\t\t\t\tcontainer.appendChild(ghostEl);\n\t\t\t}\n\t\t},\n\n\t\t_onDragStart: function (/**Event*/evt, /**boolean*/fallback) {\n\t\t\tvar _this = this;\n\t\t\tvar dataTransfer = evt.dataTransfer;\n\t\t\tvar options = _this.options;\n\n\t\t\t// Setup clone\n\t\t\tcloneEl = _clone(dragEl);\n\n\t\t\tcloneEl.draggable = false;\n\t\t\tcloneEl.style['will-change'] = '';\n\n\t\t\tthis._hideClone();\n\n\t\t\t_toggleClass(cloneEl, _this.options.chosenClass, false);\n\n\n\t\t\t// #1143: IFrame support workaround\n\t\t\t_this._cloneId = _nextTick(function () {\n\t\t\t\tif (!_this.options.removeCloneOnHide) {\n\t\t\t\t\trootEl.insertBefore(cloneEl, dragEl);\n\t\t\t\t}\n\t\t\t\t_dispatchEvent(_this, rootEl, 'clone', dragEl);\n\t\t\t});\n\n\n\t\t\t!fallback && _toggleClass(dragEl, options.dragClass, true);\n\n\t\t\t// Set proper drop events\n\t\t\tif (fallback) {\n\t\t\t\tignoreNextClick = true;\n\t\t\t\t_this._loopId = setInterval(_this._emulateDragOver, 50);\n\t\t\t} else {\n\t\t\t\t// Undo what was set in _prepareDragStart before drag started\n\t\t\t\t_off(document, 'mouseup', _this._onDrop);\n\t\t\t\t_off(document, 'touchend', _this._onDrop);\n\t\t\t\t_off(document, 'touchcancel', _this._onDrop);\n\n\t\t\t\tif (dataTransfer) {\n\t\t\t\t\tdataTransfer.effectAllowed = 'move';\n\t\t\t\t\toptions.setData && options.setData.call(_this, dataTransfer, dragEl);\n\t\t\t\t}\n\n\t\t\t\t_on(document, 'drop', _this);\n\n\t\t\t\t// #1276 fix:\n\t\t\t\t_css(dragEl, 'transform', 'translateZ(0)');\n\t\t\t}\n\n\t\t\tawaitingDragStarted = true;\n\n\t\t\t_this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));\n\t\t\t_on(document, 'selectstart', _this);\n\t\t\tif (Safari) {\n\t\t\t\t_css(document.body, 'user-select', 'none');\n\t\t\t}\n\t\t},\n\n\n\t\t// Returns true - if no further action is needed (either inserted or another condition)\n\t\t_onDragOver: function (/**Event*/evt) {\n\t\t\tvar el = this.el,\n\t\t\t\ttarget = evt.target,\n\t\t\t\tdragRect,\n\t\t\t\ttargetRect,\n\t\t\t\trevert,\n\t\t\t\toptions = this.options,\n\t\t\t\tgroup = options.group,\n\t\t\t\tactiveSortable = Sortable.active,\n\t\t\t\tisOwner = (activeGroup === group),\n\t\t\t\tcanSort = options.sort,\n\t\t\t\t_this = this;\n\n\t\t\tif (_silent) return;\n\n\t\t\t// Return invocation when dragEl is inserted (or completed)\n\t\t\tfunction completed(insertion) {\n\t\t\t\tif (insertion) {\n\t\t\t\t\tif (isOwner) {\n\t\t\t\t\t\tactiveSortable._hideClone();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tactiveSortable._showClone(_this);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (activeSortable) {\n\t\t\t\t\t\t// Set ghost class to new sortable's ghost class\n\t\t\t\t\t\t_toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);\n\t\t\t\t\t\t_toggleClass(dragEl, options.ghostClass, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (putSortable !== _this && _this !== Sortable.active) {\n\t\t\t\t\t\tputSortable = _this;\n\t\t\t\t\t} else if (_this === Sortable.active) {\n\t\t\t\t\t\tputSortable = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Animation\n\t\t\t\t\tdragRect && _this._animate(dragRect, dragEl);\n\t\t\t\t\ttarget && targetRect && _this._animate(targetRect, target);\n\t\t\t\t}\n\n\n\t\t\t\t// Null lastTarget if it is not inside a previously swapped element\n\t\t\t\tif ((target === dragEl && !dragEl.animated) || (target === el && !target.animated)) {\n\t\t\t\t\tlastTarget = null;\n\t\t\t\t}\n\n\t\t\t\t// no bubbling and not fallback\n\t\t\t\tif (!options.dragoverBubble && !evt.rootEl && target !== document) {\n\t\t\t\t\t_this._handleAutoScroll(evt);\n\t\t\t\t\tdragEl.parentNode[expando]._computeIsAligned(evt);\n\n\t\t\t\t\t// Do not detect for empty insert if already inserted\n\t\t\t\t\t!insertion && nearestEmptyInsertDetectEvent(evt);\n\t\t\t\t}\n\n\t\t\t\t!options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Call when dragEl has been inserted\n\t\t\tfunction changed() {\n\t\t\t\t_dispatchEvent(_this, rootEl, 'change', target, el, rootEl, oldIndex, _index(dragEl), oldDraggableIndex, _index(dragEl, options.draggable), evt);\n\t\t\t}\n\n\n\t\t\tif (evt.preventDefault !== void 0) {\n\t\t\t\tevt.cancelable && evt.preventDefault();\n\t\t\t}\n\n\n\t\t\tmoved = true;\n\n\t\t\ttarget = _closest(target, options.draggable, el, true);\n\n\t\t\t// target is dragEl or target is animated\n\t\t\tif (dragEl.contains(evt.target) || target.animated) {\n\t\t\t\treturn completed(false);\n\t\t\t}\n\n\t\t\tif (target !== dragEl) {\n\t\t\t\tignoreNextClick = false;\n\t\t\t}\n\n\t\t\tif (activeSortable && !options.disabled &&\n\t\t\t\t(isOwner\n\t\t\t\t\t? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list\n\t\t\t\t\t: (\n\t\t\t\t\t\tputSortable === this ||\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\t(this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) &&\n\t\t\t\t\t\t\tgroup.checkPut(this, activeSortable, dragEl, evt)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tvar axis = this._getDirection(evt, target);\n\n\t\t\t\tdragRect = _getRect(dragEl);\n\n\t\t\t\tif (revert) {\n\t\t\t\t\tthis._hideClone();\n\t\t\t\t\tparentEl = rootEl; // actualization\n\n\t\t\t\t\tif (nextEl) {\n\t\t\t\t\t\trootEl.insertBefore(dragEl, nextEl);\n\t\t\t\t\t} else {\n\t\t\t\t\t\trootEl.appendChild(dragEl);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn completed(true);\n\t\t\t\t}\n\n\t\t\t\tvar elLastChild = _lastChild(el);\n\n\t\t\t\tif (!elLastChild || _ghostIsLast(evt, axis, el) && !elLastChild.animated) {\n\t\t\t\t\t// assign target only if condition is true\n\t\t\t\t\tif (elLastChild && el === evt.target) {\n\t\t\t\t\t\ttarget = elLastChild;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (target) {\n\t\t\t\t\t\ttargetRect = _getRect(target);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isOwner) {\n\t\t\t\t\t\tactiveSortable._hideClone();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tactiveSortable._showClone(this);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {\n\t\t\t\t\t\tel.appendChild(dragEl);\n\t\t\t\t\t\tparentEl = el; // actualization\n\t\t\t\t\t\trealDragElRect = null;\n\n\t\t\t\t\t\tchanged();\n\t\t\t\t\t\treturn completed(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (target && target !== dragEl && target.parentNode === el) {\n\t\t\t\t\tvar direction = 0,\n\t\t\t\t\t\ttargetBeforeFirstSwap,\n\t\t\t\t\t\taligned = target.sortableMouseAligned,\n\t\t\t\t\t\tdifferentLevel = dragEl.parentNode !== el,\n\t\t\t\t\t\tside1 = axis === 'vertical' ? 'top' : 'left',\n\t\t\t\t\t\tscrolledPastTop = _isScrolledPast(target, 'top') || _isScrolledPast(dragEl, 'top'),\n\t\t\t\t\t\tscrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\n\n\n\t\t\t\t\tif (lastTarget !== target) {\n\t\t\t\t\t\tlastMode = null;\n\t\t\t\t\t\ttargetBeforeFirstSwap = _getRect(target)[side1];\n\t\t\t\t\t\tpastFirstInvertThresh = false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Reference: https://www.lucidchart.com/documents/view/10fa0e93-e362-4126-aca2-b709ee56bd8b/0\n\t\t\t\t\tif (\n\t\t\t\t\t\t_isElInRowColumn(dragEl, target, axis) && aligned ||\n\t\t\t\t\t\tdifferentLevel ||\n\t\t\t\t\t\tscrolledPastTop ||\n\t\t\t\t\t\toptions.invertSwap ||\n\t\t\t\t\t\tlastMode === 'insert' ||\n\t\t\t\t\t\t// Needed, in the case that we are inside target and inserted because not aligned... aligned will stay false while inside\n\t\t\t\t\t\t// and lastMode will change to 'insert', but we must swap\n\t\t\t\t\t\tlastMode === 'swap'\n\t\t\t\t\t) {\n\t\t\t\t\t\t// New target that we will be inside\n\t\t\t\t\t\tif (lastMode !== 'swap') {\n\t\t\t\t\t\t\tisCircumstantialInvert = options.invertSwap || differentLevel;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdirection = _getSwapDirection(evt, target, axis,\n\t\t\t\t\t\t\toptions.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold,\n\t\t\t\t\t\t\tisCircumstantialInvert,\n\t\t\t\t\t\t\tlastTarget === target);\n\t\t\t\t\t\tlastMode = 'swap';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Insert at position\n\t\t\t\t\t\tdirection = _getInsertDirection(target);\n\t\t\t\t\t\tlastMode = 'insert';\n\t\t\t\t\t}\n\t\t\t\t\tif (direction === 0) return completed(false);\n\n\t\t\t\t\trealDragElRect = null;\n\t\t\t\t\tlastTarget = target;\n\n\t\t\t\t\tlastDirection = direction;\n\n\t\t\t\t\ttargetRect = _getRect(target);\n\n\t\t\t\t\tvar nextSibling = target.nextElementSibling,\n\t\t\t\t\t\tafter = false;\n\n\t\t\t\t\tafter = direction === 1;\n\n\t\t\t\t\tvar moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);\n\n\t\t\t\t\tif (moveVector !== false) {\n\t\t\t\t\t\tif (moveVector === 1 || moveVector === -1) {\n\t\t\t\t\t\t\tafter = (moveVector === 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_silent = true;\n\t\t\t\t\t\tsetTimeout(_unsilent, 30);\n\n\t\t\t\t\t\tif (isOwner) {\n\t\t\t\t\t\t\tactiveSortable._hideClone();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tactiveSortable._showClone(this);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (after && !nextSibling) {\n\t\t\t\t\t\t\tel.appendChild(dragEl);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget.parentNode.insertBefore(dragEl, after ? nextSibling : target);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Undo chrome's scroll adjustment\n\t\t\t\t\t\tif (scrolledPastTop) {\n\t\t\t\t\t\t\t_scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparentEl = dragEl.parentNode; // actualization\n\n\t\t\t\t\t\t// must be done before animation\n\t\t\t\t\t\tif (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\n\t\t\t\t\t\t\ttargetMoveDistance = abs(targetBeforeFirstSwap - _getRect(target)[side1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchanged();\n\n\t\t\t\t\t\treturn completed(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (el.contains(dragEl)) {\n\t\t\t\t\treturn completed(false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\t_animate: function (prevRect, target) {\n\t\t\tvar ms = this.options.animation;\n\n\t\t\tif (ms) {\n\t\t\t\tvar currentRect = _getRect(target);\n\n\t\t\t\tif (target === dragEl) {\n\t\t\t\t\trealDragElRect = currentRect;\n\t\t\t\t}\n\n\t\t\t\tif (prevRect.nodeType === 1) {\n\t\t\t\t\tprevRect = _getRect(prevRect);\n\t\t\t\t}\n\n\t\t\t\t// Check if actually moving position\n\t\t\t\tif ((prevRect.left + prevRect.width / 2) !== (currentRect.left + currentRect.width / 2)\n\t\t\t\t\t|| (prevRect.top + prevRect.height / 2) !== (currentRect.top + currentRect.height / 2)\n\t\t\t\t) {\n\t\t\t\t\tvar matrix = _matrix(this.el),\n\t\t\t\t\t\tscaleX = matrix && matrix.a,\n\t\t\t\t\t\tscaleY = matrix && matrix.d;\n\n\t\t\t\t\t_css(target, 'transition', 'none');\n\t\t\t\t\t_css(target, 'transform', 'translate3d('\n\t\t\t\t\t\t+ (prevRect.left - currentRect.left) / (scaleX ? scaleX : 1) + 'px,'\n\t\t\t\t\t\t+ (prevRect.top - currentRect.top) / (scaleY ? scaleY : 1) + 'px,0)'\n\t\t\t\t\t);\n\n\t\t\t\t\tthis._repaint(target);\n\t\t\t\t\t_css(target, 'transition', 'transform ' + ms + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));\n\t\t\t\t\t_css(target, 'transform', 'translate3d(0,0,0)');\n\t\t\t\t}\n\n\t\t\t\t(typeof target.animated === 'number') && clearTimeout(target.animated);\n\t\t\t\ttarget.animated = setTimeout(function () {\n\t\t\t\t\t_css(target, 'transition', '');\n\t\t\t\t\t_css(target, 'transform', '');\n\t\t\t\t\ttarget.animated = false;\n\t\t\t\t}, ms);\n\t\t\t}\n\t\t},\n\n\t\t_repaint: function(target) {\n\t\t\treturn target.offsetWidth;\n\t\t},\n\n\t\t_offMoveEvents: function() {\n\t\t\t_off(document, 'touchmove', this._onTouchMove);\n\t\t\t_off(document, 'pointermove', this._onTouchMove);\n\t\t\t_off(document, 'dragover', nearestEmptyInsertDetectEvent);\n\t\t\t_off(document, 'mousemove', nearestEmptyInsertDetectEvent);\n\t\t\t_off(document, 'touchmove', nearestEmptyInsertDetectEvent);\n\t\t},\n\n\t\t_offUpEvents: function () {\n\t\t\tvar ownerDocument = this.el.ownerDocument;\n\n\t\t\t_off(ownerDocument, 'mouseup', this._onDrop);\n\t\t\t_off(ownerDocument, 'touchend', this._onDrop);\n\t\t\t_off(ownerDocument, 'pointerup', this._onDrop);\n\t\t\t_off(ownerDocument, 'touchcancel', this._onDrop);\n\t\t\t_off(document, 'selectstart', this);\n\t\t},\n\n\t\t_onDrop: function (/**Event*/evt) {\n\t\t\tvar el = this.el,\n\t\t\t\toptions = this.options;\n\t\t\tawaitingDragStarted = false;\n\t\t\tscrolling = false;\n\t\t\tisCircumstantialInvert = false;\n\t\t\tpastFirstInvertThresh = false;\n\n\t\t\tclearInterval(this._loopId);\n\n\t\t\tclearInterval(pointerElemChangedInterval);\n\t\t\t_clearAutoScrolls();\n\t\t\t_cancelThrottle();\n\n\t\t\tclearTimeout(this._dragStartTimer);\n\n\t\t\t_cancelNextTick(this._cloneId);\n\t\t\t_cancelNextTick(this._dragStartId);\n\n\t\t\t// Unbind events\n\t\t\t_off(document, 'mousemove', this._onTouchMove);\n\n\n\t\t\tif (this.nativeDraggable) {\n\t\t\t\t_off(document, 'drop', this);\n\t\t\t\t_off(el, 'dragstart', this._onDragStart);\n\t\t\t\t_off(document, 'dragover', this._handleAutoScroll);\n\t\t\t\t_off(document, 'dragover', _checkAlignment);\n\t\t\t}\n\n\t\t\tif (Safari) {\n\t\t\t\t_css(document.body, 'user-select', '');\n\t\t\t}\n\n\t\t\tthis._offMoveEvents();\n\t\t\tthis._offUpEvents();\n\n\t\t\tif (evt) {\n\t\t\t\tif (moved) {\n\t\t\t\t\tevt.cancelable && evt.preventDefault();\n\t\t\t\t\t!options.dropBubble && evt.stopPropagation();\n\t\t\t\t}\n\n\t\t\t\tghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);\n\n\t\t\t\tif (rootEl === parentEl || (putSortable && putSortable.lastPutMode !== 'clone')) {\n\t\t\t\t\t// Remove clone\n\t\t\t\t\tcloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);\n\t\t\t\t}\n\n\t\t\t\tif (dragEl) {\n\t\t\t\t\tif (this.nativeDraggable) {\n\t\t\t\t\t\t_off(dragEl, 'dragend', this);\n\t\t\t\t\t}\n\n\t\t\t\t\t_disableDraggable(dragEl);\n\t\t\t\t\tdragEl.style['will-change'] = '';\n\n\t\t\t\t\t// Remove class's\n\t\t\t\t\t_toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);\n\t\t\t\t\t_toggleClass(dragEl, this.options.chosenClass, false);\n\n\t\t\t\t\t// Drag stop event\n\t\t\t\t\t_dispatchEvent(this, rootEl, 'unchoose', dragEl, parentEl, rootEl, oldIndex, null, oldDraggableIndex, null, evt);\n\n\t\t\t\t\tif (rootEl !== parentEl) {\n\t\t\t\t\t\tnewIndex = _index(dragEl);\n\t\t\t\t\t\tnewDraggableIndex = _index(dragEl, options.draggable);\n\n\t\t\t\t\t\tif (newIndex >= 0) {\n\t\t\t\t\t\t\t// Add event\n\t\t\t\t\t\t\t_dispatchEvent(null, parentEl, 'add', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\n\n\t\t\t\t\t\t\t// Remove event\n\t\t\t\t\t\t\t_dispatchEvent(this, rootEl, 'remove', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\n\n\t\t\t\t\t\t\t// drag from one list and drop into another\n\t\t\t\t\t\t\t_dispatchEvent(null, parentEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\n\t\t\t\t\t\t\t_dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tputSortable && putSortable.save();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (dragEl.nextSibling !== nextEl) {\n\t\t\t\t\t\t\t// Get the index of the dragged element within its parent\n\t\t\t\t\t\t\tnewIndex = _index(dragEl);\n\t\t\t\t\t\t\tnewDraggableIndex = _index(dragEl, options.draggable);\n\n\t\t\t\t\t\t\tif (newIndex >= 0) {\n\t\t\t\t\t\t\t\t// drag & drop within the same list\n\t\t\t\t\t\t\t\t_dispatchEvent(this, rootEl, 'update', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\n\t\t\t\t\t\t\t\t_dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Sortable.active) {\n\t\t\t\t\t\t/* jshint eqnull:true */\n\t\t\t\t\t\tif (newIndex == null || newIndex === -1) {\n\t\t\t\t\t\t\tnewIndex = oldIndex;\n\t\t\t\t\t\t\tnewDraggableIndex = oldDraggableIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_dispatchEvent(this, rootEl, 'end', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\n\n\t\t\t\t\t\t// Save sorting\n\t\t\t\t\t\tthis.save();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tthis._nulling();\n\t\t},\n\n\t\t_nulling: function() {\n\t\t\trootEl =\n\t\t\tdragEl =\n\t\t\tparentEl =\n\t\t\tghostEl =\n\t\t\tnextEl =\n\t\t\tcloneEl =\n\t\t\tlastDownEl =\n\n\t\t\tscrollEl =\n\t\t\tscrollParentEl =\n\t\t\tautoScrolls.length =\n\n\t\t\tpointerElemChangedInterval =\n\t\t\tlastPointerElemX =\n\t\t\tlastPointerElemY =\n\n\t\t\ttapEvt =\n\t\t\ttouchEvt =\n\n\t\t\tmoved =\n\t\t\tnewIndex =\n\t\t\toldIndex =\n\n\t\t\tlastTarget =\n\t\t\tlastDirection =\n\n\t\t\trealDragElRect =\n\n\t\t\tputSortable =\n\t\t\tactiveGroup =\n\t\t\tSortable.active = null;\n\n\t\t\tsavedInputChecked.forEach(function (el) {\n\t\t\t\tel.checked = true;\n\t\t\t});\n\n\t\t\tsavedInputChecked.length = 0;\n\t\t},\n\n\t\thandleEvent: function (/**Event*/evt) {\n\t\t\tswitch (evt.type) {\n\t\t\t\tcase 'drop':\n\t\t\t\tcase 'dragend':\n\t\t\t\t\tthis._onDrop(evt);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'dragenter':\n\t\t\t\tcase 'dragover':\n\t\t\t\t\tif (dragEl) {\n\t\t\t\t\t\tthis._onDragOver(evt);\n\t\t\t\t\t\t_globalDragOver(evt);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'selectstart':\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * Serializes the item into an array of string.\n\t\t * @returns {String[]}\n\t\t */\n\t\ttoArray: function () {\n\t\t\tvar order = [],\n\t\t\t\tel,\n\t\t\t\tchildren = this.el.children,\n\t\t\t\ti = 0,\n\t\t\t\tn = children.length,\n\t\t\t\toptions = this.options;\n\n\t\t\tfor (; i < n; i++) {\n\t\t\t\tel = children[i];\n\t\t\t\tif (_closest(el, options.draggable, this.el, false)) {\n\t\t\t\t\torder.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn order;\n\t\t},\n\n\n\t\t/**\n\t\t * Sorts the elements according to the array.\n\t\t * @param  {String[]}  order  order of the items\n\t\t */\n\t\tsort: function (order) {\n\t\t\tvar items = {}, rootEl = this.el;\n\n\t\t\tthis.toArray().forEach(function (id, i) {\n\t\t\t\tvar el = rootEl.children[i];\n\n\t\t\t\tif (_closest(el, this.options.draggable, rootEl, false)) {\n\t\t\t\t\titems[id] = el;\n\t\t\t\t}\n\t\t\t}, this);\n\n\t\t\torder.forEach(function (id) {\n\t\t\t\tif (items[id]) {\n\t\t\t\t\trootEl.removeChild(items[id]);\n\t\t\t\t\trootEl.appendChild(items[id]);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\n\t\t/**\n\t\t * Save the current sorting\n\t\t */\n\t\tsave: function () {\n\t\t\tvar store = this.options.store;\n\t\t\tstore && store.set && store.set(this);\n\t\t},\n\n\n\t\t/**\n\t\t * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\n\t\t * @param   {HTMLElement}  el\n\t\t * @param   {String}       [selector]  default: `options.draggable`\n\t\t * @returns {HTMLElement|null}\n\t\t */\n\t\tclosest: function (el, selector) {\n\t\t\treturn _closest(el, selector || this.options.draggable, this.el, false);\n\t\t},\n\n\n\t\t/**\n\t\t * Set/get option\n\t\t * @param   {string} name\n\t\t * @param   {*}      [value]\n\t\t * @returns {*}\n\t\t */\n\t\toption: function (name, value) {\n\t\t\tvar options = this.options;\n\n\t\t\tif (value === void 0) {\n\t\t\t\treturn options[name];\n\t\t\t} else {\n\t\t\t\toptions[name] = value;\n\n\t\t\t\tif (name === 'group') {\n\t\t\t\t\t_prepareGroup(options);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * Destroy\n\t\t */\n\t\tdestroy: function () {\n\t\t\tvar el = this.el;\n\n\t\t\tel[expando] = null;\n\n\t\t\t_off(el, 'mousedown', this._onTapStart);\n\t\t\t_off(el, 'touchstart', this._onTapStart);\n\t\t\t_off(el, 'pointerdown', this._onTapStart);\n\n\t\t\tif (this.nativeDraggable) {\n\t\t\t\t_off(el, 'dragover', this);\n\t\t\t\t_off(el, 'dragenter', this);\n\t\t\t}\n\t\t\t// Remove draggable attributes\n\t\t\tArray.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {\n\t\t\t\tel.removeAttribute('draggable');\n\t\t\t});\n\n\t\t\tthis._onDrop();\n\n\t\t\tsortables.splice(sortables.indexOf(this.el), 1);\n\n\t\t\tthis.el = el = null;\n\t\t},\n\n\t\t_hideClone: function() {\n\t\t\tif (!cloneEl.cloneHidden) {\n\t\t\t\t_css(cloneEl, 'display', 'none');\n\t\t\t\tcloneEl.cloneHidden = true;\n\t\t\t\tif (cloneEl.parentNode && this.options.removeCloneOnHide) {\n\t\t\t\t\tcloneEl.parentNode.removeChild(cloneEl);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_showClone: function(putSortable) {\n\t\t\tif (putSortable.lastPutMode !== 'clone') {\n\t\t\t\tthis._hideClone();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (cloneEl.cloneHidden) {\n\t\t\t\t// show clone at dragEl or original position\n\t\t\t\tif (rootEl.contains(dragEl) && !this.options.group.revertClone) {\n\t\t\t\t\trootEl.insertBefore(cloneEl, dragEl);\n\t\t\t\t} else if (nextEl) {\n\t\t\t\t\trootEl.insertBefore(cloneEl, nextEl);\n\t\t\t\t} else {\n\t\t\t\t\trootEl.appendChild(cloneEl);\n\t\t\t\t}\n\n\t\t\t\tif (this.options.group.revertClone) {\n\t\t\t\t\tthis._animate(dragEl, cloneEl);\n\t\t\t\t}\n\t\t\t\t_css(cloneEl, 'display', '');\n\t\t\t\tcloneEl.cloneHidden = false;\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction _closest(/**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {\n\t\tif (el) {\n\t\t\tctx = ctx || document;\n\n\t\t\tdo {\n\t\t\t\tif (\n\t\t\t\t\tselector != null &&\n\t\t\t\t\t(\n\t\t\t\t\t\tselector[0] === '>' ?\n\t\t\t\t\t\tel.parentNode === ctx && _matches(el, selector) :\n\t\t\t\t\t\t_matches(el, selector)\n\t\t\t\t\t) ||\n\t\t\t\t\tincludeCTX && el === ctx\n\t\t\t\t) {\n\t\t\t\t\treturn el;\n\t\t\t\t}\n\n\t\t\t\tif (el === ctx) break;\n\t\t\t\t/* jshint boss:true */\n\t\t\t} while (el = _getParentOrHost(el));\n\t\t}\n\n\t\treturn null;\n\t}\n\n\n\tfunction _getParentOrHost(el) {\n\t\treturn (el.host && el !== document && el.host.nodeType)\n\t\t\t? el.host\n\t\t\t: el.parentNode;\n\t}\n\n\n\tfunction _globalDragOver(/**Event*/evt) {\n\t\tif (evt.dataTransfer) {\n\t\t\tevt.dataTransfer.dropEffect = 'move';\n\t\t}\n\t\tevt.cancelable && evt.preventDefault();\n\t}\n\n\n\tfunction _on(el, event, fn) {\n\t\tel.addEventListener(event, fn, IE11OrLess ? false : captureMode);\n\t}\n\n\n\tfunction _off(el, event, fn) {\n\t\tel.removeEventListener(event, fn, IE11OrLess ? false : captureMode);\n\t}\n\n\n\tfunction _toggleClass(el, name, state) {\n\t\tif (el && name) {\n\t\t\tif (el.classList) {\n\t\t\t\tel.classList[state ? 'add' : 'remove'](name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');\n\t\t\t\tel.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfunction _css(el, prop, val) {\n\t\tvar style = el && el.style;\n\n\t\tif (style) {\n\t\t\tif (val === void 0) {\n\t\t\t\tif (document.defaultView && document.defaultView.getComputedStyle) {\n\t\t\t\t\tval = document.defaultView.getComputedStyle(el, '');\n\t\t\t\t}\n\t\t\t\telse if (el.currentStyle) {\n\t\t\t\t\tval = el.currentStyle;\n\t\t\t\t}\n\n\t\t\t\treturn prop === void 0 ? val : val[prop];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!(prop in style) && prop.indexOf('webkit') === -1) {\n\t\t\t\t\tprop = '-webkit-' + prop;\n\t\t\t\t}\n\n\t\t\t\tstyle[prop] = val + (typeof val === 'string' ? '' : 'px');\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction _matrix(el) {\n\t\tvar appliedTransforms = '';\n\t\tdo {\n\t\t\tvar transform = _css(el, 'transform');\n\n\t\t\tif (transform && transform !== 'none') {\n\t\t\t\tappliedTransforms = transform + ' ' + appliedTransforms;\n\t\t\t}\n\t\t\t/* jshint boss:true */\n\t\t} while (el = el.parentNode);\n\n\t\tif (window.DOMMatrix) {\n\t\t\treturn new DOMMatrix(appliedTransforms);\n\t\t} else if (window.WebKitCSSMatrix) {\n\t\t\treturn new WebKitCSSMatrix(appliedTransforms);\n\t\t} else if (window.CSSMatrix) {\n\t\t\treturn new CSSMatrix(appliedTransforms);\n\t\t}\n\t}\n\n\n\tfunction _find(ctx, tagName, iterator) {\n\t\tif (ctx) {\n\t\t\tvar list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;\n\n\t\t\tif (iterator) {\n\t\t\t\tfor (; i < n; i++) {\n\t\t\t\t\titerator(list[i], i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn list;\n\t\t}\n\n\t\treturn [];\n\t}\n\n\n\n\tfunction _dispatchEvent(\n\t\tsortable, rootEl, name,\n\t\ttargetEl, toEl, fromEl,\n\t\tstartIndex, newIndex,\n\t\tstartDraggableIndex, newDraggableIndex,\n\t\toriginalEvt\n\t) {\n\t\tsortable = (sortable || rootEl[expando]);\n\t\tvar evt,\n\t\t\toptions = sortable.options,\n\t\t\tonName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);\n\t\t// Support for new CustomEvent feature\n\t\tif (window.CustomEvent && !IE11OrLess && !Edge) {\n\t\t\tevt = new CustomEvent(name, {\n\t\t\t\tbubbles: true,\n\t\t\t\tcancelable: true\n\t\t\t});\n\t\t} else {\n\t\t\tevt = document.createEvent('Event');\n\t\t\tevt.initEvent(name, true, true);\n\t\t}\n\n\t\tevt.to = toEl || rootEl;\n\t\tevt.from = fromEl || rootEl;\n\t\tevt.item = targetEl || rootEl;\n\t\tevt.clone = cloneEl;\n\n\t\tevt.oldIndex = startIndex;\n\t\tevt.newIndex = newIndex;\n\n\t\tevt.oldDraggableIndex = startDraggableIndex;\n\t\tevt.newDraggableIndex = newDraggableIndex;\n\n\t\tevt.originalEvent = originalEvt;\n\t\tevt.pullMode = putSortable ? putSortable.lastPutMode : undefined;\n\n\t\tif (rootEl) {\n\t\t\trootEl.dispatchEvent(evt);\n\t\t}\n\n\t\tif (options[onName]) {\n\t\t\toptions[onName].call(sortable, evt);\n\t\t}\n\t}\n\n\n\tfunction _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt, willInsertAfter) {\n\t\tvar evt,\n\t\t\tsortable = fromEl[expando],\n\t\t\tonMoveFn = sortable.options.onMove,\n\t\t\tretVal;\n\t\t// Support for new CustomEvent feature\n\t\tif (window.CustomEvent && !IE11OrLess && !Edge) {\n\t\t\tevt = new CustomEvent('move', {\n\t\t\t\tbubbles: true,\n\t\t\t\tcancelable: true\n\t\t\t});\n\t\t} else {\n\t\t\tevt = document.createEvent('Event');\n\t\t\tevt.initEvent('move', true, true);\n\t\t}\n\n\t\tevt.to = toEl;\n\t\tevt.from = fromEl;\n\t\tevt.dragged = dragEl;\n\t\tevt.draggedRect = dragRect;\n\t\tevt.related = targetEl || toEl;\n\t\tevt.relatedRect = targetRect || _getRect(toEl);\n\t\tevt.willInsertAfter = willInsertAfter;\n\n\t\tevt.originalEvent = originalEvt;\n\n\t\tfromEl.dispatchEvent(evt);\n\n\t\tif (onMoveFn) {\n\t\t\tretVal = onMoveFn.call(sortable, evt, originalEvt);\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\tfunction _disableDraggable(el) {\n\t\tel.draggable = false;\n\t}\n\n\tfunction _unsilent() {\n\t\t_silent = false;\n\t}\n\n\t/**\n\t * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\n\t * and non-draggable elements\n\t * @param  {HTMLElement} el       The parent element\n\t * @param  {Number} childNum      The index of the child\n\t * @param  {Object} options       Parent Sortable's options\n\t * @return {HTMLElement}          The child at index childNum, or null if not found\n\t */\n\tfunction _getChild(el, childNum, options) {\n\t\tvar currentChild = 0,\n\t\t\ti = 0,\n\t\t\tchildren = el.children;\n\n\t\twhile (i < children.length) {\n\t\t\tif (\n\t\t\t\tchildren[i].style.display !== 'none' &&\n\t\t\t\tchildren[i] !== ghostEl &&\n\t\t\t\tchildren[i] !== dragEl &&\n\t\t\t\t_closest(children[i], options.draggable, el, false)\n\t\t\t) {\n\t\t\t\tif (currentChild === childNum) {\n\t\t\t\t\treturn children[i];\n\t\t\t\t}\n\t\t\t\tcurrentChild++;\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\n\t * @param  {HTMLElement} el       Parent element\n\t * @return {HTMLElement}          The last child, ignoring ghostEl\n\t */\n\tfunction _lastChild(el) {\n\t\tvar last = el.lastElementChild;\n\n\t\twhile (last && (last === ghostEl || _css(last, 'display') === 'none')) {\n\t\t\tlast = last.previousElementSibling;\n\t\t}\n\n\t\treturn last || null;\n\t}\n\n\tfunction _ghostIsLast(evt, axis, el) {\n\t\tvar elRect = _getRect(_lastChild(el)),\n\t\t\tmouseOnAxis = axis === 'vertical' ? evt.clientY : evt.clientX,\n\t\t\tmouseOnOppAxis = axis === 'vertical' ? evt.clientX : evt.clientY,\n\t\t\ttargetS2 = axis === 'vertical' ? elRect.bottom : elRect.right,\n\t\t\ttargetS1Opp = axis === 'vertical' ? elRect.left : elRect.top,\n\t\t\ttargetS2Opp = axis === 'vertical' ? elRect.right : elRect.bottom,\n\t\t\tspacer = 10;\n\n\t\treturn (\n\t\t\taxis === 'vertical' ?\n\t\t\t\t(mouseOnOppAxis > targetS2Opp + spacer || mouseOnOppAxis <= targetS2Opp && mouseOnAxis > targetS2 && mouseOnOppAxis >= targetS1Opp) :\n\t\t\t\t(mouseOnAxis > targetS2 && mouseOnOppAxis > targetS1Opp || mouseOnAxis <= targetS2 && mouseOnOppAxis > targetS2Opp + spacer)\n\t\t);\n\t}\n\n\tfunction _getSwapDirection(evt, target, axis, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {\n\t\tvar targetRect = _getRect(target),\n\t\t\tmouseOnAxis = axis === 'vertical' ? evt.clientY : evt.clientX,\n\t\t\ttargetLength = axis === 'vertical' ? targetRect.height : targetRect.width,\n\t\t\ttargetS1 = axis === 'vertical' ? targetRect.top : targetRect.left,\n\t\t\ttargetS2 = axis === 'vertical' ? targetRect.bottom : targetRect.right,\n\t\t\tdragRect = _getRect(dragEl),\n\t\t\tinvert = false;\n\n\n\t\tif (!invertSwap) {\n\t\t\t// Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\n\t\t\tif (isLastTarget && targetMoveDistance < targetLength * swapThreshold) { // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\n\t\t\t\t// check if past first invert threshold on side opposite of lastDirection\n\t\t\t\tif (!pastFirstInvertThresh &&\n\t\t\t\t\t(lastDirection === 1 ?\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tmouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2\n\t\t\t\t\t\t) :\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tmouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\t// past first invert threshold, do not restrict inverted threshold to dragEl shadow\n\t\t\t\t\tpastFirstInvertThresh = true;\n\t\t\t\t}\n\n\t\t\t\tif (!pastFirstInvertThresh) {\n\t\t\t\t\tvar dragS1 = axis === 'vertical' ? dragRect.top : dragRect.left,\n\t\t\t\t\t\tdragS2 = axis === 'vertical' ? dragRect.bottom : dragRect.right;\n\t\t\t\t\t// dragEl shadow (target move distance shadow)\n\t\t\t\t\tif (\n\t\t\t\t\t\tlastDirection === 1 ?\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tmouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\n\t\t\t\t\t\t) :\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tmouseOnAxis > targetS2 - targetMoveDistance\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn lastDirection * -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tinvert = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Regular\n\t\t\t\tif (\n\t\t\t\t\tmouseOnAxis > targetS1 + (targetLength * (1 - swapThreshold) / 2) &&\n\t\t\t\t\tmouseOnAxis < targetS2 - (targetLength * (1 - swapThreshold) / 2)\n\t\t\t\t) {\n\t\t\t\t\treturn _getInsertDirection(target);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinvert = invert || invertSwap;\n\n\t\tif (invert) {\n\t\t\t// Invert of regular\n\t\t\tif (\n\t\t\t\tmouseOnAxis < targetS1 + (targetLength * invertedSwapThreshold / 2) ||\n\t\t\t\tmouseOnAxis > targetS2 - (targetLength * invertedSwapThreshold / 2)\n\t\t\t)\n\t\t\t{\n\t\t\t\treturn ((mouseOnAxis > targetS1 + targetLength / 2) ? 1 : -1);\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Gets the direction dragEl must be swapped relative to target in order to make it\n\t * seem that dragEl has been \"inserted\" into that element's position\n\t * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\n\t * @return {Number}                   Direction dragEl must be swapped\n\t */\n\tfunction _getInsertDirection(target) {\n\t\tvar dragElIndex = _index(dragEl),\n\t\t\ttargetIndex = _index(target);\n\n\t\tif (dragElIndex < targetIndex) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\n\t/**\n\t * Generate id\n\t * @param   {HTMLElement} el\n\t * @returns {String}\n\t * @private\n\t */\n\tfunction _generateId(el) {\n\t\tvar str = el.tagName + el.className + el.src + el.href + el.textContent,\n\t\t\ti = str.length,\n\t\t\tsum = 0;\n\n\t\twhile (i--) {\n\t\t\tsum += str.charCodeAt(i);\n\t\t}\n\n\t\treturn sum.toString(36);\n\t}\n\n\t/**\n\t * Returns the index of an element within its parent for a selected set of\n\t * elements\n\t * @param  {HTMLElement} el\n\t * @param  {selector} selector\n\t * @return {number}\n\t */\n\tfunction _index(el, selector) {\n\t\tvar index = 0;\n\n\t\tif (!el || !el.parentNode) {\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (el && (el = el.previousElementSibling)) {\n\t\t\tif ((el.nodeName.toUpperCase() !== 'TEMPLATE') && el !== cloneEl && (!selector || _matches(el, selector))) {\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\n\t\treturn index;\n\t}\n\n\tfunction _matches(/**HTMLElement*/el, /**String*/selector) {\n\t\tif (!selector) return;\n\n\t\tselector[0] === '>' && (selector = selector.substring(1));\n\n\t\tif (el) {\n\t\t\ttry {\n\t\t\t\tif (el.matches) {\n\t\t\t\t\treturn el.matches(selector);\n\t\t\t\t} else if (el.msMatchesSelector) {\n\t\t\t\t\treturn el.msMatchesSelector(selector);\n\t\t\t\t} else if (el.webkitMatchesSelector) {\n\t\t\t\t\treturn el.webkitMatchesSelector(selector);\n\t\t\t\t}\n\t\t\t} catch(_) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tvar _throttleTimeout;\n\tfunction _throttle(callback, ms) {\n\t\treturn function () {\n\t\t\tif (!_throttleTimeout) {\n\t\t\t\tvar args = arguments,\n\t\t\t\t\t_this = this;\n\n\t\t\t\t_throttleTimeout = setTimeout(function () {\n\t\t\t\t\tif (args.length === 1) {\n\t\t\t\t\t\tcallback.call(_this, args[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallback.apply(_this, args);\n\t\t\t\t\t}\n\n\t\t\t\t\t_throttleTimeout = void 0;\n\t\t\t\t}, ms);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction _cancelThrottle() {\n\t\tclearTimeout(_throttleTimeout);\n\t\t_throttleTimeout = void 0;\n\t}\n\n\tfunction _extend(dst, src) {\n\t\tif (dst && src) {\n\t\t\tfor (var key in src) {\n\t\t\t\tif (src.hasOwnProperty(key)) {\n\t\t\t\t\tdst[key] = src[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn dst;\n\t}\n\n\tfunction _clone(el) {\n\t\tif (Polymer && Polymer.dom) {\n\t\t\treturn Polymer.dom(el).cloneNode(true);\n\t\t}\n\t\telse if ($) {\n\t\t\treturn $(el).clone(true)[0];\n\t\t}\n\t\telse {\n\t\t\treturn el.cloneNode(true);\n\t\t}\n\t}\n\n\tfunction _saveInputCheckedState(root) {\n\t\tsavedInputChecked.length = 0;\n\n\t\tvar inputs = root.getElementsByTagName('input');\n\t\tvar idx = inputs.length;\n\n\t\twhile (idx--) {\n\t\t\tvar el = inputs[idx];\n\t\t\tel.checked && savedInputChecked.push(el);\n\t\t}\n\t}\n\n\tfunction _nextTick(fn) {\n\t\treturn setTimeout(fn, 0);\n\t}\n\n\tfunction _cancelNextTick(id) {\n\t\treturn clearTimeout(id);\n\t}\n\n\n\t/**\n\t * Returns the \"bounding client rect\" of given element\n\t * @param  {HTMLElement} el                The element whose boundingClientRect is wanted\n\t * @param  {[HTMLElement]} container       the parent the element will be placed in\n\t * @param  {[Boolean]} adjustForTransform  Whether the rect should compensate for parent's transform\n\t * @return {Object}                        The boundingClientRect of el\n\t */\n\tfunction _getRect(el, adjustForTransform, container, adjustForFixed) {\n\t\tif (!el.getBoundingClientRect && el !== win) return;\n\n\t\tvar elRect,\n\t\t\ttop,\n\t\t\tleft,\n\t\t\tbottom,\n\t\t\tright,\n\t\t\theight,\n\t\t\twidth;\n\n\t\tif (el !== win && el !== _getWindowScrollingElement()) {\n\t\t\telRect = el.getBoundingClientRect();\n\t\t\ttop = elRect.top;\n\t\t\tleft = elRect.left;\n\t\t\tbottom = elRect.bottom;\n\t\t\tright = elRect.right;\n\t\t\theight = elRect.height;\n\t\t\twidth = elRect.width;\n\t\t} else {\n\t\t\ttop = 0;\n\t\t\tleft = 0;\n\t\t\tbottom = window.innerHeight;\n\t\t\tright = window.innerWidth;\n\t\t\theight = window.innerHeight;\n\t\t\twidth = window.innerWidth;\n\t\t}\n\n\t\tif (adjustForFixed && el !== win) {\n\t\t\t// Adjust for translate()\n\t\t\tcontainer = container || el.parentNode;\n\n\t\t\t// solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)\n\t\t\t// Not needed on <= IE11\n\t\t\tif (!IE11OrLess) {\n\t\t\t\tdo {\n\t\t\t\t\tif (container && container.getBoundingClientRect && _css(container, 'transform') !== 'none') {\n\t\t\t\t\t\tvar containerRect = container.getBoundingClientRect();\n\n\t\t\t\t\t\t// Set relative to edges of padding box of container\n\t\t\t\t\t\ttop -= containerRect.top + parseInt(_css(container, 'border-top-width'));\n\t\t\t\t\t\tleft -= containerRect.left + parseInt(_css(container, 'border-left-width'));\n\t\t\t\t\t\tbottom = top + elRect.height;\n\t\t\t\t\t\tright = left + elRect.width;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* jshint boss:true */\n\t\t\t\t} while (container = container.parentNode);\n\t\t\t}\n\t\t}\n\n\t\tif (adjustForTransform && el !== win) {\n\t\t\t// Adjust for scale()\n\t\t\tvar matrix = _matrix(container || el),\n\t\t\t\tscaleX = matrix && matrix.a,\n\t\t\t\tscaleY = matrix && matrix.d;\n\n\t\t\tif (matrix) {\n\t\t\t\ttop /= scaleY;\n\t\t\t\tleft /= scaleX;\n\n\t\t\t\twidth /= scaleX;\n\t\t\t\theight /= scaleY;\n\n\t\t\t\tbottom = top + height;\n\t\t\t\tright = left + width;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttop: top,\n\t\t\tleft: left,\n\t\t\tbottom: bottom,\n\t\t\tright: right,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\t}\n\n\n\t/**\n\t * Checks if a side of an element is scrolled past a side of it's parents\n\t * @param  {HTMLElement}  el       The element who's side being scrolled out of view is in question\n\t * @param  {String}       side     Side of the element in question ('top', 'left', 'right', 'bottom')\n\t * @return {HTMLElement}           The parent scroll element that the el's side is scrolled past, or null if there is no such element\n\t */\n\tfunction _isScrolledPast(el, side) {\n\t\tvar parent = _getParentAutoScrollElement(el, true),\n\t\t\telSide = _getRect(el)[side];\n\n\t\t/* jshint boss:true */\n\t\twhile (parent) {\n\t\t\tvar parentSide = _getRect(parent)[side],\n\t\t\t\tvisible;\n\n\t\t\tif (side === 'top' || side === 'left') {\n\t\t\t\tvisible = elSide >= parentSide;\n\t\t\t} else {\n\t\t\t\tvisible = elSide <= parentSide;\n\t\t\t}\n\n\t\t\tif (!visible) return parent;\n\n\t\t\tif (parent === _getWindowScrollingElement()) break;\n\n\t\t\tparent = _getParentAutoScrollElement(parent, false);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\n\t * The value is returned in real pixels.\n\t * @param  {HTMLElement} el\n\t * @return {Array}             Offsets in the format of [left, top]\n\t */\n\tfunction _getRelativeScrollOffset(el) {\n\t\tvar offsetLeft = 0,\n\t\t\toffsetTop = 0,\n\t\t\twinScroller = _getWindowScrollingElement();\n\n\t\tif (el) {\n\t\t\tdo {\n\t\t\t\tvar matrix = _matrix(el),\n\t\t\t\t\tscaleX = matrix.a,\n\t\t\t\t\tscaleY = matrix.d;\n\n\t\t\t\toffsetLeft += el.scrollLeft * scaleX;\n\t\t\t\toffsetTop += el.scrollTop * scaleY;\n\t\t\t} while (el !== winScroller && (el = el.parentNode));\n\t\t}\n\n\t\treturn [offsetLeft, offsetTop];\n\t}\n\n\t// Fixed #973:\n\t_on(document, 'touchmove', function(evt) {\n\t\tif ((Sortable.active || awaitingDragStarted) && evt.cancelable) {\n\t\t\tevt.preventDefault();\n\t\t}\n\t});\n\n\n\t// Export utils\n\tSortable.utils = {\n\t\ton: _on,\n\t\toff: _off,\n\t\tcss: _css,\n\t\tfind: _find,\n\t\tis: function (el, selector) {\n\t\t\treturn !!_closest(el, selector, el, false);\n\t\t},\n\t\textend: _extend,\n\t\tthrottle: _throttle,\n\t\tclosest: _closest,\n\t\ttoggleClass: _toggleClass,\n\t\tclone: _clone,\n\t\tindex: _index,\n\t\tnextTick: _nextTick,\n\t\tcancelNextTick: _cancelNextTick,\n\t\tdetectDirection: _detectDirection,\n\t\tgetChild: _getChild\n\t};\n\n\n\t/**\n\t * Create sortable instance\n\t * @param {HTMLElement}  el\n\t * @param {Object}      [options]\n\t */\n\tSortable.create = function (el, options) {\n\t\treturn new Sortable(el, options);\n\t};\n\n\n\t// Export\n\tSortable.version = '1.9.0';\n\treturn Sortable;\n});\n\n\n//# sourceURL=webpack:///./node_modules/sortablejs/Sortable.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/vee-validate/dist/locale/ru.js":
/*!*****************************************************!*\
  !*** ./node_modules/vee-validate/dist/locale/ru.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function(n,e){ true?module.exports=e():undefined}(this,function(){\"use strict\";var n,e={name:\"ru\",messages:{_default:function(n){return\"  \"+n+\" .\"},after:function(n,e){var t=e[0];return\"  \"+n+\"     \"+(e[1]?\"  \":\"\")+t+\".\"},alpha:function(n){return\" \"+n+\"    .\"},alpha_dash:function(n){return\" \"+n+\"    ,   .\"},alpha_num:function(n){return\" \"+n+\"      .\"},alpha_spaces:function(n){return\" \"+n+\"      .\"},before:function(n,e){var t=e[0];return\"  \"+n+\"     \"+(e[1]?\"  \":\"\")+t+\".\"},between:function(n,e){return\" \"+n+\"    \"+e[0]+\"  \"+e[1]+\".\"},confirmed:function(n,e){return\" \"+n+\"     \"+e[0]+\".\"},credit_card:function(n){return\" \"+n+\"     \"},date_between:function(n,e){return\" \"+n+\"    \"+e[0]+\"  \"+e[1]+\".\"},date_format:function(n,e){return\" \"+n+\"     \"+e[0]+\".\"},decimal:function(n,e){void 0===e&&(e=[]);var t=e[0];return void 0===t&&(t=\"*\"),\" \"+n+\"      \"+(\"*\"===t?\"  \":\" \"+t+\"  \")+\".\"},digits:function(n,e){return\" \"+n+\"       \"+e[0]+\" .\"},dimensions:function(n,e){return\" \"+n+\"   \"+e[0]+\"   \"+e[1]+\" .\"},email:function(n){return\" \"+n+\"     .\"},excluded:function(n){return\" \"+n+\"    .\"},ext:function(n,e){return\" \"+n+\"    . (\"+e.slice(0)+\")\"},image:function(n){return\" \"+n+\"   .\"},included:function(n){return\" \"+n+\"    .\"},integer:function(n){return\" \"+n+\"    .\"},ip:function(n){return\" \"+n+\"    IP-.\"},length:function(n,e){var t=e[0],r=e[1];return r?\"  \"+n+\"    \"+t+\"  \"+r+\".\":\"  \"+n+\"   \"+t+\".\"},max:function(n,e){return\" \"+n+\"     \"+e[0]+\" .\"},max_value:function(n,e){return\" \"+n+\"   \"+e[0]+\"  .\"},mimes:function(n,e){return\" \"+n+\"     . (\"+e.slice(0)+\")\"},min:function(n,e){return\" \"+n+\"     \"+e[0]+\" .\"},min_value:function(n,e){return\" \"+n+\"   \"+e[0]+\"  .\"},numeric:function(n){return\" \"+n+\"   .\"},regex:function(n){return\" \"+n+\"   .\"},required:function(n){return\" \"+n+\"   .\"},size:function(n,e){return\" \"+n+\"   ,  \"+function(n){var e=1024,t=0===(n=Number(n)*e)?0:Math.floor(Math.log(n)/Math.log(e));return 1*(n/Math.pow(e,t)).toFixed(2)+\" \"+[\"Byte\",\"KB\",\"MB\",\"GB\",\"TB\",\"PB\",\"EB\",\"ZB\",\"YB\"][t]}(e[0])+\".\"},url:function(n){return\" \"+n+\"    URL.\"}},attributes:{}};return\"undefined\"!=typeof VeeValidate&&VeeValidate.Validator.localize(((n={})[e.name]=e,n)),e});\n\n//# sourceURL=webpack:///./node_modules/vee-validate/dist/locale/ru.js?");

/***/ }),

/***/ "./node_modules/vee-validate/dist/vee-validate.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/vee-validate/dist/vee-validate.esm.js ***!
  \************************************************************/
/*! exports provided: default, ErrorBag, Rules, ValidationObserver, ValidationProvider, Validator, directive, install, mapFields, mixin, version, withValidation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ErrorBag\", function() { return ErrorBag; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Rules\", function() { return Rules; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidationObserver\", function() { return ValidationObserver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidationProvider\", function() { return ValidationProvider; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Validator\", function() { return Validator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"directive\", function() { return directive; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"install\", function() { return install; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapFields\", function() { return mapFields; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mixin\", function() { return mixin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return version; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"withValidation\", function() { return withValidation; });\n/**\n  * vee-validate v2.2.12\n  * (c) 2019 Abdelrahman Awad\n  * @license MIT\n  */\n// \n\nvar isTextInput = function (el) {\n  return includes(['text', 'password', 'search', 'email', 'tel', 'url', 'textarea', 'number'], el.type);\n};\n\nvar isCheckboxOrRadioInput = function (el) {\n  return includes(['radio', 'checkbox'], el.type);\n};\n\nvar isDateInput = function (el) {\n  return includes(['date', 'week', 'month', 'datetime-local', 'time'], el.type);\n};\n\n/**\n * Gets the data attribute. the name must be kebab-case.\n */\nvar getDataAttribute = function (el, name) { return el.getAttribute((\"data-vv-\" + name)); };\n\nvar isNaN$1 = function (value) {\n  if ('isNaN' in Number) {\n    return Number.isNaN(value);\n  }\n\n  // eslint-disable-next-line\n  return typeof(value) === 'number' && value !== value;\n};\n\n/**\n * Checks if the values are either null or undefined.\n */\nvar isNullOrUndefined = function () {\n  var values = [], len = arguments.length;\n  while ( len-- ) values[ len ] = arguments[ len ];\n\n  return values.every(function (value) {\n    return value === null || value === undefined;\n  });\n};\n\n/**\n * Creates the default flags object.\n */\nvar createFlags = function () { return ({\n  untouched: true,\n  touched: false,\n  dirty: false,\n  pristine: true,\n  valid: null,\n  invalid: null,\n  validated: false,\n  pending: false,\n  required: false,\n  changed: false\n}); };\n\n/**\n * Shallow object comparison.\n */\nvar isEqual = function (lhs, rhs) {\n  if (lhs instanceof RegExp && rhs instanceof RegExp) {\n    return isEqual(lhs.source, rhs.source) && isEqual(lhs.flags, rhs.flags);\n  }\n\n  if (Array.isArray(lhs) && Array.isArray(rhs)) {\n    if (lhs.length !== rhs.length) { return false; }\n\n    for (var i = 0; i < lhs.length; i++) {\n      if (!isEqual(lhs[i], rhs[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // if both are objects, compare each key recursively.\n  if (isObject(lhs) && isObject(rhs)) {\n    return Object.keys(lhs).every(function (key) {\n      return isEqual(lhs[key], rhs[key]);\n    }) && Object.keys(rhs).every(function (key) {\n      return isEqual(lhs[key], rhs[key]);\n    });\n  }\n\n  if (isNaN$1(lhs) && isNaN$1(rhs)) {\n    return true;\n  }\n\n  return lhs === rhs;\n};\n\n/**\n * Determines the input field scope.\n */\nvar getScope = function (el) {\n  var scope = getDataAttribute(el, 'scope');\n  if (isNullOrUndefined(scope)) {\n    var form = getForm(el);\n\n    if (form) {\n      scope = getDataAttribute(form, 'scope');\n    }\n  }\n\n  return !isNullOrUndefined(scope) ? scope : null;\n};\n\n/**\n * Get the closest form element.\n */\nvar getForm = function (el) {\n  if (isNullOrUndefined(el)) { return null; }\n\n  if (el.tagName === 'FORM') { return el; }\n\n  if (!isNullOrUndefined(el.form)) { return el.form; }\n\n  return !isNullOrUndefined(el.parentNode) ? getForm(el.parentNode) : null;\n};\n\n/**\n * Gets the value in an object safely.\n */\nvar getPath = function (path, target, def) {\n  if ( def === void 0 ) def = undefined;\n\n  if (!path || !target) { return def; }\n\n  var value = target;\n  path.split('.').every(function (prop) {\n    if (prop in value) {\n      value = value[prop];\n\n      return true;\n    }\n\n    value = def;\n\n    return false;\n  });\n\n  return value;\n};\n\n/**\n * Checks if path exists within an object.\n */\nvar hasPath = function (path, target) {\n  var obj = target;\n  var previousPath = null;\n  var isNullOrNonObject = false;\n  var isValidPath = path.split('.').reduce(function (reducer, prop) {\n    if (obj == null || typeof obj !== 'object') {\n      isNullOrNonObject = true;\n      return reducer && false;\n    }\n\n    if (prop in obj) {\n      obj = obj[prop];\n      previousPath = previousPath === null ? prop : previousPath + '.' + prop;\n\n      return reducer && true;\n    }\n\n    return reducer && false;\n  }, true);\n\n  if (true) {\n    if (isNullOrNonObject) {\n      throw new Error(previousPath + ' is not an object');\n    }\n  }\n\n  return isValidPath;\n};\n\n/**\n * Parses a rule string expression.\n */\nvar parseRule = function (rule) {\n  var params = [];\n  var name = rule.split(':')[0];\n\n  if (includes(rule, ':')) {\n    params = rule.split(':').slice(1).join(':').split(',');\n  }\n\n  return { name: name, params: params };\n};\n\n/**\n * Debounces a function.\n */\nvar debounce = function (fn, wait, token) {\n  if ( wait === void 0 ) wait = 0;\n  if ( token === void 0 ) token = { cancelled: false };\n\n  if (wait === 0) {\n    return fn;\n  }\n\n  var timeout;\n\n  return function () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var later = function () {\n      timeout = null;\n\n      // check if the fn call was cancelled.\n      if (!token.cancelled) { fn.apply(void 0, args); }\n    };\n\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (!timeout) { fn.apply(void 0, args); }\n  };\n};\n\n/**\n * Appends a rule definition to a list of rules.\n */\nvar appendRule = function (rule, rules) {\n  if (!rules) {\n    return normalizeRules(rule);\n  }\n\n  if (!rule) {\n    return normalizeRules(rules);\n  }\n\n  if (typeof rules === 'string') {\n    rules = normalizeRules(rules);\n  }\n\n  return assign({}, rules, normalizeRules(rule));\n};\n\n/**\n * Normalizes the given rules expression.\n */\nvar normalizeRules = function (rules) {\n  // if falsy value return an empty object.\n  if (!rules) {\n    return {};\n  }\n\n  if (isObject(rules)) {\n    // $FlowFixMe\n    return Object.keys(rules).reduce(function (prev, curr) {\n      var params = [];\n      // $FlowFixMe\n      if (rules[curr] === true) {\n        params = [];\n      } else if (Array.isArray(rules[curr])) {\n        params = rules[curr];\n      } else if (isObject(rules[curr])) {\n        params = rules[curr];\n      } else {\n        params = [rules[curr]];\n      }\n\n      // $FlowFixMe\n      if (rules[curr] !== false) {\n        prev[curr] = params;\n      }\n\n      return prev;\n    }, {});\n  }\n\n  if (typeof rules !== 'string') {\n    warn('rules must be either a string or an object.');\n    return {};\n  }\n\n  return rules.split('|').reduce(function (prev, rule) {\n    var parsedRule = parseRule(rule);\n    if (!parsedRule.name) {\n      return prev;\n    }\n\n    prev[parsedRule.name] = parsedRule.params;\n    return prev;\n  }, {});\n};\n\n/**\n * Emits a warning to the console.\n */\nvar warn = function (message) {\n  console.warn((\"[vee-validate] \" + message)); // eslint-disable-line\n};\n\n/**\n * Creates a branded error object.\n */\nvar createError = function (message) { return new Error((\"[vee-validate] \" + message)); };\n\n/**\n * Checks if the value is an object.\n */\nvar isObject = function (obj) { return obj !== null && obj && typeof obj === 'object' && ! Array.isArray(obj); };\n\n/**\n * Checks if a function is callable.\n */\nvar isCallable = function (func) { return typeof func === 'function'; };\n\n/**\n * Check if element has the css class on it.\n */\nvar hasClass = function (el, className) {\n  if (el.classList) {\n    return el.classList.contains(className);\n  }\n\n  return !!el.className.match(new RegExp((\"(\\\\s|^)\" + className + \"(\\\\s|$)\")));\n};\n\n/**\n * Adds the provided css className to the element.\n */\nvar addClass = function (el, className) {\n  if (el.classList) {\n    el.classList.add(className);\n    return;\n  }\n\n  if (!hasClass(el, className)) {\n    el.className += \" \" + className;\n  }\n};\n\n/**\n * Remove the provided css className from the element.\n */\nvar removeClass = function (el, className) {\n  if (el.classList) {\n    el.classList.remove(className);\n    return;\n  }\n\n  if (hasClass(el, className)) {\n    var reg = new RegExp((\"(\\\\s|^)\" + className + \"(\\\\s|$)\"));\n    el.className = el.className.replace(reg, ' ');\n  }\n};\n\n/**\n * Adds or removes a class name on the input depending on the status flag.\n */\nvar toggleClass = function (el, className, status) {\n  if (!el || !className) { return; }\n\n  if (Array.isArray(className)) {\n    className.forEach(function (item) { return toggleClass(el, item, status); });\n    return;\n  }\n\n  if (status) {\n    return addClass(el, className);\n  }\n\n  removeClass(el, className);\n};\n\n/**\n * Converts an array-like object to array, provides a simple polyfill for Array.from\n */\nvar toArray = function (arrayLike) {\n  if (isCallable(Array.from)) {\n    return Array.from(arrayLike);\n  }\n\n  var array = [];\n  var length = arrayLike.length;\n  /* istanbul ignore next */\n  for (var i = 0; i < length; i++) {\n    array.push(arrayLike[i]);\n  }\n\n  /* istanbul ignore next */\n  return array;\n};\n\n/**\n * Converts an array-like object to array and place other elements in an array\n */\nvar ensureArray = function (arrayLike) {\n  if (Array.isArray(arrayLike)) {\n    return [].concat( arrayLike );\n  }\n  var array = toArray(arrayLike);\n  return isEmptyArray(array) ? [arrayLike] : array;\n};\n\n/**\n * Assign polyfill from the mdn.\n */\nvar assign = function (target) {\n  var others = [], len = arguments.length - 1;\n  while ( len-- > 0 ) others[ len ] = arguments[ len + 1 ];\n\n  /* istanbul ignore else */\n  if (isCallable(Object.assign)) {\n    return Object.assign.apply(Object, [ target ].concat( others ));\n  }\n\n  /* istanbul ignore next */\n  if (target == null) {\n    throw new TypeError('Cannot convert undefined or null to object');\n  }\n\n  /* istanbul ignore next */\n  var to = Object(target);\n  /* istanbul ignore next */\n  others.forEach(function (arg) {\n    // Skip over if undefined or null\n    if (arg != null) {\n      Object.keys(arg).forEach(function (key) {\n        to[key] = arg[key];\n      });\n    }\n  });\n  /* istanbul ignore next */\n  return to;\n};\n\nvar id = 0;\nvar idTemplate = '{id}';\n\n/**\n * Generates a unique id.\n */\nvar uniqId = function () {\n  // handle too many uses of uniqId, although unlikely.\n  if (id >= 9999) {\n    id = 0;\n    // shift the template.\n    idTemplate = idTemplate.replace('{id}', '_{id}');\n  }\n\n  id++;\n  var newId = idTemplate.replace('{id}', String(id));\n\n  return newId;\n};\n\nvar findIndex = function (arrayLike, predicate) {\n  var array = Array.isArray(arrayLike) ? arrayLike : toArray(arrayLike);\n  for (var i = 0; i < array.length; i++) {\n    if (predicate(array[i])) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\n/**\n * finds the first element that satisfies the predicate callback, polyfills array.find\n */\nvar find = function (arrayLike, predicate) {\n  var array = Array.isArray(arrayLike) ? arrayLike : toArray(arrayLike);\n  var idx = findIndex(array, predicate);\n\n  return idx === -1 ? undefined : array[idx];\n};\n\nvar isBuiltInComponent = function (vnode) {\n  if (!vnode) {\n    return false;\n  }\n\n  var tag = vnode.componentOptions.tag;\n\n  return /^(keep-alive|transition|transition-group)$/.test(tag);\n};\n\nvar makeDelayObject = function (events, delay, delayConfig) {\n  if (typeof delay === 'number') {\n    return events.reduce(function (prev, e) {\n      prev[e] = delay;\n      return prev;\n    }, {});\n  }\n\n  return events.reduce(function (prev, e) {\n    if (typeof delay === 'object' && e in delay) {\n      prev[e] = delay[e];\n      return prev;\n    }\n\n    if (typeof delayConfig === 'number') {\n      prev[e] = delayConfig;\n      return prev;\n    }\n\n    prev[e] = (delayConfig && delayConfig[e]) || 0;\n\n    return prev;\n  }, {});\n};\n\nvar deepParseInt = function (input) {\n  if (typeof input === 'number') { return input; }\n\n  if (typeof input === 'string') { return parseInt(input); }\n\n  var map = {};\n  for (var element in input) {\n    map[element] = parseInt(input[element]);\n  }\n\n  return map;\n};\n\nvar merge = function (target, source) {\n  if (! (isObject(target) && isObject(source))) {\n    return target;\n  }\n\n  Object.keys(source).forEach(function (key) {\n    var obj, obj$1;\n\n    if (isObject(source[key])) {\n      if (! target[key]) {\n        assign(target, ( obj = {}, obj[key] = {}, obj ));\n      }\n\n      merge(target[key], source[key]);\n      return;\n    }\n\n    assign(target, ( obj$1 = {}, obj$1[key] = source[key], obj$1 ));\n  });\n\n  return target;\n};\n\nvar fillRulesFromElement = function (el, rules) {\n  if (el.required) {\n    rules = appendRule('required', rules);\n  }\n\n  if (isTextInput(el)) {\n    if (el.type === 'email') {\n      rules = appendRule((\"email\" + (el.multiple ? ':multiple' : '')), rules);\n    }\n\n    if (el.pattern) {\n      rules = appendRule({ regex: el.pattern }, rules);\n    }\n\n    // 524288 is the max on some browsers and test environments.\n    if (el.maxLength >= 0 && el.maxLength < 524288) {\n      rules = appendRule((\"max:\" + (el.maxLength)), rules);\n    }\n\n    if (el.minLength > 0) {\n      rules = appendRule((\"min:\" + (el.minLength)), rules);\n    }\n\n    if (el.type === 'number') {\n      rules = appendRule('decimal', rules);\n      if (el.min !== '') {\n        rules = appendRule((\"min_value:\" + (el.min)), rules);\n      }\n\n      if (el.max !== '') {\n        rules = appendRule((\"max_value:\" + (el.max)), rules);\n      }\n    }\n\n    return rules;\n  }\n\n  if (isDateInput(el)) {\n    var timeFormat = el.step && Number(el.step) < 60 ? 'HH:mm:ss' : 'HH:mm';\n\n    if (el.type === 'date') {\n      return appendRule('date_format:yyyy-MM-dd', rules);\n    }\n\n    if (el.type === 'datetime-local') {\n      return appendRule((\"date_format:yyyy-MM-ddT\" + timeFormat), rules);\n    }\n\n    if (el.type === 'month') {\n      return appendRule('date_format:yyyy-MM', rules);\n    }\n\n    if (el.type === 'week') {\n      return appendRule('date_format:yyyy-[W]WW', rules);\n    }\n\n    if (el.type === 'time') {\n      return appendRule((\"date_format:\" + timeFormat), rules);\n    }\n  }\n\n  return rules;\n};\n\nvar values = function (obj) {\n  if (isCallable(Object.values)) {\n    return Object.values(obj);\n  }\n\n  // fallback to keys()\n  /* istanbul ignore next */\n  return Object.keys(obj).map(function (k) { return obj[k]; });\n};\n\nvar parseSelector = function (selector) {\n  var rule = null;\n  if (includes(selector, ':')) {\n    rule = selector.split(':').pop();\n    selector = selector.replace((\":\" + rule), '');\n  }\n\n  if (selector[0] === '#') {\n    return {\n      id: selector.slice(1),\n      rule: rule,\n      name: null,\n      scope: null\n    };\n  }\n\n  var scope = null;\n  var name = selector;\n  if (includes(selector, '.')) {\n    var parts = selector.split('.');\n    scope = parts[0];\n    name = parts.slice(1).join('.');\n  }\n\n  return {\n    id: null,\n    scope: scope,\n    name: name,\n    rule: rule\n  };\n};\n\nvar includes = function (collection, item) {\n  return collection.indexOf(item) !== -1;\n};\n\nvar isEmptyArray = function (arr) {\n  return Array.isArray(arr) && arr.length === 0;\n};\n\nvar defineNonReactive = function (obj, prop, value) {\n  Object.defineProperty(obj, prop, {\n    configurable: false,\n    writable: true,\n    value: value\n  });\n};\n\n// \n\nvar LOCALE = 'en';\n\nvar Dictionary = function Dictionary (dictionary) {\n  if ( dictionary === void 0 ) dictionary = {};\n\n  this.container = {};\n  this.merge(dictionary);\n};\n\nvar prototypeAccessors = { locale: { configurable: true } };\n\nprototypeAccessors.locale.get = function () {\n  return LOCALE;\n};\n\nprototypeAccessors.locale.set = function (value) {\n  LOCALE = value || 'en';\n};\n\nDictionary.prototype.hasLocale = function hasLocale (locale) {\n  return !!this.container[locale];\n};\n\nDictionary.prototype.setDateFormat = function setDateFormat (locale, format) {\n  if (!this.container[locale]) {\n    this.container[locale] = {};\n  }\n\n  this.container[locale].dateFormat = format;\n};\n\nDictionary.prototype.getDateFormat = function getDateFormat (locale) {\n  if (!this.container[locale] || !this.container[locale].dateFormat) {\n    return null;\n  }\n\n  return this.container[locale].dateFormat;\n};\n\nDictionary.prototype.getMessage = function getMessage (locale, key, data) {\n  var message = null;\n  if (!this.hasMessage(locale, key)) {\n    message = this._getDefaultMessage(locale);\n  } else {\n    message = this.container[locale].messages[key];\n  }\n\n  return isCallable(message) ? message.apply(void 0, data) : message;\n};\n\n/**\n * Gets a specific message for field. falls back to the rule message.\n */\nDictionary.prototype.getFieldMessage = function getFieldMessage (locale, field, key, data) {\n  if (!this.hasLocale(locale)) {\n    return this.getMessage(locale, key, data);\n  }\n\n  var dict = this.container[locale].custom && this.container[locale].custom[field];\n  if (!dict || !dict[key]) {\n    return this.getMessage(locale, key, data);\n  }\n\n  var message = dict[key];\n  return isCallable(message) ? message.apply(void 0, data) : message;\n};\n\nDictionary.prototype._getDefaultMessage = function _getDefaultMessage (locale) {\n  if (this.hasMessage(locale, '_default')) {\n    return this.container[locale].messages._default;\n  }\n\n  return this.container.en.messages._default;\n};\n\nDictionary.prototype.getAttribute = function getAttribute (locale, key, fallback) {\n    if ( fallback === void 0 ) fallback = '';\n\n  if (!this.hasAttribute(locale, key)) {\n    return fallback;\n  }\n\n  return this.container[locale].attributes[key];\n};\n\nDictionary.prototype.hasMessage = function hasMessage (locale, key) {\n  return !! (\n    this.hasLocale(locale) &&\n          this.container[locale].messages &&\n          this.container[locale].messages[key]\n  );\n};\n\nDictionary.prototype.hasAttribute = function hasAttribute (locale, key) {\n  return !! (\n    this.hasLocale(locale) &&\n          this.container[locale].attributes &&\n          this.container[locale].attributes[key]\n  );\n};\n\nDictionary.prototype.merge = function merge$1 (dictionary) {\n  merge(this.container, dictionary);\n};\n\nDictionary.prototype.setMessage = function setMessage (locale, key, message) {\n  if (! this.hasLocale(locale)) {\n    this.container[locale] = {\n      messages: {},\n      attributes: {}\n    };\n  }\n    \n  if (!this.container[locale].messages) {\n    this.container[locale].messages = {};\n  }\n\n  this.container[locale].messages[key] = message;\n};\n\nDictionary.prototype.setAttribute = function setAttribute (locale, key, attribute) {\n  if (! this.hasLocale(locale)) {\n    this.container[locale] = {\n      messages: {},\n      attributes: {}\n    };\n  }\n\n  this.container[locale].attributes[key] = attribute;\n};\n\nObject.defineProperties( Dictionary.prototype, prototypeAccessors );\n\nvar drivers = {\n  default: new Dictionary({\n    en: {\n      messages: {},\n      attributes: {},\n      custom: {}\n    }\n  })\n};\n\nvar currentDriver = 'default';\n\nvar DictionaryResolver = function DictionaryResolver () {};\n\nDictionaryResolver._checkDriverName = function _checkDriverName (driver) {\n  if (!driver) {\n    throw createError('you must provide a name to the dictionary driver');\n  }\n};\n\nDictionaryResolver.setDriver = function setDriver (driver, implementation) {\n    if ( implementation === void 0 ) implementation = null;\n\n  this._checkDriverName(driver);\n  if (implementation) {\n    drivers[driver] = implementation;\n  }\n\n  currentDriver = driver;\n};\n\nDictionaryResolver.getDriver = function getDriver () {\n  return drivers[currentDriver];\n};\n\n// \n\nvar ErrorBag = function ErrorBag (errorBag, id) {\n  if ( errorBag === void 0 ) errorBag = null;\n  if ( id === void 0 ) id = null;\n\n  this.vmId = id || null;\n  // make this bag a mirror of the provided one, sharing the same items reference.\n  if (errorBag && errorBag instanceof ErrorBag) {\n    this.items = errorBag.items;\n  } else {\n    this.items = [];\n  }\n};\n\nErrorBag.prototype[typeof Symbol === 'function' ? Symbol.iterator : '@@iterator'] = function () {\n    var this$1 = this;\n\n  var index = 0;\n  return {\n    next: function () {\n      return { value: this$1.items[index++], done: index > this$1.items.length };\n    }\n  };\n};\n\n/**\n * Adds an error to the internal array.\n */\nErrorBag.prototype.add = function add (error) {\n    var ref;\n\n  (ref = this.items).push.apply(\n    ref, this._normalizeError(error)\n  );\n};\n\n/**\n * Normalizes passed errors to an error array.\n */\nErrorBag.prototype._normalizeError = function _normalizeError (error) {\n    var this$1 = this;\n\n  if (Array.isArray(error)) {\n    return error.map(function (e) {\n      e.scope = !isNullOrUndefined(e.scope) ? e.scope : null;\n      e.vmId = !isNullOrUndefined(e.vmId) ? e.vmId : (this$1.vmId || null);\n\n      return e;\n    });\n  }\n\n  error.scope = !isNullOrUndefined(error.scope) ? error.scope : null;\n  error.vmId = !isNullOrUndefined(error.vmId) ? error.vmId : (this.vmId || null);\n\n  return [error];\n};\n\n/**\n * Regenrates error messages if they have a generator function.\n */\nErrorBag.prototype.regenerate = function regenerate () {\n  this.items.forEach(function (i) {\n    i.msg = isCallable(i.regenerate) ? i.regenerate() : i.msg;\n  });\n};\n\n/**\n * Updates a field error with the new field scope.\n */\nErrorBag.prototype.update = function update (id, error) {\n  var item = find(this.items, function (i) { return i.id === id; });\n  if (!item) {\n    return;\n  }\n\n  var idx = this.items.indexOf(item);\n  this.items.splice(idx, 1);\n  item.scope = error.scope;\n  this.items.push(item);\n};\n\n/**\n * Gets all error messages from the internal array.\n */\nErrorBag.prototype.all = function all (scope) {\n    var this$1 = this;\n\n  var filterFn = function (item) {\n    var matchesScope = true;\n    var matchesVM = true;\n    if (!isNullOrUndefined(scope)) {\n      matchesScope = item.scope === scope;\n    }\n\n    if (!isNullOrUndefined(this$1.vmId)) {\n      matchesVM = item.vmId === this$1.vmId;\n    }\n\n    return matchesVM && matchesScope;\n  };\n\n  return this.items.filter(filterFn).map(function (e) { return e.msg; });\n};\n\n/**\n * Checks if there are any errors in the internal array.\n */\nErrorBag.prototype.any = function any (scope) {\n    var this$1 = this;\n\n  var filterFn = function (item) {\n    var matchesScope = true;\n    var matchesVM = true;\n    if (!isNullOrUndefined(scope)) {\n      matchesScope = item.scope === scope;\n    }\n\n    if (!isNullOrUndefined(this$1.vmId)) {\n      matchesVM = item.vmId === this$1.vmId;\n    }\n\n    return matchesVM && matchesScope;\n  };\n\n  return !!this.items.filter(filterFn).length;\n};\n\n/**\n * Removes all items from the internal array.\n */\nErrorBag.prototype.clear = function clear (scope) {\n    var this$1 = this;\n\n  var matchesVM = isNullOrUndefined(this.vmId) ? function () { return true; } : function (i) { return i.vmId === this$1.vmId; };\n  if (isNullOrUndefined(scope)) {\n    scope = null;\n  }\n\n  for (var i = 0; i < this.items.length; ++i) {\n    if (matchesVM(this.items[i]) && this.items[i].scope === scope) {\n      this.items.splice(i, 1);\n      --i;\n    }\n  }\n};\n\n/**\n * Collects errors into groups or for a specific field.\n */\nErrorBag.prototype.collect = function collect (field, scope, map) {\n    var this$1 = this;\n    if ( map === void 0 ) map = true;\n\n  var isSingleField = !isNullOrUndefined(field) && !field.includes('*');\n  var groupErrors = function (items) {\n    var errors = items.reduce(function (collection, error) {\n      if (!isNullOrUndefined(this$1.vmId) && error.vmId !== this$1.vmId) {\n        return collection;\n      }\n\n      if (!collection[error.field]) {\n        collection[error.field] = [];\n      }\n\n      collection[error.field].push(map ? error.msg : error);\n\n      return collection;\n    }, {});\n\n    // reduce the collection to be a single array.\n    if (isSingleField) {\n      return values(errors)[0] || [];\n    }\n\n    return errors;\n  };\n\n  if (isNullOrUndefined(field)) {\n    return groupErrors(this.items);\n  }\n\n  var selector = isNullOrUndefined(scope) ? String(field) : (scope + \".\" + field);\n  var ref = this._makeCandidateFilters(selector);\n    var isPrimary = ref.isPrimary;\n    var isAlt = ref.isAlt;\n\n  var collected = this.items.reduce(function (prev, curr) {\n    if (isPrimary(curr)) {\n      prev.primary.push(curr);\n    }\n\n    if (isAlt(curr)) {\n      prev.alt.push(curr);\n    }\n\n    return prev;\n  }, { primary: [], alt: [] });\n\n  collected = collected.primary.length ? collected.primary : collected.alt;\n\n  return groupErrors(collected);\n};\n\n/**\n * Gets the internal array length.\n */\nErrorBag.prototype.count = function count () {\n    var this$1 = this;\n\n  if (this.vmId) {\n    return this.items.filter(function (e) { return e.vmId === this$1.vmId; }).length;\n  }\n\n  return this.items.length;\n};\n\n/**\n * Finds and fetches the first error message for the specified field id.\n */\nErrorBag.prototype.firstById = function firstById (id) {\n  var error = find(this.items, function (i) { return i.id === id; });\n\n  return error ? error.msg : undefined;\n};\n\n/**\n * Gets the first error message for a specific field.\n */\nErrorBag.prototype.first = function first (field, scope) {\n    if ( scope === void 0 ) scope = null;\n\n  var selector = isNullOrUndefined(scope) ? field : (scope + \".\" + field);\n  var match = this._match(selector);\n\n  return match && match.msg;\n};\n\n/**\n * Returns the first error rule for the specified field\n */\nErrorBag.prototype.firstRule = function firstRule (field, scope) {\n  var errors = this.collect(field, scope, false);\n\n  return (errors.length && errors[0].rule) || undefined;\n};\n\n/**\n * Checks if the internal array has at least one error for the specified field.\n */\nErrorBag.prototype.has = function has (field, scope) {\n    if ( scope === void 0 ) scope = null;\n\n  return !!this.first(field, scope);\n};\n\n/**\n * Gets the first error message for a specific field and a rule.\n */\nErrorBag.prototype.firstByRule = function firstByRule (name, rule, scope) {\n    if ( scope === void 0 ) scope = null;\n\n  var error = this.collect(name, scope, false).filter(function (e) { return e.rule === rule; })[0];\n\n  return (error && error.msg) || undefined;\n};\n\n/**\n * Gets the first error message for a specific field that not match the rule.\n */\nErrorBag.prototype.firstNot = function firstNot (name, rule, scope) {\n    if ( rule === void 0 ) rule = 'required';\n    if ( scope === void 0 ) scope = null;\n\n  var error = this.collect(name, scope, false).filter(function (e) { return e.rule !== rule; })[0];\n\n  return (error && error.msg) || undefined;\n};\n\n/**\n * Removes errors by matching against the id or ids.\n */\nErrorBag.prototype.removeById = function removeById (id) {\n  var condition = function (item) { return item.id === id; };\n  if (Array.isArray(id)) {\n    condition = function (item) { return id.indexOf(item.id) !== -1; };\n  }\n\n  for (var i = 0; i < this.items.length; ++i) {\n    if (condition(this.items[i])) {\n      this.items.splice(i, 1);\n      --i;\n    }\n  }\n};\n\n/**\n * Removes all error messages associated with a specific field.\n */\nErrorBag.prototype.remove = function remove (field, scope, vmId) {\n  if (isNullOrUndefined(field)) {\n    return;\n  }\n\n  var selector = isNullOrUndefined(scope) ? String(field) : (scope + \".\" + field);\n  var ref = this._makeCandidateFilters(selector);\n    var isPrimary = ref.isPrimary;\n    var isAlt = ref.isAlt;\n  var matches = function (item) { return isPrimary(item) || isAlt(item); };\n  var shouldRemove = function (item) {\n    if (isNullOrUndefined(vmId)) { return matches(item); }\n\n    return matches(item) && item.vmId === vmId;\n  };\n\n  for (var i = 0; i < this.items.length; ++i) {\n    if (shouldRemove(this.items[i])) {\n      this.items.splice(i, 1);\n      --i;\n    }\n  }\n};\n\nErrorBag.prototype._makeCandidateFilters = function _makeCandidateFilters (selector) {\n    var this$1 = this;\n\n  var matchesRule = function () { return true; };\n  var matchesScope = function () { return true; };\n  var matchesName = function () { return true; };\n  var matchesVM = function () { return true; };\n\n  var ref = parseSelector(selector);\n    var id = ref.id;\n    var rule = ref.rule;\n    var scope = ref.scope;\n    var name = ref.name;\n\n  if (rule) {\n    matchesRule = function (item) { return item.rule === rule; };\n  }\n\n  // match by id, can be combined with rule selection.\n  if (id) {\n    return {\n      isPrimary: function (item) { return matchesRule(item) && (function (item) { return id === item.id; }); },\n      isAlt: function () { return false; }\n    };\n  }\n\n  if (isNullOrUndefined(scope)) {\n    // if no scope specified, make sure the found error has no scope.\n    matchesScope = function (item) { return isNullOrUndefined(item.scope); };\n  } else {\n    matchesScope = function (item) { return item.scope === scope; };\n  }\n\n  if (!isNullOrUndefined(name) && name !== '*') {\n    matchesName = function (item) { return item.field === name; };\n  }\n\n  if (!isNullOrUndefined(this.vmId)) {\n    matchesVM = function (item) { return item.vmId === this$1.vmId; };\n  }\n\n  // matches the first candidate.\n  var isPrimary = function (item) {\n    return matchesVM(item) && matchesName(item) && matchesRule(item) && matchesScope(item);\n  };\n\n  // matches a second candidate, which is a field with a name containing the '.' character.\n  var isAlt = function (item) {\n    return matchesVM(item) && matchesRule(item) && item.field === (scope + \".\" + name);\n  };\n\n  return {\n    isPrimary: isPrimary,\n    isAlt: isAlt\n  };\n};\n\nErrorBag.prototype._match = function _match (selector) {\n  if (isNullOrUndefined(selector)) {\n    return undefined;\n  }\n\n  var ref = this._makeCandidateFilters(selector);\n    var isPrimary = ref.isPrimary;\n    var isAlt = ref.isAlt;\n\n  return this.items.reduce(function (prev, item, idx, arr) {\n    var isLast = idx === arr.length - 1;\n    if (prev.primary) {\n      return isLast ? prev.primary : prev;\n    }\n\n    if (isPrimary(item)) {\n      prev.primary = item;\n    }\n\n    if (isAlt(item)) {\n      prev.alt = item;\n    }\n\n    // keep going.\n    if (!isLast) {\n      return prev;\n    }\n\n    return prev.primary || prev.alt;\n  }, {});\n};\n\nvar DEFAULT_CONFIG = {\n  locale: 'en',\n  delay: 0,\n  errorBagName: 'errors',\n  dictionary: null,\n  fieldsBagName: 'fields',\n  classes: false,\n  classNames: null,\n  events: 'input',\n  inject: true,\n  fastExit: true,\n  aria: true,\n  validity: false,\n  mode: 'aggressive',\n  useConstraintAttrs: true,\n  i18n: null,\n  i18nRootKey: 'validation'\n};\n\nvar currentConfig = assign({}, DEFAULT_CONFIG);\n\nvar resolveConfig = function (ctx) {\n  var selfConfig = getPath('$options.$_veeValidate', ctx, {});\n\n  return assign({}, currentConfig, selfConfig);\n};\n\nvar getConfig = function () { return currentConfig; };\n\nvar setConfig = function (newConf) {\n  currentConfig = assign({}, currentConfig, newConf);\n};\n\n// VNode Utils\n\n// Gets the model object on the vnode.\nfunction findModel (vnode) {\n  if (!vnode.data) {\n    return null;\n  }\n\n  // Component Model\n  if (vnode.data.model) {\n    return vnode.data.model;\n  }\n\n  return !!(vnode.data.directives) && find(vnode.data.directives, function (d) { return d.name === 'model'; });\n}\n\nfunction extractChildren (vnode) {\n  if (Array.isArray(vnode)) {\n    return vnode;\n  }\n\n  if (Array.isArray(vnode.children)) {\n    return vnode.children;\n  }\n\n  if (vnode.componentOptions && Array.isArray(vnode.componentOptions.children)) {\n    return vnode.componentOptions.children;\n  }\n\n  return [];\n}\n\nfunction extractVNodes (vnode) {\n  if (findModel(vnode)) {\n    return [vnode];\n  }\n\n  var children = extractChildren(vnode);\n\n  return children.reduce(function (nodes, node) {\n    var candidates = extractVNodes(node);\n    if (candidates.length) {\n      nodes.push.apply(nodes, candidates);\n    }\n\n    return nodes;\n  }, []);\n}\n\n// Resolves v-model config if exists.\nfunction findModelConfig (vnode) {\n  if (!vnode.componentOptions) { return null; }\n\n  return vnode.componentOptions.Ctor.options.model;\n}\n// Adds a listener to vnode listener object.\nfunction mergeVNodeListeners (obj, eventName, handler) {\n  // Has a single listener.\n  if (isCallable(obj[eventName])) {\n    var prevHandler = obj[eventName];\n    obj[eventName] = [prevHandler];\n  }\n\n  // has other listeners.\n  if (Array.isArray(obj[eventName])) {\n    obj[eventName].push(handler);\n    return;\n  }\n\n  // no listener at all.\n  if (isNullOrUndefined(obj[eventName])) {\n    obj[eventName] = [handler];\n  }\n}\n\n// Adds a listener to a native HTML vnode.\nfunction addNativeNodeListener (node, eventName, handler) {\n  if (isNullOrUndefined(node.data.on)) {\n    node.data.on = {};\n  }\n\n  mergeVNodeListeners(node.data.on, eventName, handler);\n}\n\n// Adds a listener to a Vue component vnode.\nfunction addComponentNodeListener (node, eventName, handler) {\n  /* istanbul ignore next */\n  if (!node.componentOptions.listeners) {\n    node.componentOptions.listeners = {};\n  }\n\n  mergeVNodeListeners(node.componentOptions.listeners, eventName, handler);\n}\nfunction addVNodeListener (vnode, eventName, handler) {\n  if (vnode.componentOptions) {\n    addComponentNodeListener(vnode, eventName, handler);\n    return;\n  }\n\n  addNativeNodeListener(vnode, eventName, handler);\n}\n// Determines if `change` should be used over `input` for listeners.\nfunction getInputEventName (vnode, model) {\n  // Is a component.\n  if (vnode.componentOptions) {\n    var ref = findModelConfig(vnode) || { event: 'input' };\n    var event = ref.event;\n\n    return event;\n  }\n\n  // Lazy Models and select tag typically use change event\n  if ((model && model.modifiers && model.modifiers.lazy) || vnode.tag === 'select') {\n    return 'change';\n  }\n\n  // is a textual-type input.\n  if (vnode.data.attrs && isTextInput({ type: vnode.data.attrs.type || 'text' })) {\n    return 'input';\n  }\n\n  return 'change';\n}\n\nfunction normalizeSlots (slots, ctx) {\n  return Object.keys(slots).reduce(function (arr, key) {\n    slots[key].forEach(function (vnode) {\n      if (!vnode.context) {\n        slots[key].context = ctx;\n        if (!vnode.data) {\n          vnode.data = {};\n        }\n        vnode.data.slot = key;\n      }\n    });\n\n    return arr.concat(slots[key]);\n  }, []);\n}\nfunction createRenderless (h, children) {\n  // Only render the first item of the node.\n  if (Array.isArray(children) && children[0]) {\n    return children[0];\n  }\n\n  // a single node.\n  if (children) {\n    return children;\n  }\n\n  // No slots, render nothing.\n  return h();\n}\n\n/**\n * Generates the options required to construct a field.\n */\nvar Resolver = function Resolver () {};\n\nResolver.generate = function generate (el, binding, vnode) {\n  var model = Resolver.resolveModel(binding, vnode);\n  var options = resolveConfig(vnode.context);\n\n  return {\n    name: Resolver.resolveName(el, vnode),\n    el: el,\n    listen: !binding.modifiers.disable,\n    bails: binding.modifiers.bails ? true : (binding.modifiers.continues === true ? false : undefined),\n    scope: Resolver.resolveScope(el, binding, vnode),\n    vm: vnode.context,\n    expression: binding.value,\n    component: vnode.componentInstance,\n    classes: options.classes,\n    classNames: options.classNames,\n    getter: Resolver.resolveGetter(el, vnode, model),\n    events: Resolver.resolveEvents(el, vnode) || options.events,\n    model: model,\n    delay: Resolver.resolveDelay(el, vnode, options),\n    rules: Resolver.resolveRules(el, binding, vnode),\n    immediate: !!binding.modifiers.initial || !!binding.modifiers.immediate,\n    persist: !!binding.modifiers.persist,\n    validity: options.validity && !vnode.componentInstance,\n    aria: options.aria && !vnode.componentInstance,\n    initialValue: Resolver.resolveInitialValue(vnode)\n  };\n};\n\nResolver.getCtorConfig = function getCtorConfig (vnode) {\n  if (!vnode.componentInstance) { return null; }\n\n  var config = getPath('componentInstance.$options.$_veeValidate', vnode);\n\n  return config;\n};\n\n/**\n * Resolves the rules defined on an element.\n */\nResolver.resolveRules = function resolveRules (el, binding, vnode) {\n  var rules = '';\n  if (!binding.value && (!binding || !binding.expression)) {\n    rules = getDataAttribute(el, 'rules');\n  }\n\n  if (binding.value && includes(['string', 'object'], typeof binding.value.rules)) {\n    rules = binding.value.rules;\n  } else if (binding.value) {\n    rules = binding.value;\n  }\n\n  if (vnode.componentInstance) {\n    return rules;\n  }\n\n  // If validity is disabled, ignore field rules.\n  var normalized = normalizeRules(rules);\n  if (!getConfig().useConstraintAttrs) {\n    return normalized;\n  }\n\n  return assign({}, fillRulesFromElement(el, {}), normalized);\n};\n\n/**\n * @param {*} vnode\n */\nResolver.resolveInitialValue = function resolveInitialValue (vnode) {\n  var model = vnode.data.model || find(vnode.data.directives, function (d) { return d.name === 'model'; });\n\n  return model && model.value;\n};\n\n/**\n * Resolves the delay value.\n * @param {*} el\n * @param {*} vnode\n * @param {Object} options\n */\nResolver.resolveDelay = function resolveDelay (el, vnode, options) {\n  var delay = getDataAttribute(el, 'delay');\n  var globalDelay = (options && 'delay' in options) ? options.delay : 0;\n\n  if (!delay && vnode.componentInstance && vnode.componentInstance.$attrs) {\n    delay = vnode.componentInstance.$attrs['data-vv-delay'];\n  }\n\n  if (!isObject(globalDelay)) {\n    return deepParseInt(delay || globalDelay);\n  }\n\n  if (!isNullOrUndefined(delay)) {\n    globalDelay.input = delay;\n  }\n\n  return deepParseInt(globalDelay);\n};\n\n/**\n * Resolves the events to validate in response to.\n * @param {*} el\n * @param {*} vnode\n */\nResolver.resolveEvents = function resolveEvents (el, vnode) {\n  // resolve it from the root element.\n  var events = getDataAttribute(el, 'validate-on');\n\n  // resolve from data-vv-validate-on if its a vue component.\n  if (!events && vnode.componentInstance && vnode.componentInstance.$attrs) {\n    events = vnode.componentInstance.$attrs['data-vv-validate-on'];\n  }\n\n  // resolve it from $_veeValidate options.\n  if (!events && vnode.componentInstance) {\n    var config = Resolver.getCtorConfig(vnode);\n    events = config && config.events;\n  }\n\n  if (!events && getConfig().events) {\n    events = getConfig().events;\n  }\n\n  // resolve the model event if its configured for custom components.\n  if (events && vnode.componentInstance && includes(events, 'input')) {\n    var ref = vnode.componentInstance.$options.model || { event: 'input' };\n      var event = ref.event;\n    // if the prop was configured but not the model.\n    if (!event) {\n      return events;\n    }\n\n    events = events.replace('input', event);\n  }\n\n  return events;\n};\n\n/**\n * Resolves the scope for the field.\n * @param {*} el\n * @param {*} binding\n */\nResolver.resolveScope = function resolveScope (el, binding, vnode) {\n    if ( vnode === void 0 ) vnode = {};\n\n  var scope = null;\n  if (vnode.componentInstance && isNullOrUndefined(scope)) {\n    scope = vnode.componentInstance.$attrs && vnode.componentInstance.$attrs['data-vv-scope'];\n  }\n\n  return !isNullOrUndefined(scope) ? scope : getScope(el);\n};\n\n/**\n * Checks if the node directives contains a v-model or a specified arg.\n * Args take priority over models.\n *\n * @return {Object}\n */\nResolver.resolveModel = function resolveModel (binding, vnode) {\n  if (binding.arg) {\n    return { expression: binding.arg };\n  }\n\n  var model = findModel(vnode);\n  if (!model) {\n    return null;\n  }\n\n  // https://github.com/vuejs/vue/blob/dev/src/core/util/lang.js#L26\n  var watchable = !/[^\\w.$]/.test(model.expression) && hasPath(model.expression, vnode.context);\n  var lazy = !!(model.modifiers && model.modifiers.lazy);\n\n  if (!watchable) {\n    return { expression: null, lazy: lazy };\n  }\n\n  return { expression: model.expression, lazy: lazy };\n};\n\n/**\n * Resolves the field name to trigger validations.\n * @return {String} The field name.\n */\nResolver.resolveName = function resolveName (el, vnode) {\n  var name = getDataAttribute(el, 'name');\n\n  if (!name && !vnode.componentInstance) {\n    return el.name;\n  }\n\n  if (!name && vnode.componentInstance && vnode.componentInstance.$attrs) {\n    name = vnode.componentInstance.$attrs['data-vv-name'] || vnode.componentInstance.$attrs['name'];\n  }\n\n  if (!name && vnode.componentInstance) {\n    var config = Resolver.getCtorConfig(vnode);\n    if (config && isCallable(config.name)) {\n      var boundGetter = config.name.bind(vnode.componentInstance);\n\n      return boundGetter();\n    }\n\n    return vnode.componentInstance.name;\n  }\n\n  return name;\n};\n\n/**\n * Returns a value getter input type.\n */\nResolver.resolveGetter = function resolveGetter (el, vnode, model) {\n  if (model && model.expression) {\n    return function () {\n      return getPath(model.expression, vnode.context);\n    };\n  }\n\n  if (vnode.componentInstance) {\n    var path = getDataAttribute(el, 'value-path') || (vnode.componentInstance.$attrs && vnode.componentInstance.$attrs['data-vv-value-path']);\n    if (path) {\n      return function () {\n        return getPath(path, vnode.componentInstance);\n      };\n    }\n\n    var config = Resolver.getCtorConfig(vnode);\n    if (config && isCallable(config.value)) {\n      var boundGetter = config.value.bind(vnode.componentInstance);\n\n      return function () {\n        return boundGetter();\n      };\n    }\n\n    var ref = vnode.componentInstance.$options.model || { prop: 'value' };\n      var prop = ref.prop;\n\n    return function () {\n      return vnode.componentInstance[prop];\n    };\n  }\n\n  switch (el.type) {\n  case 'checkbox': return function () {\n    var els = document.querySelectorAll((\"input[name=\\\"\" + (el.name) + \"\\\"]\"));\n\n    els = toArray(els).filter(function (el) { return el.checked; });\n    if (!els.length) { return undefined; }\n\n    return els.map(function (checkbox) { return checkbox.value; });\n  };\n  case 'radio': return function () {\n    var els = document.querySelectorAll((\"input[name=\\\"\" + (el.name) + \"\\\"]\"));\n    var elm = find(els, function (el) { return el.checked; });\n\n    return elm && elm.value;\n  };\n  case 'file': return function (context) {\n    return toArray(el.files);\n  };\n  case 'select-multiple': return function () {\n    return toArray(el.options).filter(function (opt) { return opt.selected; }).map(function (opt) { return opt.value; });\n  };\n  default: return function () {\n    return el && el.value;\n  };\n  }\n};\n\nvar RULES = {};\n\nvar RuleContainer = function RuleContainer () {};\n\nvar staticAccessors = { rules: { configurable: true } };\n\nRuleContainer.add = function add (name, ref) {\n    var validate = ref.validate;\n    var options = ref.options;\n    var paramNames = ref.paramNames;\n\n  RULES[name] = {\n    validate: validate,\n    options: options,\n    paramNames: paramNames\n  };\n};\n\nstaticAccessors.rules.get = function () {\n  return RULES;\n};\n\nRuleContainer.has = function has (name) {\n  return !!RULES[name];\n};\n\nRuleContainer.isImmediate = function isImmediate (name) {\n  return !!(RULES[name] && RULES[name].options.immediate);\n};\n\nRuleContainer.isRequireRule = function isRequireRule (name) {\n  return !!(RULES[name] && RULES[name].options.computesRequired);\n};\n\nRuleContainer.isTargetRule = function isTargetRule (name) {\n  return !!(RULES[name] && RULES[name].options.hasTarget);\n};\n\nRuleContainer.remove = function remove (ruleName) {\n  delete RULES[ruleName];\n};\n\nRuleContainer.getParamNames = function getParamNames (ruleName) {\n  return RULES[ruleName] && RULES[ruleName].paramNames;\n};\n\nRuleContainer.getOptions = function getOptions (ruleName) {\n  return RULES[ruleName] && RULES[ruleName].options;\n};\n\nRuleContainer.getValidatorMethod = function getValidatorMethod (ruleName) {\n  return RULES[ruleName] ? RULES[ruleName].validate : null;\n};\n\nObject.defineProperties( RuleContainer, staticAccessors );\n\n// \n\nvar isEvent = function (evt) {\n  return (typeof Event !== 'undefined' && isCallable(Event) && evt instanceof Event) || (evt && evt.srcElement);\n};\n\nvar normalizeEvents = function (evts) {\n  if (!evts) { return []; }\n\n  return (typeof evts === 'string' ? evts.split('|') : evts);\n};\n\nvar supportsPassive = true;\n\nvar detectPassiveSupport = function () {\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      get: function get () {\n        supportsPassive = true;\n      }\n    });\n    window.addEventListener('testPassive', null, opts);\n    window.removeEventListener('testPassive', null, opts);\n  } catch (e) {\n    supportsPassive = false;\n  }\n  return supportsPassive;\n};\n\nvar addEventListener = function (el, eventName, cb) {\n  el.addEventListener(eventName, cb, supportsPassive ? { passive: true } : false);\n};\n\n// \n\nvar DEFAULT_OPTIONS = {\n  targetOf: null,\n  immediate: false,\n  persist: false,\n  scope: null,\n  listen: true,\n  name: null,\n  rules: {},\n  vm: null,\n  classes: false,\n  validity: true,\n  aria: true,\n  events: 'input|blur',\n  delay: 0,\n  classNames: {\n    touched: 'touched', // the control has been blurred\n    untouched: 'untouched', // the control hasn't been blurred\n    valid: 'valid', // model is valid\n    invalid: 'invalid', // model is invalid\n    pristine: 'pristine', // control has not been interacted with\n    dirty: 'dirty' // control has been interacted with\n  }\n};\n\nvar Field = function Field (options) {\n  if ( options === void 0 ) options = {};\n\n  this.id = uniqId();\n  this.el = options.el;\n  this.updated = false;\n  this.vmId = options.vmId;\n  defineNonReactive(this, 'dependencies', []);\n  defineNonReactive(this, 'watchers', []);\n  defineNonReactive(this, 'events', []);\n  this.delay = 0;\n  this.rules = {};\n  this.forceRequired = false;\n  this._cacheId(options);\n  this.classNames = assign({}, DEFAULT_OPTIONS.classNames);\n  options = assign({}, DEFAULT_OPTIONS, options);\n  this._delay = !isNullOrUndefined(options.delay) ? options.delay : 0; // cache initial delay\n  this.validity = options.validity;\n  this.aria = options.aria;\n  this.flags = options.flags || createFlags();\n  defineNonReactive(this, 'vm', options.vm);\n  defineNonReactive(this, 'componentInstance', options.component);\n  this.ctorConfig = this.componentInstance ? getPath('$options.$_veeValidate', this.componentInstance) : undefined;\n  this.update(options);\n  // set initial value.\n  this.initialValue = this.value;\n  this.updated = false;\n};\n\nvar prototypeAccessors$1 = { validator: { configurable: true },isRequired: { configurable: true },isDisabled: { configurable: true },alias: { configurable: true },value: { configurable: true },bails: { configurable: true },rejectsFalse: { configurable: true } };\n\nprototypeAccessors$1.validator.get = function () {\n  if (!this.vm || !this.vm.$validator) {\n    return { validate: function () { return Promise.resolve(true); } };\n  }\n\n  return this.vm.$validator;\n};\n\nprototypeAccessors$1.isRequired.get = function () {\n  return !!this.rules.required || this.forceRequired;\n};\n\nprototypeAccessors$1.isDisabled.get = function () {\n  return !!(this.el && this.el.disabled);\n};\n\n/**\n * Gets the display name (user-friendly name).\n */\nprototypeAccessors$1.alias.get = function () {\n  if (this._alias) {\n    return this._alias;\n  }\n\n  var alias = null;\n  if (this.ctorConfig && this.ctorConfig.alias) {\n    alias = isCallable(this.ctorConfig.alias) ? this.ctorConfig.alias.call(this.componentInstance) : this.ctorConfig.alias;\n  }\n\n  if (!alias && this.el) {\n    alias = getDataAttribute(this.el, 'as');\n  }\n\n  if (!alias && this.componentInstance) {\n    return this.componentInstance.$attrs && this.componentInstance.$attrs['data-vv-as'];\n  }\n\n  return alias;\n};\n\n/**\n * Gets the input value.\n */\n\nprototypeAccessors$1.value.get = function () {\n  if (!isCallable(this.getter)) {\n    return undefined;\n  }\n\n  return this.getter();\n};\n\nprototypeAccessors$1.bails.get = function () {\n  return this._bails;\n};\n\n/**\n * If the field rejects false as a valid value for the required rule.\n */\n\nprototypeAccessors$1.rejectsFalse.get = function () {\n  if (this.componentInstance && this.ctorConfig) {\n    return !!this.ctorConfig.rejectsFalse;\n  }\n\n  if (!this.el) {\n    return false;\n  }\n\n  return this.el.type === 'checkbox';\n};\n\n/**\n * Determines if the instance matches the options provided.\n */\nField.prototype.matches = function matches (options) {\n    var this$1 = this;\n\n  if (!options) {\n    return true;\n  }\n\n  if (options.id) {\n    return this.id === options.id;\n  }\n\n  var matchesComponentId = isNullOrUndefined(options.vmId) ? function () { return true; } : function (id) { return id === this$1.vmId; };\n  if (!matchesComponentId(options.vmId)) {\n    return false;\n  }\n\n  if (options.name === undefined && options.scope === undefined) {\n    return true;\n  }\n\n  if (options.scope === undefined) {\n    return this.name === options.name;\n  }\n\n  if (options.name === undefined) {\n    return this.scope === options.scope;\n  }\n\n  return options.name === this.name && options.scope === this.scope;\n};\n\n/**\n * Caches the field id.\n */\nField.prototype._cacheId = function _cacheId (options) {\n  if (this.el && !options.targetOf) {\n    this.el._veeValidateId = this.id;\n  }\n};\n\n/**\n * Keeps a reference of the most current validation run.\n */\nField.prototype.waitFor = function waitFor (pendingPromise) {\n  this._waitingFor = pendingPromise;\n};\n\nField.prototype.isWaitingFor = function isWaitingFor (promise) {\n  return this._waitingFor === promise;\n};\n\n/**\n * Updates the field with changed data.\n */\nField.prototype.update = function update (options) {\n    var this$1 = this;\n\n  this.targetOf = options.targetOf || null;\n  this.immediate = options.immediate || this.immediate || false;\n  this.persist = options.persist || this.persist || false;\n\n  // update errors scope if the field scope was changed.\n  if (!isNullOrUndefined(options.scope) && options.scope !== this.scope && isCallable(this.validator.update)) {\n    this.validator.update(this.id, { scope: options.scope });\n  }\n  this.scope = !isNullOrUndefined(options.scope) ? options.scope\n    : !isNullOrUndefined(this.scope) ? this.scope : null;\n  this.name = (!isNullOrUndefined(options.name) ? String(options.name) : options.name) || this.name || null;\n  this.rules = options.rules !== undefined ? normalizeRules(options.rules) : this.rules;\n  this._bails = options.bails !== undefined ? options.bails : this._bails;\n  this.model = options.model || this.model;\n  this.listen = options.listen !== undefined ? options.listen : this.listen;\n  this.classes = (options.classes || this.classes || false) && !this.componentInstance;\n  this.classNames = isObject(options.classNames) ? merge(this.classNames, options.classNames) : this.classNames;\n  this.getter = isCallable(options.getter) ? options.getter : this.getter;\n  this._alias = options.alias || this._alias;\n  this.events = (options.events) ? normalizeEvents(options.events) : this.events;\n  this.delay = makeDelayObject(this.events, options.delay || this.delay, this._delay);\n  this.updateDependencies();\n  this.addActionListeners();\n\n  if ( true && !this.name && !this.targetOf) {\n    warn('A field is missing a \"name\" or \"data-vv-name\" attribute');\n  }\n\n  // update required flag flags\n  if (options.rules !== undefined) {\n    this.flags.required = this.isRequired;\n  }\n\n  if (Object.keys(options.rules || {}).length === 0 && this.updated) {\n    var resetFlag = this.flags.validated;\n    this.validator.validate((\"#\" + (this.id))).then(function () {\n      this$1.flags.validated = resetFlag;\n    });\n  }\n\n  // validate if it was validated before and field was updated and there was a rules mutation.\n  if (this.flags.validated && options.rules !== undefined && this.updated) {\n    this.validator.validate((\"#\" + (this.id)));\n  }\n\n  this.updated = true;\n  this.addValueListeners();\n\n  // no need to continue.\n  if (!this.el) {\n    return;\n  }\n  this.updateClasses();\n  this.updateAriaAttrs();\n};\n\n/**\n * Resets field flags and errors.\n */\nField.prototype.reset = function reset () {\n    var this$1 = this;\n\n  if (this._cancellationToken) {\n    this._cancellationToken.cancelled = true;\n    delete this._cancellationToken;\n  }\n\n  var defaults = createFlags();\n  Object.keys(this.flags).filter(function (flag) { return flag !== 'required'; }).forEach(function (flag) {\n    this$1.flags[flag] = defaults[flag];\n  });\n\n  // update initial value\n  this.initialValue = this.value;\n  this.flags.changed = false;\n\n  this.addValueListeners();\n  this.addActionListeners();\n  this.updateClasses(true);\n  this.updateAriaAttrs();\n  this.updateCustomValidity();\n};\n\n/**\n * Sets the flags and their negated counterparts, and updates the classes and re-adds action listeners.\n */\nField.prototype.setFlags = function setFlags (flags) {\n    var this$1 = this;\n\n  var negated = {\n    pristine: 'dirty',\n    dirty: 'pristine',\n    valid: 'invalid',\n    invalid: 'valid',\n    touched: 'untouched',\n    untouched: 'touched'\n  };\n\n  Object.keys(flags).forEach(function (flag) {\n    this$1.flags[flag] = flags[flag];\n    // if it has a negation and was not specified, set it as well.\n    if (negated[flag] && flags[negated[flag]] === undefined) {\n      this$1.flags[negated[flag]] = !flags[flag];\n    }\n  });\n\n  if (\n    flags.untouched !== undefined ||\n    flags.touched !== undefined ||\n    flags.dirty !== undefined ||\n    flags.pristine !== undefined\n  ) {\n    this.addActionListeners();\n  }\n  this.updateClasses();\n  this.updateAriaAttrs();\n  this.updateCustomValidity();\n};\n\n/**\n * Determines if the field requires references to target fields.\n*/\nField.prototype.updateDependencies = function updateDependencies () {\n    var this$1 = this;\n\n  // reset dependencies.\n  this.dependencies.forEach(function (d) { return d.field.destroy(); });\n  this.dependencies = [];\n\n  // we get the selectors for each field.\n  var fields = Object.keys(this.rules).reduce(function (prev, r) {\n    if (RuleContainer.isTargetRule(r)) {\n      prev.push({ selector: this$1.rules[r][0], name: r });\n    }\n\n    return prev;\n  }, []);\n\n  if (!fields.length || !this.vm || !this.vm.$el) { return; }\n\n  // must be contained within the same component, so we use the vm root element constrain our dom search.\n  fields.forEach(function (ref$1) {\n      var selector = ref$1.selector;\n      var name = ref$1.name;\n\n    var ref = this$1.vm.$refs[selector];\n    var el = Array.isArray(ref) ? ref[0] : ref;\n    if (!el) {\n      return;\n    }\n\n    var options = {\n      vm: this$1.vm,\n      classes: this$1.classes,\n      classNames: this$1.classNames,\n      delay: this$1.delay,\n      scope: this$1.scope,\n      events: this$1.events.join('|'),\n      immediate: this$1.immediate,\n      targetOf: this$1.id\n    };\n\n    // probably a component.\n    if (isCallable(el.$watch)) {\n      options.component = el;\n      options.el = el.$el;\n      options.getter = Resolver.resolveGetter(el.$el, el.$vnode);\n    } else {\n      options.el = el;\n      options.getter = Resolver.resolveGetter(el, {});\n    }\n\n    this$1.dependencies.push({ name: name, field: new Field(options) });\n  });\n};\n\n/**\n * Removes listeners.\n */\nField.prototype.unwatch = function unwatch (tag) {\n    if ( tag === void 0 ) tag = null;\n\n  if (!tag) {\n    this.watchers.forEach(function (w) { return w.unwatch(); });\n    this.watchers = [];\n    return;\n  }\n\n  this.watchers.filter(function (w) { return tag.test(w.tag); }).forEach(function (w) { return w.unwatch(); });\n  this.watchers = this.watchers.filter(function (w) { return !tag.test(w.tag); });\n};\n\n/**\n * Updates the element classes depending on each field flag status.\n */\nField.prototype.updateClasses = function updateClasses (isReset) {\n    var this$1 = this;\n    if ( isReset === void 0 ) isReset = false;\n\n  if (!this.classes || this.isDisabled) { return; }\n  var applyClasses = function (el) {\n    toggleClass(el, this$1.classNames.dirty, this$1.flags.dirty);\n    toggleClass(el, this$1.classNames.pristine, this$1.flags.pristine);\n    toggleClass(el, this$1.classNames.touched, this$1.flags.touched);\n    toggleClass(el, this$1.classNames.untouched, this$1.flags.untouched);\n\n    // remove valid/invalid classes on reset.\n    if (isReset) {\n      toggleClass(el, this$1.classNames.valid, false);\n      toggleClass(el, this$1.classNames.invalid, false);\n    }\n\n    // make sure we don't set any classes if the state is undetermined.\n    if (!isNullOrUndefined(this$1.flags.valid) && this$1.flags.validated) {\n      toggleClass(el, this$1.classNames.valid, this$1.flags.valid);\n    }\n\n    if (!isNullOrUndefined(this$1.flags.invalid) && this$1.flags.validated) {\n      toggleClass(el, this$1.classNames.invalid, this$1.flags.invalid);\n    }\n  };\n\n  if (!isCheckboxOrRadioInput(this.el)) {\n    applyClasses(this.el);\n    return;\n  }\n\n  var els = document.querySelectorAll((\"input[name=\\\"\" + (this.el.name) + \"\\\"]\"));\n  toArray(els).forEach(applyClasses);\n};\n\n/**\n * Adds the listeners required for automatic classes and some flags.\n */\nField.prototype.addActionListeners = function addActionListeners () {\n    var this$1 = this;\n\n  // remove previous listeners.\n  this.unwatch(/class/);\n\n  if (!this.el) { return; }\n\n  var onBlur = function () {\n    this$1.flags.touched = true;\n    this$1.flags.untouched = false;\n    if (this$1.classes) {\n      toggleClass(this$1.el, this$1.classNames.touched, true);\n      toggleClass(this$1.el, this$1.classNames.untouched, false);\n    }\n\n    // only needed once.\n    this$1.unwatch(/^class_blur$/);\n  };\n\n  var inputEvent = isTextInput(this.el) ? 'input' : 'change';\n  var onInput = function () {\n    this$1.flags.dirty = true;\n    this$1.flags.pristine = false;\n    if (this$1.classes) {\n      toggleClass(this$1.el, this$1.classNames.pristine, false);\n      toggleClass(this$1.el, this$1.classNames.dirty, true);\n    }\n\n    // only needed once.\n    this$1.unwatch(/^class_input$/);\n  };\n\n  if (this.componentInstance && isCallable(this.componentInstance.$once)) {\n    this.componentInstance.$once('input', onInput);\n    this.componentInstance.$once('blur', onBlur);\n    this.watchers.push({\n      tag: 'class_input',\n      unwatch: function () {\n        this$1.componentInstance.$off('input', onInput);\n      }\n    });\n    this.watchers.push({\n      tag: 'class_blur',\n      unwatch: function () {\n        this$1.componentInstance.$off('blur', onBlur);\n      }\n    });\n    return;\n  }\n\n  if (!this.el) { return; }\n\n  addEventListener(this.el, inputEvent, onInput);\n  // Checkboxes and radio buttons on Mac don't emit blur naturally, so we listen on click instead.\n  var blurEvent = isCheckboxOrRadioInput(this.el) ? 'change' : 'blur';\n  addEventListener(this.el, blurEvent, onBlur);\n  this.watchers.push({\n    tag: 'class_input',\n    unwatch: function () {\n      this$1.el.removeEventListener(inputEvent, onInput);\n    }\n  });\n\n  this.watchers.push({\n    tag: 'class_blur',\n    unwatch: function () {\n      this$1.el.removeEventListener(blurEvent, onBlur);\n    }\n  });\n};\n\nField.prototype.checkValueChanged = function checkValueChanged () {\n  // handle some people initialize the value to null, since text inputs have empty string value.\n  if (this.initialValue === null && this.value === '' && isTextInput(this.el)) {\n    return false;\n  }\n\n  return this.value !== this.initialValue;\n};\n\n/**\n * Determines the suitable primary event to listen for.\n */\nField.prototype._determineInputEvent = function _determineInputEvent () {\n  // if its a custom component, use the customized model event or the input event.\n  if (this.componentInstance) {\n    return (this.componentInstance.$options.model && this.componentInstance.$options.model.event) || 'input';\n  }\n\n  if (this.model && this.model.lazy) {\n    return 'change';\n  }\n\n  if (isTextInput(this.el)) {\n    return 'input';\n  }\n\n  return 'change';\n};\n\n/**\n * Determines the list of events to listen to.\n */\nField.prototype._determineEventList = function _determineEventList (defaultInputEvent) {\n    var this$1 = this;\n\n  // if no event is configured, or it is a component or a text input then respect the user choice.\n  if (!this.events.length || this.componentInstance || isTextInput(this.el)) {\n    return [].concat( this.events ).map(function (evt) {\n      if (evt === 'input' && this$1.model && this$1.model.lazy) {\n        return 'change';\n      }\n\n      return evt;\n    });\n  }\n\n  // force suitable event for non-text type fields.\n  return this.events.map(function (e) {\n    if (e === 'input') {\n      return defaultInputEvent;\n    }\n\n    return e;\n  });\n};\n\n/**\n * Adds the listeners required for validation.\n */\nField.prototype.addValueListeners = function addValueListeners () {\n    var this$1 = this;\n\n  this.unwatch(/^input_.+/);\n  if (!this.listen || !this.el) { return; }\n\n  var token = { cancelled: false };\n  var fn = this.targetOf ? function () {\n    var target = this$1.validator._resolveField((\"#\" + (this$1.targetOf)));\n    if (target && target.flags.validated) {\n      this$1.validator.validate((\"#\" + (this$1.targetOf)));\n    }\n  } : function () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n    // if its a DOM event, resolve the value, otherwise use the first parameter as the value.\n    if (args.length === 0 || isEvent(args[0])) {\n      args[0] = this$1.value;\n    }\n\n    this$1.flags.pending = true;\n    this$1._cancellationToken = token;\n    this$1.validator.validate((\"#\" + (this$1.id)), args[0]);\n  };\n\n  var inputEvent = this._determineInputEvent();\n  var events = this._determineEventList(inputEvent);\n\n  // if on input validation is requested.\n  if (includes(events, inputEvent)) {\n    var ctx = null;\n    var expression = null;\n    var watchCtxVm = false;\n    // if its watchable from the context vm.\n    if (this.model && this.model.expression) {\n      ctx = this.vm;\n      expression = this.model.expression;\n      watchCtxVm = true;\n    }\n\n    // watch it from the custom component vm instead.\n    if (!expression && this.componentInstance && this.componentInstance.$options.model) {\n      ctx = this.componentInstance;\n      expression = this.componentInstance.$options.model.prop || 'value';\n    }\n\n    if (ctx && expression) {\n      var debouncedFn = debounce(fn, this.delay[inputEvent], token);\n      var unwatch = ctx.$watch(expression, debouncedFn);\n      this.watchers.push({\n        tag: 'input_model',\n        unwatch: function () {\n          this$1.vm.$nextTick(function () {\n            unwatch();\n          });\n        }\n      });\n\n      // filter out input event when we are watching from the context vm.\n      if (watchCtxVm) {\n        events = events.filter(function (e) { return e !== inputEvent; });\n      }\n    }\n  }\n\n  // Add events.\n  events.forEach(function (e) {\n    var debouncedFn = debounce(fn, this$1.delay[e], token);\n\n    this$1._addComponentEventListener(e, debouncedFn);\n    this$1._addHTMLEventListener(e, debouncedFn);\n  });\n};\n\nField.prototype._addComponentEventListener = function _addComponentEventListener (evt, validate) {\n    var this$1 = this;\n\n  if (!this.componentInstance) { return; }\n\n  this.componentInstance.$on(evt, validate);\n  this.watchers.push({\n    tag: 'input_vue',\n    unwatch: function () {\n      this$1.componentInstance.$off(evt, validate);\n    }\n  });\n};\n\nField.prototype._addHTMLEventListener = function _addHTMLEventListener (evt, validate) {\n    var this$1 = this;\n\n  if (!this.el || this.componentInstance) { return; }\n\n  // listen for the current element.\n  var addListener = function (el) {\n    addEventListener(el, evt, validate);\n    this$1.watchers.push({\n      tag: 'input_native',\n      unwatch: function () {\n        el.removeEventListener(evt, validate);\n      }\n    });\n  };\n\n  addListener(this.el);\n  if (!isCheckboxOrRadioInput(this.el)) {\n    return;\n  }\n\n  var els = document.querySelectorAll((\"input[name=\\\"\" + (this.el.name) + \"\\\"]\"));\n  toArray(els).forEach(function (el) {\n    // skip if it is added by v-validate and is not the current element.\n    if (el._veeValidateId && el !== this$1.el) {\n      return;\n    }\n\n    addListener(el);\n  });\n};\n\n/**\n * Updates aria attributes on the element.\n */\nField.prototype.updateAriaAttrs = function updateAriaAttrs () {\n    var this$1 = this;\n\n  if (!this.aria || !this.el || !isCallable(this.el.setAttribute)) { return; }\n\n  var applyAriaAttrs = function (el) {\n    el.setAttribute('aria-required', this$1.isRequired ? 'true' : 'false');\n    el.setAttribute('aria-invalid', this$1.flags.invalid ? 'true' : 'false');\n  };\n\n  if (!isCheckboxOrRadioInput(this.el)) {\n    applyAriaAttrs(this.el);\n    return;\n  }\n\n  var els = document.querySelectorAll((\"input[name=\\\"\" + (this.el.name) + \"\\\"]\"));\n  toArray(els).forEach(applyAriaAttrs);\n};\n\n/**\n * Updates the custom validity for the field.\n */\nField.prototype.updateCustomValidity = function updateCustomValidity () {\n  if (!this.validity || !this.el || !isCallable(this.el.setCustomValidity) || !this.validator.errors) { return; }\n\n  this.el.setCustomValidity(this.flags.valid ? '' : (this.validator.errors.firstById(this.id) || ''));\n};\n\n/**\n * Removes all listeners.\n */\nField.prototype.destroy = function destroy () {\n  // ignore the result of any ongoing validation.\n  if (this._cancellationToken) {\n    this._cancellationToken.cancelled = true;\n  }\n\n  this.unwatch();\n  this.dependencies.forEach(function (d) { return d.field.destroy(); });\n  this.dependencies = [];\n};\n\nObject.defineProperties( Field.prototype, prototypeAccessors$1 );\n\n// \n\nvar FieldBag = function FieldBag (items) {\n  if ( items === void 0 ) items = [];\n\n  this.items = items || [];\n  this.itemsById = this.items.reduce(function (itemsById, item) {\n    itemsById[item.id] = item;\n    return itemsById;\n  }, {});\n};\n\nvar prototypeAccessors$2 = { length: { configurable: true } };\n\nFieldBag.prototype[typeof Symbol === 'function' ? Symbol.iterator : '@@iterator'] = function () {\n    var this$1 = this;\n\n  var index = 0;\n  return {\n    next: function () {\n      return { value: this$1.items[index++], done: index > this$1.items.length };\n    }\n  };\n};\n\n/**\n * Gets the current items length.\n */\n\nprototypeAccessors$2.length.get = function () {\n  return this.items.length;\n};\n\n/**\n * Finds the first field that matches the provided matcher object.\n */\nFieldBag.prototype.find = function find$1 (matcher) {\n  return find(this.items, function (item) { return item.matches(matcher); });\n};\n\n/**\n * Finds the field with the given id, using a plain object as a map to link\n * ids to items faster than by looping over the array and matching.\n */\nFieldBag.prototype.findById = function findById (id) {\n  return this.itemsById[id] || null;\n};\n\n/**\n * Filters the items down to the matched fields.\n */\nFieldBag.prototype.filter = function filter (matcher) {\n  // multiple matchers to be tried.\n  if (Array.isArray(matcher)) {\n    return this.items.filter(function (item) { return matcher.some(function (m) { return item.matches(m); }); });\n  }\n\n  return this.items.filter(function (item) { return item.matches(matcher); });\n};\n\n/**\n * Maps the field items using the mapping function.\n */\nFieldBag.prototype.map = function map (mapper) {\n  return this.items.map(mapper);\n};\n\n/**\n * Finds and removes the first field that matches the provided matcher object, returns the removed item.\n */\nFieldBag.prototype.remove = function remove (matcher) {\n  var item = null;\n  if (matcher instanceof Field) {\n    item = matcher;\n  } else {\n    item = this.find(matcher);\n  }\n\n  if (!item) { return null; }\n\n  var index = this.items.indexOf(item);\n  this.items.splice(index, 1);\n  delete this.itemsById[item.id];\n\n  return item;\n};\n\n/**\n * Adds a field item to the list.\n */\nFieldBag.prototype.push = function push (item) {\n  if (! (item instanceof Field)) {\n    throw createError('FieldBag only accepts instances of Field that has an id defined.');\n  }\n\n  if (!item.id) {\n    throw createError('Field id must be defined.');\n  }\n\n  if (this.findById(item.id)) {\n    throw createError((\"Field with id \" + (item.id) + \" is already added.\"));\n  }\n\n  this.items.push(item);\n  this.itemsById[item.id] = item;\n};\n\nObject.defineProperties( FieldBag.prototype, prototypeAccessors$2 );\n\nvar ScopedValidator = function ScopedValidator (base, vm) {\n  this.id = vm._uid;\n  this._base = base;\n  this._paused = false;\n\n  // create a mirror bag with limited component scope.\n  this.errors = new ErrorBag(base.errors, this.id);\n};\n\nvar prototypeAccessors$3 = { flags: { configurable: true },rules: { configurable: true },fields: { configurable: true },dictionary: { configurable: true },locale: { configurable: true } };\n\nprototypeAccessors$3.flags.get = function () {\n    var this$1 = this;\n\n  return this._base.fields.items.filter(function (f) { return f.vmId === this$1.id; }).reduce(function (acc, field) {\n    if (field.scope) {\n      if (!acc[(\"$\" + (field.scope))]) {\n        acc[(\"$\" + (field.scope))] = {};\n      }\n\n      acc[(\"$\" + (field.scope))][field.name] = field.flags;\n    }\n\n    acc[field.name] = field.flags;\n\n    return acc;\n  }, {});\n};\n\nprototypeAccessors$3.rules.get = function () {\n  return this._base.rules;\n};\n\nprototypeAccessors$3.fields.get = function () {\n  return new FieldBag(this._base.fields.filter({ vmId: this.id }));\n};\n\nprototypeAccessors$3.dictionary.get = function () {\n  return this._base.dictionary;\n};\n\nprototypeAccessors$3.locale.get = function () {\n  return this._base.locale;\n};\n\nprototypeAccessors$3.locale.set = function (val) {\n  this._base.locale = val;\n};\n\nScopedValidator.prototype.localize = function localize () {\n    var ref;\n\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n  return (ref = this._base).localize.apply(ref, args);\n};\n\nScopedValidator.prototype.update = function update () {\n    var ref;\n\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n  return (ref = this._base).update.apply(ref, args);\n};\n\nScopedValidator.prototype.attach = function attach (opts) {\n  var attachOpts = assign({}, opts, { vmId: this.id });\n\n  return this._base.attach(attachOpts);\n};\n\nScopedValidator.prototype.pause = function pause () {\n  this._paused = true;\n};\n\nScopedValidator.prototype.resume = function resume () {\n  this._paused = false;\n};\n\nScopedValidator.prototype.remove = function remove (ruleName) {\n  return this._base.remove(ruleName);\n};\n\nScopedValidator.prototype.detach = function detach (name, scope) {\n  return this._base.detach(name, scope, this.id);\n};\n\nScopedValidator.prototype.extend = function extend () {\n    var ref;\n\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n  return (ref = this._base).extend.apply(ref, args);\n};\n\nScopedValidator.prototype.validate = function validate (descriptor, value, opts) {\n    if ( opts === void 0 ) opts = {};\n\n  if (this._paused) { return Promise.resolve(true); }\n\n  return this._base.validate(descriptor, value, assign({}, { vmId: this.id }, opts || {}));\n};\n\nScopedValidator.prototype.verify = function verify () {\n    var ref;\n\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n  return (ref = this._base).verify.apply(ref, args);\n};\n\nScopedValidator.prototype.validateAll = function validateAll (values, opts) {\n    if ( opts === void 0 ) opts = {};\n\n  if (this._paused) { return Promise.resolve(true); }\n\n  return this._base.validateAll(values, assign({}, { vmId: this.id }, opts || {}));\n};\n\nScopedValidator.prototype.validateScopes = function validateScopes (opts) {\n    if ( opts === void 0 ) opts = {};\n\n  if (this._paused) { return Promise.resolve(true); }\n\n  return this._base.validateScopes(assign({}, { vmId: this.id }, opts || {}));\n};\n\nScopedValidator.prototype.destroy = function destroy () {\n  delete this.id;\n  delete this._base;\n};\n\nScopedValidator.prototype.reset = function reset (matcher) {\n  return this._base.reset(Object.assign({}, matcher || {}, { vmId: this.id }));\n};\n\nScopedValidator.prototype.flag = function flag () {\n    var ref;\n\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n  return (ref = this._base).flag.apply(ref, args.concat( [this.id] ));\n};\n\nScopedValidator.prototype._resolveField = function _resolveField () {\n    var ref;\n\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n  return (ref = this._base)._resolveField.apply(ref, args);\n};\n\nObject.defineProperties( ScopedValidator.prototype, prototypeAccessors$3 );\n\nvar VALIDATOR = null;\n\nvar getValidator = function () {\n  return VALIDATOR;\n};\n\nvar setValidator = function (value) {\n  VALIDATOR = value;\n\n  return value;\n};\n\n// \n\n/**\n * Checks if a parent validator instance was requested.\n */\nvar requestsValidator = function (injections) {\n  if (isObject(injections) && injections.$validator) {\n    return true;\n  }\n\n  return false;\n};\n\nvar mixin = {\n  provide: function provide () {\n    if (this.$validator && !isBuiltInComponent(this.$vnode)) {\n      return {\n        $validator: this.$validator\n      };\n    }\n\n    return {};\n  },\n  beforeCreate: function beforeCreate () {\n    // if built in do nothing.\n    if (isBuiltInComponent(this.$vnode) || this.$options.$__veeInject === false) {\n      return;\n    }\n\n    // if its a root instance set the config if it exists.\n    if (!this.$parent) {\n      setConfig(this.$options.$_veeValidate || {});\n    }\n\n    var options = resolveConfig(this);\n\n    // if its a root instance, inject anyways, or if it requested a new instance.\n    if (!this.$parent || (this.$options.$_veeValidate && /new/.test(this.$options.$_veeValidate.validator))) {\n      this.$validator = new ScopedValidator(getValidator(), this);\n    }\n\n    var requested = requestsValidator(this.$options.inject);\n\n    // if automatic injection is enabled and no instance was requested.\n    if (! this.$validator && options.inject && !requested) {\n      this.$validator = new ScopedValidator(getValidator(), this);\n    }\n\n    // don't inject errors or fieldBag as no validator was resolved.\n    if (!requested && !this.$validator) {\n      return;\n    }\n\n    // There is a validator but it isn't injected, mark as reactive.\n    if (!requested && this.$validator) {\n      var Vue = this.$options._base; // the vue constructor.\n      Vue.util.defineReactive(this.$validator, 'errors', this.$validator.errors);\n    }\n\n    if (!this.$options.computed) {\n      this.$options.computed = {};\n    }\n\n    this.$options.computed[options.errorBagName || 'errors'] = function errorBagGetter () {\n      return this.$validator.errors;\n    };\n    this.$options.computed[options.fieldsBagName || 'fields'] = function fieldBagGetter () {\n      return this.$validator.fields.items.reduce(function (acc, field) {\n        if (field.scope) {\n          if (!acc[(\"$\" + (field.scope))]) {\n            acc[(\"$\" + (field.scope))] = {};\n          }\n\n          acc[(\"$\" + (field.scope))][field.name] = field.flags;\n\n          return acc;\n        }\n\n        acc[field.name] = field.flags;\n\n        return acc;\n      }, {});\n    };\n  },\n  beforeDestroy: function beforeDestroy () {\n    if (this.$validator && this._uid === this.$validator.id) {\n      this.$validator.errors.clear(); // remove errors generated by this component.\n    }\n  }\n};\n\n// \n\n/**\n * Finds the requested field by id from the context object.\n */\nfunction findField (el, context) {\n  if (!context || !context.$validator) {\n    return null;\n  }\n\n  return context.$validator.fields.findById(el._veeValidateId);\n}\nvar directive = {\n  bind: function bind (el, binding, vnode) {\n    var validator = vnode.context.$validator;\n    if (!validator) {\n      if (true) {\n        warn(\"No validator instance is present on vm, did you forget to inject '$validator'?\");\n      }\n\n      return;\n    }\n\n    var fieldOptions = Resolver.generate(el, binding, vnode);\n    validator.attach(fieldOptions);\n  },\n  inserted: function inserted (el, binding, vnode) {\n    var field = findField(el, vnode.context);\n    var scope = Resolver.resolveScope(el, binding, vnode);\n\n    // skip if scope hasn't changed.\n    if (!field || scope === field.scope) { return; }\n\n    // only update scope.\n    field.update({ scope: scope });\n\n    // allows the field to re-evaluated once more in the update hook.\n    field.updated = false;\n  },\n  update: function update (el, binding, vnode) {\n    var field = findField(el, vnode.context);\n\n    // make sure we don't do unneccasary work if no important change was done.\n    if (!field || (field.updated && isEqual(binding.value, binding.oldValue))) { return; }\n    var scope = Resolver.resolveScope(el, binding, vnode);\n    var rules = Resolver.resolveRules(el, binding, vnode);\n\n    field.update({\n      scope: scope,\n      rules: rules\n    });\n  },\n  unbind: function unbind (el, binding, ref) {\n    var context = ref.context;\n\n    var field = findField(el, context);\n    if (!field) { return; }\n\n    context.$validator.detach(field);\n  }\n};\n\n// \n\nvar Validator = function Validator (validations, options, pluginContainer) {\n  if ( options === void 0 ) options = { fastExit: true };\n  if ( pluginContainer === void 0 ) pluginContainer = null;\n\n  this.errors = new ErrorBag();\n  this.fields = new FieldBag();\n  this._createFields(validations);\n  this.paused = false;\n  this.fastExit = !isNullOrUndefined(options && options.fastExit) ? options.fastExit : true;\n  this.$vee = pluginContainer || {\n    _vm: {\n      $nextTick: function (cb) { return isCallable(cb) ? cb() : Promise.resolve(); },\n      $emit: function () {},\n      $off: function () {}\n    }\n  };\n};\n\nvar prototypeAccessors$4 = { rules: { configurable: true },dictionary: { configurable: true },flags: { configurable: true },locale: { configurable: true } };\nvar staticAccessors$1 = { rules: { configurable: true },dictionary: { configurable: true },locale: { configurable: true } };\n\n/**\n * @deprecated\n */\nstaticAccessors$1.rules.get = function () {\n  if (true) {\n    warn('this accessor will be deprecated, use `import { rules } from \"vee-validate\"` instead.');\n  }\n\n  return RuleContainer.rules;\n};\n\n/**\n * @deprecated\n */\nprototypeAccessors$4.rules.get = function () {\n  if (true) {\n    warn('this accessor will be deprecated, use `import { rules } from \"vee-validate\"` instead.');\n  }\n\n  return RuleContainer.rules;\n};\n\nprototypeAccessors$4.dictionary.get = function () {\n  return DictionaryResolver.getDriver();\n};\n\nstaticAccessors$1.dictionary.get = function () {\n  return DictionaryResolver.getDriver();\n};\n\nprototypeAccessors$4.flags.get = function () {\n  return this.fields.items.reduce(function (acc, field) {\n      var obj;\n\n    if (field.scope) {\n      acc[(\"$\" + (field.scope))] = ( obj = {}, obj[field.name] = field.flags, obj );\n\n      return acc;\n    }\n\n    acc[field.name] = field.flags;\n\n    return acc;\n  }, {});\n};\n\n/**\n * Getter for the current locale.\n */\nprototypeAccessors$4.locale.get = function () {\n  return Validator.locale;\n};\n\n/**\n * Setter for the validator locale.\n */\nprototypeAccessors$4.locale.set = function (value) {\n  Validator.locale = value;\n};\n\nstaticAccessors$1.locale.get = function () {\n  return DictionaryResolver.getDriver().locale;\n};\n\n/**\n * Setter for the validator locale.\n */\nstaticAccessors$1.locale.set = function (value) {\n  var hasChanged = value !== DictionaryResolver.getDriver().locale;\n  DictionaryResolver.getDriver().locale = value;\n  if (hasChanged && Validator.$vee && Validator.$vee._vm) {\n    Validator.$vee._vm.$emit('localeChanged');\n  }\n};\n\n/**\n * Static constructor.\n * @deprecated\n */\nValidator.create = function create (validations, options) {\n  if (true) {\n    warn('Please use `new` to create new validator instances.');\n  }\n\n  return new Validator(validations, options);\n};\n\n/**\n * Adds a custom validator to the list of validation rules.\n */\nValidator.extend = function extend (name, validator, options) {\n    if ( options === void 0 ) options = {};\n\n  Validator._guardExtend(name, validator);\n  // rules imported from the minimal bundle\n  // will have the options embedded in them\n  var mergedOpts = validator.options || {};\n  Validator._merge(name, {\n    validator: validator,\n    paramNames: (options && options.paramNames) || validator.paramNames,\n    options: assign({ hasTarget: false, immediate: true }, mergedOpts, options || {})\n  });\n};\n\n/**\n * Removes a rule from the list of validators.\n * @deprecated\n */\nValidator.remove = function remove (name) {\n  if (true) {\n    warn('this method will be deprecated, you can still override your rules with `extend`');\n  }\n\n  RuleContainer.remove(name);\n};\n\n/**\n * Adds and sets the current locale for the validator.\n*/\nValidator.prototype.localize = function localize (lang, dictionary) {\n  Validator.localize(lang, dictionary);\n};\n\n/**\n * Adds and sets the current locale for the validator.\n */\nValidator.localize = function localize (lang, dictionary) {\n    var obj;\n\n  if (isObject(lang)) {\n    DictionaryResolver.getDriver().merge(lang);\n    return;\n  }\n\n  // merge the dictionary.\n  if (dictionary) {\n    var locale = lang || dictionary.name;\n    dictionary = assign({}, dictionary);\n    DictionaryResolver.getDriver().merge(( obj = {}, obj[locale] = dictionary, obj ));\n  }\n\n  if (lang) {\n    // set the locale.\n    Validator.locale = lang;\n  }\n};\n\n/**\n * Registers a field to be validated.\n */\nValidator.prototype.attach = function attach (fieldOpts) {\n    var this$1 = this;\n\n  // We search for a field with the same name & scope, having persist enabled\n  var oldFieldMatcher = { name: fieldOpts.name, scope: fieldOpts.scope, persist: true };\n  var oldField = fieldOpts.persist ? this.fields.find(oldFieldMatcher) : null;\n\n  if (oldField) {\n    // We keep the flags of the old field, then we remove its instance\n    fieldOpts.flags = oldField.flags;\n    oldField.destroy();\n    this.fields.remove(oldField);\n  }\n\n  // fixes initial value detection with v-model and select elements.\n  var value = fieldOpts.initialValue;\n  var field = new Field(fieldOpts);\n  this.fields.push(field);\n\n  // validate the field initially\n  if (field.immediate) {\n    this.$vee._vm.$nextTick(function () { return this$1.validate((\"#\" + (field.id)), value || field.value, { vmId: fieldOpts.vmId }); });\n  } else {\n    this._validate(field, value || field.value, { initial: true }).then(function (result) {\n      field.flags.valid = result.valid;\n      field.flags.invalid = !result.valid;\n    });\n  }\n\n  return field;\n};\n\n/**\n * Sets the flags on a field.\n */\nValidator.prototype.flag = function flag (name, flags, uid) {\n    if ( uid === void 0 ) uid = null;\n\n  var field = this._resolveField(name, undefined, uid);\n  if (!field || !flags) {\n    return;\n  }\n\n  field.setFlags(flags);\n};\n\n/**\n * Removes a field from the validator.\n */\nValidator.prototype.detach = function detach (name, scope, uid) {\n  var field = isCallable(name.destroy) ? name : this._resolveField(name, scope, uid);\n  if (!field) { return; }\n\n  // We destroy/remove the field & error instances if it's not a `persist` one\n  if (!field.persist) {\n    field.destroy();\n    this.errors.remove(field.name, field.scope, field.vmId);\n    this.fields.remove(field);\n  }\n};\n\n/**\n * Adds a custom validator to the list of validation rules.\n */\nValidator.prototype.extend = function extend (name, validator, options) {\n    if ( options === void 0 ) options = {};\n\n  Validator.extend(name, validator, options);\n};\n\nValidator.prototype.reset = function reset (matcher) {\n    var this$1 = this;\n\n  // two ticks\n  return this.$vee._vm.$nextTick().then(function () {\n    return this$1.$vee._vm.$nextTick();\n  }).then(function () {\n    this$1.fields.filter(matcher).forEach(function (field) {\n      field.waitFor(null);\n      field.reset(); // reset field flags.\n      this$1.errors.remove(field.name, field.scope, matcher && matcher.vmId);\n    });\n  });\n};\n\n/**\n * Updates a field, updating both errors and flags.\n */\nValidator.prototype.update = function update (id, ref) {\n    var scope = ref.scope;\n\n  var field = this._resolveField((\"#\" + id));\n  if (!field) { return; }\n\n  // remove old scope.\n  this.errors.update(id, { scope: scope });\n};\n\n/**\n * Removes a rule from the list of validators.\n * @deprecated\n */\nValidator.prototype.remove = function remove (name) {\n  Validator.remove(name);\n};\n\n/**\n * Validates a value against a registered field validations.\n */\nValidator.prototype.validate = function validate (fieldDescriptor, value, ref) {\n    var this$1 = this;\n    if ( ref === void 0 ) ref = {};\n    var silent = ref.silent;\n    var vmId = ref.vmId;\n\n  if (this.paused) { return Promise.resolve(true); }\n\n  // overload to validate all.\n  if (isNullOrUndefined(fieldDescriptor)) {\n    return this.validateScopes({ silent: silent, vmId: vmId });\n  }\n\n  // overload to validate scope-less fields.\n  if (fieldDescriptor === '*') {\n    return this.validateAll(undefined, { silent: silent, vmId: vmId });\n  }\n\n  // if scope validation was requested.\n  if (/^(.+)\\.\\*$/.test(fieldDescriptor)) {\n    var matched = fieldDescriptor.match(/^(.+)\\.\\*$/)[1];\n    return this.validateAll(matched);\n  }\n\n  var field = this._resolveField(fieldDescriptor);\n  if (!field) {\n    return this._handleFieldNotFound(fieldDescriptor);\n  }\n\n  if (!silent) { field.flags.pending = true; }\n  if (value === undefined) {\n    value = field.value;\n  }\n\n  var validationPromise = this._validate(field, value);\n  field.waitFor(validationPromise);\n\n  return validationPromise.then(function (result) {\n    if (!silent && field.isWaitingFor(validationPromise)) {\n      // allow next validation to mutate the state.\n      field.waitFor(null);\n      this$1._handleValidationResults([result], vmId);\n    }\n\n    return result.valid;\n  });\n};\n\n/**\n * Pauses the validator.\n */\nValidator.prototype.pause = function pause () {\n  this.paused = true;\n\n  return this;\n};\n\n/**\n * Resumes the validator.\n */\nValidator.prototype.resume = function resume () {\n  this.paused = false;\n\n  return this;\n};\n\n/**\n * Validates each value against the corresponding field validations.\n */\nValidator.prototype.validateAll = function validateAll (values, ref) {\n    var this$1 = this;\n    if ( ref === void 0 ) ref = {};\n    var silent = ref.silent;\n    var vmId = ref.vmId;\n\n  if (this.paused) { return Promise.resolve(true); }\n\n  var matcher = null;\n  var providedValues = false;\n\n  if (typeof values === 'string') {\n    matcher = { scope: values, vmId: vmId };\n  } else if (isObject(values)) {\n    matcher = Object.keys(values).map(function (key) {\n      return { name: key, vmId: vmId, scope: null };\n    });\n    providedValues = true;\n  } else if (Array.isArray(values)) {\n    matcher = values.map(function (key) {\n      return typeof key === 'object' ? Object.assign({ vmId: vmId }, key) : { name: key, vmId: vmId };\n    });\n  } else {\n    matcher = { scope: null, vmId: vmId };\n  }\n\n  return Promise.all(\n    this.fields.filter(matcher).map(function (field) { return this$1._validate(field, providedValues ? values[field.name] : field.value); })\n  ).then(function (results) {\n    if (!silent) {\n      this$1._handleValidationResults(results, vmId);\n    }\n\n    return results.every(function (t) { return t.valid; });\n  });\n};\n\n/**\n * Validates all scopes.\n */\nValidator.prototype.validateScopes = function validateScopes (ref) {\n    var this$1 = this;\n    if ( ref === void 0 ) ref = {};\n    var silent = ref.silent;\n    var vmId = ref.vmId;\n\n  if (this.paused) { return Promise.resolve(true); }\n\n  return Promise.all(\n    this.fields.filter({ vmId: vmId }).map(function (field) { return this$1._validate(field, field.value); })\n  ).then(function (results) {\n    if (!silent) {\n      this$1._handleValidationResults(results, vmId);\n    }\n\n    return results.every(function (t) { return t.valid; });\n  });\n};\n\n/**\n * Validates a value against the rules.\n */\nValidator.prototype.verify = function verify (value, rules, options) {\n    if ( options === void 0 ) options = {};\n\n  var field = {\n    name: (options && options.name) || '{field}',\n    rules: normalizeRules(rules),\n    bails: getPath('bails', options, true),\n    forceRequired: false,\n    get isRequired () {\n      return !!this.rules.required || this.forceRequired;\n    }\n  };\n\n  var targetRules = Object.keys(field.rules).filter(RuleContainer.isTargetRule);\n  if (targetRules.length && options && isObject(options.values)) {\n    field.dependencies = targetRules.map(function (rule) {\n      var ref = field.rules[rule];\n        var targetKey = ref[0];\n\n      return {\n        name: rule,\n        field: { value: options.values[targetKey] }\n      };\n    });\n  }\n\n  return this._validate(field, value).then(function (result) {\n    var errors = [];\n    var ruleMap = {};\n    result.errors.forEach(function (e) {\n      errors.push(e.msg);\n      ruleMap[e.rule] = e.msg;\n    });\n\n    return {\n      valid: result.valid,\n      errors: errors,\n      failedRules: ruleMap\n    };\n  });\n};\n\n/**\n * Perform cleanup.\n */\nValidator.prototype.destroy = function destroy () {\n  this.$vee._vm.$off('localeChanged');\n};\n\n/**\n * Creates the fields to be validated.\n */\nValidator.prototype._createFields = function _createFields (validations) {\n    var this$1 = this;\n\n  if (!validations) { return; }\n\n  Object.keys(validations).forEach(function (field) {\n    var options = assign({}, { name: field, rules: validations[field] });\n    this$1.attach(options);\n  });\n};\n\n/**\n * Date rules need the existence of a format, so date_format must be supplied.\n */\nValidator.prototype._getDateFormat = function _getDateFormat (validations) {\n  var format = null;\n  if (validations.date_format && Array.isArray(validations.date_format)) {\n    format = validations.date_format[0];\n  }\n\n  return format || DictionaryResolver.getDriver().getDateFormat(this.locale);\n};\n\n/**\n * Formats an error message for field and a rule.\n */\nValidator.prototype._formatErrorMessage = function _formatErrorMessage (field, rule, data, targetName) {\n    if ( data === void 0 ) data = {};\n    if ( targetName === void 0 ) targetName = null;\n\n  var name = this._getFieldDisplayName(field);\n  var params = this._getLocalizedParams(rule, targetName);\n\n  return DictionaryResolver.getDriver().getFieldMessage(this.locale, field.name, rule.name, [name, params, data]);\n};\n\n/**\n * We need to convert any object param to an array format since the locales do not handle params as objects yet.\n */\nValidator.prototype._convertParamObjectToArray = function _convertParamObjectToArray (obj, ruleName) {\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n\n  var paramNames = RuleContainer.getParamNames(ruleName);\n  if (!paramNames || !isObject(obj)) {\n    return obj;\n  }\n\n  return paramNames.reduce(function (prev, paramName) {\n    if (paramName in obj) {\n      prev.push(obj[paramName]);\n    }\n\n    return prev;\n  }, []);\n};\n\n/**\n * Translates the parameters passed to the rule (mainly for target fields).\n */\nValidator.prototype._getLocalizedParams = function _getLocalizedParams (rule, targetName) {\n    if ( targetName === void 0 ) targetName = null;\n\n  var params = this._convertParamObjectToArray(rule.params, rule.name);\n  if (rule.options.hasTarget && params && params[0]) {\n    var localizedName = targetName || DictionaryResolver.getDriver().getAttribute(this.locale, params[0], params[0]);\n    return [localizedName].concat(params.slice(1));\n  }\n\n  return params;\n};\n\n/**\n * Resolves an appropriate display name, first checking 'data-as' or the registered 'prettyName'\n */\nValidator.prototype._getFieldDisplayName = function _getFieldDisplayName (field) {\n  return field.alias || DictionaryResolver.getDriver().getAttribute(this.locale, field.name, field.name);\n};\n\n/**\n * Converts an array of params to an object with named properties.\n * Only works if the rule is configured with a paramNames array.\n * Returns the same params if it cannot convert it.\n */\nValidator.prototype._convertParamArrayToObj = function _convertParamArrayToObj (params, ruleName) {\n  var paramNames = RuleContainer.getParamNames(ruleName);\n  if (!paramNames) {\n    return params;\n  }\n\n  if (isObject(params)) {\n    // check if the object is either a config object or a single parameter that is an object.\n    var hasKeys = paramNames.some(function (name) { return Object.keys(params).indexOf(name) !== -1; });\n    // if it has some of the keys, return it as is.\n    if (hasKeys) {\n      return params;\n    }\n    // otherwise wrap the object in an array.\n    params = [params];\n  }\n\n  // Reduce the paramsNames to a param object.\n  return params.reduce(function (prev, value, idx) {\n    prev[paramNames[idx]] = value;\n\n    return prev;\n  }, {});\n};\n\n/**\n * Tests a single input value against a rule.\n */\nValidator.prototype._test = function _test (field, value, rule) {\n    var this$1 = this;\n\n  var validator = RuleContainer.getValidatorMethod(rule.name);\n  var params = Array.isArray(rule.params) ? toArray(rule.params) : rule.params;\n  if (!params) {\n    params = [];\n  }\n\n  var targetName = null;\n  if (!validator || typeof validator !== 'function') {\n    return Promise.reject(createError((\"No such validator '\" + (rule.name) + \"' exists.\")));\n  }\n\n  // has field dependencies.\n  if (rule.options.hasTarget && field.dependencies) {\n    var target = find(field.dependencies, function (d) { return d.name === rule.name; });\n    if (target) {\n      targetName = target.field.alias;\n      params = [target.field.value].concat(params.slice(1));\n    }\n  } else if (rule.name === 'required' && field.rejectsFalse) {\n    // invalidate false if no args were specified and the field rejects false by default.\n    params = params.length ? params : [true];\n  }\n\n  if (rule.options.isDate) {\n    var dateFormat = this._getDateFormat(field.rules);\n    if (rule.name !== 'date_format') {\n      params.push(dateFormat);\n    }\n  }\n\n  var result = validator(value, this._convertParamArrayToObj(params, rule.name));\n\n  // If it is a promise.\n  if (isCallable(result.then)) {\n    return result.then(function (values) {\n      var allValid = true;\n      var data = {};\n      if (Array.isArray(values)) {\n        allValid = values.every(function (t) { return (isObject(t) ? t.valid : t); });\n      } else { // Is a single object/boolean.\n        allValid = isObject(values) ? values.valid : values;\n        data = values.data;\n      }\n\n      return {\n        valid: allValid,\n        data: result.data,\n        errors: allValid ? [] : [this$1._createFieldError(field, rule, data, targetName)]\n      };\n    });\n  }\n\n  if (!isObject(result)) {\n    result = { valid: result, data: {} };\n  }\n\n  return {\n    valid: result.valid,\n    data: result.data,\n    errors: result.valid ? [] : [this._createFieldError(field, rule, result.data, targetName)]\n  };\n};\n\n/**\n * Merges a validator object into the RULES and Messages.\n */\nValidator._merge = function _merge (name, ref) {\n    var validator = ref.validator;\n    var options = ref.options;\n    var paramNames = ref.paramNames;\n\n  var validate = isCallable(validator) ? validator : validator.validate;\n  if (validator.getMessage) {\n    DictionaryResolver.getDriver().setMessage(Validator.locale, name, validator.getMessage);\n  }\n\n  RuleContainer.add(name, {\n    validate: validate,\n    options: options,\n    paramNames: paramNames\n  });\n};\n\n/**\n * Guards from extension violations.\n */\nValidator._guardExtend = function _guardExtend (name, validator) {\n  if (isCallable(validator)) {\n    return;\n  }\n\n  if (!isCallable(validator.validate)) {\n    throw createError(\n      (\"Extension Error: The validator '\" + name + \"' must be a function or have a 'validate' method.\")\n    );\n  }\n};\n\n/**\n * Creates a Field Error Object.\n */\nValidator.prototype._createFieldError = function _createFieldError (field, rule, data, targetName) {\n    var this$1 = this;\n\n  return {\n    id: field.id,\n    vmId: field.vmId,\n    field: field.name,\n    msg: this._formatErrorMessage(field, rule, data, targetName),\n    rule: rule.name,\n    scope: field.scope,\n    regenerate: function () {\n      return this$1._formatErrorMessage(field, rule, data, targetName);\n    }\n  };\n};\n\n/**\n * Tries different strategies to find a field.\n */\nValidator.prototype._resolveField = function _resolveField (name, scope, uid) {\n  if (name[0] === '#') {\n    return this.fields.findById(name.slice(1));\n  }\n\n  if (!isNullOrUndefined(scope)) {\n    return this.fields.find({ name: name, scope: scope, vmId: uid });\n  }\n\n  if (includes(name, '.')) {\n    var ref = name.split('.');\n      var fieldScope = ref[0];\n      var fieldName = ref.slice(1);\n    var field = this.fields.find({ name: fieldName.join('.'), scope: fieldScope, vmId: uid });\n    if (field) {\n      return field;\n    }\n  }\n\n  return this.fields.find({ name: name, scope: null, vmId: uid });\n};\n\n/**\n * Handles when a field is not found.\n */\nValidator.prototype._handleFieldNotFound = function _handleFieldNotFound (name, scope) {\n  var fullName = isNullOrUndefined(scope) ? name : (\"\" + (!isNullOrUndefined(scope) ? scope + '.' : '') + name);\n\n  return Promise.reject(createError(\n    (\"Validating a non-existent field: \\\"\" + fullName + \"\\\". Use \\\"attach()\\\" first.\")\n  ));\n};\n\n/**\n * Handles validation results.\n */\nValidator.prototype._handleValidationResults = function _handleValidationResults (results, vmId) {\n    var this$1 = this;\n\n  var matchers = results.map(function (result) { return ({ id: result.id }); });\n  this.errors.removeById(matchers.map(function (m) { return m.id; }));\n  // remove by name and scope to remove any custom errors added.\n  results.forEach(function (result) {\n    this$1.errors.remove(result.field, result.scope, vmId);\n  });\n  var allErrors = results.reduce(function (prev, curr) {\n    prev.push.apply(prev, curr.errors);\n\n    return prev;\n  }, []);\n\n  this.errors.add(allErrors);\n\n  // handle flags.\n  this.fields.filter(matchers).forEach(function (field) {\n    var result = find(results, function (r) { return r.id === field.id; });\n    field.setFlags({\n      pending: false,\n      valid: result.valid,\n      validated: true\n    });\n  });\n};\n\nValidator.prototype._shouldSkip = function _shouldSkip (field, value) {\n  // field is configured to run through the pipeline regardless\n  if (field.bails === false) {\n    return false;\n  }\n\n  // disabled fields are skipped if useConstraintAttrs is enabled in config\n  if (field.isDisabled && getConfig().useConstraintAttrs) {\n    return true;\n  }\n\n  // skip if the field is not required and has an empty value.\n  return !field.isRequired && (isNullOrUndefined(value) || value === '' || isEmptyArray(value));\n};\n\nValidator.prototype._shouldBail = function _shouldBail (field) {\n  // if the field was configured explicitly.\n  if (field.bails !== undefined) {\n    return field.bails;\n  }\n\n  return this.fastExit;\n};\n\n/**\n * Starts the validation process.\n */\nValidator.prototype._validate = function _validate (field, value, ref) {\n    var this$1 = this;\n    if ( ref === void 0 ) ref = {};\n    var initial = ref.initial;\n\n  var requireRules = Object.keys(field.rules).filter(RuleContainer.isRequireRule);\n\n  field.forceRequired = false;\n  requireRules.forEach(function (rule) {\n    var ruleOptions = RuleContainer.getOptions(rule);\n    var result = this$1._test(field, value, { name: rule, params: field.rules[rule], options: ruleOptions });\n\n    if (isCallable(result.then)) { throw createError('Require rules cannot be async'); }\n    if (!isObject(result)) { throw createError('Require rules has to return an object (see docs)'); }\n\n    if (result.data.required === true) {\n      field.forceRequired = true;\n    }\n  });\n\n  if (this._shouldSkip(field, value)) {\n    return Promise.resolve({ valid: true, id: field.id, field: field.name, scope: field.scope, errors: [] });\n  }\n\n  var promises = [];\n  var errors = [];\n  var isExitEarly = false;\n  if (isCallable(field.checkValueChanged)) {\n    field.flags.changed = field.checkValueChanged();\n  }\n\n  // use of '.some()' is to break iteration in middle by returning true\n  Object.keys(field.rules).filter(function (rule) {\n    if (!initial || !RuleContainer.has(rule)) { return true; }\n\n    return RuleContainer.isImmediate(rule);\n  }).some(function (rule) {\n    var ruleOptions = RuleContainer.getOptions(rule);\n    var result = this$1._test(field, value, { name: rule, params: field.rules[rule], options: ruleOptions });\n    if (isCallable(result.then)) {\n      promises.push(result);\n    } else if (!result.valid && this$1._shouldBail(field)) {\n      errors.push.apply(errors, result.errors);\n      isExitEarly = true;\n    } else {\n      // promisify the result.\n      promises.push(new Promise(function (resolve) { return resolve(result); }));\n    }\n\n    return isExitEarly;\n  });\n\n  if (isExitEarly) {\n    return Promise.resolve({ valid: false, errors: errors, id: field.id, field: field.name, scope: field.scope });\n  }\n\n  return Promise.all(promises).then(function (results) {\n    return results.reduce(function (prev, v) {\n        var ref;\n\n      if (!v.valid) {\n        (ref = prev.errors).push.apply(ref, v.errors);\n      }\n\n      prev.valid = prev.valid && v.valid;\n\n      return prev;\n    }, { valid: true, errors: errors, id: field.id, field: field.name, scope: field.scope });\n  });\n};\n\nObject.defineProperties( Validator.prototype, prototypeAccessors$4 );\nObject.defineProperties( Validator, staticAccessors$1 );\n\n// \n\nvar normalizeValue = function (value) {\n  if (isObject(value)) {\n    return Object.keys(value).reduce(function (prev, key) {\n      prev[key] = normalizeValue(value[key]);\n\n      return prev;\n    }, {});\n  }\n\n  if (isCallable(value)) {\n    return value('{0}', ['{1}', '{2}', '{3}']);\n  }\n\n  return value;\n};\n\nvar normalizeFormat = function (locale) {\n  // normalize messages\n  var dictionary = {};\n  if (locale.messages) {\n    dictionary.messages = normalizeValue(locale.messages);\n  }\n\n  if (locale.custom) {\n    dictionary.custom = normalizeValue(locale.custom);\n  }\n\n  if (locale.attributes) {\n    dictionary.attributes = locale.attributes;\n  }\n\n  if (!isNullOrUndefined(locale.dateFormat)) {\n    dictionary.dateFormat = locale.dateFormat;\n  }\n\n  return dictionary;\n};\n\nvar I18nDictionary = function I18nDictionary (i18n, rootKey) {\n  this.i18n = i18n;\n  this.rootKey = rootKey;\n};\n\nvar prototypeAccessors$5 = { locale: { configurable: true } };\n\nprototypeAccessors$5.locale.get = function () {\n  return this.i18n.locale;\n};\n\nprototypeAccessors$5.locale.set = function (value) {\n  warn('Cannot set locale from the validator when using vue-i18n, use i18n.locale setter instead');\n};\n\nI18nDictionary.prototype.getDateFormat = function getDateFormat (locale) {\n  return this.i18n.getDateTimeFormat(locale || this.locale);\n};\n\nI18nDictionary.prototype.setDateFormat = function setDateFormat (locale, value) {\n  this.i18n.setDateTimeFormat(locale || this.locale, value);\n};\n\nI18nDictionary.prototype.getMessage = function getMessage (_, key, data) {\n  var path = (this.rootKey) + \".messages.\" + key;\n  var dataOptions = data;\n\n  if (Array.isArray(data)) {\n    dataOptions = [].concat.apply([], data);\n  }\n\n  if (this.i18n.te(path)) {\n    return this.i18n.t(path, dataOptions);\n  }\n\n  // fallback to the fallback message\n  if (this.i18n.te(path, this.i18n.fallbackLocale)) {\n    return this.i18n.t(path, this.i18n.fallbackLocale, dataOptions);\n  }\n\n  // fallback to the root message\n  return this.i18n.t(((this.rootKey) + \".messages._default\"), dataOptions);\n};\n\nI18nDictionary.prototype.getAttribute = function getAttribute (_, key, fallback) {\n    if ( fallback === void 0 ) fallback = '';\n\n  var path = (this.rootKey) + \".attributes.\" + key;\n  if (this.i18n.te(path)) {\n    return this.i18n.t(path);\n  }\n\n  return fallback;\n};\n\nI18nDictionary.prototype.getFieldMessage = function getFieldMessage (_, field, key, data) {\n  var path = (this.rootKey) + \".custom.\" + field + \".\" + key;\n  if (this.i18n.te(path)) {\n    return this.i18n.t(path, data);\n  }\n\n  return this.getMessage(_, key, data);\n};\n\nI18nDictionary.prototype.merge = function merge$1 (dictionary) {\n    var this$1 = this;\n\n  Object.keys(dictionary).forEach(function (localeKey) {\n      var obj;\n\n    // i18n doesn't deep merge\n    // first clone the existing locale (avoid mutations to locale)\n    var clone = merge({}, getPath((localeKey + \".\" + (this$1.rootKey)), this$1.i18n.messages, {}));\n    // Merge cloned locale with new one\n    var locale = merge(clone, normalizeFormat(dictionary[localeKey]));\n    this$1.i18n.mergeLocaleMessage(localeKey, ( obj = {}, obj[this$1.rootKey] = locale, obj ));\n    if (locale.dateFormat) {\n      this$1.i18n.setDateTimeFormat(localeKey, locale.dateFormat);\n    }\n  });\n};\n\nI18nDictionary.prototype.setMessage = function setMessage (locale, key, value) {\n    var obj, obj$1;\n\n  this.merge(( obj$1 = {}, obj$1[locale] = {\n      messages: ( obj = {}, obj[key] = value, obj )\n    }, obj$1 ));\n};\n\nI18nDictionary.prototype.setAttribute = function setAttribute (locale, key, value) {\n    var obj, obj$1;\n\n  this.merge(( obj$1 = {}, obj$1[locale] = {\n      attributes: ( obj = {}, obj[key] = value, obj )\n    }, obj$1 ));\n};\n\nObject.defineProperties( I18nDictionary.prototype, prototypeAccessors$5 );\n\nvar aggressive = function () { return ({\n  on: ['input']\n}); };\n\nvar lazy = function () { return ({\n  on: ['change']\n}); };\n\nvar eager = function (ref) {\n  var errors = ref.errors;\n\n  if (errors.length) {\n    return {\n      on: ['input']\n    };\n  }\n\n  return {\n    on: ['change', 'blur']\n  };\n};\n\nvar passive = function () { return ({\n  on: []\n}); };\n\nvar modes = {\n  aggressive: aggressive,\n  eager: eager,\n  passive: passive,\n  lazy: lazy\n};\n\n// \n\nvar Vue;\nvar pendingPlugins;\nvar pluginInstance;\n\nvar VeeValidate$1 = function VeeValidate (config, _Vue) {\n  this.configure(config);\n  pluginInstance = this;\n  if (_Vue) {\n    Vue = _Vue;\n  }\n  this._validator = setValidator(\n    new Validator(null, { fastExit: config && config.fastExit }, this)\n  );\n  this._initVM(this.config);\n  this._initI18n(this.config);\n};\n\nvar prototypeAccessors$6 = { i18nDriver: { configurable: true },config: { configurable: true } };\nvar staticAccessors$2 = { i18nDriver: { configurable: true },config: { configurable: true } };\n\nVeeValidate$1.setI18nDriver = function setI18nDriver (driver, instance) {\n  DictionaryResolver.setDriver(driver, instance);\n};\n\nVeeValidate$1.configure = function configure (cfg) {\n  setConfig(cfg);\n};\n\nVeeValidate$1.setMode = function setMode (mode, implementation) {\n  setConfig({ mode: mode });\n  if (!implementation) {\n    return;\n  }\n\n  if (!isCallable(implementation)) {\n    throw new Error('A mode implementation must be a function');\n  }\n\n  modes[mode] = implementation;\n};\n\nVeeValidate$1.use = function use (plugin, options) {\n    if ( options === void 0 ) options = {};\n\n  if (!isCallable(plugin)) {\n    return warn('The plugin must be a callable function');\n  }\n\n  // Don't install plugins until vee-validate is installed.\n  if (!pluginInstance) {\n    if (!pendingPlugins) {\n      pendingPlugins = [];\n    }\n    pendingPlugins.push({ plugin: plugin, options: options });\n    return;\n  }\n\n  plugin({ Validator: Validator, ErrorBag: ErrorBag, Rules: Validator.rules }, options);\n};\nVeeValidate$1.install = function install (_Vue, opts) {\n  if (Vue && _Vue === Vue) {\n    if (true) {\n      warn('already installed, Vue.use(VeeValidate) should only be called once.');\n    }\n    return;\n  }\n\n  Vue = _Vue;\n  pluginInstance = new VeeValidate$1(opts);\n  // inject the plugin container statically into the validator class\n  Validator.$vee = pluginInstance;\n\n  detectPassiveSupport();\n\n  Vue.mixin(mixin);\n  Vue.directive('validate', directive);\n  if (pendingPlugins) {\n    pendingPlugins.forEach(function (ref) {\n        var plugin = ref.plugin;\n        var options = ref.options;\n\n      VeeValidate$1.use(plugin, options);\n    });\n    pendingPlugins = null;\n  }\n};\n\nprototypeAccessors$6.i18nDriver.get = function () {\n  return DictionaryResolver.getDriver();\n};\n\nstaticAccessors$2.i18nDriver.get = function () {\n  return DictionaryResolver.getDriver();\n};\n\nprototypeAccessors$6.config.get = function () {\n  return getConfig();\n};\n\nstaticAccessors$2.config.get = function () {\n  return getConfig();\n};\n\nVeeValidate$1.prototype._initVM = function _initVM (config) {\n    var this$1 = this;\n\n  this._vm = new Vue({\n    data: function () { return ({\n      errors: this$1._validator.errors,\n      fields: this$1._validator.fields\n    }); }\n  });\n};\n\nVeeValidate$1.prototype._initI18n = function _initI18n (config) {\n    var this$1 = this;\n\n  var dictionary = config.dictionary;\n    var i18n = config.i18n;\n    var i18nRootKey = config.i18nRootKey;\n    var locale = config.locale;\n  var onLocaleChanged = function () {\n    if (dictionary) {\n      this$1.i18nDriver.merge(dictionary);\n    }\n\n    this$1._validator.errors.regenerate();\n  };\n\n  // i18 is being used for localization.\n  if (i18n) {\n    VeeValidate$1.setI18nDriver('i18n', new I18nDictionary(i18n, i18nRootKey));\n    i18n._vm.$watch('locale', onLocaleChanged);\n  } else if (typeof window !== 'undefined') {\n    this._vm.$on('localeChanged', onLocaleChanged);\n  }\n\n  if (dictionary) {\n    this.i18nDriver.merge(dictionary);\n  }\n\n  if (locale && !i18n) {\n    this._validator.localize(locale);\n  }\n};\n\nVeeValidate$1.prototype.configure = function configure (cfg) {\n  setConfig(cfg);\n};\n\nObject.defineProperties( VeeValidate$1.prototype, prototypeAccessors$6 );\nObject.defineProperties( VeeValidate$1, staticAccessors$2 );\n\nVeeValidate$1.mixin = mixin;\nVeeValidate$1.directive = directive;\nVeeValidate$1.Validator = Validator;\nVeeValidate$1.ErrorBag = ErrorBag;\n\n/**\n * Formates file size.\n *\n * @param {Number|String} size\n */\nvar formatFileSize = function (size) {\n  var units = ['Byte', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n  var threshold = 1024;\n  size = Number(size) * threshold;\n  var i = size === 0 ? 0 : Math.floor(Math.log(size) / Math.log(threshold));\n  return (((size / Math.pow(threshold, i)).toFixed(2) * 1) + \" \" + (units[i]));\n};\n\n/**\n * Checks if vee-validate is defined globally.\n */\nvar isDefinedGlobally = function () {\n  return typeof VeeValidate !== 'undefined';\n};\n\nvar obj;\n\nvar messages = {\n  _default: function (field) { return (\"The \" + field + \" value is not valid.\"); },\n  after: function (field, ref) {\n    var target = ref[0];\n    var inclusion = ref[1];\n\n    return (\"The \" + field + \" must be after \" + (inclusion ? 'or equal to ' : '') + target + \".\");\n},\n  alpha: function (field) { return (\"The \" + field + \" field may only contain alphabetic characters.\"); },\n  alpha_dash: function (field) { return (\"The \" + field + \" field may contain alpha-numeric characters as well as dashes and underscores.\"); },\n  alpha_num: function (field) { return (\"The \" + field + \" field may only contain alpha-numeric characters.\"); },\n  alpha_spaces: function (field) { return (\"The \" + field + \" field may only contain alphabetic characters as well as spaces.\"); },\n  before: function (field, ref) {\n    var target = ref[0];\n    var inclusion = ref[1];\n\n    return (\"The \" + field + \" must be before \" + (inclusion ? 'or equal to ' : '') + target + \".\");\n},\n  between: function (field, ref) {\n    var min = ref[0];\n    var max = ref[1];\n\n    return (\"The \" + field + \" field must be between \" + min + \" and \" + max + \".\");\n},\n  confirmed: function (field) { return (\"The \" + field + \" confirmation does not match.\"); },\n  credit_card: function (field) { return (\"The \" + field + \" field is invalid.\"); },\n  date_between: function (field, ref) {\n    var min = ref[0];\n    var max = ref[1];\n\n    return (\"The \" + field + \" must be between \" + min + \" and \" + max + \".\");\n},\n  date_format: function (field, ref) {\n    var format = ref[0];\n\n    return (\"The \" + field + \" must be in the format \" + format + \".\");\n},\n  decimal: function (field, ref) {\n    if ( ref === void 0 ) ref = [];\n    var decimals = ref[0]; if ( decimals === void 0 ) decimals = '*';\n\n    return (\"The \" + field + \" field must be numeric and may contain\" + (!decimals || decimals === '*' ? '' : ' ' + decimals) + \" decimal points.\");\n},\n  digits: function (field, ref) {\n    var length = ref[0];\n\n    return (\"The \" + field + \" field must be numeric and contains exactly \" + length + \" digits.\");\n},\n  dimensions: function (field, ref) {\n    var width = ref[0];\n    var height = ref[1];\n\n    return (\"The \" + field + \" field must be \" + width + \" pixels by \" + height + \" pixels.\");\n},\n  email: function (field) { return (\"The \" + field + \" field must be a valid email.\"); },\n  excluded: function (field) { return (\"The \" + field + \" field must be a valid value.\"); },\n  ext: function (field) { return (\"The \" + field + \" field must be a valid file.\"); },\n  image: function (field) { return (\"The \" + field + \" field must be an image.\"); },\n  included: function (field) { return (\"The \" + field + \" field must be a valid value.\"); },\n  integer: function (field) { return (\"The \" + field + \" field must be an integer.\"); },\n  ip: function (field) { return (\"The \" + field + \" field must be a valid ip address.\"); },\n  ip_or_fqdn: function (field) { return (\"The \" + field + \" field must be a valid ip address or FQDN.\"); },\n  length: function (field, ref) {\n    var length = ref[0];\n    var max = ref[1];\n\n    if (max) {\n      return (\"The \" + field + \" length must be between \" + length + \" and \" + max + \".\");\n    }\n\n    return (\"The \" + field + \" length must be \" + length + \".\");\n  },\n  max: function (field, ref) {\n    var length = ref[0];\n\n    return (\"The \" + field + \" field may not be greater than \" + length + \" characters.\");\n},\n  max_value: function (field, ref) {\n    var max = ref[0];\n\n    return (\"The \" + field + \" field must be \" + max + \" or less.\");\n},\n  mimes: function (field) { return (\"The \" + field + \" field must have a valid file type.\"); },\n  min: function (field, ref) {\n    var length = ref[0];\n\n    return (\"The \" + field + \" field must be at least \" + length + \" characters.\");\n},\n  min_value: function (field, ref) {\n    var min = ref[0];\n\n    return (\"The \" + field + \" field must be \" + min + \" or more.\");\n},\n  numeric: function (field) { return (\"The \" + field + \" field may only contain numeric characters.\"); },\n  regex: function (field) { return (\"The \" + field + \" field format is invalid.\"); },\n  required: function (field) { return (\"The \" + field + \" field is required.\"); },\n  required_if: function (field, ref) {\n    var target = ref[0];\n\n    return (\"The \" + field + \" field is required when the \" + target + \" field has this value.\");\n},\n  size: function (field, ref) {\n    var size = ref[0];\n\n    return (\"The \" + field + \" size must be less than \" + (formatFileSize(size)) + \".\");\n},\n  url: function (field) { return (\"The \" + field + \" field is not a valid URL.\"); }\n};\n\nvar locale = {\n  name: 'en',\n  messages: messages,\n  attributes: {}\n};\n\nif (isDefinedGlobally()) {\n  // eslint-disable-next-line\n  VeeValidate.Validator.localize(( obj = {}, obj[locale.name] = locale, obj ));\n}\n\nfunction toInteger (dirtyNumber) {\n  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {\n    return NaN\n  }\n\n  var number = Number(dirtyNumber);\n\n  if (isNaN(number)) {\n    return number\n  }\n\n  return number < 0 ? Math.ceil(number) : Math.floor(number)\n}\n\nvar MILLISECONDS_IN_MINUTE = 60000;\n\n/**\n * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.\n * They usually appear for dates that denote time before the timezones were introduced\n * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891\n * and GMT+01:00:00 after that date)\n *\n * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,\n * which would lead to incorrect calculations.\n *\n * This function returns the timezone offset in milliseconds that takes seconds in account.\n */\nfunction getTimezoneOffsetInMilliseconds (dirtyDate) {\n  var date = new Date(dirtyDate.getTime());\n  var baseTimezoneOffset = date.getTimezoneOffset();\n  date.setSeconds(0, 0);\n  var millisecondsPartOfTimezoneOffset = date.getTime() % MILLISECONDS_IN_MINUTE;\n\n  return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset\n}\n\nvar MILLISECONDS_IN_HOUR = 3600000;\nvar MILLISECONDS_IN_MINUTE$1 = 60000;\nvar DEFAULT_ADDITIONAL_DIGITS = 2;\n\nvar patterns = {\n  dateTimeDelimeter: /[T ]/,\n  plainTime: /:/,\n  timeZoneDelimeter: /[Z ]/i,\n\n  // year tokens\n  YY: /^(\\d{2})$/,\n  YYY: [\n    /^([+-]\\d{2})$/, // 0 additional digits\n    /^([+-]\\d{3})$/, // 1 additional digit\n    /^([+-]\\d{4})$/ // 2 additional digits\n  ],\n  YYYY: /^(\\d{4})/,\n  YYYYY: [\n    /^([+-]\\d{4})/, // 0 additional digits\n    /^([+-]\\d{5})/, // 1 additional digit\n    /^([+-]\\d{6})/ // 2 additional digits\n  ],\n\n  // date tokens\n  MM: /^-(\\d{2})$/,\n  DDD: /^-?(\\d{3})$/,\n  MMDD: /^-?(\\d{2})-?(\\d{2})$/,\n  Www: /^-?W(\\d{2})$/,\n  WwwD: /^-?W(\\d{2})-?(\\d{1})$/,\n\n  HH: /^(\\d{2}([.,]\\d*)?)$/,\n  HHMM: /^(\\d{2}):?(\\d{2}([.,]\\d*)?)$/,\n  HHMMSS: /^(\\d{2}):?(\\d{2}):?(\\d{2}([.,]\\d*)?)$/,\n\n  // timezone tokens\n  timezone: /([Z+-].*)$/,\n  timezoneZ: /^(Z)$/,\n  timezoneHH: /^([+-])(\\d{2})$/,\n  timezoneHHMM: /^([+-])(\\d{2}):?(\\d{2})$/\n};\n\n/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If an argument is a string, the function tries to parse it.\n * Function accepts complete ISO 8601 formats as well as partial implementations.\n * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601\n * If the function cannot parse the string or the values are invalid, it returns Invalid Date.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n * All *date-fns* functions will throw `RangeError` if `options.additionalDigits` is not 0, 1, 2 or undefined.\n *\n * @param {Date|String|Number} argument - the value to convert\n * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}\n * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format\n * @returns {Date} the parsed date in the local time zone\n * @throws {TypeError} 1 argument required\n * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2\n *\n * @example\n * // Convert string '2014-02-11T11:30:30' to date:\n * var result = toDate('2014-02-11T11:30:30')\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert string '+02014101' to date,\n * // if the additional number of digits in the extended year format is 1:\n * var result = toDate('+02014101', {additionalDigits: 1})\n * //=> Fri Apr 11 2014 00:00:00\n */\nfunction toDate (argument, dirtyOptions) {\n  if (arguments.length < 1) {\n    throw new TypeError('1 argument required, but only ' + arguments.length + ' present')\n  }\n\n  if (argument === null) {\n    return new Date(NaN)\n  }\n\n  var options = dirtyOptions || {};\n\n  var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : toInteger(options.additionalDigits);\n  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {\n    throw new RangeError('additionalDigits must be 0, 1 or 2')\n  }\n\n  // Clone the date\n  if (argument instanceof Date ||\n    (typeof argument === 'object' && Object.prototype.toString.call(argument) === '[object Date]')\n  ) {\n    // Prevent the date to lose the milliseconds when passed to new Date() in IE10\n    return new Date(argument.getTime())\n  } else if (typeof argument === 'number' || Object.prototype.toString.call(argument) === '[object Number]') {\n    return new Date(argument)\n  } else if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {\n    return new Date(NaN)\n  }\n\n  var dateStrings = splitDateString(argument);\n\n  var parseYearResult = parseYear(dateStrings.date, additionalDigits);\n  var year = parseYearResult.year;\n  var restDateString = parseYearResult.restDateString;\n\n  var date = parseDate(restDateString, year);\n\n  if (isNaN(date)) {\n    return new Date(NaN)\n  }\n\n  if (date) {\n    var timestamp = date.getTime();\n    var time = 0;\n    var offset;\n\n    if (dateStrings.time) {\n      time = parseTime(dateStrings.time);\n\n      if (isNaN(time)) {\n        return new Date(NaN)\n      }\n    }\n\n    if (dateStrings.timezone) {\n      offset = parseTimezone(dateStrings.timezone);\n      if (isNaN(offset)) {\n        return new Date(NaN)\n      }\n    } else {\n      // get offset accurate to hour in timezones that change offset\n      offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time));\n      offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time + offset));\n    }\n\n    return new Date(timestamp + time + offset)\n  } else {\n    return new Date(NaN)\n  }\n}\n\nfunction splitDateString (dateString) {\n  var dateStrings = {};\n  var array = dateString.split(patterns.dateTimeDelimeter);\n  var timeString;\n\n  if (patterns.plainTime.test(array[0])) {\n    dateStrings.date = null;\n    timeString = array[0];\n  } else {\n    dateStrings.date = array[0];\n    timeString = array[1];\n    if (patterns.timeZoneDelimeter.test(dateStrings.date)) {\n      dateStrings.date = dateString.split(patterns.timeZoneDelimeter)[0];\n      timeString = dateString.substr(dateStrings.date.length, dateString.length);\n    }\n  }\n\n  if (timeString) {\n    var token = patterns.timezone.exec(timeString);\n    if (token) {\n      dateStrings.time = timeString.replace(token[1], '');\n      dateStrings.timezone = token[1];\n    } else {\n      dateStrings.time = timeString;\n    }\n  }\n\n  return dateStrings\n}\n\nfunction parseYear (dateString, additionalDigits) {\n  var patternYYY = patterns.YYY[additionalDigits];\n  var patternYYYYY = patterns.YYYYY[additionalDigits];\n\n  var token;\n\n  // YYYY or YYYYY\n  token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);\n  if (token) {\n    var yearString = token[1];\n    return {\n      year: parseInt(yearString, 10),\n      restDateString: dateString.slice(yearString.length)\n    }\n  }\n\n  // YY or YYY\n  token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);\n  if (token) {\n    var centuryString = token[1];\n    return {\n      year: parseInt(centuryString, 10) * 100,\n      restDateString: dateString.slice(centuryString.length)\n    }\n  }\n\n  // Invalid ISO-formatted year\n  return {\n    year: null\n  }\n}\n\nfunction parseDate (dateString, year) {\n  // Invalid ISO-formatted year\n  if (year === null) {\n    return null\n  }\n\n  var token;\n  var date;\n  var month;\n  var week;\n\n  // YYYY\n  if (dateString.length === 0) {\n    date = new Date(0);\n    date.setUTCFullYear(year);\n    return date\n  }\n\n  // YYYY-MM\n  token = patterns.MM.exec(dateString);\n  if (token) {\n    date = new Date(0);\n    month = parseInt(token[1], 10) - 1;\n\n    if (!validateDate(year, month)) {\n      return new Date(NaN)\n    }\n\n    date.setUTCFullYear(year, month);\n    return date\n  }\n\n  // YYYY-DDD or YYYYDDD\n  token = patterns.DDD.exec(dateString);\n  if (token) {\n    date = new Date(0);\n    var dayOfYear = parseInt(token[1], 10);\n\n    if (!validateDayOfYearDate(year, dayOfYear)) {\n      return new Date(NaN)\n    }\n\n    date.setUTCFullYear(year, 0, dayOfYear);\n    return date\n  }\n\n  // YYYY-MM-DD or YYYYMMDD\n  token = patterns.MMDD.exec(dateString);\n  if (token) {\n    date = new Date(0);\n    month = parseInt(token[1], 10) - 1;\n    var day = parseInt(token[2], 10);\n\n    if (!validateDate(year, month, day)) {\n      return new Date(NaN)\n    }\n\n    date.setUTCFullYear(year, month, day);\n    return date\n  }\n\n  // YYYY-Www or YYYYWww\n  token = patterns.Www.exec(dateString);\n  if (token) {\n    week = parseInt(token[1], 10) - 1;\n\n    if (!validateWeekDate(year, week)) {\n      return new Date(NaN)\n    }\n\n    return dayOfISOWeekYear(year, week)\n  }\n\n  // YYYY-Www-D or YYYYWwwD\n  token = patterns.WwwD.exec(dateString);\n  if (token) {\n    week = parseInt(token[1], 10) - 1;\n    var dayOfWeek = parseInt(token[2], 10) - 1;\n\n    if (!validateWeekDate(year, week, dayOfWeek)) {\n      return new Date(NaN)\n    }\n\n    return dayOfISOWeekYear(year, week, dayOfWeek)\n  }\n\n  // Invalid ISO-formatted date\n  return null\n}\n\nfunction parseTime (timeString) {\n  var token;\n  var hours;\n  var minutes;\n\n  // hh\n  token = patterns.HH.exec(timeString);\n  if (token) {\n    hours = parseFloat(token[1].replace(',', '.'));\n\n    if (!validateTime(hours)) {\n      return NaN\n    }\n\n    return (hours % 24) * MILLISECONDS_IN_HOUR\n  }\n\n  // hh:mm or hhmm\n  token = patterns.HHMM.exec(timeString);\n  if (token) {\n    hours = parseInt(token[1], 10);\n    minutes = parseFloat(token[2].replace(',', '.'));\n\n    if (!validateTime(hours, minutes)) {\n      return NaN\n    }\n\n    return (hours % 24) * MILLISECONDS_IN_HOUR +\n      minutes * MILLISECONDS_IN_MINUTE$1\n  }\n\n  // hh:mm:ss or hhmmss\n  token = patterns.HHMMSS.exec(timeString);\n  if (token) {\n    hours = parseInt(token[1], 10);\n    minutes = parseInt(token[2], 10);\n    var seconds = parseFloat(token[3].replace(',', '.'));\n\n    if (!validateTime(hours, minutes, seconds)) {\n      return NaN\n    }\n\n    return (hours % 24) * MILLISECONDS_IN_HOUR +\n      minutes * MILLISECONDS_IN_MINUTE$1 +\n      seconds * 1000\n  }\n\n  // Invalid ISO-formatted time\n  return null\n}\n\nfunction parseTimezone (timezoneString) {\n  var token;\n  var absoluteOffset;\n\n  // Z\n  token = patterns.timezoneZ.exec(timezoneString);\n  if (token) {\n    return 0\n  }\n\n  var hours;\n\n  // hh\n  token = patterns.timezoneHH.exec(timezoneString);\n  if (token) {\n    hours = parseInt(token[2], 10);\n\n    if (!validateTimezone(hours)) {\n      return NaN\n    }\n\n    absoluteOffset = hours * MILLISECONDS_IN_HOUR;\n    return (token[1] === '+') ? -absoluteOffset : absoluteOffset\n  }\n\n  // hh:mm or hhmm\n  token = patterns.timezoneHHMM.exec(timezoneString);\n  if (token) {\n    hours = parseInt(token[2], 10);\n    var minutes = parseInt(token[3], 10);\n\n    if (!validateTimezone(hours, minutes)) {\n      return NaN\n    }\n\n    absoluteOffset = hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE$1;\n    return (token[1] === '+') ? -absoluteOffset : absoluteOffset\n  }\n\n  return 0\n}\n\nfunction dayOfISOWeekYear (isoWeekYear, week, day) {\n  week = week || 0;\n  day = day || 0;\n  var date = new Date(0);\n  date.setUTCFullYear(isoWeekYear, 0, 4);\n  var fourthOfJanuaryDay = date.getUTCDay() || 7;\n  var diff = week * 7 + day + 1 - fourthOfJanuaryDay;\n  date.setUTCDate(date.getUTCDate() + diff);\n  return date\n}\n\n// Validation functions\n\nvar DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nvar DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\nfunction isLeapYearIndex (year) {\n  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0)\n}\n\nfunction validateDate (year, month, date) {\n  if (month < 0 || month > 11) {\n    return false\n  }\n\n  if (date != null) {\n    if (date < 1) {\n      return false\n    }\n\n    var isLeapYear = isLeapYearIndex(year);\n    if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {\n      return false\n    }\n    if (!isLeapYear && date > DAYS_IN_MONTH[month]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction validateDayOfYearDate (year, dayOfYear) {\n  if (dayOfYear < 1) {\n    return false\n  }\n\n  var isLeapYear = isLeapYearIndex(year);\n  if (isLeapYear && dayOfYear > 366) {\n    return false\n  }\n  if (!isLeapYear && dayOfYear > 365) {\n    return false\n  }\n\n  return true\n}\n\nfunction validateWeekDate (year, week, day) {\n  if (week < 0 || week > 52) {\n    return false\n  }\n\n  if (day != null && (day < 0 || day > 6)) {\n    return false\n  }\n\n  return true\n}\n\nfunction validateTime (hours, minutes, seconds) {\n  if (hours != null && (hours < 0 || hours >= 25)) {\n    return false\n  }\n\n  if (minutes != null && (minutes < 0 || minutes >= 60)) {\n    return false\n  }\n\n  if (seconds != null && (seconds < 0 || seconds >= 60)) {\n    return false\n  }\n\n  return true\n}\n\nfunction validateTimezone (hours, minutes) {\n  if (minutes != null && (minutes < 0 || minutes > 59)) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @name addMilliseconds\n * @category Millisecond Helpers\n * @summary Add the specified number of milliseconds to the given date.\n *\n * @description\n * Add the specified number of milliseconds to the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of milliseconds to be added\n * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}\n * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}\n * @returns {Date} the new date with the milliseconds added\n * @throws {TypeError} 2 arguments required\n * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2\n *\n * @example\n * // Add 750 milliseconds to 10 July 2014 12:45:30.000:\n * var result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)\n * //=> Thu Jul 10 2014 12:45:30.750\n */\nfunction addMilliseconds (dirtyDate, dirtyAmount, dirtyOptions) {\n  if (arguments.length < 2) {\n    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')\n  }\n\n  var timestamp = toDate(dirtyDate, dirtyOptions).getTime();\n  var amount = toInteger(dirtyAmount);\n  return new Date(timestamp + amount)\n}\n\n/**\n * @name isValid\n * @category Common Helpers\n * @summary Is the given date valid?\n *\n * @description\n * Returns false if argument is Invalid Date and true otherwise.\n * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}\n * Invalid Date is a Date, whose time value is NaN.\n *\n * Time value of Date: http://es5.github.io/#x15.9.1.1\n *\n * @param {*} date - the date to check\n * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}\n * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}\n * @returns {Boolean} the date is valid\n * @throws {TypeError} 1 argument required\n * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2\n *\n * @example\n * // For the valid date:\n * var result = isValid(new Date(2014, 1, 31))\n * //=> true\n *\n * @example\n * // For the value, convertable into a date:\n * var result = isValid('2014-02-31')\n * //=> true\n *\n * @example\n * // For the invalid date:\n * var result = isValid(new Date(''))\n * //=> false\n */\nfunction isValid (dirtyDate, dirtyOptions) {\n  if (arguments.length < 1) {\n    throw new TypeError('1 argument required, but only ' + arguments.length + ' present')\n  }\n\n  var date = toDate(dirtyDate, dirtyOptions);\n  return !isNaN(date)\n}\n\nvar formatDistanceLocale = {\n  lessThanXSeconds: {\n    one: 'less than a second',\n    other: 'less than {{count}} seconds'\n  },\n\n  xSeconds: {\n    one: '1 second',\n    other: '{{count}} seconds'\n  },\n\n  halfAMinute: 'half a minute',\n\n  lessThanXMinutes: {\n    one: 'less than a minute',\n    other: 'less than {{count}} minutes'\n  },\n\n  xMinutes: {\n    one: '1 minute',\n    other: '{{count}} minutes'\n  },\n\n  aboutXHours: {\n    one: 'about 1 hour',\n    other: 'about {{count}} hours'\n  },\n\n  xHours: {\n    one: '1 hour',\n    other: '{{count}} hours'\n  },\n\n  xDays: {\n    one: '1 day',\n    other: '{{count}} days'\n  },\n\n  aboutXMonths: {\n    one: 'about 1 month',\n    other: 'about {{count}} months'\n  },\n\n  xMonths: {\n    one: '1 month',\n    other: '{{count}} months'\n  },\n\n  aboutXYears: {\n    one: 'about 1 year',\n    other: 'about {{count}} years'\n  },\n\n  xYears: {\n    one: '1 year',\n    other: '{{count}} years'\n  },\n\n  overXYears: {\n    one: 'over 1 year',\n    other: 'over {{count}} years'\n  },\n\n  almostXYears: {\n    one: 'almost 1 year',\n    other: 'almost {{count}} years'\n  }\n};\n\nfunction formatDistance (token, count, options) {\n  options = options || {};\n\n  var result;\n  if (typeof formatDistanceLocale[token] === 'string') {\n    result = formatDistanceLocale[token];\n  } else if (count === 1) {\n    result = formatDistanceLocale[token].one;\n  } else {\n    result = formatDistanceLocale[token].other.replace('{{count}}', count);\n  }\n\n  if (options.addSuffix) {\n    if (options.comparison > 0) {\n      return 'in ' + result\n    } else {\n      return result + ' ago'\n    }\n  }\n\n  return result\n}\n\nfunction buildFormatLongFn (args) {\n  return function (dirtyOptions) {\n    var options = dirtyOptions || {};\n    var width = options.width ? String(options.width) : args.defaultWidth;\n    var format = args.formats[width] || args.formats[args.defaultWidth];\n    return format\n  }\n}\n\nvar dateFormats = {\n  full: 'EEEE, MMMM do, y',\n  long: 'MMMM do, y',\n  medium: 'MMM d, y',\n  short: 'MM/dd/yyyy'\n};\n\nvar timeFormats = {\n  full: 'h:mm:ss a zzzz',\n  long: 'h:mm:ss a z',\n  medium: 'h:mm:ss a',\n  short: 'h:mm a'\n};\n\nvar dateTimeFormats = {\n  full: \"{{date}} 'at' {{time}}\",\n  long: \"{{date}} 'at' {{time}}\",\n  medium: '{{date}}, {{time}}',\n  short: '{{date}}, {{time}}'\n};\n\nvar formatLong = {\n  date: buildFormatLongFn({\n    formats: dateFormats,\n    defaultWidth: 'full'\n  }),\n\n  time: buildFormatLongFn({\n    formats: timeFormats,\n    defaultWidth: 'full'\n  }),\n\n  dateTime: buildFormatLongFn({\n    formats: dateTimeFormats,\n    defaultWidth: 'full'\n  })\n};\n\nvar formatRelativeLocale = {\n  lastWeek: \"'last' eeee 'at' p\",\n  yesterday: \"'yesterday at' p\",\n  today: \"'today at' p\",\n  tomorrow: \"'tomorrow at' p\",\n  nextWeek: \"eeee 'at' p\",\n  other: 'P'\n};\n\nfunction formatRelative (token, date, baseDate, options) {\n  return formatRelativeLocale[token]\n}\n\nfunction buildLocalizeFn (args) {\n  return function (dirtyIndex, dirtyOptions) {\n    var options = dirtyOptions || {};\n    var width = options.width ? String(options.width) : args.defaultWidth;\n    var context = options.context ? String(options.context) : 'standalone';\n\n    var valuesArray;\n    if (context === 'formatting' && args.formattingValues) {\n      valuesArray = args.formattingValues[width] || args.formattingValues[args.defaultFormattingWidth];\n    } else {\n      valuesArray = args.values[width] || args.values[args.defaultWidth];\n    }\n    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;\n    return valuesArray[index]\n  }\n}\n\nvar eraValues = {\n  narrow: ['B', 'A'],\n  abbreviated: ['BC', 'AD'],\n  wide: ['Before Christ', 'Anno Domini']\n};\n\nvar quarterValues = {\n  narrow: ['1', '2', '3', '4'],\n  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],\n  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']\n};\n\n// Note: in English, the names of days of the week and months are capitalized.\n// If you are making a new locale based on this one, check if the same is true for the language you're working on.\n// Generally, formatted dates should look like they are in the middle of a sentence,\n// e.g. in Spanish language the weekdays and months should be in the lowercase.\nvar monthValues = {\n  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],\n  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']\n};\n\nvar dayValues = {\n  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],\n  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],\n  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']\n};\n\nvar dayPeriodValues = {\n  narrow: {\n    am: 'a',\n    pm: 'p',\n    midnight: 'mi',\n    noon: 'n',\n    morning: 'morning',\n    afternoon: 'afternoon',\n    evening: 'evening',\n    night: 'night'\n  },\n  abbreviated: {\n    am: 'AM',\n    pm: 'PM',\n    midnight: 'midnight',\n    noon: 'noon',\n    morning: 'morning',\n    afternoon: 'afternoon',\n    evening: 'evening',\n    night: 'night'\n  },\n  wide: {\n    am: 'a.m.',\n    pm: 'p.m.',\n    midnight: 'midnight',\n    noon: 'noon',\n    morning: 'morning',\n    afternoon: 'afternoon',\n    evening: 'evening',\n    night: 'night'\n  }\n};\nvar formattingDayPeriodValues = {\n  narrow: {\n    am: 'a',\n    pm: 'p',\n    midnight: 'mi',\n    noon: 'n',\n    morning: 'in the morning',\n    afternoon: 'in the afternoon',\n    evening: 'in the evening',\n    night: 'at night'\n  },\n  abbreviated: {\n    am: 'AM',\n    pm: 'PM',\n    midnight: 'midnight',\n    noon: 'noon',\n    morning: 'in the morning',\n    afternoon: 'in the afternoon',\n    evening: 'in the evening',\n    night: 'at night'\n  },\n  wide: {\n    am: 'a.m.',\n    pm: 'p.m.',\n    midnight: 'midnight',\n    noon: 'noon',\n    morning: 'in the morning',\n    afternoon: 'in the afternoon',\n    evening: 'in the evening',\n    night: 'at night'\n  }\n};\n\nfunction ordinalNumber (dirtyNumber, dirtyOptions) {\n  var number = Number(dirtyNumber);\n\n  // If ordinal numbers depend on context, for example,\n  // if they are different for different grammatical genders,\n  // use `options.unit`:\n  //\n  //   var options = dirtyOptions || {}\n  //   var unit = String(options.unit)\n  //\n  // where `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',\n  // 'day', 'hour', 'minute', 'second'\n\n  var rem100 = number % 100;\n  if (rem100 > 20 || rem100 < 10) {\n    switch (rem100 % 10) {\n      case 1:\n        return number + 'st'\n      case 2:\n        return number + 'nd'\n      case 3:\n        return number + 'rd'\n    }\n  }\n  return number + 'th'\n}\n\nvar localize = {\n  ordinalNumber: ordinalNumber,\n\n  era: buildLocalizeFn({\n    values: eraValues,\n    defaultWidth: 'wide'\n  }),\n\n  quarter: buildLocalizeFn({\n    values: quarterValues,\n    defaultWidth: 'wide',\n    argumentCallback: function (quarter) {\n      return Number(quarter) - 1\n    }\n  }),\n\n  month: buildLocalizeFn({\n    values: monthValues,\n    defaultWidth: 'wide'\n  }),\n\n  day: buildLocalizeFn({\n    values: dayValues,\n    defaultWidth: 'wide'\n  }),\n\n  dayPeriod: buildLocalizeFn({\n    values: dayPeriodValues,\n    defaultWidth: 'wide',\n    formattingValues: formattingDayPeriodValues,\n    defaulFormattingWidth: 'wide'\n  })\n};\n\nfunction buildMatchPatternFn (args) {\n  return function (dirtyString, dirtyOptions) {\n    var string = String(dirtyString);\n    var options = dirtyOptions || {};\n\n    var matchResult = string.match(args.matchPattern);\n    if (!matchResult) {\n      return null\n    }\n    var matchedString = matchResult[0];\n\n    var parseResult = string.match(args.parsePattern);\n    if (!parseResult) {\n      return null\n    }\n    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];\n    value = options.valueCallback ? options.valueCallback(value) : value;\n\n    return {\n      value: value,\n      rest: string.slice(matchedString.length)\n    }\n  }\n}\n\nfunction buildMatchFn (args) {\n  return function (dirtyString, dirtyOptions) {\n    var string = String(dirtyString);\n    var options = dirtyOptions || {};\n    var width = options.width;\n\n    var matchPattern = (width && args.matchPatterns[width]) || args.matchPatterns[args.defaultMatchWidth];\n    var matchResult = string.match(matchPattern);\n\n    if (!matchResult) {\n      return null\n    }\n    var matchedString = matchResult[0];\n\n    var parsePatterns = (width && args.parsePatterns[width]) || args.parsePatterns[args.defaultParseWidth];\n\n    var value;\n    if (Object.prototype.toString.call(parsePatterns) === '[object Array]') {\n      value = parsePatterns.findIndex(function (pattern) {\n        return pattern.test(string)\n      });\n    } else {\n      value = findKey(parsePatterns, function (pattern) {\n        return pattern.test(string)\n      });\n    }\n\n    value = args.valueCallback ? args.valueCallback(value) : value;\n    value = options.valueCallback ? options.valueCallback(value) : value;\n\n    return {\n      value: value,\n      rest: string.slice(matchedString.length)\n    }\n  }\n}\n\nfunction findKey (object, predicate) {\n  for (var key in object) {\n    if (object.hasOwnProperty(key) && predicate(object[key])) {\n      return key\n    }\n  }\n}\n\nvar matchOrdinalNumberPattern = /^(\\d+)(th|st|nd|rd)?/i;\nvar parseOrdinalNumberPattern = /\\d+/i;\n\nvar matchEraPatterns = {\n  narrow: /^(b|a)/i,\n  abbreviated: /^(b\\.?\\s?c\\.?|b\\.?\\s?c\\.?\\s?e\\.?|a\\.?\\s?d\\.?|c\\.?\\s?e\\.?)/i,\n  wide: /^(before christ|before common era|anno domini|common era)/i\n};\nvar parseEraPatterns = {\n  any: [/^b/i, /^(a|c)/i]\n};\n\nvar matchQuarterPatterns = {\n  narrow: /^[1234]/i,\n  abbreviated: /^q[1234]/i,\n  wide: /^[1234](th|st|nd|rd)? quarter/i\n};\nvar parseQuarterPatterns = {\n  any: [/1/i, /2/i, /3/i, /4/i]\n};\n\nvar matchMonthPatterns = {\n  narrow: /^[jfmasond]/i,\n  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,\n  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i\n};\nvar parseMonthPatterns = {\n  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],\n  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]\n};\n\nvar matchDayPatterns = {\n  narrow: /^[smtwf]/i,\n  short: /^(su|mo|tu|we|th|fr|sa)/i,\n  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,\n  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i\n};\nvar parseDayPatterns = {\n  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],\n  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]\n};\n\nvar matchDayPeriodPatterns = {\n  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,\n  any: /^([ap]\\.?\\s?m\\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i\n};\nvar parseDayPeriodPatterns = {\n  any: {\n    am: /^a/i,\n    pm: /^p/i,\n    midnight: /^mi/i,\n    noon: /^no/i,\n    morning: /morning/i,\n    afternoon: /afternoon/i,\n    evening: /evening/i,\n    night: /night/i\n  }\n};\n\nvar match = {\n  ordinalNumber: buildMatchPatternFn({\n    matchPattern: matchOrdinalNumberPattern,\n    parsePattern: parseOrdinalNumberPattern,\n    valueCallback: function (value) {\n      return parseInt(value, 10)\n    }\n  }),\n\n  era: buildMatchFn({\n    matchPatterns: matchEraPatterns,\n    defaultMatchWidth: 'wide',\n    parsePatterns: parseEraPatterns,\n    defaultParseWidth: 'any'\n  }),\n\n  quarter: buildMatchFn({\n    matchPatterns: matchQuarterPatterns,\n    defaultMatchWidth: 'wide',\n    parsePatterns: parseQuarterPatterns,\n    defaultParseWidth: 'any',\n    valueCallback: function (index) {\n      return index + 1\n    }\n  }),\n\n  month: buildMatchFn({\n    matchPatterns: matchMonthPatterns,\n    defaultMatchWidth: 'wide',\n    parsePatterns: parseMonthPatterns,\n    defaultParseWidth: 'any'\n  }),\n\n  day: buildMatchFn({\n    matchPatterns: matchDayPatterns,\n    defaultMatchWidth: 'wide',\n    parsePatterns: parseDayPatterns,\n    defaultParseWidth: 'any'\n  }),\n\n  dayPeriod: buildMatchFn({\n    matchPatterns: matchDayPeriodPatterns,\n    defaultMatchWidth: 'any',\n    parsePatterns: parseDayPeriodPatterns,\n    defaultParseWidth: 'any'\n  })\n};\n\n/**\n * @type {Locale}\n * @category Locales\n * @summary English locale (United States).\n * @language English\n * @iso-639-2 eng\n * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}\n * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}\n */\nvar locale$1 = {\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 0 /* Sunday */,\n    firstWeekContainsDate: 1\n  }\n};\n\nvar MILLISECONDS_IN_DAY = 86400000;\n\n// This function will be a part of public API when UTC function will be implemented.\n// See issue: https://github.com/date-fns/date-fns/issues/376\nfunction getUTCDayOfYear (dirtyDate, dirtyOptions) {\n  if (arguments.length < 1) {\n    throw new TypeError('1 argument required, but only ' + arguments.length + ' present')\n  }\n\n  var date = toDate(dirtyDate, dirtyOptions);\n  var timestamp = date.getTime();\n  date.setUTCMonth(0, 1);\n  date.setUTCHours(0, 0, 0, 0);\n  var startOfYearTimestamp = date.getTime();\n  var difference = timestamp - startOfYearTimestamp;\n  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1\n}\n\n// This function will be a part of public API when UTC function will be implemented.\n// See issue: https://github.com/date-fns/date-fns/issues/376\nfunction startOfUTCISOWeek (dirtyDate, dirtyOptions) {\n  if (arguments.length < 1) {\n    throw new TypeError('1 argument required, but only ' + arguments.length + ' present')\n  }\n\n  var weekStartsOn = 1;\n\n  var date = toDate(dirtyDate, dirtyOptions);\n  var day = date.getUTCDay();\n  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;\n\n  date.setUTCDate(date.getUTCDate() - diff);\n  date.setUTCHours(0, 0, 0, 0);\n  return date\n}\n\n// This function will be a part of public API when UTC function will be implemented.\n// See issue: https://github.com/date-fns/date-fns/issues/376\nfunction getUTCISOWeekYear (dirtyDate, dirtyOptions) {\n  if (arguments.length < 1) {\n    throw new TypeError('1 argument required, but only ' + arguments.length + ' present')\n  }\n\n  var date = toDate(dirtyDate, dirtyOptions);\n  var year = date.getUTCFullYear();\n\n  var fourthOfJanuaryOfNextYear = new Date(0);\n  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);\n  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);\n  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear, dirtyOptions);\n\n  var fourthOfJanuaryOfThisYear = new Date(0);\n  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);\n  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);\n  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear, dirtyOptions);\n\n  if (date.getTime() >= startOfNextYear.getTime()) {\n    return year + 1\n  } else if (date.getTime() >= startOfThisYear.getTime()) {\n    return year\n  } else {\n    return year - 1\n  }\n}\n\n// This function will be a part of public API when UTC function will be implemented.\n// See issue: https://github.com/date-fns/date-fns/issues/376\nfunction startOfUTCISOWeekYear (dirtyDate, dirtyOptions) {\n  if (arguments.length < 1) {\n    throw new TypeError('1 argument required, but only ' + arguments.length + ' present')\n  }\n\n  var year = getUTCISOWeekYear(dirtyDate, dirtyOptions);\n  var fourthOfJanuary = new Date(0);\n  fourthOfJanuary.setUTCFullYear(year, 0, 4);\n  fourthOfJanuary.setUTCHours(0, 0, 0, 0);\n  var date = startOfUTCISOWeek(fourthOfJanuary, dirtyOptions);\n  return date\n}\n\nvar MILLISECONDS_IN_WEEK = 604800000;\n\n// This function will be a part of public API when UTC function will be implemented.\n// See issue: https://github.com/date-fns/date-fns/issues/376\nfunction getUTCISOWeek (dirtyDate, dirtyOptions) {\n  if (arguments.length < 1) {\n    throw new TypeError('1 argument required, but only ' + arguments.length + ' present')\n  }\n\n  var date = toDate(dirtyDate, dirtyOptions);\n  var diff = startOfUTCISOWeek(date, dirtyOptions).getTime() - startOfUTCISOWeekYear(date, dirtyOptions).getTime();\n\n  // Round the number of days to the nearest integer\n  // because the number of milliseconds in a week is not constant\n  // (e.g. it's different in the week of the daylight saving time clock shift)\n  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1\n}\n\n// This function will be a part of public API when UTC function will be implemented.\n// See issue: https://github.com/date-fns/date-fns/issues/376\nfunction startOfUTCWeek (dirtyDate, dirtyOptions) {\n  if (arguments.length < 1) {\n    throw new TypeError('1 argument required, but only ' + arguments.length + ' present')\n  }\n\n  var options = dirtyOptions || {};\n  var locale = options.locale;\n  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;\n  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);\n  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);\n\n  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN\n  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {\n    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively')\n  }\n\n  var date = toDate(dirtyDate, options);\n  var day = date.getUTCDay();\n  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;\n\n  date.setUTCDate(date.getUTCDate() - diff);\n  date.setUTCHours(0, 0, 0, 0);\n  return date\n}\n\n// This function will be a part of public API when UTC function will be implemented.\n// See issue: https://github.com/date-fns/date-fns/issues/376\nfunction getUTCWeekYear (dirtyDate, dirtyOptions) {\n  if (arguments.length < 1) {\n    throw new TypeError('1 argument required, but only ' + arguments.length + ' present')\n  }\n\n  var date = toDate(dirtyDate, dirtyOptions);\n  var year = date.getUTCFullYear();\n\n  var options = dirtyOptions || {};\n  var locale = options.locale;\n  var localeFirstWeekContainsDate = locale &&\n    locale.options &&\n    locale.options.firstWeekContainsDate;\n  var defaultFirstWeekContainsDate =\n    localeFirstWeekContainsDate == null\n      ? 1\n      : toInteger(localeFirstWeekContainsDate);\n  var firstWeekContainsDate =\n    options.firstWeekContainsDate == null\n      ? defaultFirstWeekContainsDate\n      : toInteger(options.firstWeekContainsDate);\n\n  // Test if weekStartsOn is between 1 and 7 _and_ is not NaN\n  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {\n    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively')\n  }\n\n  var firstWeekOfNextYear = new Date(0);\n  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);\n  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);\n  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);\n\n  var firstWeekOfThisYear = new Date(0);\n  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);\n  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);\n  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);\n\n  if (date.getTime() >= startOfNextYear.getTime()) {\n    return year + 1\n  } else if (date.getTime() >= startOfThisYear.getTime()) {\n    return year\n  } else {\n    return year - 1\n  }\n}\n\n// This function will be a part of public API when UTC function will be implemented.\n// See issue: https://github.com/date-fns/date-fns/issues/376\nfunction startOfUTCWeekYear (dirtyDate, dirtyOptions) {\n  if (arguments.length < 1) {\n    throw new TypeError('1 argument required, but only ' + arguments.length + ' present')\n  }\n\n  var options = dirtyOptions || {};\n  var locale = options.locale;\n  var localeFirstWeekContainsDate = locale &&\n    locale.options &&\n    locale.options.firstWeekContainsDate;\n  var defaultFirstWeekContainsDate =\n    localeFirstWeekContainsDate == null\n      ? 1\n      : toInteger(localeFirstWeekContainsDate);\n  var firstWeekContainsDate =\n    options.firstWeekContainsDate == null\n      ? defaultFirstWeekContainsDate\n      : toInteger(options.firstWeekContainsDate);\n\n  var year = getUTCWeekYear(dirtyDate, dirtyOptions);\n  var firstWeek = new Date(0);\n  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);\n  firstWeek.setUTCHours(0, 0, 0, 0);\n  var date = startOfUTCWeek(firstWeek, dirtyOptions);\n  return date\n}\n\nvar MILLISECONDS_IN_WEEK$1 = 604800000;\n\n// This function will be a part of public API when UTC function will be implemented.\n// See issue: https://github.com/date-fns/date-fns/issues/376\nfunction getUTCWeek (dirtyDate, dirtyOptions) {\n  if (arguments.length < 1) {\n    throw new TypeError('1 argument required, but only ' + arguments.length + ' present')\n  }\n\n  var date = toDate(dirtyDate, dirtyOptions);\n  var diff = startOfUTCWeek(date, dirtyOptions).getTime() - startOfUTCWeekYear(date, dirtyOptions).getTime();\n\n  // Round the number of days to the nearest integer\n  // because the number of milliseconds in a week is not constant\n  // (e.g. it's different in the week of the daylight saving time clock shift)\n  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1\n}\n\nvar dayPeriodEnum = {\n  am: 'am',\n  pm: 'pm',\n  midnight: 'midnight',\n  noon: 'noon',\n  morning: 'morning',\n  afternoon: 'afternoon',\n  evening: 'evening',\n  night: 'night'\n};\n\n/*\n * |     | Unit                           |     | Unit                           |\n * |-----|--------------------------------|-----|--------------------------------|\n * |  a  | AM, PM                         |  A* | Milliseconds in day            |\n * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |\n * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |\n * |  d  | Day of month                   |  D  | Day of year                    |\n * |  e  | Local day of week              |  E  | Day of week                    |\n * |  f  |                                |  F* | Day of week in month           |\n * |  g* | Modified Julian day            |  G  | Era                            |\n * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |\n * |  i! | ISO day of week                |  I! | ISO week of year               |\n * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |\n * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |\n * |  l* | (deprecated)                   |  L  | Stand-alone month              |\n * |  m  | Minute                         |  M  | Month                          |\n * |  n  |                                |  N  |                                |\n * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |\n * |  p! | Long localized time            |  P! | Long localized date            |\n * |  q  | Stand-alone quarter            |  Q  | Quarter                        |\n * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |\n * |  s  | Second                         |  S  | Fraction of second             |\n * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |\n * |  u  | Extended year                  |  U* | Cyclic year                    |\n * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |\n * |  w  | Local week of year             |  W* | Week of month                  |\n * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |\n * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |\n * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |\n *\n * Letters marked by * are not implemented but reserved by Unicode standard.\n *\n * Letters marked by ! are non-standard, but implemented by date-fns:\n * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)\n * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,\n *   i.e. 7 for Sunday, 1 for Monday, etc.\n * - `I` is ISO week of year, as opposed to `w` which is local week of year.\n * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.\n *   `R` is supposed to be used in conjunction with `I` and `i`\n *   for universal ISO week-numbering date, whereas\n *   `Y` is supposed to be used in conjunction with `w` and `e`\n *   for week-numbering date specific to the locale.\n * - `P` is long localized date format\n * - `p` is long localized time format\n */\n\nvar formatters = {\n  // Era\n  G: function (date, token, localize) {\n    var era = date.getUTCFullYear() > 0 ? 1 : 0;\n    switch (token) {\n      // AD, BC\n      case 'G':\n      case 'GG':\n      case 'GGG':\n        return localize.era(era, {width: 'abbreviated'})\n      // A, B\n      case 'GGGGG':\n        return localize.era(era, {width: 'narrow'})\n      // Anno Domini, Before Christ\n      case 'GGGG':\n      default:\n        return localize.era(era, {width: 'wide'})\n    }\n  },\n\n  // Year\n  y: function (date, token, localize, options) {\n    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens\n    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |\n    // |----------|-------|----|-------|-------|-------|\n    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |\n    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |\n    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |\n    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |\n    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |\n\n    var signedYear = date.getUTCFullYear();\n\n    // Returns 1 for 1 BC (which is year 0 in JavaScript)\n    var year = signedYear > 0 ? signedYear : 1 - signedYear;\n\n    // Two digit year\n    if (token === 'yy') {\n      var twoDigitYear = year % 100;\n      return addLeadingZeros(twoDigitYear, 2)\n    }\n\n    // Ordinal number\n    if (token === 'yo') {\n      return localize.ordinalNumber(year, {unit: 'year'})\n    }\n\n    // Padding\n    return addLeadingZeros(year, token.length)\n  },\n\n  // Local week-numbering year\n  Y: function (date, token, localize, options) {\n    var signedWeekYear = getUTCWeekYear(date, options);\n    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;\n\n    // Two digit year\n    if (token === 'YY') {\n      var twoDigitYear = weekYear % 100;\n      return addLeadingZeros(twoDigitYear, 2)\n    }\n\n    // Ordinal number\n    if (token === 'Yo') {\n      return localize.ordinalNumber(weekYear, {unit: 'year'})\n    }\n\n    // Padding\n    return addLeadingZeros(weekYear, token.length)\n  },\n\n  // ISO week-numbering year\n  R: function (date, token, localize, options) {\n    var isoWeekYear = getUTCISOWeekYear(date, options);\n\n    // Padding\n    return addLeadingZeros(isoWeekYear, token.length)\n  },\n\n  // Extended year. This is a single number designating the year of this calendar system.\n  // The main difference between `y` and `u` localizers are B.C. years:\n  // | Year | `y` | `u` |\n  // |------|-----|-----|\n  // | AC 1 |   1 |   1 |\n  // | BC 1 |   1 |   0 |\n  // | BC 2 |   2 |  -1 |\n  // Also `yy` always returns the last two digits of a year,\n  // while `uu` pads single digit years to 2 characters and returns other years unchanged.\n  u: function (date, token, localize, options) {\n    var year = date.getUTCFullYear();\n    return addLeadingZeros(year, token.length)\n  },\n\n  // Quarter\n  Q: function (date, token, localize, options) {\n    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);\n    switch (token) {\n      // 1, 2, 3, 4\n      case 'Q':\n        return String(quarter)\n      // 01, 02, 03, 04\n      case 'QQ':\n        return addLeadingZeros(quarter, 2)\n      // 1st, 2nd, 3rd, 4th\n      case 'Qo':\n        return localize.ordinalNumber(quarter, {unit: 'quarter'})\n      // Q1, Q2, Q3, Q4\n      case 'QQQ':\n        return localize.quarter(quarter, {width: 'abbreviated', context: 'formatting'})\n      // 1, 2, 3, 4 (narrow quarter; could be not numerical)\n      case 'QQQQQ':\n        return localize.quarter(quarter, {width: 'narrow', context: 'formatting'})\n      // 1st quarter, 2nd quarter, ...\n      case 'QQQQ':\n      default:\n        return localize.quarter(quarter, {width: 'wide', context: 'formatting'})\n    }\n  },\n\n  // Stand-alone quarter\n  q: function (date, token, localize, options) {\n    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);\n    switch (token) {\n      // 1, 2, 3, 4\n      case 'q':\n        return String(quarter)\n      // 01, 02, 03, 04\n      case 'qq':\n        return addLeadingZeros(quarter, 2)\n      // 1st, 2nd, 3rd, 4th\n      case 'qo':\n        return localize.ordinalNumber(quarter, {unit: 'quarter'})\n      // Q1, Q2, Q3, Q4\n      case 'qqq':\n        return localize.quarter(quarter, {width: 'abbreviated', context: 'standalone'})\n      // 1, 2, 3, 4 (narrow quarter; could be not numerical)\n      case 'qqqqq':\n        return localize.quarter(quarter, {width: 'narrow', context: 'standalone'})\n      // 1st quarter, 2nd quarter, ...\n      case 'qqqq':\n      default:\n        return localize.quarter(quarter, {width: 'wide', context: 'standalone'})\n    }\n  },\n\n  // Month\n  M: function (date, token, localize, options) {\n    var month = date.getUTCMonth();\n    switch (token) {\n      // 1, 2, ..., 12\n      case 'M':\n        return String(month + 1)\n      // 01, 02, ..., 12\n      case 'MM':\n        return addLeadingZeros(month + 1, 2)\n      // 1st, 2nd, ..., 12th\n      case 'Mo':\n        return localize.ordinalNumber(month + 1, {unit: 'month'})\n      // Jan, Feb, ..., Dec\n      case 'MMM':\n        return localize.month(month, {width: 'abbreviated', context: 'formatting'})\n      // J, F, ..., D\n      case 'MMMMM':\n        return localize.month(month, {width: 'narrow', context: 'formatting'})\n      // January, February, ..., December\n      case 'MMMM':\n      default:\n        return localize.month(month, {width: 'wide', context: 'formatting'})\n    }\n  },\n\n  // Stand-alone month\n  L: function (date, token, localize, options) {\n    var month = date.getUTCMonth();\n    switch (token) {\n      // 1, 2, ..., 12\n      case 'L':\n        return String(month + 1)\n      // 01, 02, ..., 12\n      case 'LL':\n        return addLeadingZeros(month + 1, 2)\n      // 1st, 2nd, ..., 12th\n      case 'Lo':\n        return localize.ordinalNumber(month + 1, {unit: 'month'})\n      // Jan, Feb, ..., Dec\n      case 'LLL':\n        return localize.month(month, {width: 'abbreviated', context: 'standalone'})\n      // J, F, ..., D\n      case 'LLLLL':\n        return localize.month(month, {width: 'narrow', context: 'standalone'})\n      // January, February, ..., December\n      case 'LLLL':\n      default:\n        return localize.month(month, {width: 'wide', context: 'standalone'})\n    }\n  },\n\n  // Local week of year\n  w: function (date, token, localize, options) {\n    var week = getUTCWeek(date, options);\n\n    if (token === 'wo') {\n      return localize.ordinalNumber(week, {unit: 'week'})\n    }\n\n    return addLeadingZeros(week, token.length)\n  },\n\n  // ISO week of year\n  I: function (date, token, localize, options) {\n    var isoWeek = getUTCISOWeek(date, options);\n\n    if (token === 'Io') {\n      return localize.ordinalNumber(isoWeek, {unit: 'week'})\n    }\n\n    return addLeadingZeros(isoWeek, token.length)\n  },\n\n  // Day of the month\n  d: function (date, token, localize, options) {\n    var dayOfMonth = date.getUTCDate();\n\n    if (token === 'do') {\n      return localize.ordinalNumber(dayOfMonth, {unit: 'date'})\n    }\n\n    return addLeadingZeros(dayOfMonth, token.length)\n  },\n\n  // Day of year\n  D: function (date, token, localize, options) {\n    var dayOfYear = getUTCDayOfYear(date, options);\n\n    if (token === 'Do') {\n      return localize.ordinalNumber(dayOfYear, {unit: 'dayOfYear'})\n    }\n\n    return addLeadingZeros(dayOfYear, token.length)\n  },\n\n  // Day of week\n  E: function (date, token, localize, options) {\n    var dayOfWeek = date.getUTCDay();\n    switch (token) {\n      // Tue\n      case 'E':\n      case 'EE':\n      case 'EEE':\n        return localize.day(dayOfWeek, {width: 'abbreviated', context: 'formatting'})\n      // T\n      case 'EEEEE':\n        return localize.day(dayOfWeek, {width: 'narrow', context: 'formatting'})\n      // Tu\n      case 'EEEEEE':\n        return localize.day(dayOfWeek, {width: 'short', context: 'formatting'})\n      // Tuesday\n      case 'EEEE':\n      default:\n        return localize.day(dayOfWeek, {width: 'wide', context: 'formatting'})\n    }\n  },\n\n  // Local day of week\n  e: function (date, token, localize, options) {\n    var dayOfWeek = date.getUTCDay();\n    var localDayOfWeek = ((dayOfWeek - options.weekStartsOn + 8) % 7) || 7;\n    switch (token) {\n      // Numerical value (Nth day of week with current locale or weekStartsOn)\n      case 'e':\n        return String(localDayOfWeek)\n      // Padded numerical value\n      case 'ee':\n        return addLeadingZeros(localDayOfWeek, 2)\n      // 1st, 2nd, ..., 7th\n      case 'eo':\n        return localize.ordinalNumber(localDayOfWeek, {unit: 'day'})\n      case 'eee':\n        return localize.day(dayOfWeek, {width: 'abbreviated', context: 'formatting'})\n      // T\n      case 'eeeee':\n        return localize.day(dayOfWeek, {width: 'narrow', context: 'formatting'})\n      // Tu\n      case 'eeeeee':\n        return localize.day(dayOfWeek, {width: 'short', context: 'formatting'})\n      // Tuesday\n      case 'eeee':\n      default:\n        return localize.day(dayOfWeek, {width: 'wide', context: 'formatting'})\n    }\n  },\n\n  // Stand-alone local day of week\n  c: function (date, token, localize, options) {\n    var dayOfWeek = date.getUTCDay();\n    var localDayOfWeek = ((dayOfWeek - options.weekStartsOn + 8) % 7) || 7;\n    switch (token) {\n      // Numerical value (same as in `e`)\n      case 'c':\n        return String(localDayOfWeek)\n      // Padded numberical value\n      case 'cc':\n        return addLeadingZeros(localDayOfWeek, token.length)\n      // 1st, 2nd, ..., 7th\n      case 'co':\n        return localize.ordinalNumber(localDayOfWeek, {unit: 'day'})\n      case 'ccc':\n        return localize.day(dayOfWeek, {width: 'abbreviated', context: 'standalone'})\n      // T\n      case 'ccccc':\n        return localize.day(dayOfWeek, {width: 'narrow', context: 'standalone'})\n      // Tu\n      case 'cccccc':\n        return localize.day(dayOfWeek, {width: 'short', context: 'standalone'})\n      // Tuesday\n      case 'cccc':\n      default:\n        return localize.day(dayOfWeek, {width: 'wide', context: 'standalone'})\n    }\n  },\n\n  // ISO day of week\n  i: function (date, token, localize, options) {\n    var dayOfWeek = date.getUTCDay();\n    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;\n    switch (token) {\n      // 2\n      case 'i':\n        return String(isoDayOfWeek)\n      // 02\n      case 'ii':\n        return addLeadingZeros(isoDayOfWeek, token.length)\n      // 2nd\n      case 'io':\n        return localize.ordinalNumber(isoDayOfWeek, {unit: 'day'})\n      // Tue\n      case 'iii':\n        return localize.day(dayOfWeek, {width: 'abbreviated', context: 'formatting'})\n      // T\n      case 'iiiii':\n        return localize.day(dayOfWeek, {width: 'narrow', context: 'formatting'})\n      // Tu\n      case 'iiiiii':\n        return localize.day(dayOfWeek, {width: 'short', context: 'formatting'})\n      // Tuesday\n      case 'iiii':\n      default:\n        return localize.day(dayOfWeek, {width: 'wide', context: 'formatting'})\n    }\n  },\n\n  // AM or PM\n  a: function (date, token, localize) {\n    var hours = date.getUTCHours();\n    var dayPeriodEnumValue = (hours / 12) >= 1 ? 'pm' : 'am';\n\n    switch (token) {\n      case 'a':\n      case 'aa':\n      case 'aaa':\n        return localize.dayPeriod(dayPeriodEnumValue, {width: 'abbreviated', context: 'formatting'})\n      case 'aaaaa':\n        return localize.dayPeriod(dayPeriodEnumValue, {width: 'narrow', context: 'formatting'})\n      case 'aaaa':\n      default:\n        return localize.dayPeriod(dayPeriodEnumValue, {width: 'wide', context: 'formatting'})\n    }\n  },\n\n  // AM, PM, midnight, noon\n  b: function (date, token, localize) {\n    var hours = date.getUTCHours();\n    var dayPeriodEnumValue;\n    if (hours === 12) {\n      dayPeriodEnumValue = dayPeriodEnum.noon;\n    } else if (hours === 0) {\n      dayPeriodEnumValue = dayPeriodEnum.midnight;\n    } else {\n      dayPeriodEnumValue = (hours / 12) >= 1 ? 'pm' : 'am';\n    }\n\n    switch (token) {\n      case 'b':\n      case 'bb':\n      case 'bbb':\n        return localize.dayPeriod(dayPeriodEnumValue, {width: 'abbreviated', context: 'formatting'})\n      case 'bbbbb':\n        return localize.dayPeriod(dayPeriodEnumValue, {width: 'narrow', context: 'formatting'})\n      case 'bbbb':\n      default:\n        return localize.dayPeriod(dayPeriodEnumValue, {width: 'wide', context: 'formatting'})\n    }\n  },\n\n  // in the morning, in the afternoon, in the evening, at night\n  B: function (date, token, localize) {\n    var hours = date.getUTCHours();\n    var dayPeriodEnumValue;\n    if (hours >= 17) {\n      dayPeriodEnumValue = dayPeriodEnum.evening;\n    } else if (hours >= 12) {\n      dayPeriodEnumValue = dayPeriodEnum.afternoon;\n    } else if (hours >= 4) {\n      dayPeriodEnumValue = dayPeriodEnum.morning;\n    } else {\n      dayPeriodEnumValue = dayPeriodEnum.night;\n    }\n\n    switch (token) {\n      case 'B':\n      case 'BB':\n      case 'BBB':\n        return localize.dayPeriod(dayPeriodEnumValue, {width: 'abbreviated', context: 'formatting'})\n      case 'BBBBB':\n        return localize.dayPeriod(dayPeriodEnumValue, {width: 'narrow', context: 'formatting'})\n      case 'BBBB':\n      default:\n        return localize.dayPeriod(dayPeriodEnumValue, {width: 'wide', context: 'formatting'})\n    }\n  },\n\n  // Hour [1-12]\n  h: function (date, token, localize, options) {\n    var hours = date.getUTCHours() % 12;\n\n    if (hours === 0) {\n      hours = 12;\n    }\n\n    if (token === 'ho') {\n      return localize.ordinalNumber(hours, {unit: 'hour'})\n    }\n\n    return addLeadingZeros(hours, token.length)\n  },\n\n  // Hour [0-23]\n  H: function (date, token, localize, options) {\n    var hours = date.getUTCHours();\n\n    if (token === 'Ho') {\n      return localize.ordinalNumber(hours, {unit: 'hour'})\n    }\n\n    return addLeadingZeros(hours, token.length)\n  },\n\n  // Hour [0-11]\n  K: function (date, token, localize, options) {\n    var hours = date.getUTCHours() % 12;\n\n    if (token === 'Ko') {\n      return localize.ordinalNumber(hours, {unit: 'hour'})\n    }\n\n    return addLeadingZeros(hours, token.length)\n  },\n\n  // Hour [1-24]\n  k: function (date, token, localize, options) {\n    var hours = date.getUTCHours();\n\n    if (hours === 0) {\n      hours = 24;\n    }\n\n    if (token === 'ko') {\n      return localize.ordinalNumber(hours, {unit: 'hour'})\n    }\n\n    return addLeadingZeros(hours, token.length)\n  },\n\n  // Minute\n  m: function (date, token, localize, options) {\n    var minutes = date.getUTCMinutes();\n\n    if (token === 'mo') {\n      return localize.ordinalNumber(minutes, {unit: 'minute'})\n    }\n\n    return addLeadingZeros(minutes, token.length)\n  },\n\n  // Second\n  s: function (date, token, localize, options) {\n    var seconds = date.getUTCSeconds();\n\n    if (token === 'so') {\n      return localize.ordinalNumber(seconds, {unit: 'second'})\n    }\n\n    return addLeadingZeros(seconds, token.length)\n  },\n\n  // Fraction of second\n  S: function (date, token, localize, options) {\n    var numberOfDigits = token.length;\n    var milliseconds = date.getUTCMilliseconds();\n    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));\n    return addLeadingZeros(fractionalSeconds, numberOfDigits)\n  },\n\n  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)\n  X: function (date, token, localize, options) {\n    var originalDate = options._originalDate || date;\n    var timezoneOffset = originalDate.getTimezoneOffset();\n\n    if (timezoneOffset === 0) {\n      return 'Z'\n    }\n\n    switch (token) {\n      // Hours and optional minutes\n      case 'X':\n        return formatTimezoneWithOptionalMinutes(timezoneOffset)\n\n      // Hours, minutes and optional seconds without `:` delimeter\n      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets\n      // so this token always has the same output as `XX`\n      case 'XXXX':\n      case 'XX': // Hours and minutes without `:` delimeter\n        return formatTimezone(timezoneOffset)\n\n      // Hours, minutes and optional seconds with `:` delimeter\n      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets\n      // so this token always has the same output as `XXX`\n      case 'XXXXX':\n      case 'XXX': // Hours and minutes with `:` delimeter\n      default:\n        return formatTimezone(timezoneOffset, ':')\n    }\n  },\n\n  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)\n  x: function (date, token, localize, options) {\n    var originalDate = options._originalDate || date;\n    var timezoneOffset = originalDate.getTimezoneOffset();\n\n    switch (token) {\n      // Hours and optional minutes\n      case 'x':\n        return formatTimezoneWithOptionalMinutes(timezoneOffset)\n\n      // Hours, minutes and optional seconds without `:` delimeter\n      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets\n      // so this token always has the same output as `xx`\n      case 'xxxx':\n      case 'xx': // Hours and minutes without `:` delimeter\n        return formatTimezone(timezoneOffset)\n\n      // Hours, minutes and optional seconds with `:` delimeter\n      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets\n      // so this token always has the same output as `xxx`\n      case 'xxxxx':\n      case 'xxx': // Hours and minutes with `:` delimeter\n      default:\n        return formatTimezone(timezoneOffset, ':')\n    }\n  },\n\n  // Timezone (GMT)\n  O: function (date, token, localize, options) {\n    var originalDate = options._originalDate || date;\n    var timezoneOffset = originalDate.getTimezoneOffset();\n\n    switch (token) {\n      // Short\n      case 'O':\n      case 'OO':\n      case 'OOO':\n        return 'GMT' + formatTimezoneShort(timezoneOffset, ':')\n      // Long\n      case 'OOOO':\n      default:\n        return 'GMT' + formatTimezone(timezoneOffset, ':')\n    }\n  },\n\n  // Timezone (specific non-location)\n  z: function (date, token, localize, options) {\n    var originalDate = options._originalDate || date;\n    var timezoneOffset = originalDate.getTimezoneOffset();\n\n    switch (token) {\n      // Short\n      case 'z':\n      case 'zz':\n      case 'zzz':\n        return 'GMT' + formatTimezoneShort(timezoneOffset, ':')\n      // Long\n      case 'zzzz':\n      default:\n        return 'GMT' + formatTimezone(timezoneOffset, ':')\n    }\n  },\n\n  // Seconds timestamp\n  t: function (date, token, localize, options) {\n    var originalDate = options._originalDate || date;\n    var timestamp = Math.floor(originalDate.getTime() / 1000);\n    return addLeadingZeros(timestamp, token.length)\n  },\n\n  // Milliseconds timestamp\n  T: function (date, token, localize, options) {\n    var originalDate = options._originalDate || date;\n    var timestamp = originalDate.getTime();\n    return addLeadingZeros(timestamp, token.length)\n  }\n};\n\nfunction addLeadingZeros (number, targetLength) {\n  var sign = number < 0 ? '-' : '';\n  var output = Math.abs(number).toString();\n  while (output.length < targetLength) {\n    output = '0' + output;\n  }\n  return sign + output\n}\n\nfunction formatTimezone (offset, dirtyDelimeter) {\n  var delimeter = dirtyDelimeter || '';\n  var sign = offset > 0 ? '-' : '+';\n  var absOffset = Math.abs(offset);\n  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);\n  var minutes = addLeadingZeros(absOffset % 60, 2);\n  return sign + hours + delimeter + minutes\n}\n\nfunction formatTimezoneWithOptionalMinutes (offset, dirtyDelimeter) {\n  if (offset % 60 === 0) {\n    var sign = offset > 0 ? '-' : '+';\n    return sign + addLeadingZeros(Math.abs(offset) / 60, 2)\n  }\n  return formatTimezone(offset, dirtyDelimeter)\n}\n\nfunction formatTimezoneShort (offset, dirtyDelimeter) {\n  var sign = offset > 0 ? '-' : '+';\n  var absOffset = Math.abs(offset);\n  var hours = Math.floor(absOffset / 60);\n  var minutes = absOffset % 60;\n  if (minutes === 0) {\n    return sign + String(hours)\n  }\n  var delimeter = dirtyDelimeter || '';\n  return sign + String(hours) + delimeter + addLeadingZeros(minutes, 2)\n}\n\nfunction dateLongFormatter (pattern, formatLong, options) {\n  switch (pattern) {\n    case 'P':\n      return formatLong.date({width: 'short'})\n    case 'PP':\n      return formatLong.date({width: 'medium'})\n    case 'PPP':\n      return formatLong.date({width: 'long'})\n    case 'PPPP':\n    default:\n      return formatLong.date({width: 'full'})\n  }\n}\n\nfunction timeLongFormatter (pattern, formatLong, options) {\n  switch (pattern) {\n    case 'p':\n      return formatLong.time({width: 'short'})\n    case 'pp':\n      return formatLong.time({width: 'medium'})\n    case 'ppp':\n      return formatLong.time({width: 'long'})\n    case 'pppp':\n    default:\n      return formatLong.time({width: 'full'})\n  }\n}\n\nfunction dateTimeLongFormatter (pattern, formatLong, options) {\n  var matchResult = pattern.match(/(P+)(p+)?/);\n  var datePattern = matchResult[1];\n  var timePattern = matchResult[2];\n\n  if (!timePattern) {\n    return dateLongFormatter(pattern, formatLong, options)\n  }\n\n  var dateTimeFormat;\n\n  switch (datePattern) {\n    case 'P':\n      dateTimeFormat = formatLong.dateTime({width: 'short'});\n      break\n    case 'PP':\n      dateTimeFormat = formatLong.dateTime({width: 'medium'});\n      break\n    case 'PPP':\n      dateTimeFormat = formatLong.dateTime({width: 'long'});\n      break\n    case 'PPPP':\n    default:\n      dateTimeFormat = formatLong.dateTime({width: 'full'});\n      break\n  }\n\n  return dateTimeFormat\n    .replace('{{date}}', dateLongFormatter(datePattern, formatLong, options))\n    .replace('{{time}}', timeLongFormatter(timePattern, formatLong, options))\n}\n\nvar longFormatters = {\n  p: timeLongFormatter,\n  P: dateTimeLongFormatter\n};\n\n/**\n * @name subMilliseconds\n * @category Millisecond Helpers\n * @summary Subtract the specified number of milliseconds from the given date.\n *\n * @description\n * Subtract the specified number of milliseconds from the given date.\n *\n * @param {Date|String|Number} date - the date to be changed\n * @param {Number} amount - the amount of milliseconds to be subtracted\n * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}\n * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}\n * @returns {Date} the new date with the milliseconds subtracted\n * @throws {TypeError} 2 arguments required\n * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2\n *\n * @example\n * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:\n * var result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)\n * //=> Thu Jul 10 2014 12:45:29.250\n */\nfunction subMilliseconds (dirtyDate, dirtyAmount, dirtyOptions) {\n  if (arguments.length < 2) {\n    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')\n  }\n\n  var amount = toInteger(dirtyAmount);\n  return addMilliseconds(dirtyDate, -amount, dirtyOptions)\n}\n\nvar protectedTokens = ['D', 'DD', 'YY', 'YYYY'];\n\nfunction isProtectedToken(token) {\n  return protectedTokens.indexOf(token) !== -1\n}\n\nfunction throwProtectedError(token) {\n  throw new RangeError(\n    '`options.awareOfUnicodeTokens` must be set to `true` to use `' +\n      token +\n      '` token; see: https://git.io/fxCyr'\n  )\n}\n\n// This RegExp consists of three parts separated by `|`:\n// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token\n//   (one of the certain letters followed by `o`)\n// - (\\w)\\1* matches any sequences of the same letter\n// - '' matches two quote characters in a row\n// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),\n//   except a single quote symbol, which ends the sequence.\n//   Two quote characters do not end the sequence.\n//   If there is no matching single quote\n//   then the sequence will continue until the end of the string.\n// - . matches any single character unmatched by previous parts of the RegExps\nvar formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\\w)\\1*|''|'(''|[^'])+('|$)|./g;\n\n// This RegExp catches symbols escaped by quotes, and also\n// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`\nvar longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;\n\nvar escapedStringRegExp = /^'(.*?)'?$/;\nvar doubleQuoteRegExp = /''/g;\n\n/**\n * @name format\n * @category Common Helpers\n * @summary Format the date.\n *\n * @description\n * Return the formatted date string in the given format. The result may vary by locale.\n *\n * >  Please note that the `format` tokens differ from Moment.js and other libraries.\n * > See: https://git.io/fxCyr\n *\n * The characters wrapped between two single quotes characters (') are escaped.\n * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.\n * (see the last example)\n *\n * Format of the string is based on Unicode Technical Standard #35:\n * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n * with a few additions (see note 7 below the table).\n *\n * Accepted patterns:\n * | Unit                            | Pattern | Result examples                   | Notes |\n * |---------------------------------|---------|-----------------------------------|-------|\n * | Era                             | G..GGG  | AD, BC                            |       |\n * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |\n * |                                 | GGGGG   | A, B                              |       |\n * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |\n * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |\n * |                                 | yy      | 44, 01, 00, 17                    | 5     |\n * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |\n * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |\n * |                                 | yyyyy   | ...                               | 3,5   |\n * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |\n * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |\n * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |\n * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |\n * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |\n * |                                 | YYYYY   | ...                               | 3,5   |\n * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |\n * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |\n * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |\n * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |\n * |                                 | RRRRR   | ...                               | 3,5,7 |\n * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |\n * |                                 | uu      | -43, 01, 1900, 2017               | 5     |\n * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |\n * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |\n * |                                 | uuuuu   | ...                               | 3,5   |\n * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |\n * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |\n * |                                 | QQ      | 01, 02, 03, 04                    |       |\n * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |\n * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |\n * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |\n * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |\n * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |\n * |                                 | qq      | 01, 02, 03, 04                    |       |\n * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |\n * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |\n * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |\n * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |\n * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |\n * |                                 | MM      | 01, 02, ..., 12                   |       |\n * |                                 | MMM     | Jan, Feb, ..., Dec                |       |\n * |                                 | MMMM    | January, February, ..., December  | 2     |\n * |                                 | MMMMM   | J, F, ..., D                      |       |\n * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |\n * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |\n * |                                 | LL      | 01, 02, ..., 12                   |       |\n * |                                 | LLL     | Jan, Feb, ..., Dec                |       |\n * |                                 | LLLL    | January, February, ..., December  | 2     |\n * |                                 | LLLLL   | J, F, ..., D                      |       |\n * | Local week of year              | w       | 1, 2, ..., 53                     |       |\n * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |\n * |                                 | ww      | 01, 02, ..., 53                   |       |\n * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |\n * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |\n * |                                 | II      | 01, 02, ..., 53                   | 7     |\n * | Day of month                    | d       | 1, 2, ..., 31                     |       |\n * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |\n * |                                 | dd      | 01, 02, ..., 31                   |       |\n * | Day of year                     | D       | 1, 2, ..., 365, 366               | 8     |\n * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |\n * |                                 | DD      | 01, 02, ..., 365, 366             | 8     |\n * |                                 | DDD     | 001, 002, ..., 365, 366           |       |\n * |                                 | DDDD    | ...                               | 3     |\n * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Su            |       |\n * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |\n * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |\n * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Su, Sa        |       |\n * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |\n * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |\n * |                                 | ii      | 01, 02, ..., 07                   | 7     |\n * |                                 | iii     | Mon, Tue, Wed, ..., Su            | 7     |\n * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |\n * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |\n * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Su, Sa        | 7     |\n * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |\n * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |\n * |                                 | ee      | 02, 03, ..., 01                   |       |\n * |                                 | eee     | Mon, Tue, Wed, ..., Su            |       |\n * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |\n * |                                 | eeeee   | M, T, W, T, F, S, S               |       |\n * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Su, Sa        |       |\n * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |\n * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |\n * |                                 | cc      | 02, 03, ..., 01                   |       |\n * |                                 | ccc     | Mon, Tue, Wed, ..., Su            |       |\n * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |\n * |                                 | ccccc   | M, T, W, T, F, S, S               |       |\n * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Su, Sa        |       |\n * | AM, PM                          | a..aaa  | AM, PM                            |       |\n * |                                 | aaaa    | a.m., p.m.                        | 2     |\n * |                                 | aaaaa   | a, p                              |       |\n * | AM, PM, noon, midnight          | b..bbb  | AM, PM, noon, midnight            |       |\n * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |\n * |                                 | bbbbb   | a, p, n, mi                       |       |\n * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |\n * |                                 | BBBB    | at night, in the morning, ...     | 2     |\n * |                                 | BBBBB   | at night, in the morning, ...     |       |\n * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |\n * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |\n * |                                 | hh      | 01, 02, ..., 11, 12               |       |\n * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |\n * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |\n * |                                 | HH      | 00, 01, 02, ..., 23               |       |\n * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |\n * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |\n * |                                 | KK      | 1, 2, ..., 11, 0                  |       |\n * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |\n * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |\n * |                                 | kk      | 24, 01, 02, ..., 23               |       |\n * | Minute                          | m       | 0, 1, ..., 59                     |       |\n * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |\n * |                                 | mm      | 00, 01, ..., 59                   |       |\n * | Second                          | s       | 0, 1, ..., 59                     |       |\n * |                                 | so      | 0th, 1st, ..., 59th               | 7     |\n * |                                 | ss      | 00, 01, ..., 59                   |       |\n * | Fraction of second              | S       | 0, 1, ..., 9                      |       |\n * |                                 | SS      | 00, 01, ..., 99                   |       |\n * |                                 | SSS     | 000, 0001, ..., 999               |       |\n * |                                 | SSSS    | ...                               | 3     |\n * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |\n * |                                 | XX      | -0800, +0530, Z                   |       |\n * |                                 | XXX     | -08:00, +05:30, Z                 |       |\n * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |\n * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |\n * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |\n * |                                 | xx      | -0800, +0530, +0000               |       |\n * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |\n * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |\n * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |\n * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |\n * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |\n * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |\n * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |\n * | Seconds timestamp               | t       | 512969520                         | 7     |\n * |                                 | tt      | ...                               | 3,7   |\n * | Milliseconds timestamp          | T       | 512969520900                      | 7     |\n * |                                 | TT      | ...                               | 3,7   |\n * | Long localized date             | P       | 05/29/1453                        | 7     |\n * |                                 | PP      | May 29, 1453                      | 7     |\n * |                                 | PPP     | May 29th, 1453                    | 7     |\n * |                                 | PPPP    | Sunday, May 29th, 1453            | 2,7   |\n * | Long localized time             | p       | 12:00 AM                          | 7     |\n * |                                 | pp      | 12:00:00 AM                       | 7     |\n * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |\n * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |\n * | Combination of date and time    | Pp      | 05/29/1453, 12:00 AM              | 7     |\n * |                                 | PPpp    | May 29, 1453, 12:00:00 AM         | 7     |\n * |                                 | PPPppp  | May 29th, 1453 at ...             | 7     |\n * |                                 | PPPPpppp| Sunday, May 29th, 1453 at ...     | 2,7   |\n * Notes:\n * 1. \"Formatting\" units (e.g. formatting quarter) in the default en-US locale\n *    are the same as \"stand-alone\" units, but are different in some languages.\n *    \"Formatting\" units are declined according to the rules of the language\n *    in the context of a date. \"Stand-alone\" units are always nominative singular:\n *\n *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`\n *\n *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`\n *\n * 2. Any sequence of the identical letters is a pattern, unless it is escaped by\n *    the single quote characters (see below).\n *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)\n *    the output will be the same as default pattern for this unit, usually\n *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units\n *    are marked with \"2\" in the last column of the table.\n *\n *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`\n *\n *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`\n *\n *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`\n *\n *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`\n *\n *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`\n *\n * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).\n *    The output will be padded with zeros to match the length of the pattern.\n *\n *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`\n *\n * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.\n *    These tokens represent the shortest form of the quarter.\n *\n * 5. The main difference between `y` and `u` patterns are B.C. years:\n *\n *    | Year | `y` | `u` |\n *    |------|-----|-----|\n *    | AC 1 |   1 |   1 |\n *    | BC 1 |   1 |   0 |\n *    | BC 2 |   2 |  -1 |\n *\n *    Also `yy` always returns the last two digits of a year,\n *    while `uu` pads single digit years to 2 characters and returns other years unchanged:\n *\n *    | Year | `yy` | `uu` |\n *    |------|------|------|\n *    | 1    |   01 |   01 |\n *    | 14   |   14 |   14 |\n *    | 376  |   76 |  376 |\n *    | 1453 |   53 | 1453 |\n *\n *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),\n *    except local week-numbering years are dependent on `options.weekStartsOn`\n *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}\n *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).\n *\n * 6. Specific non-location timezones are currently unavailable in `date-fns`,\n *    so right now these tokens fall back to GMT timezones.\n *\n * 7. These patterns are not in the Unicode Technical Standard #35:\n *    - `i`: ISO day of week\n *    - `I`: ISO week of year\n *    - `R`: ISO week-numbering year\n *    - `t`: seconds timestamp\n *    - `T`: milliseconds timestamp\n *    - `o`: ordinal number modifier\n *    - `P`: long localized date\n *    - `p`: long localized time\n *\n * 8. These tokens are often confused with others. See: https://git.io/fxCyr\n *\n * @param {Date|String|Number} date - the original date\n * @param {String} format - the string of tokens\n * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}\n * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}\n * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)\n * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is\n * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}\n * @param {Boolean} [options.awareOfUnicodeTokens=false] - if true, allows usage of Unicode tokens causes confusion:\n *   - Some of the day of year tokens (`D`, `DD`) that are confused with the day of month tokens (`d`, `dd`).\n *   - Some of the local week-numbering year tokens (`YY`, `YYYY`) that are confused with the calendar year tokens (`yy`, `yyyy`).\n *   See: https://git.io/fxCyr\n * @returns {String} the formatted date string\n * @throws {TypeError} 2 arguments required\n * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2\n * @throws {RangeError} `options.locale` must contain `localize` property\n * @throws {RangeError} `options.locale` must contain `formatLong` property\n * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6\n * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7\n * @throws {RangeError} `options.awareOfUnicodeTokens` must be set to `true` to use `XX` token; see: https://git.io/fxCyr\n *\n * @example\n * // Represent 11 February 2014 in middle-endian format:\n * var result = format(\n *   new Date(2014, 1, 11),\n *   'MM/dd/yyyy'\n * )\n * //=> '02/11/2014'\n *\n * @example\n * // Represent 2 July 2014 in Esperanto:\n * import { eoLocale } from 'date-fns/locale/eo'\n * var result = format(\n *   new Date(2014, 6, 2),\n *   \"do 'de' MMMM yyyy\",\n *   {locale: eoLocale}\n * )\n * //=> '2-a de julio 2014'\n *\n * @example\n * // Escape string by single quote characters:\n * var result = format(\n *   new Date(2014, 6, 2, 15),\n *   \"h 'o''clock'\"\n * )\n * //=> \"3 o'clock\"\n */\nfunction format(dirtyDate, dirtyFormatStr, dirtyOptions) {\n  if (arguments.length < 2) {\n    throw new TypeError(\n      '2 arguments required, but only ' + arguments.length + ' present'\n    )\n  }\n\n  var formatStr = String(dirtyFormatStr);\n  var options = dirtyOptions || {};\n\n  var locale = options.locale || locale$1;\n\n  var localeFirstWeekContainsDate =\n    locale.options && locale.options.firstWeekContainsDate;\n  var defaultFirstWeekContainsDate =\n    localeFirstWeekContainsDate == null\n      ? 1\n      : toInteger(localeFirstWeekContainsDate);\n  var firstWeekContainsDate =\n    options.firstWeekContainsDate == null\n      ? defaultFirstWeekContainsDate\n      : toInteger(options.firstWeekContainsDate);\n\n  // Test if weekStartsOn is between 1 and 7 _and_ is not NaN\n  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {\n    throw new RangeError(\n      'firstWeekContainsDate must be between 1 and 7 inclusively'\n    )\n  }\n\n  var localeWeekStartsOn = locale.options && locale.options.weekStartsOn;\n  var defaultWeekStartsOn =\n    localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);\n  var weekStartsOn =\n    options.weekStartsOn == null\n      ? defaultWeekStartsOn\n      : toInteger(options.weekStartsOn);\n\n  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN\n  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {\n    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively')\n  }\n\n  if (!locale.localize) {\n    throw new RangeError('locale must contain localize property')\n  }\n\n  if (!locale.formatLong) {\n    throw new RangeError('locale must contain formatLong property')\n  }\n\n  var originalDate = toDate(dirtyDate, options);\n\n  if (!isValid(originalDate, options)) {\n    return 'Invalid Date'\n  }\n\n  // Convert the date in system timezone to the same date in UTC+00:00 timezone.\n  // This ensures that when UTC functions will be implemented, locales will be compatible with them.\n  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376\n  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);\n  var utcDate = subMilliseconds(originalDate, timezoneOffset, options);\n\n  var formatterOptions = {\n    firstWeekContainsDate: firstWeekContainsDate,\n    weekStartsOn: weekStartsOn,\n    locale: locale,\n    _originalDate: originalDate\n  };\n\n  var result = formatStr\n    .match(longFormattingTokensRegExp)\n    .map(function(substring) {\n      var firstCharacter = substring[0];\n      if (firstCharacter === 'p' || firstCharacter === 'P') {\n        var longFormatter = longFormatters[firstCharacter];\n        return longFormatter(substring, locale.formatLong, formatterOptions)\n      }\n      return substring\n    })\n    .join('')\n    .match(formattingTokensRegExp)\n    .map(function(substring) {\n      // Replace two single quote characters with one single quote character\n      if (substring === \"''\") {\n        return \"'\"\n      }\n\n      var firstCharacter = substring[0];\n      if (firstCharacter === \"'\") {\n        return cleanEscapedString(substring)\n      }\n\n      var formatter = formatters[firstCharacter];\n      if (formatter) {\n        if (!options.awareOfUnicodeTokens && isProtectedToken(substring)) {\n          throwProtectedError(substring);\n        }\n        return formatter(utcDate, substring, locale.localize, formatterOptions)\n      }\n\n      return substring\n    })\n    .join('');\n\n  return result\n}\n\nfunction cleanEscapedString(input) {\n  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, \"'\")\n}\n\n/**\n * @name isAfter\n * @category Common Helpers\n * @summary Is the first date after the second one?\n *\n * @description\n * Is the first date after the second one?\n *\n * @param {Date|String|Number} date - the date that should be after the other one to return true\n * @param {Date|String|Number} dateToCompare - the date to compare with\n * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}\n * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}\n * @returns {Boolean} the first date is after the second date\n * @throws {TypeError} 2 arguments required\n * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2\n *\n * @example\n * // Is 10 July 1989 after 11 February 1987?\n * var result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))\n * //=> true\n */\nfunction isAfter (dirtyDate, dirtyDateToCompare, dirtyOptions) {\n  if (arguments.length < 2) {\n    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')\n  }\n\n  var date = toDate(dirtyDate, dirtyOptions);\n  var dateToCompare = toDate(dirtyDateToCompare, dirtyOptions);\n  return date.getTime() > dateToCompare.getTime()\n}\n\n/**\n * @name isBefore\n * @category Common Helpers\n * @summary Is the first date before the second one?\n *\n * @description\n * Is the first date before the second one?\n *\n * @param {Date|String|Number} date - the date that should be before the other one to return true\n * @param {Date|String|Number} dateToCompare - the date to compare with\n * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}\n * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}\n * @returns {Boolean} the first date is before the second date\n * @throws {TypeError} 2 arguments required\n * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2\n *\n * @example\n * // Is 10 July 1989 before 11 February 1987?\n * var result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))\n * //=> false\n */\nfunction isBefore (dirtyDate, dirtyDateToCompare, dirtyOptions) {\n  if (arguments.length < 2) {\n    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')\n  }\n\n  var date = toDate(dirtyDate, dirtyOptions);\n  var dateToCompare = toDate(dirtyDateToCompare, dirtyOptions);\n  return date.getTime() < dateToCompare.getTime()\n}\n\n/**\n * @name isDate\n * @category Common Helpers\n * @summary Is the given value a date?\n *\n * @description\n * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.\n *\n * @param {*} value - the value to check\n * @param {Options} [options] - the object with options. Unused; present for FP submodule compatibility sake. See [Options]{@link https://date-fns.org/docs/Options}\n * @returns {boolean} true if the given value is a date\n * @throws {TypeError} 1 arguments required\n *\n * @example\n * // For a valid date:\n * var result = isDate(new Date())\n * //=> true\n *\n * @example\n * // For an invalid date:\n * var result = isDate(new Date(NaN))\n * //=> true\n *\n * @example\n * // For some value:\n * var result = isDate('2014-02-31')\n * //=> false\n *\n * @example\n * // For an object:\n * var result = isDate({})\n * //=> false\n */\n\n/**\n * @name isEqual\n * @category Common Helpers\n * @summary Are the given dates equal?\n *\n * @description\n * Are the given dates equal?\n *\n * @param {Date|String|Number} dateLeft - the first date to compare\n * @param {Date|String|Number} dateRight - the second date to compare\n * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}\n * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}\n * @returns {Boolean} the dates are equal\n * @throws {TypeError} 2 arguments required\n * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2\n *\n * @example\n * // Are 2 July 2014 06:30:45.000 and 2 July 2014 06:30:45.500 equal?\n * var result = isEqual(\n *   new Date(2014, 6, 2, 6, 30, 45, 0)\n *   new Date(2014, 6, 2, 6, 30, 45, 500)\n * )\n * //=> false\n */\nfunction isEqual$1 (dirtyLeftDate, dirtyRightDate, dirtyOptions) {\n  if (arguments.length < 2) {\n    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')\n  }\n\n  var dateLeft = toDate(dirtyLeftDate, dirtyOptions);\n  var dateRight = toDate(dirtyRightDate, dirtyOptions);\n  return dateLeft.getTime() === dateRight.getTime()\n}\n\n// This function will be a part of public API when UTC function will be implemented.\n// See issue: https://github.com/date-fns/date-fns/issues/376\nfunction setUTCDay (dirtyDate, dirtyDay, dirtyOptions) {\n  if (arguments.length < 2) {\n    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')\n  }\n\n  var options = dirtyOptions || {};\n  var locale = options.locale;\n  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;\n  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);\n  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);\n\n  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN\n  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {\n    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively')\n  }\n\n  var date = toDate(dirtyDate, dirtyOptions);\n  var day = toInteger(dirtyDay);\n\n  var currentDay = date.getUTCDay();\n\n  var remainder = day % 7;\n  var dayIndex = (remainder + 7) % 7;\n\n  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;\n\n  date.setUTCDate(date.getUTCDate() + diff);\n  return date\n}\n\n// This function will be a part of public API when UTC function will be implemented.\n// See issue: https://github.com/date-fns/date-fns/issues/376\nfunction setUTCWeek (dirtyDate, dirtyWeek, dirtyOptions) {\n  if (arguments.length < 2) {\n    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')\n  }\n\n  var date = toDate(dirtyDate, dirtyOptions);\n  var week = toInteger(dirtyWeek);\n  var diff = getUTCWeek(date, dirtyOptions) - week;\n  date.setUTCDate(date.getUTCDate() - diff * 7);\n  return date\n}\n\n// This function will be a part of public API when UTC function will be implemented.\n// See issue: https://github.com/date-fns/date-fns/issues/376\nfunction setUTCISODay (dirtyDate, dirtyDay, dirtyOptions) {\n  if (arguments.length < 2) {\n    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')\n  }\n\n  var day = toInteger(dirtyDay);\n\n  if (day % 7 === 0) {\n    day = day - 7;\n  }\n\n  var weekStartsOn = 1;\n  var date = toDate(dirtyDate, dirtyOptions);\n  var currentDay = date.getUTCDay();\n\n  var remainder = day % 7;\n  var dayIndex = (remainder + 7) % 7;\n\n  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;\n\n  date.setUTCDate(date.getUTCDate() + diff);\n  return date\n}\n\n// This function will be a part of public API when UTC function will be implemented.\n// See issue: https://github.com/date-fns/date-fns/issues/376\nfunction setUTCISOWeek (dirtyDate, dirtyISOWeek, dirtyOptions) {\n  if (arguments.length < 2) {\n    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present')\n  }\n\n  var date = toDate(dirtyDate, dirtyOptions);\n  var isoWeek = toInteger(dirtyISOWeek);\n  var diff = getUTCISOWeek(date, dirtyOptions) - isoWeek;\n  date.setUTCDate(date.getUTCDate() - diff * 7);\n  return date\n}\n\nvar MILLISECONDS_IN_HOUR$1 = 3600000;\nvar MILLISECONDS_IN_MINUTE$2 = 60000;\nvar MILLISECONDS_IN_SECOND = 1000;\n\nvar numericPatterns = {\n  month: /^(1[0-2]|0?\\d)/, // 0 to 12\n  date: /^(3[0-1]|[0-2]?\\d)/, // 0 to 31\n  dayOfYear: /^(36[0-6]|3[0-5]\\d|[0-2]?\\d?\\d)/, // 0 to 366\n  week: /^(5[0-3]|[0-4]?\\d)/, // 0 to 53\n  hour23h: /^(2[0-3]|[0-1]?\\d)/, // 0 to 23\n  hour24h: /^(2[0-4]|[0-1]?\\d)/, // 0 to 24\n  hour11h: /^(1[0-1]|0?\\d)/, // 0 to 11\n  hour12h: /^(1[0-2]|0?\\d)/, // 0 to 12\n  minute: /^[0-5]?\\d/, // 0 to 59\n  second: /^[0-5]?\\d/, // 0 to 59\n\n  singleDigit: /^\\d/, // 0 to 9\n  twoDigits: /^\\d{1,2}/, // 0 to 99\n  threeDigits: /^\\d{1,3}/, // 0 to 999\n  fourDigits: /^\\d{1,4}/, // 0 to 9999\n\n  anyDigitsSigned: /^-?\\d+/,\n  singleDigitSigned: /^-?\\d/, // 0 to 9, -0 to -9\n  twoDigitsSigned: /^-?\\d{1,2}/, // 0 to 99, -0 to -99\n  threeDigitsSigned: /^-?\\d{1,3}/, // 0 to 999, -0 to -999\n  fourDigitsSigned: /^-?\\d{1,4}/ // 0 to 9999, -0 to -9999\n};\n\nvar timezonePatterns = {\n  basicOptionalMinutes: /^([+-])(\\d{2})(\\d{2})?|Z/,\n  basic: /^([+-])(\\d{2})(\\d{2})|Z/,\n  basicOptionalSeconds: /^([+-])(\\d{2})(\\d{2})((\\d{2}))?|Z/,\n  extended: /^([+-])(\\d{2}):(\\d{2})|Z/,\n  extendedOptionalSeconds: /^([+-])(\\d{2}):(\\d{2})(:(\\d{2}))?|Z/\n};\n\nfunction parseNumericPattern (pattern, string, valueCallback) {\n  var matchResult = string.match(pattern);\n\n  if (!matchResult) {\n    return null\n  }\n\n  var value = parseInt(matchResult[0], 10);\n\n  return {\n    value: valueCallback ? valueCallback(value) : value,\n    rest: string.slice(matchResult[0].length)\n  }\n}\n\nfunction parseTimezonePattern (pattern, string) {\n  var matchResult = string.match(pattern);\n\n  if (!matchResult) {\n    return null\n  }\n\n  // Input is 'Z'\n  if (matchResult[0] === 'Z') {\n    return {\n      value: 0,\n      rest: string.slice(1)\n    }\n  }\n\n  var sign = matchResult[1] === '+' ? 1 : -1;\n  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;\n  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;\n  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;\n\n  return {\n    value: sign * (\n      hours * MILLISECONDS_IN_HOUR$1 +\n        minutes * MILLISECONDS_IN_MINUTE$2 +\n        seconds * MILLISECONDS_IN_SECOND\n    ),\n    rest: string.slice(matchResult[0].length)\n  }\n}\n\nfunction parseAnyDigitsSigned (string, valueCallback) {\n  return parseNumericPattern(numericPatterns.anyDigitsSigned, string, valueCallback)\n}\n\nfunction parseNDigits (n, string, valueCallback) {\n  switch (n) {\n    case 1:\n      return parseNumericPattern(numericPatterns.singleDigit, string, valueCallback)\n    case 2:\n      return parseNumericPattern(numericPatterns.twoDigits, string, valueCallback)\n    case 3:\n      return parseNumericPattern(numericPatterns.threeDigits, string, valueCallback)\n    case 4:\n      return parseNumericPattern(numericPatterns.fourDigits, string, valueCallback)\n    default:\n      return parseNumericPattern(new RegExp('^\\\\d{1,' + n + '}'), string, valueCallback)\n  }\n}\n\nfunction parseNDigitsSigned (n, string, valueCallback) {\n  switch (n) {\n    case 1:\n      return parseNumericPattern(numericPatterns.singleDigitSigned, string, valueCallback)\n    case 2:\n      return parseNumericPattern(numericPatterns.twoDigitsSigned, string, valueCallback)\n    case 3:\n      return parseNumericPattern(numericPatterns.threeDigitsSigned, string, valueCallback)\n    case 4:\n      return parseNumericPattern(numericPatterns.fourDigitsSigned, string, valueCallback)\n    default:\n      return parseNumericPattern(new RegExp('^-?\\\\d{1,' + n + '}'), string, valueCallback)\n  }\n}\n\nfunction dayPeriodEnumToHours (enumValue) {\n  switch (enumValue) {\n    case 'morning':\n      return 4\n    case 'evening':\n      return 17\n    case 'pm':\n    case 'noon':\n    case 'afternoon':\n      return 12\n    case 'am':\n    case 'midnight':\n    case 'night':\n    default:\n      return 0\n  }\n}\n\nfunction normalizeTwoDigitYear (twoDigitYear, currentYear) {\n  var isCommonEra = currentYear > 0;\n  // Absolute number of the current year:\n  // 1 -> 1 AC\n  // 0 -> 1 BC\n  // -1 -> 2 BC\n  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;\n\n  var result;\n  if (absCurrentYear <= 50) {\n    result = twoDigitYear || 100;\n  } else {\n    var rangeEnd = absCurrentYear + 50;\n    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;\n    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;\n    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);\n  }\n\n  return isCommonEra ? result : 1 - result\n}\n\nvar DAYS_IN_MONTH$1 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nvar DAYS_IN_MONTH_LEAP_YEAR$1 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n// User for validation\nfunction isLeapYearIndex$1 (year) {\n  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0)\n}\n\n/*\n * |     | Unit                           |     | Unit                           |\n * |-----|--------------------------------|-----|--------------------------------|\n * |  a  | AM, PM                         |  A* | Milliseconds in day            |\n * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |\n * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |\n * |  d  | Day of month                   |  D  | Day of year                    |\n * |  e  | Local day of week              |  E  | Day of week                    |\n * |  f  |                                |  F* | Day of week in month           |\n * |  g* | Modified Julian day            |  G  | Era                            |\n * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |\n * |  i! | ISO day of week                |  I! | ISO week of year               |\n * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |\n * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |\n * |  l* | (deprecated)                   |  L  | Stand-alone month              |\n * |  m  | Minute                         |  M  | Month                          |\n * |  n  |                                |  N  |                                |\n * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |\n * |  p  |                                |  P  |                                |\n * |  q  | Stand-alone quarter            |  Q  | Quarter                        |\n * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |\n * |  s  | Second                         |  S  | Fraction of second             |\n * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |\n * |  u  | Extended year                  |  U* | Cyclic year                    |\n * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |\n * |  w  | Local week of year             |  W* | Week of month                  |\n * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |\n * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |\n * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |\n *\n * Letters marked by * are not implemented but reserved by Unicode standard.\n *\n * Letters marked by ! are non-standard, but implemented by date-fns:\n * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)\n * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,\n *   i.e. 7 for Sunday, 1 for Monday, etc.\n * - `I` is ISO week of year, as opposed to `w` which is local week of year.\n * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.\n *   `R` is supposed to be used in conjunction with `I` and `i`\n *   for universal ISO week-numbering date, whereas\n *   `Y` is supposed to be used in conjunction with `w` and `e`\n *   for week-numbering date specific to the locale.\n */\nvar parsers = {\n  // Era\n  G: {\n    priority: 140,\n    parse: function (string, token, match, options) {\n      switch (token) {\n        // AD, BC\n        case 'G':\n        case 'GG':\n        case 'GGG':\n          return match.era(string, {width: 'abbreviated'}) ||\n            match.era(string, {width: 'narrow'})\n        // A, B\n        case 'GGGGG':\n          return match.era(string, {width: 'narrow'})\n        // Anno Domini, Before Christ\n        case 'GGGG':\n        default:\n          return match.era(string, {width: 'wide'}) ||\n            match.era(string, {width: 'abbreviated'}) ||\n            match.era(string, {width: 'narrow'})\n      }\n    },\n    set: function (date, value, options) {\n      // Sets year 10 BC if BC, or 10 AC if AC\n      date.setUTCFullYear(value === 1 ? 10 : -9, 0, 1);\n      date.setUTCHours(0, 0, 0, 0);\n      return date\n    }\n  },\n\n  // Year\n  y: {\n    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns\n    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |\n    // |----------|-------|----|-------|-------|-------|\n    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |\n    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |\n    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |\n    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |\n    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |\n\n    priority: 130,\n    parse: function (string, token, match, options) {\n      var valueCallback = function (year) {\n        return {\n          year: year,\n          isTwoDigitYear: token === 'yy'\n        }\n      };\n\n      switch (token) {\n        case 'y':\n          return parseNDigits(4, string, valueCallback)\n        case 'yo':\n          return match.ordinalNumber(string, {unit: 'year', valueCallback: valueCallback})\n        default:\n          return parseNDigits(token.length, string, valueCallback)\n      }\n    },\n    validate: function (date, value, options) {\n      return value.isTwoDigitYear || value.year > 0\n    },\n    set: function (date, value, options) {\n      var currentYear = getUTCWeekYear(date, options);\n\n      if (value.isTwoDigitYear) {\n        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);\n        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);\n        date.setUTCHours(0, 0, 0, 0);\n        return date\n      }\n\n      var year = currentYear > 0 ? value.year : 1 - value.year;\n      date.setUTCFullYear(year, 0, 1);\n      date.setUTCHours(0, 0, 0, 0);\n      return date\n    }\n  },\n\n  // Local week-numbering year\n  Y: {\n    priority: 130,\n    parse: function (string, token, match, options) {\n      var valueCallback = function (year) {\n        return {\n          year: year,\n          isTwoDigitYear: token === 'YY'\n        }\n      };\n\n      switch (token) {\n        case 'Y':\n          return parseNDigits(4, string, valueCallback)\n        case 'Yo':\n          return match.ordinalNumber(string, {unit: 'year', valueCallback: valueCallback})\n        default:\n          return parseNDigits(token.length, string, valueCallback)\n      }\n    },\n    validate: function (date, value, options) {\n      return value.isTwoDigitYear || value.year > 0\n    },\n    set: function (date, value, options) {\n      var currentYear = date.getUTCFullYear();\n\n      if (value.isTwoDigitYear) {\n        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);\n        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);\n        date.setUTCHours(0, 0, 0, 0);\n        return startOfUTCWeek(date, options)\n      }\n\n      var year = currentYear > 0 ? value.year : 1 - value.year;\n      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);\n      date.setUTCHours(0, 0, 0, 0);\n      return startOfUTCWeek(date, options)\n    }\n  },\n\n  // ISO week-numbering year\n  R: {\n    priority: 130,\n    parse: function (string, token, match, options) {\n      if (token === 'R') {\n        return parseNDigitsSigned(4, string)\n      }\n\n      return parseNDigitsSigned(token.length, string)\n    },\n    set: function (date, value, options) {\n      var firstWeekOfYear = new Date(0);\n      firstWeekOfYear.setUTCFullYear(value, 0, 4);\n      firstWeekOfYear.setUTCHours(0, 0, 0, 0);\n      return startOfUTCISOWeek(firstWeekOfYear)\n    }\n  },\n\n  // Extended year\n  u: {\n    priority: 130,\n    parse: function (string, token, match, options) {\n      if (token === 'u') {\n        return parseNDigitsSigned(4, string)\n      }\n\n      return parseNDigitsSigned(token.length, string)\n    },\n    set: function (date, value, options) {\n      date.setUTCFullYear(value, 0, 1);\n      date.setUTCHours(0, 0, 0, 0);\n      return date\n    }\n  },\n\n  // Quarter\n  Q: {\n    priority: 120,\n    parse: function (string, token, match, options) {\n      switch (token) {\n        // 1, 2, 3, 4\n        case 'Q':\n        case 'QQ': // 01, 02, 03, 04\n          return parseNDigits(token.length, string)\n        // 1st, 2nd, 3rd, 4th\n        case 'Qo':\n          return match.ordinalNumber(string, {unit: 'quarter'})\n        // Q1, Q2, Q3, Q4\n        case 'QQQ':\n          return match.quarter(string, {width: 'abbreviated', context: 'formatting'}) ||\n            match.quarter(string, {width: 'narrow', context: 'formatting'})\n        // 1, 2, 3, 4 (narrow quarter; could be not numerical)\n        case 'QQQQQ':\n          return match.quarter(string, {width: 'narrow', context: 'formatting'})\n        // 1st quarter, 2nd quarter, ...\n        case 'QQQQ':\n        default:\n          return match.quarter(string, {width: 'wide', context: 'formatting'}) ||\n            match.quarter(string, {width: 'abbreviated', context: 'formatting'}) ||\n            match.quarter(string, {width: 'narrow', context: 'formatting'})\n      }\n    },\n    validate: function (date, value, options) {\n      return value >= 1 && value <= 4\n    },\n    set: function (date, value, options) {\n      date.setUTCMonth((value - 1) * 3, 1);\n      date.setUTCHours(0, 0, 0, 0);\n      return date\n    }\n  },\n\n  // Stand-alone quarter\n  q: {\n    priority: 120,\n    parse: function (string, token, match, options) {\n      switch (token) {\n        // 1, 2, 3, 4\n        case 'q':\n        case 'qq': // 01, 02, 03, 04\n          return parseNDigits(token.length, string)\n        // 1st, 2nd, 3rd, 4th\n        case 'qo':\n          return match.ordinalNumber(string, {unit: 'quarter'})\n        // Q1, Q2, Q3, Q4\n        case 'qqq':\n          return match.quarter(string, {width: 'abbreviated', context: 'standalone'}) ||\n            match.quarter(string, {width: 'narrow', context: 'standalone'})\n        // 1, 2, 3, 4 (narrow quarter; could be not numerical)\n        case 'qqqqq':\n          return match.quarter(string, {width: 'narrow', context: 'standalone'})\n        // 1st quarter, 2nd quarter, ...\n        case 'qqqq':\n        default:\n          return match.quarter(string, {width: 'wide', context: 'standalone'}) ||\n            match.quarter(string, {width: 'abbreviated', context: 'standalone'}) ||\n            match.quarter(string, {width: 'narrow', context: 'standalone'})\n      }\n    },\n    validate: function (date, value, options) {\n      return value >= 1 && value <= 4\n    },\n    set: function (date, value, options) {\n      date.setUTCMonth((value - 1) * 3, 1);\n      date.setUTCHours(0, 0, 0, 0);\n      return date\n    }\n  },\n\n  // Month\n  M: {\n    priority: 110,\n    parse: function (string, token, match, options) {\n      var valueCallback = function (value) {\n        return value - 1\n      };\n\n      switch (token) {\n        // 1, 2, ..., 12\n        case 'M':\n          return parseNumericPattern(numericPatterns.month, string, valueCallback)\n        // 01, 02, ..., 12\n        case 'MM':\n          return parseNDigits(2, string, valueCallback)\n        // 1st, 2nd, ..., 12th\n        case 'Mo':\n          return match.ordinalNumber(string, {unit: 'month', valueCallback: valueCallback})\n        // Jan, Feb, ..., Dec\n        case 'MMM':\n          return match.month(string, {width: 'abbreviated', context: 'formatting'}) ||\n            match.month(string, {width: 'narrow', context: 'formatting'})\n        // J, F, ..., D\n        case 'MMMMM':\n          return match.month(string, {width: 'narrow', context: 'formatting'})\n        // January, February, ..., December\n        case 'MMMM':\n        default:\n          return match.month(string, {width: 'wide', context: 'formatting'}) ||\n            match.month(string, {width: 'abbreviated', context: 'formatting'}) ||\n            match.month(string, {width: 'narrow', context: 'formatting'})\n      }\n    },\n    validate: function (date, value, options) {\n      return value >= 0 && value <= 11\n    },\n    set: function (date, value, options) {\n      date.setUTCMonth(value, 1);\n      date.setUTCHours(0, 0, 0, 0);\n      return date\n    }\n  },\n\n  // Stand-alone month\n  L: {\n    priority: 110,\n    parse: function (string, token, match, options) {\n      var valueCallback = function (value) {\n        return value - 1\n      };\n\n      switch (token) {\n        // 1, 2, ..., 12\n        case 'L':\n          return parseNumericPattern(numericPatterns.month, string, valueCallback)\n        // 01, 02, ..., 12\n        case 'LL':\n          return parseNDigits(2, string, valueCallback)\n        // 1st, 2nd, ..., 12th\n        case 'Lo':\n          return match.ordinalNumber(string, {unit: 'month', valueCallback: valueCallback})\n        // Jan, Feb, ..., Dec\n        case 'LLL':\n          return match.month(string, {width: 'abbreviated', context: 'standalone'}) ||\n            match.month(string, {width: 'narrow', context: 'standalone'})\n        // J, F, ..., D\n        case 'LLLLL':\n          return match.month(string, {width: 'narrow', context: 'standalone'})\n        // January, February, ..., December\n        case 'LLLL':\n        default:\n          return match.month(string, {width: 'wide', context: 'standalone'}) ||\n            match.month(string, {width: 'abbreviated', context: 'standalone'}) ||\n            match.month(string, {width: 'narrow', context: 'standalone'})\n      }\n    },\n    validate: function (date, value, options) {\n      return value >= 0 && value <= 11\n    },\n    set: function (date, value, options) {\n      date.setUTCMonth(value, 1);\n      date.setUTCHours(0, 0, 0, 0);\n      return date\n    }\n  },\n\n  // Local week of year\n  w: {\n    priority: 100,\n    parse: function (string, token, match, options) {\n      switch (token) {\n        case 'w':\n          return parseNumericPattern(numericPatterns.week, string)\n        case 'wo':\n          return match.ordinalNumber(string, {unit: 'week'})\n        default:\n          return parseNDigits(token.length, string)\n      }\n    },\n    validate: function (date, value, options) {\n      return value >= 1 && value <= 53\n    },\n    set: function (date, value, options) {\n      return startOfUTCWeek(setUTCWeek(date, value, options), options)\n    }\n  },\n\n  // ISO week of year\n  I: {\n    priority: 100,\n    parse: function (string, token, match, options) {\n      switch (token) {\n        case 'I':\n          return parseNumericPattern(numericPatterns.week, string)\n        case 'Io':\n          return match.ordinalNumber(string, {unit: 'week'})\n        default:\n          return parseNDigits(token.length, string)\n      }\n    },\n    validate: function (date, value, options) {\n      return value >= 1 && value <= 53\n    },\n    set: function (date, value, options) {\n      return startOfUTCISOWeek(setUTCISOWeek(date, value, options), options)\n    }\n  },\n\n  // Day of the month\n  d: {\n    priority: 90,\n    parse: function (string, token, match, options) {\n      switch (token) {\n        case 'd':\n          return parseNumericPattern(numericPatterns.date, string)\n        case 'do':\n          return match.ordinalNumber(string, {unit: 'date'})\n        default:\n          return parseNDigits(token.length, string)\n      }\n    },\n    validate: function (date, value, options) {\n      var year = date.getUTCFullYear();\n      var isLeapYear = isLeapYearIndex$1(year);\n      var month = date.getUTCMonth();\n      if (isLeapYear) {\n        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR$1[month]\n      } else {\n        return value >= 1 && value <= DAYS_IN_MONTH$1[month]\n      }\n    },\n    set: function (date, value, options) {\n      date.setUTCDate(value);\n      date.setUTCHours(0, 0, 0, 0);\n      return date\n    }\n  },\n\n  // Day of year\n  D: {\n    priority: 90,\n    parse: function (string, token, match, options) {\n      switch (token) {\n        case 'D':\n        case 'DD':\n          return parseNumericPattern(numericPatterns.dayOfYear, string)\n        case 'Do':\n          return match.ordinalNumber(string, {unit: 'date'})\n        default:\n          return parseNDigits(token.length, string)\n      }\n    },\n    validate: function (date, value, options) {\n      var year = date.getUTCFullYear();\n      var isLeapYear = isLeapYearIndex$1(year);\n      if (isLeapYear) {\n        return value >= 1 && value <= 366\n      } else {\n        return value >= 1 && value <= 365\n      }\n    },\n    set: function (date, value, options) {\n      date.setUTCMonth(0, value);\n      date.setUTCHours(0, 0, 0, 0);\n      return date\n    }\n  },\n\n  // Day of week\n  E: {\n    priority: 90,\n    parse: function (string, token, match, options) {\n      switch (token) {\n        // Tue\n        case 'E':\n        case 'EE':\n        case 'EEE':\n          return match.day(string, {width: 'abbreviated', context: 'formatting'}) ||\n            match.day(string, {width: 'short', context: 'formatting'}) ||\n            match.day(string, {width: 'narrow', context: 'formatting'})\n        // T\n        case 'EEEEE':\n          return match.day(string, {width: 'narrow', context: 'formatting'})\n        // Tu\n        case 'EEEEEE':\n          return match.day(string, {width: 'short', context: 'formatting'}) ||\n          match.day(string, {width: 'narrow', context: 'formatting'})\n        // Tuesday\n        case 'EEEE':\n        default:\n          return match.day(string, {width: 'wide', context: 'formatting'}) ||\n            match.day(string, {width: 'abbreviated', context: 'formatting'}) ||\n            match.day(string, {width: 'short', context: 'formatting'}) ||\n            match.day(string, {width: 'narrow', context: 'formatting'})\n      }\n    },\n    validate: function (date, value, options) {\n      return value >= 0 && value <= 6\n    },\n    set: function (date, value, options) {\n      date = setUTCDay(date, value, options);\n      date.setUTCHours(0, 0, 0, 0);\n      return date\n    }\n  },\n\n  // Local day of week\n  e: {\n    priority: 90,\n    parse: function (string, token, match, options) {\n      var valueCallback = function (value) {\n        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;\n        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays\n      };\n\n      switch (token) {\n        // 3\n        case 'e':\n        case 'ee': // 03\n          return parseNDigits(token.length, string, valueCallback)\n        // 3rd\n        case 'eo':\n          return match.ordinalNumber(string, {unit: 'day', valueCallback: valueCallback})\n        // Tue\n        case 'eee':\n          return match.day(string, {width: 'abbreviated', context: 'formatting'}) ||\n            match.day(string, {width: 'short', context: 'formatting'}) ||\n            match.day(string, {width: 'narrow', context: 'formatting'})\n        // T\n        case 'eeeee':\n          return match.day(string, {width: 'narrow', context: 'formatting'})\n        // Tu\n        case 'eeeeee':\n          return match.day(string, {width: 'short', context: 'formatting'}) ||\n          match.day(string, {width: 'narrow', context: 'formatting'})\n        // Tuesday\n        case 'eeee':\n        default:\n          return match.day(string, {width: 'wide', context: 'formatting'}) ||\n            match.day(string, {width: 'abbreviated', context: 'formatting'}) ||\n            match.day(string, {width: 'short', context: 'formatting'}) ||\n            match.day(string, {width: 'narrow', context: 'formatting'})\n      }\n    },\n    validate: function (date, value, options) {\n      return value >= 0 && value <= 6\n    },\n    set: function (date, value, options) {\n      date = setUTCDay(date, value, options);\n      date.setUTCHours(0, 0, 0, 0);\n      return date\n    }\n  },\n\n  // Stand-alone local day of week\n  c: {\n    priority: 90,\n    parse: function (string, token, match, options) {\n      var valueCallback = function (value) {\n        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;\n        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays\n      };\n\n      switch (token) {\n        // 3\n        case 'c':\n        case 'cc': // 03\n          return parseNDigits(token.length, string, valueCallback)\n        // 3rd\n        case 'co':\n          return match.ordinalNumber(string, {unit: 'day', valueCallback: valueCallback})\n        // Tue\n        case 'ccc':\n          return match.day(string, {width: 'abbreviated', context: 'standalone'}) ||\n            match.day(string, {width: 'short', context: 'standalone'}) ||\n            match.day(string, {width: 'narrow', context: 'standalone'})\n        // T\n        case 'ccccc':\n          return match.day(string, {width: 'narrow', context: 'standalone'})\n        // Tu\n        case 'cccccc':\n          return match.day(string, {width: 'short', context: 'standalone'}) ||\n          match.day(string, {width: 'narrow', context: 'standalone'})\n        // Tuesday\n        case 'cccc':\n        default:\n          return match.day(string, {width: 'wide', context: 'standalone'}) ||\n            match.day(string, {width: 'abbreviated', context: 'standalone'}) ||\n            match.day(string, {width: 'short', context: 'standalone'}) ||\n            match.day(string, {width: 'narrow', context: 'standalone'})\n      }\n    },\n    validate: function (date, value, options) {\n      return value >= 0 && value <= 6\n    },\n    set: function (date, value, options) {\n      date = setUTCDay(date, value, options);\n      date.setUTCHours(0, 0, 0, 0);\n      return date\n    }\n  },\n\n  // ISO day of week\n  i: {\n    priority: 90,\n    parse: function (string, token, match, options) {\n      var valueCallback = function (value) {\n        if (value === 0) {\n          return 7\n        }\n        return value\n      };\n\n      switch (token) {\n        // 2\n        case 'i':\n        case 'ii': // 02\n          return parseNDigits(token.length, string)\n        // 2nd\n        case 'io':\n          return match.ordinalNumber(string, {unit: 'day'})\n        // Tue\n        case 'iii':\n          return match.day(string, {width: 'abbreviated', context: 'formatting', valueCallback: valueCallback}) ||\n            match.day(string, {width: 'short', context: 'formatting', valueCallback: valueCallback}) ||\n            match.day(string, {width: 'narrow', context: 'formatting', valueCallback: valueCallback})\n        // T\n        case 'iiiii':\n          return match.day(string, {width: 'narrow', context: 'formatting', valueCallback: valueCallback})\n        // Tu\n        case 'iiiiii':\n          return match.day(string, {width: 'short', context: 'formatting', valueCallback: valueCallback}) ||\n          match.day(string, {width: 'narrow', context: 'formatting', valueCallback: valueCallback})\n        // Tuesday\n        case 'iiii':\n        default:\n          return match.day(string, {width: 'wide', context: 'formatting', valueCallback: valueCallback}) ||\n            match.day(string, {width: 'abbreviated', context: 'formatting', valueCallback: valueCallback}) ||\n            match.day(string, {width: 'short', context: 'formatting', valueCallback: valueCallback}) ||\n            match.day(string, {width: 'narrow', context: 'formatting', valueCallback: valueCallback})\n      }\n    },\n    validate: function (date, value, options) {\n      return value >= 1 && value <= 7\n    },\n    set: function (date, value, options) {\n      date = setUTCISODay(date, value, options);\n      date.setUTCHours(0, 0, 0, 0);\n      return date\n    }\n  },\n\n  // AM or PM\n  a: {\n    priority: 80,\n    parse: function (string, token, match, options) {\n      switch (token) {\n        case 'a':\n        case 'aa':\n        case 'aaa':\n          return match.dayPeriod(string, {width: 'abbreviated', context: 'formatting'}) ||\n            match.dayPeriod(string, {width: 'narrow', context: 'formatting'})\n        case 'aaaaa':\n          return match.dayPeriod(string, {width: 'narrow', context: 'formatting'})\n        case 'aaaa':\n        default:\n          return match.dayPeriod(string, {width: 'wide', context: 'formatting'}) ||\n            match.dayPeriod(string, {width: 'abbreviated', context: 'formatting'}) ||\n            match.dayPeriod(string, {width: 'narrow', context: 'formatting'})\n      }\n    },\n    set: function (date, value, options) {\n      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);\n      return date\n    }\n  },\n\n  // AM, PM, midnight\n  b: {\n    priority: 80,\n    parse: function (string, token, match, options) {\n      switch (token) {\n        case 'b':\n        case 'bb':\n        case 'bbb':\n          return match.dayPeriod(string, {width: 'abbreviated', context: 'formatting'}) ||\n            match.dayPeriod(string, {width: 'narrow', context: 'formatting'})\n        case 'bbbbb':\n          return match.dayPeriod(string, {width: 'narrow', context: 'formatting'})\n        case 'bbbb':\n        default:\n          return match.dayPeriod(string, {width: 'wide', context: 'formatting'}) ||\n            match.dayPeriod(string, {width: 'abbreviated', context: 'formatting'}) ||\n            match.dayPeriod(string, {width: 'narrow', context: 'formatting'})\n      }\n    },\n    set: function (date, value, options) {\n      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);\n      return date\n    }\n  },\n\n  // in the morning, in the afternoon, in the evening, at night\n  B: {\n    priority: 80,\n    parse: function (string, token, match, options) {\n      switch (token) {\n        case 'B':\n        case 'BB':\n        case 'BBB':\n          return match.dayPeriod(string, {width: 'abbreviated', context: 'formatting'}) ||\n            match.dayPeriod(string, {width: 'narrow', context: 'formatting'})\n        case 'BBBBB':\n          return match.dayPeriod(string, {width: 'narrow', context: 'formatting'})\n        case 'BBBB':\n        default:\n          return match.dayPeriod(string, {width: 'wide', context: 'formatting'}) ||\n            match.dayPeriod(string, {width: 'abbreviated', context: 'formatting'}) ||\n            match.dayPeriod(string, {width: 'narrow', context: 'formatting'})\n      }\n    },\n    set: function (date, value, options) {\n      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);\n      return date\n    }\n  },\n\n  // Hour [1-12]\n  h: {\n    priority: 70,\n    parse: function (string, token, match, options) {\n      switch (token) {\n        case 'h':\n          return parseNumericPattern(numericPatterns.hour12h, string)\n        case 'ho':\n          return match.ordinalNumber(string, {unit: 'hour'})\n        default:\n          return parseNDigits(token.length, string)\n      }\n    },\n    validate: function (date, value, options) {\n      return value >= 1 && value <= 12\n    },\n    set: function (date, value, options) {\n      var isPM = date.getUTCHours() >= 12;\n      if (isPM && value < 12) {\n        date.setUTCHours(value + 12, 0, 0, 0);\n      } else if (!isPM && value === 12) {\n        date.setUTCHours(0, 0, 0, 0);\n      } else {\n        date.setUTCHours(value, 0, 0, 0);\n      }\n      return date\n    }\n  },\n\n  // Hour [0-23]\n  H: {\n    priority: 70,\n    parse: function (string, token, match, options) {\n      switch (token) {\n        case 'H':\n          return parseNumericPattern(numericPatterns.hour23h, string)\n        case 'Ho':\n          return match.ordinalNumber(string, {unit: 'hour'})\n        default:\n          return parseNDigits(token.length, string)\n      }\n    },\n    validate: function (date, value, options) {\n      return value >= 0 && value <= 23\n    },\n    set: function (date, value, options) {\n      date.setUTCHours(value, 0, 0, 0);\n      return date\n    }\n  },\n\n  // Hour [0-11]\n  K: {\n    priority: 70,\n    parse: function (string, token, match, options) {\n      switch (token) {\n        case 'K':\n          return parseNumericPattern(numericPatterns.hour11h, string)\n        case 'Ko':\n          return match.ordinalNumber(string, {unit: 'hour'})\n        default:\n          return parseNDigits(token.length, string)\n      }\n    },\n    validate: function (date, value, options) {\n      return value >= 0 && value <= 11\n    },\n    set: function (date, value, options) {\n      var isPM = date.getUTCHours() >= 12;\n      if (isPM && value < 12) {\n        date.setUTCHours(value + 12, 0, 0, 0);\n      } else {\n        date.setUTCHours(value, 0, 0, 0);\n      }\n      return date\n    }\n  },\n\n  // Hour [1-24]\n  k: {\n    priority: 70,\n    parse: function (string, token, match, options) {\n      switch (token) {\n        case 'k':\n          return parseNumericPattern(numericPatterns.hour24h, string)\n        case 'ko':\n          return match.ordinalNumber(string, {unit: 'hour'})\n        default:\n          return parseNDigits(token.length, string)\n      }\n    },\n    validate: function (date, value, options) {\n      return value >= 1 && value <= 24\n    },\n    set: function (date, value, options) {\n      var hours = value <= 24 ? value % 24 : value;\n      date.setUTCHours(hours, 0, 0, 0);\n      return date\n    }\n  },\n\n  // Minute\n  m: {\n    priority: 60,\n    parse: function (string, token, match, options) {\n      switch (token) {\n        case 'm':\n          return parseNumericPattern(numericPatterns.minute, string)\n        case 'mo':\n          return match.ordinalNumber(string, {unit: 'minute'})\n        default:\n          return parseNDigits(token.length, string)\n      }\n    },\n    validate: function (date, value, options) {\n      return value >= 0 && value <= 59\n    },\n    set: function (date, value, options) {\n      date.setUTCMinutes(value, 0, 0);\n      return date\n    }\n  },\n\n  // Second\n  s: {\n    priority: 50,\n    parse: function (string, token, match, options) {\n      switch (token) {\n        case 's':\n          return parseNumericPattern(numericPatterns.second, string)\n        case 'so':\n          return match.ordinalNumber(string, {unit: 'second'})\n        default:\n          return parseNDigits(token.length, string)\n      }\n    },\n    validate: function (date, value, options) {\n      return value >= 0 && value <= 59\n    },\n    set: function (date, value, options) {\n      date.setUTCSeconds(value, 0);\n      return date\n    }\n  },\n\n  // Fraction of second\n  S: {\n    priority: 40,\n    parse: function (string, token, match, options) {\n      var valueCallback = function (value) {\n        return Math.floor(value * Math.pow(10, -token.length + 3))\n      };\n      return parseNDigits(token.length, string, valueCallback)\n    },\n    set: function (date, value, options) {\n      date.setUTCMilliseconds(value);\n      return date\n    }\n  },\n\n  // Timezone (ISO-8601. +00:00 is `'Z'`)\n  X: {\n    priority: 20,\n    parse: function (string, token, match, options) {\n      switch (token) {\n        case 'X':\n          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string)\n        case 'XX':\n          return parseTimezonePattern(timezonePatterns.basic, string)\n        case 'XXXX':\n          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string)\n        case 'XXXXX':\n          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string)\n        case 'XXX':\n        default:\n          return parseTimezonePattern(timezonePatterns.extended, string)\n      }\n    },\n    set: function (date, value, options) {\n      return new Date(date.getTime() - value)\n    }\n  },\n\n  // Timezone (ISO-8601)\n  x: {\n    priority: 20,\n    parse: function (string, token, match, options) {\n      switch (token) {\n        case 'x':\n          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string)\n        case 'xx':\n          return parseTimezonePattern(timezonePatterns.basic, string)\n        case 'xxxx':\n          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string)\n        case 'xxxxx':\n          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string)\n        case 'xxx':\n        default:\n          return parseTimezonePattern(timezonePatterns.extended, string)\n      }\n    },\n    set: function (date, value, options) {\n      return new Date(date.getTime() - value)\n    }\n  },\n\n  // Seconds timestamp\n  t: {\n    priority: 10,\n    parse: function (string, token, match, options) {\n      return parseAnyDigitsSigned(string)\n    },\n    set: function (date, value, options) {\n      return new Date(value * 1000)\n    }\n  },\n\n  // Milliseconds timestamp\n  T: {\n    priority: 10,\n    parse: function (string, token, match, options) {\n      return parseAnyDigitsSigned(string)\n    },\n    set: function (date, value, options) {\n      return new Date(value)\n    }\n  }\n};\n\nvar TIMEZONE_UNIT_PRIORITY = 20;\n\n// This RegExp consists of three parts separated by `|`:\n// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token\n//   (one of the certain letters followed by `o`)\n// - (\\w)\\1* matches any sequences of the same letter\n// - '' matches two quote characters in a row\n// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),\n//   except a single quote symbol, which ends the sequence.\n//   Two quote characters do not end the sequence.\n//   If there is no matching single quote\n//   then the sequence will continue until the end of the string.\n// - . matches any single character unmatched by previous parts of the RegExps\nvar formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\\w)\\1*|''|'(''|[^'])+('|$)|./g;\n\nvar escapedStringRegExp$1 = /^'(.*?)'?$/;\nvar doubleQuoteRegExp$1 = /''/g;\n\nvar notWhitespaceRegExp = /\\S/;\n\n/**\n * @name parse\n * @category Common Helpers\n * @summary Parse the date.\n *\n * @description\n * Return the date parsed from string using the given format string.\n *\n * >  Please note that the `format` tokens differ from Moment.js and other libraries.\n * > See: https://git.io/fxCyr\n *\n * The characters in the format string wrapped between two single quotes characters (') are escaped.\n * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.\n *\n * Format of the format string is based on Unicode Technical Standard #35:\n * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n * with a few additions (see note 5 below the table).\n *\n * Accepted format string patterns:\n * | Unit                            |Prior| Pattern | Result examples                   | Notes |\n * |---------------------------------|-----|---------|-----------------------------------|-------|\n * | Era                             | 140 | G..GGG  | AD, BC                            |       |\n * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |\n * |                                 |     | GGGGG   | A, B                              |       |\n * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |\n * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |\n * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |\n * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |\n * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |\n * |                                 |     | yyyyy   | ...                               | 2,4   |\n * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |\n * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |\n * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |\n * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |\n * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |\n * |                                 |     | YYYYY   | ...                               | 2,4   |\n * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |\n * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |\n * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |\n * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |\n * |                                 |     | RRRRR   | ...                               | 2,4,5 |\n * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |\n * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |\n * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |\n * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |\n * |                                 |     | uuuuu   | ...                               | 2,4   |\n * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |\n * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |\n * |                                 |     | QQ      | 01, 02, 03, 04                    |       |\n * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |\n * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |\n * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |\n * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |\n * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |\n * |                                 |     | qq      | 01, 02, 03, 04                    |       |\n * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |\n * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |\n * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |\n * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |\n * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |\n * |                                 |     | MM      | 01, 02, ..., 12                   |       |\n * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |\n * |                                 |     | MMMM    | January, February, ..., December  | 2     |\n * |                                 |     | MMMMM   | J, F, ..., D                      |       |\n * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |\n * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |\n * |                                 |     | LL      | 01, 02, ..., 12                   |       |\n * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |\n * |                                 |     | LLLL    | January, February, ..., December  | 2     |\n * |                                 |     | LLLLL   | J, F, ..., D                      |       |\n * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |\n * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |\n * |                                 |     | ww      | 01, 02, ..., 53                   |       |\n * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |\n * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |\n * |                                 |     | II      | 01, 02, ..., 53                   | 5     |\n * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |\n * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |\n * |                                 |     | dd      | 01, 02, ..., 31                   |       |\n * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 6     |\n * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |\n * |                                 |     | DD      | 01, 02, ..., 365, 366             | 6     |\n * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |\n * |                                 |     | DDDD    | ...                               | 2     |\n * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Su            |       |\n * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |\n * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |\n * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Su, Sa        |       |\n * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |\n * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |\n * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |\n * |                                 |     | iii     | Mon, Tue, Wed, ..., Su            | 5     |\n * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |\n * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |\n * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Su, Sa        | 5     |\n * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |\n * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |\n * |                                 |     | ee      | 02, 03, ..., 01                   |       |\n * |                                 |     | eee     | Mon, Tue, Wed, ..., Su            |       |\n * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |\n * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |\n * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Su, Sa        |       |\n * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |\n * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |\n * |                                 |     | cc      | 02, 03, ..., 01                   |       |\n * |                                 |     | ccc     | Mon, Tue, Wed, ..., Su            |       |\n * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |\n * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |\n * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Su, Sa        |       |\n * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |\n * |                                 |     | aaaa    | a.m., p.m.                        | 2     |\n * |                                 |     | aaaaa   | a, p                              |       |\n * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |\n * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |\n * |                                 |     | bbbbb   | a, p, n, mi                       |       |\n * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |\n * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |\n * |                                 |     | BBBBB   | at night, in the morning, ...     |       |\n * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |\n * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |\n * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |\n * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |\n * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |\n * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |\n * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |\n * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |\n * |                                 |     | KK      | 1, 2, ..., 11, 0                  |       |\n * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |\n * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |\n * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |\n * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |\n * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |\n * |                                 |     | mm      | 00, 01, ..., 59                   |       |\n * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |\n * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |\n * |                                 |     | ss      | 00, 01, ..., 59                   |       |\n * | Fraction of second              |  40 | S       | 0, 1, ..., 9                      |       |\n * |                                 |     | SS      | 00, 01, ..., 99                   |       |\n * |                                 |     | SSS     | 000, 0001, ..., 999               |       |\n * |                                 |     | SSSS    | ...                               | 2     |\n * | Timezone (ISO-8601 w/ Z)        |  20 | X       | -08, +0530, Z                     |       |\n * |                                 |     | XX      | -0800, +0530, Z                   |       |\n * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |\n * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |\n * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |\n * | Timezone (ISO-8601 w/o Z)       |  20 | x       | -08, +0530, +00                   |       |\n * |                                 |     | xx      | -0800, +0530, +0000               |       |\n * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |\n * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |\n * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |\n * | Seconds timestamp               |  10 | t       | 512969520                         |       |\n * |                                 |     | tt      | ...                               | 2     |\n * | Milliseconds timestamp          |  10 | T       | 512969520900                      |       |\n * |                                 |     | TT      | ...                               | 2     |\n * Notes:\n * 1. \"Formatting\" units (e.g. formatting quarter) in the default en-US locale\n *    are the same as \"stand-alone\" units, but are different in some languages.\n *    \"Formatting\" units are declined according to the rules of the language\n *    in the context of a date. \"Stand-alone\" units are always nominative singular.\n *    In `format` function, they will produce different result:\n *\n *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`\n *\n *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`\n *\n *    `parse` will try to match both formatting and stand-alone units interchangably.\n *\n * 2. Any sequence of the identical letters is a pattern, unless it is escaped by\n *    the single quote characters (see below).\n *    If the sequence is longer than listed in table:\n *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number\n *      as wide as the sequence\n *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.\n *      These variations are marked with \"2\" in the last column of the table.\n *\n * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.\n *    These tokens represent the shortest form of the quarter.\n *\n * 4. The main difference between `y` and `u` patterns are B.C. years:\n *\n *    | Year | `y` | `u` |\n *    |------|-----|-----|\n *    | AC 1 |   1 |   1 |\n *    | BC 1 |   1 |   0 |\n *    | BC 2 |   2 |  -1 |\n *\n *    Also `yy` will try to guess the century of two digit year by proximity with `baseDate`:\n *\n *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`\n *\n *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`\n *\n *    while `uu` will just assign the year as is:\n *\n *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`\n *\n *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`\n *\n *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),\n *    except local week-numbering years are dependent on `options.weekStartsOn`\n *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}\n *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).\n *\n * 5. These patterns are not in the Unicode Technical Standard #35:\n *    - `i`: ISO day of week\n *    - `I`: ISO week of year\n *    - `R`: ISO week-numbering year\n *    - `o`: ordinal number modifier\n *\n * 6. These tokens are often confused with others. See: https://git.io/fxCyr\n *\n * Values will be assigned to the date in the descending order of its unit's priority.\n * Units of an equal priority overwrite each other in the order of appearance.\n *\n * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),\n * the values will be taken from 3rd argument `baseDate` which works as a context of parsing.\n *\n * `baseDate` must be passed for correct work of the function.\n * If you're not sure which `baseDate` to supply, create a new instance of Date:\n * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`\n * In this case parsing will be done in the context of the current date.\n * If `baseDate` is `Invalid Date` or a value not convertible to valid `Date`,\n * then `Invalid Date` will be returned.\n *\n * The result may vary by locale.\n *\n * If `formatString` matches with `dateString` but does not provides tokens, `baseDate` will be returned.\n *\n * If parsing failed, `Invalid Date` will be returned.\n * Invalid Date is a Date, whose time value is NaN.\n * Time value of Date: http://es5.github.io/#x15.9.1.1\n *\n * @param {String} dateString - the string to parse\n * @param {String} formatString - the string of tokens\n * @param {Date|String|Number} baseDate - defines values missing from the parsed dateString\n * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}\n * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}\n * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}\n * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)\n * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year\n * @param {Boolean} [options.awareOfUnicodeTokens=false] - if true, allows usage of Unicode tokens causes confusion:\n *   - Some of the day of year tokens (`D`, `DD`) that are confused with the day of month tokens (`d`, `dd`).\n *   - Some of the local week-numbering year tokens (`YY`, `YYYY`) that are confused with the calendar year tokens (`yy`, `yyyy`).\n *   See: https://git.io/fxCyr\n * @returns {Date} the parsed date\n * @throws {TypeError} 3 arguments required\n * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2\n * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6\n * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7\n * @throws {RangeError} `options.locale` must contain `match` property\n * @throws {RangeError} `options.awareOfUnicodeTokens` must be set to `true` to use `XX` token; see: https://git.io/fxCyr\n *\n * @example\n * // Parse 11 February 2014 from middle-endian format:\n * var result = parse(\n *   '02/11/2014',\n *   'MM/dd/yyyy',\n *   new Date()\n * )\n * //=> Tue Feb 11 2014 00:00:00\n *\n * @example\n * // Parse 28th of February in Esperanto locale in the context of 2010 year:\n * import eo from 'date-fns/locale/eo'\n * var result = parse(\n *   '28-a de februaro',\n *   \"do 'de' MMMM\",\n *   new Date(2010, 0, 1),\n *   {locale: eo}\n * )\n * //=> Sun Feb 28 2010 00:00:00\n */\nfunction parse(\n  dirtyDateString,\n  dirtyFormatString,\n  dirtyBaseDate,\n  dirtyOptions\n) {\n  if (arguments.length < 3) {\n    throw new TypeError(\n      '3 arguments required, but only ' + arguments.length + ' present'\n    )\n  }\n\n  var dateString = String(dirtyDateString);\n  var formatString = String(dirtyFormatString);\n  var options = dirtyOptions || {};\n\n  var locale = options.locale || locale$1;\n\n  if (!locale.match) {\n    throw new RangeError('locale must contain match property')\n  }\n\n  var localeFirstWeekContainsDate =\n    locale.options && locale.options.firstWeekContainsDate;\n  var defaultFirstWeekContainsDate =\n    localeFirstWeekContainsDate == null\n      ? 1\n      : toInteger(localeFirstWeekContainsDate);\n  var firstWeekContainsDate =\n    options.firstWeekContainsDate == null\n      ? defaultFirstWeekContainsDate\n      : toInteger(options.firstWeekContainsDate);\n\n  // Test if weekStartsOn is between 1 and 7 _and_ is not NaN\n  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {\n    throw new RangeError(\n      'firstWeekContainsDate must be between 1 and 7 inclusively'\n    )\n  }\n\n  var localeWeekStartsOn = locale.options && locale.options.weekStartsOn;\n  var defaultWeekStartsOn =\n    localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);\n  var weekStartsOn =\n    options.weekStartsOn == null\n      ? defaultWeekStartsOn\n      : toInteger(options.weekStartsOn);\n\n  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN\n  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {\n    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively')\n  }\n\n  if (formatString === '') {\n    if (dateString === '') {\n      return toDate(dirtyBaseDate, options)\n    } else {\n      return new Date(NaN)\n    }\n  }\n\n  var subFnOptions = {\n    firstWeekContainsDate: firstWeekContainsDate,\n    weekStartsOn: weekStartsOn,\n    locale: locale\n  };\n\n  // If timezone isn't specified, it will be set to the system timezone\n  var setters = [\n    {\n      priority: TIMEZONE_UNIT_PRIORITY,\n      set: dateToSystemTimezone,\n      index: 0\n    }\n  ];\n\n  var i;\n\n  var tokens = formatString.match(formattingTokensRegExp$1);\n\n  for (i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (!options.awareOfUnicodeTokens && isProtectedToken(token)) {\n      throwProtectedError(token);\n    }\n\n    var firstCharacter = token[0];\n    var parser = parsers[firstCharacter];\n    if (parser) {\n      var parseResult = parser.parse(\n        dateString,\n        token,\n        locale.match,\n        subFnOptions\n      );\n\n      if (!parseResult) {\n        return new Date(NaN)\n      }\n\n      setters.push({\n        priority: parser.priority,\n        set: parser.set,\n        validate: parser.validate,\n        value: parseResult.value,\n        index: setters.length\n      });\n\n      dateString = parseResult.rest;\n    } else {\n      // Replace two single quote characters with one single quote character\n      if (token === \"''\") {\n        token = \"'\";\n      } else if (firstCharacter === \"'\") {\n        token = cleanEscapedString$1(token);\n      }\n\n      // Cut token from string, or, if string doesn't match the token, return Invalid Date\n      if (dateString.indexOf(token) === 0) {\n        dateString = dateString.slice(token.length);\n      } else {\n        return new Date(NaN)\n      }\n    }\n  }\n\n  // Check if the remaining input contains something other than whitespace\n  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {\n    return new Date(NaN)\n  }\n\n  var uniquePrioritySetters = setters\n    .map(function(setter) {\n      return setter.priority\n    })\n    .sort(function(a, b) {\n      return b - a\n    })\n    .filter(function(priority, index, array) {\n      return array.indexOf(priority) === index\n    })\n    .map(function(priority) {\n      return setters\n        .filter(function(setter) {\n          return setter.priority === priority\n        })\n        .reverse()\n    })\n    .map(function(setterArray) {\n      return setterArray[0]\n    });\n\n  var date = toDate(dirtyBaseDate, options);\n\n  if (isNaN(date)) {\n    return new Date(NaN)\n  }\n\n  // Convert the date in system timezone to the same date in UTC+00:00 timezone.\n  // This ensures that when UTC functions will be implemented, locales will be compatible with them.\n  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/37\n  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));\n\n  for (i = 0; i < uniquePrioritySetters.length; i++) {\n    var setter = uniquePrioritySetters[i];\n\n    if (\n      setter.validate &&\n      !setter.validate(utcDate, setter.value, subFnOptions)\n    ) {\n      return new Date(NaN)\n    }\n\n    utcDate = setter.set(utcDate, setter.value, subFnOptions);\n  }\n\n  return utcDate\n}\n\nfunction dateToSystemTimezone(date) {\n  var convertedDate = new Date(0);\n  convertedDate.setFullYear(\n    date.getUTCFullYear(),\n    date.getUTCMonth(),\n    date.getUTCDate()\n  );\n  convertedDate.setHours(\n    date.getUTCHours(),\n    date.getUTCMinutes(),\n    date.getUTCSeconds(),\n    date.getUTCMilliseconds()\n  );\n  return convertedDate\n}\n\nfunction cleanEscapedString$1(input) {\n  return input.match(escapedStringRegExp$1)[1].replace(doubleQuoteRegExp$1, \"'\")\n}\n\n// This file is generated automatically by `scripts/build/indices.js`. Please, don't change it.\n\n// \n\n/**\n * Custom parse behavior on top of date-fns parse function.\n */\nfunction parseDate$1 (date, format$1) {\n  if (typeof date !== 'string') {\n    return isValid(date) ? date : null;\n  }\n\n  var parsed = parse(date, format$1, new Date());\n\n  // if date is not valid or the formatted output after parsing does not match\n  // the string value passed in (avoids overflows)\n  if (!isValid(parsed) || format(parsed, format$1) !== date) {\n    return null;\n  }\n\n  return parsed;\n}\n\nvar afterValidator = function (value, ref) {\n  if ( ref === void 0 ) ref = {};\n  var targetValue = ref.targetValue;\n  var inclusion = ref.inclusion; if ( inclusion === void 0 ) inclusion = false;\n  var format = ref.format;\n\n  if (typeof format === 'undefined') {\n    format = inclusion;\n    inclusion = false;\n  }\n\n  value = parseDate$1(value, format);\n  targetValue = parseDate$1(targetValue, format);\n\n  // if either is not valid.\n  if (!value || !targetValue) {\n    return false;\n  }\n\n  return isAfter(value, targetValue) || (inclusion && isEqual$1(value, targetValue));\n};\n\nvar options = {\n  hasTarget: true,\n  isDate: true\n};\n\n// required to convert from a list of array values to an object.\nvar paramNames = ['targetValue', 'inclusion', 'format'];\n\nvar after = {\n  validate: afterValidator,\n  options: options,\n  paramNames: paramNames\n};\n\n/**\n * Some Alpha Regex helpers.\n * https://github.com/chriso/validator.js/blob/master/src/lib/alpha.js\n */\n\nvar alpha = {\n  en: /^[A-Z]*$/i,\n  cs: /^[A-Z]*$/i,\n  da: /^[A-Z]*$/i,\n  de: /^[A-Z]*$/i,\n  es: /^[A-Z]*$/i,\n  fr: /^[A-Z]*$/i,\n  it: /^[A-Z\\xC0-\\xFF]*$/i,\n  lt: /^[A-Z]*$/i,\n  nl: /^[A-Z]*$/i,\n  hu: /^[A-Z]*$/i,\n  pl: /^[A-Z]*$/i,\n  pt: /^[A-Z]*$/i,\n  ru: /^[-]*$/i,\n  sk: /^[A-Z]*$/i,\n  sr: /^[A-Z]*$/i,\n  sv: /^[A-Z]*$/i,\n  tr: /^[A-Z]*$/i,\n  uk: /^[-]*$/i,\n  ar: /^[]*$/,\n  az: /^[A-Z]*$/i\n};\n\nvar alphaSpaces = {\n  en: /^[A-Z\\s]*$/i,\n  cs: /^[A-Z\\s]*$/i,\n  da: /^[A-Z\\s]*$/i,\n  de: /^[A-Z\\s]*$/i,\n  es: /^[A-Z\\s]*$/i,\n  fr: /^[A-Z\\s]*$/i,\n  it: /^[A-Z\\xC0-\\xFF\\s]*$/i,\n  lt: /^[A-Z\\s]*$/i,\n  nl: /^[A-Z\\s]*$/i,\n  hu: /^[A-Z\\s]*$/i,\n  pl: /^[A-Z\\s]*$/i,\n  pt: /^[A-Z\\s]*$/i,\n  ru: /^[-\\s]*$/i,\n  sk: /^[A-Z\\s]*$/i,\n  sr: /^[A-Z\\s]*$/i,\n  sv: /^[A-Z\\s]*$/i,\n  tr: /^[A-Z\\s]*$/i,\n  uk: /^[-\\s]*$/i,\n  ar: /^[\\s]*$/,\n  az: /^[A-Z\\s]*$/i\n};\n\nvar alphanumeric = {\n  en: /^[0-9A-Z]*$/i,\n  cs: /^[0-9A-Z]*$/i,\n  da: /^[0-9A-Z]$/i,\n  de: /^[0-9A-Z]*$/i,\n  es: /^[0-9A-Z]*$/i,\n  fr: /^[0-9A-Z]*$/i,\n  it: /^[0-9A-Z\\xC0-\\xFF]*$/i,\n  lt: /^[0-9A-Z]*$/i,\n  hu: /^[0-9A-Z]*$/i,\n  nl: /^[0-9A-Z]*$/i,\n  pl: /^[0-9A-Z]*$/i,\n  pt: /^[0-9A-Z]*$/i,\n  ru: /^[0-9-]*$/i,\n  sk: /^[0-9A-Z]*$/i,\n  sr: /^[0-9A-Z]*$/i,\n  sv: /^[0-9A-Z]*$/i,\n  tr: /^[0-9A-Z]*$/i,\n  uk: /^[0-9-]*$/i,\n  ar: /^[0-9]*$/,\n  az: /^[0-9A-Z]*$/i\n};\n\nvar alphaDash = {\n  en: /^[0-9A-Z_-]*$/i,\n  cs: /^[0-9A-Z_-]*$/i,\n  da: /^[0-9A-Z_-]*$/i,\n  de: /^[0-9A-Z_-]*$/i,\n  es: /^[0-9A-Z_-]*$/i,\n  fr: /^[0-9A-Z_-]*$/i,\n  it: /^[0-9A-Z\\xC0-\\xFF_-]*$/i,\n  lt: /^[0-9A-Z_-]*$/i,\n  nl: /^[0-9A-Z_-]*$/i,\n  hu: /^[0-9A-Z_-]*$/i,\n  pl: /^[0-9A-Z_-]*$/i,\n  pt: /^[0-9A-Z_-]*$/i,\n  ru: /^[0-9-_-]*$/i,\n  sk: /^[0-9A-Z_-]*$/i,\n  sr: /^[0-9A-Z_-]*$/i,\n  sv: /^[0-9A-Z_-]*$/i,\n  tr: /^[0-9A-Z_-]*$/i,\n  uk: /^[0-9-_-]*$/i,\n  ar: /^[0-9_-]*$/,\n  az: /^[0-9A-Z_-]*$/i\n};\n\nvar validate = function (value, ref) {\n  if ( ref === void 0 ) ref = {};\n  var locale = ref.locale;\n\n  if (Array.isArray(value)) {\n    return value.every(function (val) { return validate(val, [locale]); });\n  }\n\n  // Match at least one locale.\n  if (! locale) {\n    return Object.keys(alpha).some(function (loc) { return alpha[loc].test(value); });\n  }\n\n  return (alpha[locale] || alpha.en).test(value);\n};\n\nvar paramNames$1 = ['locale'];\n\nvar alpha$1 = {\n  validate: validate,\n  paramNames: paramNames$1\n};\n\nvar validate$1 = function (value, ref) {\n  if ( ref === void 0 ) ref = {};\n  var locale = ref.locale;\n\n  if (Array.isArray(value)) {\n    return value.every(function (val) { return validate$1(val, [locale]); });\n  }\n\n  // Match at least one locale.\n  if (! locale) {\n    return Object.keys(alphaDash).some(function (loc) { return alphaDash[loc].test(value); });\n  }\n\n  return (alphaDash[locale] || alphaDash.en).test(value);\n};\n\nvar paramNames$2 = ['locale'];\n\nvar alpha_dash = {\n  validate: validate$1,\n  paramNames: paramNames$2\n};\n\nvar validate$2 = function (value, ref) {\n  if ( ref === void 0 ) ref = {};\n  var locale = ref.locale;\n\n  if (Array.isArray(value)) {\n    return value.every(function (val) { return validate$2(val, [locale]); });\n  }\n\n  // Match at least one locale.\n  if (! locale) {\n    return Object.keys(alphanumeric).some(function (loc) { return alphanumeric[loc].test(value); });\n  }\n\n  return (alphanumeric[locale] || alphanumeric.en).test(value);\n};\n\nvar paramNames$3 = ['locale'];\n\nvar alpha_num = {\n  validate: validate$2,\n  paramNames: paramNames$3\n};\n\nvar validate$3 = function (value, ref) {\n  if ( ref === void 0 ) ref = {};\n  var locale = ref.locale;\n\n  if (Array.isArray(value)) {\n    return value.every(function (val) { return validate$3(val, [locale]); });\n  }\n\n  // Match at least one locale.\n  if (! locale) {\n    return Object.keys(alphaSpaces).some(function (loc) { return alphaSpaces[loc].test(value); });\n  }\n\n  return (alphaSpaces[locale] || alphaSpaces.en).test(value);\n};\n\nvar paramNames$4 = ['locale'];\n\nvar alpha_spaces = {\n  validate: validate$3,\n  paramNames: paramNames$4\n};\n\nvar validate$4 = function (value, ref) {\n  if ( ref === void 0 ) ref = {};\n  var targetValue = ref.targetValue;\n  var inclusion = ref.inclusion; if ( inclusion === void 0 ) inclusion = false;\n  var format = ref.format;\n\n  if (typeof format === 'undefined') {\n    format = inclusion;\n    inclusion = false;\n  }\n\n  value = parseDate$1(value, format);\n  targetValue = parseDate$1(targetValue, format);\n\n  // if either is not valid.\n  if (!value || !targetValue) {\n    return false;\n  }\n\n  return isBefore(value, targetValue) || (inclusion && isEqual$1(value, targetValue));\n};\n\nvar options$1 = {\n  hasTarget: true,\n  isDate: true\n};\n\nvar paramNames$5 = ['targetValue', 'inclusion', 'format'];\n\nvar before = {\n  validate: validate$4,\n  options: options$1,\n  paramNames: paramNames$5\n};\n\nvar validate$5 = function (value, ref) {\n  if ( ref === void 0 ) ref = {};\n  var min = ref.min;\n  var max = ref.max;\n\n  if (Array.isArray(value)) {\n    return value.every(function (val) { return validate$5(val, { min: min, max: max }); });\n  }\n\n  return Number(min) <= value && Number(max) >= value;\n};\n\nvar paramNames$6 = ['min', 'max'];\n\nvar between = {\n  validate: validate$5,\n  paramNames: paramNames$6\n};\n\nvar validate$6 = function (value, ref) {\n  var targetValue = ref.targetValue;\n\n  return String(value) === String(targetValue);\n};\nvar options$2 = {\n  hasTarget: true\n};\n\nvar paramNames$7 = ['targetValue'];\n\nvar confirmed = {\n  validate: validate$6,\n  options: options$2,\n  paramNames: paramNames$7\n};\n\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar assertString_1 = createCommonjsModule(function (module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = assertString;\nfunction assertString(input) {\n  var isString = typeof input === 'string' || input instanceof String;\n\n  if (!isString) {\n    var invalidType = void 0;\n    if (input === null) {\n      invalidType = 'null';\n    } else {\n      invalidType = typeof input === 'undefined' ? 'undefined' : _typeof(input);\n      if (invalidType === 'object' && input.constructor && input.constructor.hasOwnProperty('name')) {\n        invalidType = input.constructor.name;\n      } else {\n        invalidType = 'a ' + invalidType;\n      }\n    }\n    throw new TypeError('Expected string but received ' + invalidType + '.');\n  }\n}\nmodule.exports = exports['default'];\n});\n\nunwrapExports(assertString_1);\n\nvar isCreditCard_1 = createCommonjsModule(function (module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isCreditCard;\n\n\n\nvar _assertString2 = _interopRequireDefault(assertString_1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint-disable max-len */\nvar creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11}|6[27][0-9]{14})$/;\n/* eslint-enable max-len */\n\nfunction isCreditCard(str) {\n  (0, _assertString2.default)(str);\n  var sanitized = str.replace(/[- ]+/g, '');\n  if (!creditCard.test(sanitized)) {\n    return false;\n  }\n  var sum = 0;\n  var digit = void 0;\n  var tmpNum = void 0;\n  var shouldDouble = void 0;\n  for (var i = sanitized.length - 1; i >= 0; i--) {\n    digit = sanitized.substring(i, i + 1);\n    tmpNum = parseInt(digit, 10);\n    if (shouldDouble) {\n      tmpNum *= 2;\n      if (tmpNum >= 10) {\n        sum += tmpNum % 10 + 1;\n      } else {\n        sum += tmpNum;\n      }\n    } else {\n      sum += tmpNum;\n    }\n    shouldDouble = !shouldDouble;\n  }\n  return !!(sum % 10 === 0 ? sanitized : false);\n}\nmodule.exports = exports['default'];\n});\n\nvar isCreditCard = unwrapExports(isCreditCard_1);\n\nvar validate$7 = function (value) { return isCreditCard(String(value)); };\n\nvar credit_card = {\n  validate: validate$7\n};\n\nvar validate$8 = function (value, ref) {\n  if ( ref === void 0 ) ref = {};\n  var min = ref.min;\n  var max = ref.max;\n  var inclusivity = ref.inclusivity; if ( inclusivity === void 0 ) inclusivity = '()';\n  var format = ref.format;\n\n  if (typeof format === 'undefined') {\n    format = inclusivity;\n    inclusivity = '()';\n  }\n\n  var minDate = parseDate$1(String(min), format);\n  var maxDate = parseDate$1(String(max), format);\n  var dateVal = parseDate$1(String(value), format);\n\n  if (!minDate || !maxDate || !dateVal) {\n    return false;\n  }\n\n  if (inclusivity === '()') {\n    return isAfter(dateVal, minDate) && isBefore(dateVal, maxDate);\n  }\n\n  if (inclusivity === '(]') {\n    return isAfter(dateVal, minDate) && (isEqual$1(dateVal, maxDate) || isBefore(dateVal, maxDate));\n  }\n\n  if (inclusivity === '[)') {\n    return isBefore(dateVal, maxDate) && (isEqual$1(dateVal, minDate) || isAfter(dateVal, minDate));\n  }\n\n  return isEqual$1(dateVal, maxDate) || isEqual$1(dateVal, minDate) ||\n    (isBefore(dateVal, maxDate) && isAfter(dateVal, minDate));\n};\n\nvar options$3 = {\n  isDate: true\n};\n\nvar paramNames$8 = ['min', 'max', 'inclusivity', 'format'];\n\nvar date_between = {\n  validate: validate$8,\n  options: options$3,\n  paramNames: paramNames$8\n};\n\nvar validate$9 = function (value, ref) {\n  var format = ref.format;\n\n  return !!parseDate$1(value, format);\n};\n\nvar options$4 = {\n  isDate: true\n};\n\nvar paramNames$9 = ['format'];\n\nvar date_format = {\n  validate: validate$9,\n  options: options$4,\n  paramNames: paramNames$9\n};\n\nvar validate$a = function (value, ref) {\n  if ( ref === void 0 ) ref = {};\n  var decimals = ref.decimals; if ( decimals === void 0 ) decimals = '*';\n  var separator = ref.separator; if ( separator === void 0 ) separator = '.';\n\n  if (isNullOrUndefined(value) || value === '') {\n    return false;\n  }\n\n  if (Array.isArray(value)) {\n    return value.every(function (val) { return validate$a(val, { decimals: decimals, separator: separator }); });\n  }\n\n  // if is 0.\n  if (Number(decimals) === 0) {\n    return /^-?\\d*$/.test(value);\n  }\n\n  var regexPart = decimals === '*' ? '+' : (\"{1,\" + decimals + \"}\");\n  var regex = new RegExp((\"^[-+]?\\\\d*(\\\\\" + separator + \"\\\\d\" + regexPart + \")?([eE]{1}[-]?\\\\d+)?$\"));\n\n  if (! regex.test(value)) {\n    return false;\n  }\n\n  var parsedValue = parseFloat(value);\n\n  // eslint-disable-next-line\n  return parsedValue === parsedValue;\n};\n\nvar paramNames$a = ['decimals', 'separator'];\n\nvar decimal = {\n  validate: validate$a,\n  paramNames: paramNames$a\n};\n\nvar validate$b = function (value, ref) {\n  var length = ref[0];\n\n  if (Array.isArray(value)) {\n    return value.every(function (val) { return validate$b(val, [length]); });\n  }\n  var strVal = String(value);\n\n  return /^[0-9]*$/.test(strVal) && strVal.length === Number(length);\n};\n\nvar digits = {\n  validate: validate$b\n};\n\nvar imageRegex = /\\.(jpg|svg|jpeg|png|bmp|gif)$/i;\n\nvar validateImage = function (file, width, height) {\n  var URL = window.URL || window.webkitURL;\n  return new Promise(function (resolve) {\n    var image = new Image();\n    image.onerror = function () { return resolve({ valid: false }); };\n    image.onload = function () { return resolve({\n      valid: image.width === Number(width) && image.height === Number(height)\n    }); };\n\n    image.src = URL.createObjectURL(file);\n  });\n};\n\nvar validate$c = function (files, ref) {\n  var width = ref[0];\n  var height = ref[1];\n\n  var images = ensureArray(files).filter(function (file) { return imageRegex.test(file.name); });\n  if (images.length === 0) {\n    return false;\n  }\n  return Promise.all(images.map(function (image) { return validateImage(image, width, height); }));\n};\n\nvar dimensions = {\n  validate: validate$c\n};\n\nvar merge_1 = createCommonjsModule(function (module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = merge;\nfunction merge() {\n  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var defaults = arguments[1];\n\n  for (var key in defaults) {\n    if (typeof obj[key] === 'undefined') {\n      obj[key] = defaults[key];\n    }\n  }\n  return obj;\n}\nmodule.exports = exports['default'];\n});\n\nunwrapExports(merge_1);\n\nvar isByteLength_1 = createCommonjsModule(function (module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = isByteLength;\n\n\n\nvar _assertString2 = _interopRequireDefault(assertString_1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint-disable prefer-rest-params */\nfunction isByteLength(str, options) {\n  (0, _assertString2.default)(str);\n  var min = void 0;\n  var max = void 0;\n  if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n    min = options.min || 0;\n    max = options.max;\n  } else {\n    // backwards compatibility: isByteLength(str, min [, max])\n    min = arguments[1];\n    max = arguments[2];\n  }\n  var len = encodeURI(str).split(/%..|./).length - 1;\n  return len >= min && (typeof max === 'undefined' || len <= max);\n}\nmodule.exports = exports['default'];\n});\n\nunwrapExports(isByteLength_1);\n\nvar isFQDN_1 = createCommonjsModule(function (module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isFQDN;\n\n\n\nvar _assertString2 = _interopRequireDefault(assertString_1);\n\n\n\nvar _merge2 = _interopRequireDefault(merge_1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar default_fqdn_options = {\n  require_tld: true,\n  allow_underscores: false,\n  allow_trailing_dot: false\n};\n\nfunction isFQDN(str, options) {\n  (0, _assertString2.default)(str);\n  options = (0, _merge2.default)(options, default_fqdn_options);\n\n  /* Remove the optional trailing dot before checking validity */\n  if (options.allow_trailing_dot && str[str.length - 1] === '.') {\n    str = str.substring(0, str.length - 1);\n  }\n  var parts = str.split('.');\n  for (var i = 0; i < parts.length; i++) {\n    if (parts[i].length > 63) {\n      return false;\n    }\n  }\n  if (options.require_tld) {\n    var tld = parts.pop();\n    if (!parts.length || !/^([a-z\\u00a1-\\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {\n      return false;\n    }\n    // disallow spaces\n    if (/[\\s\\u2002-\\u200B\\u202F\\u205F\\u3000\\uFEFF\\uDB40\\uDC20]/.test(tld)) {\n      return false;\n    }\n  }\n  for (var part, _i = 0; _i < parts.length; _i++) {\n    part = parts[_i];\n    if (options.allow_underscores) {\n      part = part.replace(/_/g, '');\n    }\n    if (!/^[a-z\\u00a1-\\uffff0-9-]+$/i.test(part)) {\n      return false;\n    }\n    // disallow full-width chars\n    if (/[\\uff01-\\uff5e]/.test(part)) {\n      return false;\n    }\n    if (part[0] === '-' || part[part.length - 1] === '-') {\n      return false;\n    }\n  }\n  return true;\n}\nmodule.exports = exports['default'];\n});\n\nvar isFQDN = unwrapExports(isFQDN_1);\n\nvar isIP_1 = createCommonjsModule(function (module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isIP;\n\n\n\nvar _assertString2 = _interopRequireDefault(assertString_1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ipv4Maybe = /^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$/;\nvar ipv6Block = /^[0-9A-F]{1,4}$/i;\n\nfunction isIP(str) {\n  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  (0, _assertString2.default)(str);\n  version = String(version);\n  if (!version) {\n    return isIP(str, 4) || isIP(str, 6);\n  } else if (version === '4') {\n    if (!ipv4Maybe.test(str)) {\n      return false;\n    }\n    var parts = str.split('.').sort(function (a, b) {\n      return a - b;\n    });\n    return parts[3] <= 255;\n  } else if (version === '6') {\n    var blocks = str.split(':');\n    var foundOmissionBlock = false; // marker to indicate ::\n\n    // At least some OS accept the last 32 bits of an IPv6 address\n    // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says\n    // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,\n    // and '::a.b.c.d' is deprecated, but also valid.\n    var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);\n    var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;\n\n    if (blocks.length > expectedNumberOfBlocks) {\n      return false;\n    }\n    // initial or final ::\n    if (str === '::') {\n      return true;\n    } else if (str.substr(0, 2) === '::') {\n      blocks.shift();\n      blocks.shift();\n      foundOmissionBlock = true;\n    } else if (str.substr(str.length - 2) === '::') {\n      blocks.pop();\n      blocks.pop();\n      foundOmissionBlock = true;\n    }\n\n    for (var i = 0; i < blocks.length; ++i) {\n      // test for a :: which can not be at the string start/end\n      // since those cases have been handled above\n      if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {\n        if (foundOmissionBlock) {\n          return false; // multiple :: in address\n        }\n        foundOmissionBlock = true;\n      } else if (foundIPv4TransitionBlock && i === blocks.length - 1) ; else if (!ipv6Block.test(blocks[i])) {\n        return false;\n      }\n    }\n    if (foundOmissionBlock) {\n      return blocks.length >= 1;\n    }\n    return blocks.length === expectedNumberOfBlocks;\n  }\n  return false;\n}\nmodule.exports = exports['default'];\n});\n\nvar isIP = unwrapExports(isIP_1);\n\nvar isEmail_1 = createCommonjsModule(function (module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isEmail;\n\n\n\nvar _assertString2 = _interopRequireDefault(assertString_1);\n\n\n\nvar _merge2 = _interopRequireDefault(merge_1);\n\n\n\nvar _isByteLength2 = _interopRequireDefault(isByteLength_1);\n\n\n\nvar _isFQDN2 = _interopRequireDefault(isFQDN_1);\n\n\n\nvar _isIP2 = _interopRequireDefault(isIP_1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar default_email_options = {\n  allow_display_name: false,\n  require_display_name: false,\n  allow_utf8_local_part: true,\n  require_tld: true\n};\n\n/* eslint-disable max-len */\n/* eslint-disable no-control-regex */\nvar displayName = /^[a-z\\d!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~\\.\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+[a-z\\d!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~\\,\\.\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF\\s]*<(.+)>$/i;\nvar emailUserPart = /^[a-z\\d!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]+$/i;\nvar gmailUserPart = /^[a-z\\d]+$/;\nvar quotedEmailUser = /^([\\s\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f\\x21\\x23-\\x5b\\x5d-\\x7e]|(\\\\[\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]))*$/i;\nvar emailUserUtf8Part = /^[a-z\\d!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+$/i;\nvar quotedEmailUserUtf8 = /^([\\s\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f\\x21\\x23-\\x5b\\x5d-\\x7e\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]|(\\\\[\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))*$/i;\n/* eslint-enable max-len */\n/* eslint-enable no-control-regex */\n\nfunction isEmail(str, options) {\n  (0, _assertString2.default)(str);\n  options = (0, _merge2.default)(options, default_email_options);\n\n  if (options.require_display_name || options.allow_display_name) {\n    var display_email = str.match(displayName);\n    if (display_email) {\n      str = display_email[1];\n    } else if (options.require_display_name) {\n      return false;\n    }\n  }\n\n  var parts = str.split('@');\n  var domain = parts.pop();\n  var user = parts.join('@');\n\n  var lower_domain = domain.toLowerCase();\n\n  if (options.domain_specific_validation && (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com')) {\n    /*\n      Previously we removed dots for gmail addresses before validating.\n      This was removed because it allows `multiple..dots@gmail.com`\n      to be reported as valid, but it is not.\n      Gmail only normalizes single dots, removing them from here is pointless,\n      should be done in normalizeEmail\n    */\n    user = user.toLowerCase();\n\n    // Removing sub-address from username before gmail validation\n    var username = user.split('+')[0];\n\n    // Dots are not included in gmail length restriction\n    if (!(0, _isByteLength2.default)(username.replace('.', ''), { min: 6, max: 30 })) {\n      return false;\n    }\n\n    var _user_parts = username.split('.');\n    for (var i = 0; i < _user_parts.length; i++) {\n      if (!gmailUserPart.test(_user_parts[i])) {\n        return false;\n      }\n    }\n  }\n\n  if (!(0, _isByteLength2.default)(user, { max: 64 }) || !(0, _isByteLength2.default)(domain, { max: 254 })) {\n    return false;\n  }\n\n  if (!(0, _isFQDN2.default)(domain, { require_tld: options.require_tld })) {\n    if (!options.allow_ip_domain) {\n      return false;\n    }\n\n    if (!(0, _isIP2.default)(domain)) {\n      if (!domain.startsWith('[') || !domain.endsWith(']')) {\n        return false;\n      }\n\n      var noBracketdomain = domain.substr(1, domain.length - 2);\n\n      if (noBracketdomain.length === 0 || !(0, _isIP2.default)(noBracketdomain)) {\n        return false;\n      }\n    }\n  }\n\n  if (user[0] === '\"') {\n    user = user.slice(1, user.length - 1);\n    return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);\n  }\n\n  var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;\n\n  var user_parts = user.split('.');\n  for (var _i = 0; _i < user_parts.length; _i++) {\n    if (!pattern.test(user_parts[_i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\nmodule.exports = exports['default'];\n});\n\nvar isEmail = unwrapExports(isEmail_1);\n\nfunction objectWithoutProperties (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }\n\nvar validate$d = function (value, ref) {\n  if ( ref === void 0 ) ref = {};\n  var multiple = ref.multiple; if ( multiple === void 0 ) multiple = false;\n  var rest = objectWithoutProperties( ref, [\"multiple\"] );\n  var options = rest;\n\n  if (multiple && !Array.isArray(value)) {\n    value = String(value).split(',').map(function (emailStr) { return emailStr.trim(); });\n  }\n\n  var validatorOptions = assign({}, options);\n\n  if (Array.isArray(value)) {\n    return value.every(function (val) { return isEmail(String(val), validatorOptions); });\n  }\n\n  return isEmail(String(value), validatorOptions);\n};\n\nvar email = {\n  validate: validate$d\n};\n\nvar validate$e = function (value, options) {\n  if (Array.isArray(value)) {\n    return value.every(function (val) { return validate$e(val, options); });\n  }\n\n  return toArray(options).some(function (item) {\n    // eslint-disable-next-line\n    return item == value;\n  });\n};\n\nvar included = {\n  validate: validate$e\n};\n\nvar validate$f = function () {\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n\n  return !validate$e.apply(void 0, args);\n};\n\nvar excluded = {\n  validate: validate$f\n};\n\nvar validate$g = function (files, extensions) {\n  var regex = new RegExp((\".(\" + (extensions.join('|')) + \")$\"), 'i');\n  return ensureArray(files).every(function (file) { return regex.test(file.name); });\n};\n\nvar ext = {\n  validate: validate$g\n};\n\nvar validate$h = function (files) { return (Array.isArray(files) ? files : [files]).every(function (file) { return /\\.(jpg|svg|jpeg|png|bmp|gif)$/i.test(file.name); }); };\n\nvar image = {\n  validate: validate$h\n};\n\nvar validate$i = function (value) {\n  if (Array.isArray(value)) {\n    return value.every(function (val) { return /^-?[0-9]+$/.test(String(val)); });\n  }\n\n  return /^-?[0-9]+$/.test(String(value));\n};\n\nvar integer = {\n  validate: validate$i\n};\n\nvar validate$j = function (value, ref) {\n  if ( ref === void 0 ) ref = {};\n  var version = ref.version; if ( version === void 0 ) version = 4;\n\n  if (isNullOrUndefined(value)) {\n    value = '';\n  }\n\n  if (Array.isArray(value)) {\n    return value.every(function (val) { return isIP(val, version); });\n  }\n\n  return isIP(value, version);\n};\n\nvar paramNames$b = ['version'];\n\nvar ip = {\n  validate: validate$j,\n  paramNames: paramNames$b\n};\n\nvar validate$k = function (value) {\n  if (isNullOrUndefined(value)) {\n    value = '';\n  }\n\n  if (Array.isArray(value)) {\n    return value.every(function (val) { return (isIP(val, '') || isFQDN(val)); });\n  }\n\n  return isIP(value, '') || isFQDN(value);\n};\n\nvar ip_or_fqdn = {\n  validate: validate$k\n};\n\nvar validate$l = function (value, ref) {\n  if ( ref === void 0 ) ref = [];\n  var other = ref[0];\n\n  return value === other;\n};\n\nvar is = {\n  validate: validate$l\n};\n\nvar validate$m = function (value, ref) {\n  if ( ref === void 0 ) ref = [];\n  var other = ref[0];\n\n  return value !== other;\n};\n\nvar is_not = {\n  validate: validate$m\n};\n\n/**\n * @param {Array|String} value\n * @param {Number} length\n * @param {Number} max\n */\nvar compare = function (value, length, max) {\n  if (max === undefined) {\n    return value.length === length;\n  }\n\n  // cast to number.\n  max = Number(max);\n\n  return value.length >= length && value.length <= max;\n};\n\nvar validate$n = function (value, ref) {\n  var length = ref[0];\n  var max = ref[1]; if ( max === void 0 ) max = undefined;\n\n  if (isNullOrUndefined(value)) {\n    return false;\n  }\n\n  length = Number(length);\n  if (typeof value === 'number') {\n    value = String(value);\n  }\n\n  if (!value.length) {\n    value = toArray(value);\n  }\n\n  return compare(value, length, max);\n};\n\nvar length = {\n  validate: validate$n\n};\n\nvar validate$o = function (value, ref) {\n  var length = ref[0];\n\n  if (isNullOrUndefined(value)) {\n    return length >= 0;\n  }\n\n  if (Array.isArray(value)) {\n    return value.every(function (val) { return validate$o(val, [length]); });\n  }\n\n  return String(value).length <= length;\n};\n\nvar max = {\n  validate: validate$o\n};\n\nvar validate$p = function (value, ref) {\n  var max = ref[0];\n\n  if (isNullOrUndefined(value) || value === '') {\n    return false;\n  }\n\n  if (Array.isArray(value)) {\n    return value.length > 0 && value.every(function (val) { return validate$p(val, [max]); });\n  }\n\n  return Number(value) <= max;\n};\n\nvar max_value = {\n  validate: validate$p\n};\n\nvar validate$q = function (files, mimes) {\n  var regex = new RegExp(((mimes.join('|').replace('*', '.+')) + \"$\"), 'i');\n  return ensureArray(files).every(function (file) { return regex.test(file.type); });\n};\n\nvar mimes = {\n  validate: validate$q\n};\n\nvar validate$r = function (value, ref) {\n  var length = ref[0];\n\n  if (isNullOrUndefined(value)) {\n    return false;\n  }\n\n  if (Array.isArray(value)) {\n    return value.every(function (val) { return validate$r(val, [length]); });\n  }\n\n  return String(value).length >= length;\n};\n\nvar min = {\n  validate: validate$r\n};\n\nvar validate$s = function (value, ref) {\n  var min = ref[0];\n\n  if (isNullOrUndefined(value) || value === '') {\n    return false;\n  }\n\n  if (Array.isArray(value)) {\n    return value.length > 0 && value.every(function (val) { return validate$s(val, [min]); });\n  }\n\n  return Number(value) >= min;\n};\n\nvar min_value = {\n  validate: validate$s\n};\n\nvar ar = /^[]+$/;\nvar en = /^[0-9]+$/;\n\nvar validate$t = function (value) {\n  var testValue = function (val) {\n    var strValue = String(val);\n\n    return en.test(strValue) || ar.test(strValue);\n  };\n\n  if (Array.isArray(value)) {\n    return value.every(testValue);\n  }\n\n  return testValue(value);\n};\n\nvar numeric = {\n  validate: validate$t\n};\n\nvar validate$u = function (value, ref) {\n  var expression = ref.expression;\n\n  if (typeof expression === 'string') {\n    expression = new RegExp(expression);\n  }\n\n  if (Array.isArray(value)) {\n    return value.every(function (val) { return validate$u(val, { expression: expression }); });\n  }\n\n  return expression.test(String(value));\n};\n\nvar paramNames$c = ['expression'];\n\nvar regex = {\n  validate: validate$u,\n  paramNames: paramNames$c\n};\n\nvar validate$v = function (value, ref) {\n  if ( ref === void 0 ) ref = [];\n  var invalidateFalse = ref[0]; if ( invalidateFalse === void 0 ) invalidateFalse = false;\n\n  if (isNullOrUndefined(value) || isEmptyArray(value)) {\n    return false;\n  }\n\n  // incase a field considers `false` as an empty value like checkboxes.\n  if (value === false && invalidateFalse) {\n    return false;\n  }\n\n  return !!String(value).trim().length;\n};\n\nvar required = {\n  validate: validate$v\n};\n\nvar validate$w = function (value, ref) {\n  if ( ref === void 0 ) ref = [];\n  var otherFieldVal = ref[0];\n  var possibleVals = ref.slice(1);\n\n  var required = possibleVals.includes(String(otherFieldVal).trim());\n\n  if (!required) {\n    return {\n      valid: true,\n      data: {\n        required: required\n      }\n    };\n  }\n\n  var invalid = (isEmptyArray(value) || [false, null, undefined].includes(value));\n\n  invalid = invalid || !String(value).trim().length;\n\n  return {\n    valid: !invalid,\n    data: {\n      required: required\n    }\n  };\n};\n\nvar options$5 = {\n  hasTarget: true,\n  computesRequired: true\n};\n\nvar required_if = {\n  validate: validate$w,\n  options: options$5\n};\n\nvar validate$x = function (files, ref) {\n  var size = ref[0];\n\n  if (isNaN(size)) {\n    return false;\n  }\n  var nSize = Number(size) * 1024;\n  return ensureArray(files).every(function (file) { return file.size <= nSize; });\n};\n\nvar size = {\n  validate: validate$x\n};\n\nvar isURL_1 = createCommonjsModule(function (module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isURL;\n\n\n\nvar _assertString2 = _interopRequireDefault(assertString_1);\n\n\n\nvar _isFQDN2 = _interopRequireDefault(isFQDN_1);\n\n\n\nvar _isIP2 = _interopRequireDefault(isIP_1);\n\n\n\nvar _merge2 = _interopRequireDefault(merge_1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar default_url_options = {\n  protocols: ['http', 'https', 'ftp'],\n  require_tld: true,\n  require_protocol: false,\n  require_host: true,\n  require_valid_protocol: true,\n  allow_underscores: false,\n  allow_trailing_dot: false,\n  allow_protocol_relative_urls: false\n};\n\nvar wrapped_ipv6 = /^\\[([^\\]]+)\\](?::([0-9]+))?$/;\n\nfunction isRegExp(obj) {\n  return Object.prototype.toString.call(obj) === '[object RegExp]';\n}\n\nfunction checkHost(host, matches) {\n  for (var i = 0; i < matches.length; i++) {\n    var match = matches[i];\n    if (host === match || isRegExp(match) && match.test(host)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isURL(url, options) {\n  (0, _assertString2.default)(url);\n  if (!url || url.length >= 2083 || /[\\s<>]/.test(url)) {\n    return false;\n  }\n  if (url.indexOf('mailto:') === 0) {\n    return false;\n  }\n  options = (0, _merge2.default)(options, default_url_options);\n  var protocol = void 0,\n      auth = void 0,\n      host = void 0,\n      hostname = void 0,\n      port = void 0,\n      port_str = void 0,\n      split = void 0,\n      ipv6 = void 0;\n\n  split = url.split('#');\n  url = split.shift();\n\n  split = url.split('?');\n  url = split.shift();\n\n  split = url.split('://');\n  if (split.length > 1) {\n    protocol = split.shift().toLowerCase();\n    if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {\n      return false;\n    }\n  } else if (options.require_protocol) {\n    return false;\n  } else if (url.substr(0, 2) === '//') {\n    if (!options.allow_protocol_relative_urls) {\n      return false;\n    }\n    split[0] = url.substr(2);\n  }\n  url = split.join('://');\n\n  if (url === '') {\n    return false;\n  }\n\n  split = url.split('/');\n  url = split.shift();\n\n  if (url === '' && !options.require_host) {\n    return true;\n  }\n\n  split = url.split('@');\n  if (split.length > 1) {\n    auth = split.shift();\n    if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {\n      return false;\n    }\n  }\n  hostname = split.join('@');\n\n  port_str = null;\n  ipv6 = null;\n  var ipv6_match = hostname.match(wrapped_ipv6);\n  if (ipv6_match) {\n    host = '';\n    ipv6 = ipv6_match[1];\n    port_str = ipv6_match[2] || null;\n  } else {\n    split = hostname.split(':');\n    host = split.shift();\n    if (split.length) {\n      port_str = split.join(':');\n    }\n  }\n\n  if (port_str !== null) {\n    port = parseInt(port_str, 10);\n    if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {\n      return false;\n    }\n  }\n\n  if (!(0, _isIP2.default)(host) && !(0, _isFQDN2.default)(host, options) && (!ipv6 || !(0, _isIP2.default)(ipv6, 6))) {\n    return false;\n  }\n\n  host = host || ipv6;\n\n  if (options.host_whitelist && !checkHost(host, options.host_whitelist)) {\n    return false;\n  }\n  if (options.host_blacklist && checkHost(host, options.host_blacklist)) {\n    return false;\n  }\n\n  return true;\n}\nmodule.exports = exports['default'];\n});\n\nvar isURL = unwrapExports(isURL_1);\n\nvar validate$y = function (value, options) {\n  if ( options === void 0 ) options = {};\n\n  if (isNullOrUndefined(value)) {\n    value = '';\n  }\n\n  var validatorOptions = assign({}, options);\n\n  if (Array.isArray(value)) {\n    return value.every(function (val) { return isURL(val, validatorOptions); });\n  }\n\n  return isURL(value, validatorOptions);\n};\n\nvar url = {\n  validate: validate$y\n};\n\n/* eslint-disable camelcase */\n\nvar Rules = /*#__PURE__*/Object.freeze({\n  after: after,\n  alpha_dash: alpha_dash,\n  alpha_num: alpha_num,\n  alpha_spaces: alpha_spaces,\n  alpha: alpha$1,\n  before: before,\n  between: between,\n  confirmed: confirmed,\n  credit_card: credit_card,\n  date_between: date_between,\n  date_format: date_format,\n  decimal: decimal,\n  digits: digits,\n  dimensions: dimensions,\n  email: email,\n  ext: ext,\n  image: image,\n  included: included,\n  integer: integer,\n  length: length,\n  ip: ip,\n  ip_or_fqdn: ip_or_fqdn,\n  is_not: is_not,\n  is: is,\n  max: max,\n  max_value: max_value,\n  mimes: mimes,\n  min: min,\n  min_value: min_value,\n  excluded: excluded,\n  numeric: numeric,\n  regex: regex,\n  required: required,\n  required_if: required_if,\n  size: size,\n  url: url\n});\n\n// \n\nvar normalize = function (fields) {\n  if (Array.isArray(fields)) {\n    return fields.reduce(function (prev, curr) {\n      if (includes(curr, '.')) {\n        prev[curr.split('.')[1]] = curr;\n      } else {\n        prev[curr] = curr;\n      }\n\n      return prev;\n    }, {});\n  }\n\n  return fields;\n};\n\n// Combines two flags using either AND or OR depending on the flag type.\nvar combine = function (lhs, rhs) {\n  var mapper = {\n    pristine: function (lhs, rhs) { return lhs && rhs; },\n    dirty: function (lhs, rhs) { return lhs || rhs; },\n    touched: function (lhs, rhs) { return lhs || rhs; },\n    untouched: function (lhs, rhs) { return lhs && rhs; },\n    valid: function (lhs, rhs) { return lhs && rhs; },\n    invalid: function (lhs, rhs) { return lhs || rhs; },\n    pending: function (lhs, rhs) { return lhs || rhs; },\n    required: function (lhs, rhs) { return lhs || rhs; },\n    validated: function (lhs, rhs) { return lhs && rhs; }\n  };\n\n  return Object.keys(mapper).reduce(function (flags, flag) {\n    flags[flag] = mapper[flag](lhs[flag], rhs[flag]);\n\n    return flags;\n  }, {});\n};\n\nvar mapScope = function (scope, deep) {\n  if ( deep === void 0 ) deep = true;\n\n  return Object.keys(scope).reduce(function (flags, field) {\n    if (!flags) {\n      flags = assign({}, scope[field]);\n      return flags;\n    }\n\n    // scope.\n    var isScope = field.indexOf('$') === 0;\n    if (deep && isScope) {\n      return combine(mapScope(scope[field]), flags);\n    } else if (!deep && isScope) {\n      return flags;\n    }\n\n    flags = combine(flags, scope[field]);\n\n    return flags;\n  }, null);\n};\n\n/**\n * Maps fields to computed functions.\n */\nvar mapFields = function (fields) {\n  if (!fields) {\n    return function () {\n      return mapScope(this.$validator.flags);\n    };\n  }\n\n  var normalized = normalize(fields);\n  return Object.keys(normalized).reduce(function (prev, curr) {\n    var field = normalized[curr];\n    prev[curr] = function mappedField () {\n      // if field exists\n      if (this.$validator.flags[field]) {\n        return this.$validator.flags[field];\n      }\n\n      // scopeless fields were selected.\n      if (normalized[curr] === '*') {\n        return mapScope(this.$validator.flags, false);\n      }\n\n      // if it has a scope defined\n      var index = field.indexOf('.');\n      if (index <= 0) {\n        return {};\n      }\n\n      var ref = field.split('.');\n      var scope = ref[0];\n      var name = ref.slice(1);\n\n      scope = this.$validator.flags[(\"$\" + scope)];\n      name = name.join('.');\n\n      // an entire scope was selected: scope.*\n      if (name === '*' && scope) {\n        return mapScope(scope);\n      }\n\n      if (scope && scope[name]) {\n        return scope[name];\n      }\n\n      return {};\n    };\n\n    return prev;\n  }, {});\n};\n\nvar $validator = null;\n\nvar PROVIDER_COUNTER = 0;\n\nvar ValidationProvider = {\n  $__veeInject: false,\n  inject: {\n    $_veeObserver: {\n      from: '$_veeObserver',\n      default: function default$1 () {\n        if (!this.$vnode.context.$_veeObserver) {\n          this.$vnode.context.$_veeObserver = createObserver();\n        }\n\n        return this.$vnode.context.$_veeObserver;\n      }\n    }\n  },\n  props: {\n    vid: {\n      type: [String, Number],\n      default: function () {\n        PROVIDER_COUNTER++;\n\n        return (\"_vee_\" + PROVIDER_COUNTER);\n      }\n    },\n    name: {\n      type: String,\n      default: null\n    },\n    mode: {\n      type: [String, Function],\n      default: function () {\n        return getConfig().mode;\n      }\n    },\n    events: {\n      type: Array,\n      validate: function () {\n        /* istanbul ignore next */\n        if (true) {\n          warn('events prop and config will be deprecated in future version please use the interaction modes instead');\n        }\n\n        return true;\n      },\n      default: function () {\n        var events = getConfig().events;\n        if (typeof events === 'string') {\n          return events.split('|');\n        }\n\n        return events;\n      }\n    },\n    rules: {\n      type: [Object, String],\n      default: null\n    },\n    immediate: {\n      type: Boolean,\n      default: false\n    },\n    persist: {\n      type: Boolean,\n      default: false\n    },\n    bails: {\n      type: Boolean,\n      default: function () { return getConfig().fastExit; }\n    },\n    debounce: {\n      type: Number,\n      default: function () { return getConfig().delay || 0; }\n    },\n    tag: {\n      type: String,\n      default: 'span'\n    },\n    slim: {\n      type: Boolean,\n      default: false\n    }\n  },\n  watch: {\n    rules: {\n      deep: true,\n      handler: function handler (val, oldVal) {\n        this._needsValidation = !isEqual(val, oldVal);\n      }\n    }\n  },\n  data: function () { return ({\n    messages: [],\n    value: undefined,\n    initialized: false,\n    initialValue: undefined,\n    flags: createFlags(),\n    failedRules: {},\n    forceRequired: false,\n    isDeactivated: false,\n    id: null\n  }); },\n  computed: {\n    isValid: function isValid () {\n      return this.flags.valid;\n    },\n    fieldDeps: function fieldDeps () {\n      var this$1 = this;\n\n      var rules = normalizeRules(this.rules);\n\n      return Object.keys(rules).filter(RuleContainer.isTargetRule).map(function (rule) {\n        var depName = rules[rule][0];\n        watchCrossFieldDep(this$1, depName);\n\n        return depName;\n      });\n    },\n    normalizedEvents: function normalizedEvents () {\n      var this$1 = this;\n\n      var ref = computeModeSetting(this);\n      var on = ref.on;\n\n      return normalizeEvents(on || this.events || []).map(function (e) {\n        if (e === 'input') {\n          return this$1._inputEventName;\n        }\n\n        return e;\n      });\n    },\n    isRequired: function isRequired () {\n      var rules = normalizeRules(this.rules);\n      var forceRequired = this.forceRequired;\n\n      var isRequired = rules.required || forceRequired;\n      this.flags.required = isRequired;\n\n      return isRequired;\n    },\n    classes: function classes () {\n      var this$1 = this;\n\n      var names = getConfig().classNames;\n      return Object.keys(this.flags).reduce(function (classes, flag) {\n        var className = (names && names[flag]) || flag;\n        if (isNullOrUndefined(this$1.flags[flag])) {\n          return classes;\n        }\n\n        if (className) {\n          classes[className] = this$1.flags[flag];\n        }\n\n        return classes;\n      }, {});\n    }\n  },\n  render: function render (h) {\n    var this$1 = this;\n\n    this.registerField();\n    var ctx = createValidationCtx(this);\n\n    // Gracefully handle non-existent scoped slots.\n    var slot = this.$scopedSlots.default;\n    /* istanbul ignore next */\n    if (!isCallable(slot)) {\n      if (true) {\n        warn('ValidationProvider expects a scoped slot. Did you forget to add \"v-slot\" to your slot?');\n      }\n\n      return h(this.tag, this.$slots.default);\n    }\n\n    var nodes = slot(ctx);\n    // Handle single-root slot.\n    extractVNodes(nodes).forEach(function (input) {\n      addListeners.call(this$1, input);\n    });\n\n    return this.slim ? createRenderless(h, nodes) : h(this.tag, nodes);\n  },\n  beforeDestroy: function beforeDestroy () {\n    // cleanup reference.\n    this.$_veeObserver.unsubscribe(this);\n  },\n  activated: function activated () {\n    this.$_veeObserver.subscribe(this);\n    this.isDeactivated = false;\n  },\n  deactivated: function deactivated () {\n    this.$_veeObserver.unsubscribe(this);\n    this.isDeactivated = true;\n  },\n  methods: {\n    setFlags: function setFlags (flags) {\n      var this$1 = this;\n\n      Object.keys(flags).forEach(function (flag) {\n        this$1.flags[flag] = flags[flag];\n      });\n    },\n    syncValue: function syncValue (e) {\n      var value = normalizeValue$1(e);\n      this.value = value;\n      this.flags.changed = this.initialValue !== value;\n    },\n    reset: function reset () {\n      this.messages = [];\n      this._pendingValidation = null;\n      this.initialValue = this.value;\n      var flags = createFlags();\n      this.setFlags(flags);\n    },\n    validate: function validate () {\n      var this$1 = this;\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      if (args.length > 0) {\n        this.syncValue(args[0]);\n      }\n\n      return this.validateSilent().then(function (result) {\n        this$1.applyResult(result);\n\n        return result;\n      });\n    },\n    validateSilent: function validateSilent () {\n      var this$1 = this;\n\n      this.setFlags({ pending: true });\n\n      return $validator.verify(this.value, this.rules, {\n        name: this.name,\n        values: createValuesLookup(this),\n        bails: this.bails\n      }).then(function (result) {\n        this$1.setFlags({ pending: false });\n        if (!this$1.isRequired) {\n          this$1.setFlags({ valid: result.valid, invalid: !result.valid });\n        }\n\n        return result;\n      });\n    },\n    applyResult: function applyResult (ref) {\n      var errors = ref.errors;\n      var failedRules = ref.failedRules;\n\n      this.messages = errors;\n      this.failedRules = assign({}, failedRules);\n      this.setFlags({\n        valid: !errors.length,\n        changed: this.value !== this.initialValue,\n        invalid: !!errors.length,\n        validated: true\n      });\n    },\n    registerField: function registerField () {\n      if (!$validator) {\n        $validator = getValidator() || new Validator(null, { fastExit: getConfig().fastExit });\n      }\n\n      updateRenderingContextRefs(this);\n    }\n  }\n};\n\nfunction createValidationCtx (ctx) {\n  return {\n    errors: ctx.messages,\n    flags: ctx.flags,\n    classes: ctx.classes,\n    valid: ctx.isValid,\n    failedRules: ctx.failedRules,\n    reset: function () { return ctx.reset(); },\n    validate: function () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      return ctx.validate.apply(ctx, args);\n  },\n    aria: {\n      'aria-invalid': ctx.flags.invalid ? 'true' : 'false',\n      'aria-required': ctx.isRequired ? 'true' : 'false'\n    }\n  };\n}\n\nfunction normalizeValue$1 (value) {\n  if (isEvent(value)) {\n    return value.target.type === 'file' ? toArray(value.target.files) : value.target.value;\n  }\n\n  return value;\n}\n\n/**\n * Determines if a provider needs to run validation.\n */\nfunction shouldValidate (ctx, model) {\n  // when an immediate/initial validation is needed and wasn't done before.\n  if (!ctx._ignoreImmediate && ctx.immediate) {\n    return true;\n  }\n\n  // when the value changes for whatever reason.\n  if (ctx.value !== model.value) {\n    return true;\n  }\n\n  // when it needs validation due to props/cross-fields changes.\n  if (ctx._needsValidation) {\n    return true;\n  }\n\n  // when the initial value is undefined and the field wasn't rendered yet.\n  if (!ctx.initialized && model.value === undefined) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction computeModeSetting (ctx) {\n  var compute = isCallable(ctx.mode) ? ctx.mode : modes[ctx.mode];\n\n  return compute({\n    errors: ctx.messages,\n    value: ctx.value,\n    flags: ctx.flags\n  });\n}\n\nfunction onRenderUpdate (model) {\n  if (!this.initialized) {\n    this.initialValue = model.value;\n  }\n\n  var validateNow = shouldValidate(this, model);\n  this._needsValidation = false;\n  this.value = model.value;\n  this._ignoreImmediate = true;\n\n  if (!validateNow) {\n    return;\n  }\n\n  this.validateSilent().then(this.immediate || this.flags.validated ? this.applyResult : function (x) { return x; });\n}\n\n// Creates the common handlers for a validatable context.\nfunction createCommonHandlers (ctx) {\n  var onInput = function (e) {\n    ctx.syncValue(e); // track and keep the value updated.\n    ctx.setFlags({ dirty: true, pristine: false });\n  };\n\n  // Blur event listener.\n  var onBlur = function () {\n    ctx.setFlags({ touched: true, untouched: false });\n  };\n\n  var onValidate = ctx.$veeHandler;\n  var mode = computeModeSetting(ctx);\n\n  // Handle debounce changes.\n  if (!onValidate || ctx.$veeDebounce !== ctx.debounce) {\n    onValidate = debounce(\n      function () {\n        ctx.$nextTick(function () {\n          var pendingPromise = ctx.validateSilent();\n          // avoids race conditions between successive validations.\n          ctx._pendingValidation = pendingPromise;\n          pendingPromise.then(function (result) {\n            if (pendingPromise === ctx._pendingValidation) {\n              ctx.applyResult(result);\n              ctx._pendingValidation = null;\n            }\n          });\n        });\n      },\n      mode.debounce || ctx.debounce\n    );\n\n    // Cache the handler so we don't create it each time.\n    ctx.$veeHandler = onValidate;\n    // cache the debounce value so we detect if it was changed.\n    ctx.$veeDebounce = ctx.debounce;\n  }\n\n  return { onInput: onInput, onBlur: onBlur, onValidate: onValidate };\n}\n\n// Adds all plugin listeners to the vnode.\nfunction addListeners (node) {\n  var model = findModel(node);\n  // cache the input eventName.\n  this._inputEventName = this._inputEventName || getInputEventName(node, model);\n\n  onRenderUpdate.call(this, model);\n\n  var ref = createCommonHandlers(this);\n  var onInput = ref.onInput;\n  var onBlur = ref.onBlur;\n  var onValidate = ref.onValidate;\n  addVNodeListener(node, this._inputEventName, onInput);\n  addVNodeListener(node, 'blur', onBlur);\n\n  // add the validation listeners.\n  this.normalizedEvents.forEach(function (evt) {\n    addVNodeListener(node, evt, onValidate);\n  });\n\n  this.initialized = true;\n}\n\nfunction createValuesLookup (ctx) {\n  var providers = ctx.$_veeObserver.refs;\n\n  return ctx.fieldDeps.reduce(function (acc, depName) {\n    if (!providers[depName]) {\n      return acc;\n    }\n\n    acc[depName] = providers[depName].value;\n\n    return acc;\n  }, {});\n}\n\nfunction updateRenderingContextRefs (ctx) {\n  // IDs should not be nullable.\n  if (isNullOrUndefined(ctx.id) && ctx.id === ctx.vid) {\n    ctx.id = PROVIDER_COUNTER;\n    PROVIDER_COUNTER++;\n  }\n\n  var id = ctx.id;\n  var vid = ctx.vid;\n  // Nothing has changed.\n  if (ctx.isDeactivated || (id === vid && ctx.$_veeObserver.refs[id])) {\n    return;\n  }\n\n  // vid was changed.\n  if (id !== vid && ctx.$_veeObserver.refs[id] === ctx) {\n    ctx.$_veeObserver.unsubscribe(ctx);\n  }\n\n  ctx.$_veeObserver.subscribe(ctx);\n  ctx.id = vid;\n}\n\nfunction createObserver () {\n  return {\n    refs: {},\n    subscribe: function subscribe (ctx) {\n      this.refs[ctx.vid] = ctx;\n    },\n    unsubscribe: function unsubscribe (ctx) {\n      delete this.refs[ctx.vid];\n    }\n  };\n}\n\nfunction watchCrossFieldDep (ctx, depName, withHooks) {\n  if ( withHooks === void 0 ) withHooks = true;\n\n  var providers = ctx.$_veeObserver.refs;\n  if (!ctx._veeWatchers) {\n    ctx._veeWatchers = {};\n  }\n\n  if (!providers[depName] && withHooks) {\n    return ctx.$once('hook:mounted', function () {\n      watchCrossFieldDep(ctx, depName, false);\n    });\n  }\n\n  if (!isCallable(ctx._veeWatchers[depName]) && providers[depName]) {\n    ctx._veeWatchers[depName] = providers[depName].$watch('value', function () {\n      if (ctx.flags.validated) {\n        ctx._needsValidation = true;\n        ctx.validate();\n      }\n    });\n  }\n}\n\nvar flagMergingStrategy = {\n  pristine: 'every',\n  dirty: 'some',\n  touched: 'some',\n  untouched: 'every',\n  valid: 'every',\n  invalid: 'some',\n  pending: 'some',\n  validated: 'every'\n};\n\nfunction mergeFlags (lhs, rhs, strategy) {\n  var stratName = flagMergingStrategy[strategy];\n\n  return [lhs, rhs][stratName](function (f) { return f; });\n}\n\nvar OBSERVER_COUNTER = 0;\n\nvar ValidationObserver = {\n  name: 'ValidationObserver',\n  provide: function provide () {\n    return {\n      $_veeObserver: this\n    };\n  },\n  inject: {\n    $_veeObserver: {\n      from: '$_veeObserver',\n      default: function default$1 () {\n        if (!this.$vnode.context.$_veeObserver) {\n          return null;\n        }\n\n        return this.$vnode.context.$_veeObserver;\n      }\n    }\n  },\n  props: {\n    tag: {\n      type: String,\n      default: 'span'\n    },\n    slim: {\n      type: Boolean,\n      default: false\n    }\n  },\n  data: function () { return ({\n    vid: (\"obs_\" + (OBSERVER_COUNTER++)),\n    refs: {},\n    observers: [],\n    persistedStore: {}\n  }); },\n  computed: {\n    ctx: function ctx () {\n      var this$1 = this;\n\n      var ctx = {\n        errors: {},\n        validate: function (arg) {\n          var promise = this$1.validate(arg);\n\n          return {\n            then: function then (thenable) {\n              return promise.then(function (success) {\n                if (success && isCallable(thenable)) {\n                  return Promise.resolve(thenable());\n                }\n\n                return Promise.resolve(success);\n              });\n            }\n          };\n        },\n        reset: function () { return this$1.reset(); }\n      };\n\n      return values(this.refs).concat( Object.keys(this.persistedStore).map(function (key) {\n          return {\n            vid: key,\n            flags: this$1.persistedStore[key].flags,\n            messages: this$1.persistedStore[key].errors\n          };\n        }),\n        this.observers ).reduce(function (acc, provider) {\n        Object.keys(flagMergingStrategy).forEach(function (flag) {\n          var flags = provider.flags || provider.ctx;\n          if (!(flag in acc)) {\n            acc[flag] = flags[flag];\n            return;\n          }\n\n          acc[flag] = mergeFlags(acc[flag], flags[flag], flag);\n        });\n\n        acc.errors[provider.vid] = provider.messages || values(provider.ctx.errors).reduce(function (errs, obsErrors) {\n          return errs.concat(obsErrors);\n        }, []);\n\n        return acc;\n      }, ctx);\n    }\n  },\n  created: function created () {\n    if (this.$_veeObserver) {\n      this.$_veeObserver.subscribe(this, 'observer');\n    }\n  },\n  activated: function activated () {\n    if (this.$_veeObserver) {\n      this.$_veeObserver.subscribe(this, 'observer');\n    }\n  },\n  deactivated: function deactivated () {\n    if (this.$_veeObserver) {\n      this.$_veeObserver.unsubscribe(this, 'observer');\n    }\n  },\n  beforeDestroy: function beforeDestroy () {\n    if (this.$_veeObserver) {\n      this.$_veeObserver.unsubscribe(this, 'observer');\n    }\n  },\n  render: function render (h) {\n    var slots = this.$slots.default || this.$scopedSlots.default || [];\n    if (isCallable(slots)) {\n      slots = slots(this.ctx);\n    }\n\n    return this.slim ? createRenderless(h, slots) : h(this.tag, { on: this.$listeners, attrs: this.$attrs }, slots);\n  },\n  methods: {\n    subscribe: function subscribe (subscriber, kind) {\n      var obj;\n\n      if ( kind === void 0 ) kind = 'provider';\n      if (kind === 'observer') {\n        this.observers.push(subscriber);\n        return;\n      }\n\n      this.refs = Object.assign({}, this.refs, ( obj = {}, obj[subscriber.vid] = subscriber, obj ));\n      if (subscriber.persist && this.persistedStore[subscriber.vid]) {\n        this.restoreProviderState(subscriber);\n      }\n    },\n    unsubscribe: function unsubscribe (ref, kind) {\n      var vid = ref.vid;\n      if ( kind === void 0 ) kind = 'provider';\n\n      if (kind === 'provider') {\n        this.removeProvider(vid);\n      }\n\n      var idx = findIndex(this.observers, function (o) { return o.vid === vid; });\n      if (idx !== -1) {\n        this.observers.splice(idx, 1);\n      }\n    },\n    validate: function validate (ref) {\n      if ( ref === void 0 ) ref = { silent: false };\n      var silent = ref.silent;\n\n      return Promise.all(values(this.refs).map(function (ref) { return ref[silent ? 'validateSilent' : 'validate']().then(function (r) { return r.valid; }); }).concat( this.observers.map(function (obs) { return obs.validate({ silent: silent }); })\n      )).then(function (results) { return results.every(function (r) { return r; }); });\n    },\n    reset: function reset () {\n      var this$1 = this;\n\n      Object.keys(this.persistedStore).forEach(function (key) {\n        this$1.$delete(this$1.persistedStore, key);\n      });\n      return values(this.refs).concat( this.observers).forEach(function (ref) { return ref.reset(); });\n    },\n    restoreProviderState: function restoreProviderState (provider) {\n      var state = this.persistedStore[provider.vid];\n      provider.setFlags(state.flags);\n      provider.applyResult(state);\n      this.$delete(this.persistedStore, provider.vid);\n    },\n    removeProvider: function removeProvider (vid) {\n      var obj;\n\n      var provider = this.refs[vid];\n      // save it for the next time.\n      if (provider && provider.persist) {\n        /* istanbul ignore else */\n        if (true) {\n          if (vid.indexOf('_vee_') === 0) {\n            warn('Please provide a `vid` prop when using `persist`, there might be unexpected issues otherwise.');\n          }\n        }\n\n        this.persistedStore = assign({}, this.persistedStore, ( obj = {}, obj[vid] = {\n            flags: provider.flags,\n            errors: provider.messages,\n            failedRules: provider.failedRules\n          }, obj ));\n      }\n\n      this.$delete(this.refs, vid);\n    },\n  }\n};\n\nfunction withValidation (component, ctxToProps) {\n  if ( ctxToProps === void 0 ) ctxToProps = null;\n\n  var options = isCallable(component) ? component.options : component;\n  options.$__veeInject = false;\n  var hoc = {\n    name: ((options.name || 'AnonymousHoc') + \"WithValidation\"),\n    props: assign({}, ValidationProvider.props),\n    data: ValidationProvider.data,\n    computed: assign({}, ValidationProvider.computed),\n    methods: assign({}, ValidationProvider.methods),\n    $__veeInject: false,\n    beforeDestroy: ValidationProvider.beforeDestroy,\n    inject: ValidationProvider.inject\n  };\n\n  // Default ctx converts ctx props to component props.\n  if (!ctxToProps) {\n    ctxToProps = function (ctx) { return ctx; };\n  }\n\n  var eventName = (options.model && options.model.event) || 'input';\n\n  hoc.render = function (h) {\n    var obj;\n\n    this.registerField();\n    var vctx = createValidationCtx(this);\n    var listeners = assign({}, this.$listeners);\n\n    var model = findModel(this.$vnode);\n    this._inputEventName = this._inputEventName || getInputEventName(this.$vnode, model);\n    onRenderUpdate.call(this, model);\n\n    var ref = createCommonHandlers(this);\n    var onInput = ref.onInput;\n    var onBlur = ref.onBlur;\n    var onValidate = ref.onValidate;\n\n    mergeVNodeListeners(listeners, eventName, onInput);\n    mergeVNodeListeners(listeners, 'blur', onBlur);\n    this.normalizedEvents.forEach(function (evt, idx) {\n      mergeVNodeListeners(listeners, evt, onValidate);\n    });\n\n    // Props are any attrs not associated with ValidationProvider Plus the model prop.\n    // WARNING: Accidental prop overwrite will probably happen.\n    var ref$1 = findModelConfig(this.$vnode) || { prop: 'value' };\n    var prop = ref$1.prop;\n    var props = assign({}, this.$attrs, ( obj = {}, obj[prop] = model.value, obj ), ctxToProps(vctx));\n\n    return h(options, {\n      attrs: this.$attrs,\n      props: props,\n      on: listeners\n    }, normalizeSlots(this.$slots, this.$vnode.context));\n  };\n\n  return hoc;\n}\n\nvar version = '2.2.12';\n\nObject.keys(Rules).forEach(function (rule) {\n  Validator.extend(rule, Rules[rule].validate, assign({}, Rules[rule].options, { paramNames: Rules[rule].paramNames }));\n});\n\n// Merge the english messages.\nValidator.localize({ en: locale });\n\nvar install = VeeValidate$1.install;\n\nVeeValidate$1.version = version;\nVeeValidate$1.mapFields = mapFields;\nVeeValidate$1.ValidationProvider = ValidationProvider;\nVeeValidate$1.ValidationObserver = ValidationObserver;\nVeeValidate$1.withValidation = withValidation;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (VeeValidate$1);\n\n\n\n//# sourceURL=webpack:///./node_modules/vee-validate/dist/vee-validate.esm.js?");

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/LoginForm.vue?vue&type=template&id=b397ab9e&":
/*!******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/LoginForm.vue?vue&type=template&id=b397ab9e& ***!
  \******************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", { staticClass: \"content mod-login\" }, [\n    _c(\"div\", { staticClass: \"login-wrapper\" }, [\n      _c(\"div\", { staticClass: \"login-wrapper__title\" }, [_vm._v(\"Admin\")]),\n      _vm._v(\" \"),\n      _c(\n        \"form\",\n        {\n          attrs: { action: _vm.route, method: _vm.method },\n          on: { submit: _vm.checkForm }\n        },\n        [\n          _c(\"input\", {\n            attrs: { type: \"hidden\", name: \"_token\" },\n            domProps: { value: _vm.token }\n          }),\n          _vm._v(\" \"),\n          _vm._l(_vm.errorsJsonParse, function(error) {\n            return _c(\n              \"div\",\n              { staticClass: \"login-wrapper-from__error-container\" },\n              _vm._l(error, function(message) {\n                return _c(\"div\", { staticClass: \"login-wrapper-from__error\" }, [\n                  _vm._v(\n                    \"\\n                    \" +\n                      _vm._s(message) +\n                      \"\\n                \"\n                  )\n                ])\n              }),\n              0\n            )\n          }),\n          _vm._v(\" \"),\n          _c(\"div\", { staticClass: \"login-wrapper__from\" }, [\n            _c(\"div\", { staticClass: \"login-wrapper-from__group\" }, [\n              _c(\"label\", { attrs: { for: \"email\" } }, [_vm._v(\"\")]),\n              _vm._v(\" \"),\n              _c(\"input\", {\n                directives: [\n                  {\n                    name: \"model\",\n                    rawName: \"v-model\",\n                    value: _vm.email,\n                    expression: \"email\"\n                  },\n                  {\n                    name: \"validate\",\n                    rawName: \"v-validate\",\n                    value: \"required|email\",\n                    expression: \"'required|email'\"\n                  }\n                ],\n                attrs: {\n                  type: \"text\",\n                  id: \"email\",\n                  name: \"email\",\n                  \"data-vv-as\": \"\"\n                },\n                domProps: { value: _vm.email },\n                on: {\n                  input: function($event) {\n                    if ($event.target.composing) {\n                      return\n                    }\n                    _vm.email = $event.target.value\n                  }\n                }\n              }),\n              _vm._v(\" \"),\n              _c(\"div\", { staticClass: \"login-wrapper-from__error\" }, [\n                _vm._v(_vm._s(_vm.errors.first(\"email\")))\n              ])\n            ]),\n            _vm._v(\" \"),\n            _c(\"div\", { staticClass: \"login-wrapper-from__group\" }, [\n              _c(\"label\", { attrs: { for: \"password\" } }, [_vm._v(\"\")]),\n              _vm._v(\" \"),\n              _c(\"input\", {\n                directives: [\n                  {\n                    name: \"model\",\n                    rawName: \"v-model\",\n                    value: _vm.password,\n                    expression: \"password\"\n                  },\n                  {\n                    name: \"validate\",\n                    rawName: \"v-validate\",\n                    value: \"required\",\n                    expression: \"'required'\"\n                  }\n                ],\n                attrs: {\n                  type: \"password\",\n                  id: \"password\",\n                  name: \"password\",\n                  \"data-vv-as\": \"\"\n                },\n                domProps: { value: _vm.password },\n                on: {\n                  input: function($event) {\n                    if ($event.target.composing) {\n                      return\n                    }\n                    _vm.password = $event.target.value\n                  }\n                }\n              }),\n              _vm._v(\" \"),\n              _c(\"div\", { staticClass: \"login-wrapper-from__error\" }, [\n                _vm._v(_vm._s(_vm.errors.first(\"password\")))\n              ])\n            ]),\n            _vm._v(\" \"),\n            _c(\n              \"button\",\n              {\n                staticClass: \"login-wrapper-from__button\",\n                attrs: { type: \"submit\" }\n              },\n              [_vm._v(\"\")]\n            )\n          ])\n        ],\n        2\n      )\n    ])\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n\n//# sourceURL=webpack:///./src/js/components/LoginForm.vue?./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/form/File.vue?vue&type=template&id=5191c18b&":
/*!******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/form/File.vue?vue&type=template&id=5191c18b& ***!
  \******************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", { staticClass: \"form-group__field-file__container\" }, [\n    _c(\n      \"button\",\n      {\n        staticClass: \"form-group__field-file\",\n        attrs: { type: \"button\" },\n        on: { click: _vm.openManager }\n      },\n      [_vm._v(\"\")]\n    ),\n    _vm._v(\" \"),\n    _c(\"img\", {\n      staticClass: \"form-group__field-file__image\",\n      attrs: { src: _vm.url, alt: _vm.fileName }\n    }),\n    _vm._v(\" \"),\n    _c(\"input\", {\n      directives: [\n        { name: \"model\", rawName: \"v-model\", value: _vm.url, expression: \"url\" }\n      ],\n      attrs: { type: \"hidden\", name: _vm.name },\n      domProps: { value: _vm.url },\n      on: {\n        input: function($event) {\n          if ($event.target.composing) {\n            return\n          }\n          _vm.url = $event.target.value\n        }\n      }\n    })\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n\n//# sourceURL=webpack:///./src/js/components/form/File.vue?./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/form/ImageIterator.vue?vue&type=template&id=9d90412c&":
/*!***************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/form/ImageIterator.vue?vue&type=template&id=9d90412c& ***!
  \***************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    \"div\",\n    { staticClass: \"form-group__iterator-image\" },\n    [\n      _c(\n        \"div\",\n        {\n          directives: [\n            {\n              name: \"show\",\n              rawName: \"v-show\",\n              value: _vm.images.length === 0,\n              expression: \"images.length === 0\"\n            }\n          ]\n        },\n        [_vm._v(\" \")]\n      ),\n      _vm._v(\" \"),\n      _c(\n        \"draggable\",\n        {\n          model: {\n            value: _vm.images,\n            callback: function($$v) {\n              _vm.images = $$v\n            },\n            expression: \"images\"\n          }\n        },\n        [\n          _c(\n            \"transition-group\",\n            { attrs: { type: \"transition\" } },\n            _vm._l(_vm.images, function(image, index) {\n              return _c(\n                \"div\",\n                {\n                  key: image.id,\n                  staticClass: \"form-group__iterator-image_container\"\n                },\n                [\n                  _c(\"div\", { staticClass: \"form-group__iterator-drag\" }),\n                  _vm._v(\" \"),\n                  _c(\"file\", {\n                    attrs: {\n                      name: \"images[\" + index + \"][image]\",\n                      default: image.image\n                    }\n                  }),\n                  _vm._v(\" \"),\n                  _c(\"input\", {\n                    directives: [\n                      {\n                        name: \"model\",\n                        rawName: \"v-model\",\n                        value: image.name,\n                        expression: \"image.name\"\n                      }\n                    ],\n                    staticClass: \"form-group__field iterator-image-name\",\n                    attrs: {\n                      name: \"images[\" + index + \"][name]\",\n                      type: \"text\"\n                    },\n                    domProps: { value: image.name },\n                    on: {\n                      input: function($event) {\n                        if ($event.target.composing) {\n                          return\n                        }\n                        _vm.$set(image, \"name\", $event.target.value)\n                      }\n                    }\n                  }),\n                  _vm._v(\" \"),\n                  _c(\"input\", {\n                    directives: [\n                      {\n                        name: \"model\",\n                        rawName: \"v-model\",\n                        value: image.id,\n                        expression: \"image.id\"\n                      }\n                    ],\n                    attrs: {\n                      type: \"hidden\",\n                      name: \"images[\" + index + \"][id]\"\n                    },\n                    domProps: { value: image.id },\n                    on: {\n                      input: function($event) {\n                        if ($event.target.composing) {\n                          return\n                        }\n                        _vm.$set(image, \"id\", $event.target.value)\n                      }\n                    }\n                  }),\n                  _vm._v(\" \"),\n                  _c(\n                    \"button\",\n                    {\n                      staticClass: \"form-group__field-file\",\n                      attrs: { type: \"button\" },\n                      on: {\n                        click: function($event) {\n                          return _vm.removeIterate(index)\n                        }\n                      }\n                    },\n                    [_vm._v(\"\\n                \")]\n                  )\n                ],\n                1\n              )\n            }),\n            0\n          )\n        ],\n        1\n      ),\n      _vm._v(\" \"),\n      _c(\n        \"button\",\n        {\n          staticClass: \"form-group__field-file field-file-iterator\",\n          attrs: { type: \"button\" },\n          on: { click: _vm.addIterate }\n        },\n        [_vm._v(\"\")]\n      )\n    ],\n    1\n  )\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n\n//# sourceURL=webpack:///./src/js/components/form/ImageIterator.vue?./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/form/MultiSelect.vue?vue&type=template&id=a401e754&":
/*!*************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/form/MultiSelect.vue?vue&type=template&id=a401e754& ***!
  \*************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    \"div\",\n    [\n      _c(\"multi-list-select\", {\n        attrs: {\n          list: _vm.data,\n          \"selected-items\": _vm.selectedItems,\n          \"option-value\": _vm.value,\n          \"option-text\": _vm.text,\n          placeholder: \" \"\n        },\n        on: { select: _vm.onSelect }\n      }),\n      _vm._v(\" \"),\n      _vm._l(_vm.selectedItems, function(item) {\n        return _c(\"div\", [\n          _c(\"input\", {\n            directives: [\n              {\n                name: \"model\",\n                rawName: \"v-model\",\n                value: item[_vm.value],\n                expression: \"item[value]\"\n              }\n            ],\n            attrs: { type: \"hidden\", name: _vm.name + \"[]\" },\n            domProps: { value: item[_vm.value] },\n            on: {\n              input: function($event) {\n                if ($event.target.composing) {\n                  return\n                }\n                _vm.$set(item, _vm.value, $event.target.value)\n              }\n            }\n          })\n        ])\n      })\n    ],\n    2\n  )\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n\n//# sourceURL=webpack:///./src/js/components/form/MultiSelect.vue?./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/form/Select.vue?vue&type=template&id=b5f5816a&":
/*!********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/form/Select.vue?vue&type=template&id=b5f5816a& ***!
  \********************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    \"div\",\n    [\n      _c(\"model-list-select\", {\n        attrs: {\n          list: _vm.data,\n          \"option-value\": _vm.value,\n          \"option-text\": _vm.text,\n          placeholder: \" \"\n        },\n        model: {\n          value: _vm.objectItem,\n          callback: function($$v) {\n            _vm.objectItem = $$v\n          },\n          expression: \"objectItem\"\n        }\n      }),\n      _vm._v(\" \"),\n      _c(\"input\", {\n        directives: [\n          {\n            name: \"model\",\n            rawName: \"v-model\",\n            value: _vm.objectItem[_vm.value],\n            expression: \"objectItem[value]\"\n          }\n        ],\n        attrs: { type: \"hidden\", name: _vm.name },\n        domProps: { value: _vm.objectItem[_vm.value] },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.$set(_vm.objectItem, _vm.value, $event.target.value)\n          }\n        }\n      })\n    ],\n    1\n  )\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n\n//# sourceURL=webpack:///./src/js/components/form/Select.vue?./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return normalizeComponent; });\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/vue-loader/lib/runtime/componentNormalizer.js?");

/***/ }),

/***/ "./node_modules/vue-search-select/publish/vue-search-select.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vue-search-select/publish/vue-search-select.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"./\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.ModelListSelect = exports.ModelSelect = exports.MultiListSelect = exports.ListSelect = exports.MultiSelect = exports.BasicSelect = undefined;\n\t\n\tvar _BasicSelect = __webpack_require__(44);\n\t\n\tvar _BasicSelect2 = _interopRequireDefault(_BasicSelect);\n\t\n\tvar _ListSelect = __webpack_require__(97);\n\t\n\tvar _ListSelect2 = _interopRequireDefault(_ListSelect);\n\t\n\tvar _MultiListSelect = __webpack_require__(99);\n\t\n\tvar _MultiListSelect2 = _interopRequireDefault(_MultiListSelect);\n\t\n\tvar _MultiSelect = __webpack_require__(46);\n\t\n\tvar _MultiSelect2 = _interopRequireDefault(_MultiSelect);\n\t\n\tvar _ModelSelect = __webpack_require__(45);\n\t\n\tvar _ModelSelect2 = _interopRequireDefault(_ModelSelect);\n\t\n\tvar _ModelListSelect = __webpack_require__(98);\n\t\n\tvar _ModelListSelect2 = _interopRequireDefault(_ModelListSelect);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.BasicSelect = _BasicSelect2.default;\n\texports.MultiSelect = _MultiSelect2.default;\n\texports.ListSelect = _ListSelect2.default;\n\texports.MultiListSelect = _MultiListSelect2.default;\n\texports.ModelSelect = _ModelSelect2.default;\n\texports.ModelListSelect = _ModelListSelect2.default;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n\t  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n\tif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tmodule.exports = function(it, key){\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// to indexed object, toObject with fallback for non-array-like ES3 strings\n\tvar IObject = __webpack_require__(68)\n\t  , defined = __webpack_require__(20);\n\tmodule.exports = function(it){\n\t  return IObject(defined(it));\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\n\t\tAuthor Tobias Koppers @sokra\n\t*/\n\tvar stylesInDom = {},\n\t\tmemoize = function(fn) {\n\t\t\tvar memo;\n\t\t\treturn function () {\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\t\treturn memo;\n\t\t\t};\n\t\t},\n\t\tisOldIE = memoize(function() {\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\n\t\t}),\n\t\tgetHeadElement = memoize(function () {\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t\t}),\n\t\tsingletonElement = null,\n\t\tsingletonCounter = 0,\n\t\tstyleElementsInsertedAtTop = [];\n\t\n\tmodule.exports = function(list, options) {\n\t\tif(false) {}\n\t\n\t\toptions = options || {};\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t\t// tags it will allow on a page\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\t\n\t\t// By default, add <style> tags to the bottom of <head>.\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\t\n\t\tvar styles = listToStyles(list);\n\t\taddStylesToDom(styles, options);\n\t\n\t\treturn function update(newList) {\n\t\t\tvar mayRemove = [];\n\t\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\t\tvar item = styles[i];\n\t\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\t\tdomStyle.refs--;\n\t\t\t\tmayRemove.push(domStyle);\n\t\t\t}\n\t\t\tif(newList) {\n\t\t\t\tvar newStyles = listToStyles(newList);\n\t\t\t\taddStylesToDom(newStyles, options);\n\t\t\t}\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\t\tvar domStyle = mayRemove[i];\n\t\t\t\tif(domStyle.refs === 0) {\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction addStylesToDom(styles, options) {\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tif(domStyle) {\n\t\t\t\tdomStyle.refs++;\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t\t}\n\t\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar parts = [];\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t\t}\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction listToStyles(list) {\n\t\tvar styles = [];\n\t\tvar newStyles = {};\n\t\tfor(var i = 0; i < list.length; i++) {\n\t\t\tvar item = list[i];\n\t\t\tvar id = item[0];\n\t\t\tvar css = item[1];\n\t\t\tvar media = item[2];\n\t\t\tvar sourceMap = item[3];\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\t\tif(!newStyles[id])\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\t\telse\n\t\t\t\tnewStyles[id].parts.push(part);\n\t\t}\n\t\treturn styles;\n\t}\n\t\n\tfunction insertStyleElement(options, styleElement) {\n\t\tvar head = getHeadElement();\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\t\tif (options.insertAt === \"top\") {\n\t\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t\t} else {\n\t\t\t\thead.appendChild(styleElement);\n\t\t\t}\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t\t} else if (options.insertAt === \"bottom\") {\n\t\t\thead.appendChild(styleElement);\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t\t}\n\t}\n\t\n\tfunction removeStyleElement(styleElement) {\n\t\tstyleElement.parentNode.removeChild(styleElement);\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\t\tif(idx >= 0) {\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t\t}\n\t}\n\t\n\tfunction createStyleElement(options) {\n\t\tvar styleElement = document.createElement(\"style\");\n\t\tstyleElement.type = \"text/css\";\n\t\tinsertStyleElement(options, styleElement);\n\t\treturn styleElement;\n\t}\n\t\n\tfunction addStyle(obj, options) {\n\t\tvar styleElement, update, remove;\n\t\n\t\tif (options.singleton) {\n\t\t\tvar styleIndex = singletonCounter++;\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t\t} else {\n\t\t\tstyleElement = createStyleElement(options);\n\t\t\tupdate = applyToTag.bind(null, styleElement);\n\t\t\tremove = function() {\n\t\t\t\tremoveStyleElement(styleElement);\n\t\t\t};\n\t\t}\n\t\n\t\tupdate(obj);\n\t\n\t\treturn function updateStyle(newObj) {\n\t\t\tif(newObj) {\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\t\treturn;\n\t\t\t\tupdate(obj = newObj);\n\t\t\t} else {\n\t\t\t\tremove();\n\t\t\t}\n\t\t};\n\t}\n\t\n\tvar replaceText = (function () {\n\t\tvar textStore = [];\n\t\n\t\treturn function (index, replacement) {\n\t\t\ttextStore[index] = replacement;\n\t\t\treturn textStore.filter(Boolean).join('\\n');\n\t\t};\n\t})();\n\t\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\t\tvar css = remove ? \"\" : obj.css;\n\t\n\t\tif (styleElement.styleSheet) {\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t\t} else {\n\t\t\tvar cssNode = document.createTextNode(css);\n\t\t\tvar childNodes = styleElement.childNodes;\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\t\tif (childNodes.length) {\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t\t} else {\n\t\t\t\tstyleElement.appendChild(cssNode);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction applyToTag(styleElement, obj) {\n\t\tvar css = obj.css;\n\t\tvar media = obj.media;\n\t\tvar sourceMap = obj.sourceMap;\n\t\n\t\tif (media) {\n\t\t\tstyleElement.setAttribute(\"media\", media);\n\t\t}\n\t\n\t\tif (sourceMap) {\n\t\t\t// https://developer.chrome.com/devtools/docs/javascript-debugging\n\t\t\t// this makes source maps inside style tags work properly in Chrome\n\t\t\tcss += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */';\n\t\t\t// http://stackoverflow.com/a/26603875\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t\t}\n\t\n\t\tif (styleElement.styleSheet) {\n\t\t\tstyleElement.styleSheet.cssText = css;\n\t\t} else {\n\t\t\twhile(styleElement.firstChild) {\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t\t}\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\n\t\t}\n\t}\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.optionAwareMixin = exports.commonMixin = exports.baseMixin = undefined;\n\t\n\tvar _commonMixin = __webpack_require__(54);\n\t\n\tvar _commonMixin2 = _interopRequireDefault(_commonMixin);\n\t\n\tvar _baseMixin = __webpack_require__(53);\n\t\n\tvar _baseMixin2 = _interopRequireDefault(_baseMixin);\n\t\n\tvar _optionAwareMixin = __webpack_require__(55);\n\t\n\tvar _optionAwareMixin2 = _interopRequireDefault(_optionAwareMixin);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.baseMixin = _baseMixin2.default;\n\texports.commonMixin = _commonMixin2.default;\n\texports.optionAwareMixin = _optionAwareMixin2.default;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Thank's IE8 for his funny defineProperty\n\tmodule.exports = !__webpack_require__(12)(function(){\n\t  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP         = __webpack_require__(9)\n\t  , createDesc = __webpack_require__(16);\n\tmodule.exports = __webpack_require__(7) ? function(object, key, value){\n\t  return dP.f(object, key, createDesc(1, value));\n\t} : function(object, key, value){\n\t  object[key] = value;\n\t  return object;\n\t};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar anObject       = __webpack_require__(14)\n\t  , IE8_DOM_DEFINE = __webpack_require__(36)\n\t  , toPrimitive    = __webpack_require__(30)\n\t  , dP             = Object.defineProperty;\n\t\n\texports.f = __webpack_require__(7) ? Object.defineProperty : function defineProperty(O, P, Attributes){\n\t  anObject(O);\n\t  P = toPrimitive(P, true);\n\t  anObject(Attributes);\n\t  if(IE8_DOM_DEFINE)try {\n\t    return dP(O, P, Attributes);\n\t  } catch(e){ /* empty */ }\n\t  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n\t  if('value' in Attributes)O[P] = Attributes.value;\n\t  return O;\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar store      = __webpack_require__(28)('wks')\n\t  , uid        = __webpack_require__(17)\n\t  , Symbol     = __webpack_require__(1).Symbol\n\t  , USE_SYMBOL = typeof Symbol == 'function';\n\t\n\tvar $exports = module.exports = function(name){\n\t  return store[name] || (store[name] =\n\t    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n\t};\n\t\n\t$exports.store = store;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tvar core = module.exports = {version: '2.4.0'};\n\tif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(exec){\n\t  try {\n\t    return !!exec();\n\t  } catch(e){\n\t    return true;\n\t  }\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.14 / 15.2.3.14 Object.keys(O)\n\tvar $keys       = __webpack_require__(41)\n\t  , enumBugKeys = __webpack_require__(21);\n\t\n\tmodule.exports = Object.keys || function keys(O){\n\t  return $keys(O, enumBugKeys);\n\t};\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(15);\n\tmodule.exports = function(it){\n\t  if(!isObject(it))throw TypeError(it + ' is not an object!');\n\t  return it;\n\t};\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(bitmap, value){\n\t  return {\n\t    enumerable  : !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable    : !(bitmap & 4),\n\t    value       : value\n\t  };\n\t};\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\tvar id = 0\n\t  , px = Math.random();\n\tmodule.exports = function(key){\n\t  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n\t};\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = {\n\t  openOptions: function openOptions(self) {\n\t    self.$refs.input.focus();\n\t    self.showMenu = true;\n\t    self.mousedownState = false;\n\t  },\n\t  blurInput: function blurInput(self) {\n\t    if (!self.mousedownState) {\n\t      self.searchText = '';\n\t      self.closeOptions();\n\t    }\n\t  },\n\t  closeOptions: function closeOptions(self) {\n\t    self.showMenu = false;\n\t  },\n\t  prevItem: function prevItem(self) {\n\t    var prevIndex = self.pointer - 1;\n\t    var prevIndexScrollTop = self.$el.offsetHeight * prevIndex;\n\t    if (prevIndex >= 0) {\n\t      self.pointer = prevIndex;\n\t    }\n\t\n\t    self.$refs.menu.scrollTop = prevIndexScrollTop;\n\t  },\n\t  nextItem: function nextItem(self) {\n\t    var nextIndex = self.pointer + 1;\n\t    var nextIndexScrollTop = self.$el.offsetHeight * nextIndex;\n\t    if (nextIndex <= self.filteredOptions.length - 1) {\n\t      self.pointer = nextIndex;\n\t    }\n\t\n\t    var currentMenuHeight = self.$refs.menu.offsetHeight;\n\t    var currentPage = Math.ceil((self.$refs.menu.scrollTop + self.$el.offsetHeight) / currentMenuHeight);\n\t    var itemPage = Math.ceil(nextIndexScrollTop / currentMenuHeight);\n\t\n\t    if (currentPage !== itemPage) {\n\t      self.$refs.menu.scrollTop = (itemPage - 1) * self.$refs.menu.offsetHeight;\n\t    }\n\t  },\n\t  enterItem: function enterItem(self) {\n\t    var currentItem = self.filteredOptions[self.pointer];\n\t    if (currentItem) {\n\t      self.selectItem(currentItem);\n\t    }\n\t  },\n\t  pointerSet: function pointerSet(self, index) {\n\t    self.pointer = index;\n\t  },\n\t  pointerAdjust: function pointerAdjust(self) {\n\t    if (self.pointer >= self.filteredOptions.length - 1) {\n\t      self.pointer = self.filteredOptions.length ? self.filteredOptions.length - 1 : 0;\n\t    }\n\t  },\n\t  mousedownItem: function mousedownItem(self) {\n\t    self.mousedownState = true;\n\t  }\n\t};\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(59), __esModule: true };\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\t// 7.2.1 RequireObjectCoercible(argument)\n\tmodule.exports = function(it){\n\t  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n\t  return it;\n\t};\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t// IE 8- don't enum bug keys\n\tmodule.exports = (\n\t  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n\t).split(',');\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global    = __webpack_require__(1)\n\t  , core      = __webpack_require__(11)\n\t  , ctx       = __webpack_require__(65)\n\t  , hide      = __webpack_require__(8)\n\t  , PROTOTYPE = 'prototype';\n\t\n\tvar $export = function(type, name, source){\n\t  var IS_FORCED = type & $export.F\n\t    , IS_GLOBAL = type & $export.G\n\t    , IS_STATIC = type & $export.S\n\t    , IS_PROTO  = type & $export.P\n\t    , IS_BIND   = type & $export.B\n\t    , IS_WRAP   = type & $export.W\n\t    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n\t    , expProto  = exports[PROTOTYPE]\n\t    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n\t    , key, own, out;\n\t  if(IS_GLOBAL)source = name;\n\t  for(key in source){\n\t    // contains in native\n\t    own = !IS_FORCED && target && target[key] !== undefined;\n\t    if(own && key in exports)continue;\n\t    // export native or passed\n\t    out = own ? target[key] : source[key];\n\t    // prevent global pollution for namespaces\n\t    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n\t    // bind timers to global for call from export context\n\t    : IS_BIND && own ? ctx(out, global)\n\t    // wrap global constructors for prevent change them in library\n\t    : IS_WRAP && target[key] == out ? (function(C){\n\t      var F = function(a, b, c){\n\t        if(this instanceof C){\n\t          switch(arguments.length){\n\t            case 0: return new C;\n\t            case 1: return new C(a);\n\t            case 2: return new C(a, b);\n\t          } return new C(a, b, c);\n\t        } return C.apply(this, arguments);\n\t      };\n\t      F[PROTOTYPE] = C[PROTOTYPE];\n\t      return F;\n\t    // make static versions for prototype methods\n\t    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n\t    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n\t    if(IS_PROTO){\n\t      (exports.virtual || (exports.virtual = {}))[key] = out;\n\t      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n\t      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n\t    }\n\t  }\n\t};\n\t// type bitmap\n\t$export.F = 1;   // forced\n\t$export.G = 2;   // global\n\t$export.S = 4;   // static\n\t$export.P = 8;   // proto\n\t$export.B = 16;  // bind\n\t$export.W = 32;  // wrap\n\t$export.U = 64;  // safe\n\t$export.R = 128; // real proto method for `library` \n\tmodule.exports = $export;\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {};\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\tmodule.exports = true;\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\texports.f = {}.propertyIsEnumerable;\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar def = __webpack_require__(9).f\n\t  , has = __webpack_require__(2)\n\t  , TAG = __webpack_require__(10)('toStringTag');\n\t\n\tmodule.exports = function(it, tag, stat){\n\t  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n\t};\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar shared = __webpack_require__(28)('keys')\n\t  , uid    = __webpack_require__(17);\n\tmodule.exports = function(key){\n\t  return shared[key] || (shared[key] = uid(key));\n\t};\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global = __webpack_require__(1)\n\t  , SHARED = '__core-js_shared__'\n\t  , store  = global[SHARED] || (global[SHARED] = {});\n\tmodule.exports = function(key){\n\t  return store[key] || (store[key] = {});\n\t};\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\t// 7.1.4 ToInteger\n\tvar ceil  = Math.ceil\n\t  , floor = Math.floor;\n\tmodule.exports = function(it){\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n\t};\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.1 ToPrimitive(input [, PreferredType])\n\tvar isObject = __webpack_require__(15);\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tmodule.exports = function(it, S){\n\t  if(!isObject(it))return it;\n\t  var fn, val;\n\t  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global         = __webpack_require__(1)\n\t  , core           = __webpack_require__(11)\n\t  , LIBRARY        = __webpack_require__(24)\n\t  , wksExt         = __webpack_require__(32)\n\t  , defineProperty = __webpack_require__(9).f;\n\tmodule.exports = function(name){\n\t  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n\t  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});\n\t};\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports.f = __webpack_require__(10);\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _iterator = __webpack_require__(58);\n\t\n\tvar _iterator2 = _interopRequireDefault(_iterator);\n\t\n\tvar _symbol = __webpack_require__(57);\n\t\n\tvar _symbol2 = _interopRequireDefault(_symbol);\n\t\n\tvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default ? \"symbol\" : typeof obj; };\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n\t  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t} : function (obj) {\n\t  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t};\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = function(it){\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(15)\n\t  , document = __webpack_require__(1).document\n\t  // in old IE typeof document.createElement is 'object'\n\t  , is = isObject(document) && isObject(document.createElement);\n\tmodule.exports = function(it){\n\t  return is ? document.createElement(it) : {};\n\t};\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = !__webpack_require__(7) && !__webpack_require__(12)(function(){\n\t  return Object.defineProperty(__webpack_require__(35)('div'), 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar LIBRARY        = __webpack_require__(24)\n\t  , $export        = __webpack_require__(22)\n\t  , redefine       = __webpack_require__(42)\n\t  , hide           = __webpack_require__(8)\n\t  , has            = __webpack_require__(2)\n\t  , Iterators      = __webpack_require__(23)\n\t  , $iterCreate    = __webpack_require__(70)\n\t  , setToStringTag = __webpack_require__(26)\n\t  , getPrototypeOf = __webpack_require__(77)\n\t  , ITERATOR       = __webpack_require__(10)('iterator')\n\t  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n\t  , FF_ITERATOR    = '@@iterator'\n\t  , KEYS           = 'keys'\n\t  , VALUES         = 'values';\n\t\n\tvar returnThis = function(){ return this; };\n\t\n\tmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n\t  $iterCreate(Constructor, NAME, next);\n\t  var getMethod = function(kind){\n\t    if(!BUGGY && kind in proto)return proto[kind];\n\t    switch(kind){\n\t      case KEYS: return function keys(){ return new Constructor(this, kind); };\n\t      case VALUES: return function values(){ return new Constructor(this, kind); };\n\t    } return function entries(){ return new Constructor(this, kind); };\n\t  };\n\t  var TAG        = NAME + ' Iterator'\n\t    , DEF_VALUES = DEFAULT == VALUES\n\t    , VALUES_BUG = false\n\t    , proto      = Base.prototype\n\t    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n\t    , $default   = $native || getMethod(DEFAULT)\n\t    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n\t    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n\t    , methods, key, IteratorPrototype;\n\t  // Fix native\n\t  if($anyNative){\n\t    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n\t    if(IteratorPrototype !== Object.prototype){\n\t      // Set @@toStringTag to native iterators\n\t      setToStringTag(IteratorPrototype, TAG, true);\n\t      // fix for some old engines\n\t      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n\t    }\n\t  }\n\t  // fix Array#{values, @@iterator}.name in V8 / FF\n\t  if(DEF_VALUES && $native && $native.name !== VALUES){\n\t    VALUES_BUG = true;\n\t    $default = function values(){ return $native.call(this); };\n\t  }\n\t  // Define iterator\n\t  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n\t    hide(proto, ITERATOR, $default);\n\t  }\n\t  // Plug for library\n\t  Iterators[NAME] = $default;\n\t  Iterators[TAG]  = returnThis;\n\t  if(DEFAULT){\n\t    methods = {\n\t      values:  DEF_VALUES ? $default : getMethod(VALUES),\n\t      keys:    IS_SET     ? $default : getMethod(KEYS),\n\t      entries: $entries\n\t    };\n\t    if(FORCED)for(key in methods){\n\t      if(!(key in proto))redefine(proto, key, methods[key]);\n\t    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n\t  }\n\t  return methods;\n\t};\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n\tvar anObject    = __webpack_require__(14)\n\t  , dPs         = __webpack_require__(74)\n\t  , enumBugKeys = __webpack_require__(21)\n\t  , IE_PROTO    = __webpack_require__(27)('IE_PROTO')\n\t  , Empty       = function(){ /* empty */ }\n\t  , PROTOTYPE   = 'prototype';\n\t\n\t// Create object with fake `null` prototype: use iframe Object with cleared prototype\n\tvar createDict = function(){\n\t  // Thrash, waste and sodomy: IE GC bug\n\t  var iframe = __webpack_require__(35)('iframe')\n\t    , i      = enumBugKeys.length\n\t    , lt     = '<'\n\t    , gt     = '>'\n\t    , iframeDocument;\n\t  iframe.style.display = 'none';\n\t  __webpack_require__(67).appendChild(iframe);\n\t  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n\t  // createDict = iframe.contentWindow.Object;\n\t  // html.removeChild(iframe);\n\t  iframeDocument = iframe.contentWindow.document;\n\t  iframeDocument.open();\n\t  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n\t  iframeDocument.close();\n\t  createDict = iframeDocument.F;\n\t  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n\t  return createDict();\n\t};\n\t\n\tmodule.exports = Object.create || function create(O, Properties){\n\t  var result;\n\t  if(O !== null){\n\t    Empty[PROTOTYPE] = anObject(O);\n\t    result = new Empty;\n\t    Empty[PROTOTYPE] = null;\n\t    // add \"__proto__\" for Object.getPrototypeOf polyfill\n\t    result[IE_PROTO] = O;\n\t  } else result = createDict();\n\t  return Properties === undefined ? result : dPs(result, Properties);\n\t};\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\n\tvar $keys      = __webpack_require__(41)\n\t  , hiddenKeys = __webpack_require__(21).concat('length', 'prototype');\n\t\n\texports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){\n\t  return $keys(O, hiddenKeys);\n\t};\n\n/***/ },\n/* 40 */\n/***/ function(module, exports) {\n\n\texports.f = Object.getOwnPropertySymbols;\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar has          = __webpack_require__(2)\n\t  , toIObject    = __webpack_require__(3)\n\t  , arrayIndexOf = __webpack_require__(64)(false)\n\t  , IE_PROTO     = __webpack_require__(27)('IE_PROTO');\n\t\n\tmodule.exports = function(object, names){\n\t  var O      = toIObject(object)\n\t    , i      = 0\n\t    , result = []\n\t    , key;\n\t  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n\t  // Don't enum bug & hidden keys\n\t  while(names.length > i)if(has(O, key = names[i++])){\n\t    ~arrayIndexOf(result, key) || result.push(key);\n\t  }\n\t  return result;\n\t};\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(8);\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.13 ToObject(argument)\n\tvar defined = __webpack_require__(20);\n\tmodule.exports = function(it){\n\t  return Object(defined(it));\n\t};\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_exports__, __vue_options__\n\tvar __vue_styles__ = {}\n\t\n\t/* styles */\n\t__webpack_require__(106)\n\t__webpack_require__(105)\n\t\n\t/* script */\n\t__vue_exports__ = __webpack_require__(47)\n\t\n\t/* template */\n\tvar __vue_template__ = __webpack_require__(101)\n\t__vue_options__ = __vue_exports__ = __vue_exports__ || {}\n\tif (\n\t  typeof __vue_exports__.default === \"object\" ||\n\t  typeof __vue_exports__.default === \"function\"\n\t) {\n\t__vue_options__ = __vue_exports__ = __vue_exports__.default\n\t}\n\tif (typeof __vue_options__ === \"function\") {\n\t  __vue_options__ = __vue_options__.options\n\t}\n\t\n\t__vue_options__.render = __vue_template__.render\n\t__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n\t__vue_options__._scopeId = \"data-v-4030daa2\"\n\t\n\tmodule.exports = __vue_exports__\n\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_exports__, __vue_options__\n\tvar __vue_styles__ = {}\n\t\n\t/* styles */\n\t__webpack_require__(104)\n\t__webpack_require__(103)\n\t\n\t/* script */\n\t__vue_exports__ = __webpack_require__(50)\n\t\n\t/* template */\n\tvar __vue_template__ = __webpack_require__(100)\n\t__vue_options__ = __vue_exports__ = __vue_exports__ || {}\n\tif (\n\t  typeof __vue_exports__.default === \"object\" ||\n\t  typeof __vue_exports__.default === \"function\"\n\t) {\n\t__vue_options__ = __vue_exports__ = __vue_exports__.default\n\t}\n\tif (typeof __vue_options__ === \"function\") {\n\t  __vue_options__ = __vue_options__.options\n\t}\n\t\n\t__vue_options__.render = __vue_template__.render\n\t__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n\t__vue_options__._scopeId = \"data-v-3a0c7bea\"\n\t\n\tmodule.exports = __vue_exports__\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_exports__, __vue_options__\n\tvar __vue_styles__ = {}\n\t\n\t/* styles */\n\t__webpack_require__(109)\n\t__webpack_require__(108)\n\t__webpack_require__(107)\n\t\n\t/* script */\n\t__vue_exports__ = __webpack_require__(52)\n\t\n\t/* template */\n\tvar __vue_template__ = __webpack_require__(102)\n\t__vue_options__ = __vue_exports__ = __vue_exports__ || {}\n\tif (\n\t  typeof __vue_exports__.default === \"object\" ||\n\t  typeof __vue_exports__.default === \"function\"\n\t) {\n\t__vue_options__ = __vue_exports__ = __vue_exports__.default\n\t}\n\tif (typeof __vue_options__ === \"function\") {\n\t  __vue_options__ = __vue_options__.options\n\t}\n\t\n\t__vue_options__.render = __vue_template__.render\n\t__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n\t__vue_options__._scopeId = \"data-v-a3dbfc0c\"\n\t\n\tmodule.exports = __vue_exports__\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _common = __webpack_require__(18);\n\t\n\tvar _common2 = _interopRequireDefault(_common);\n\t\n\tvar _mixins = __webpack_require__(6);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  mixins: [_mixins.baseMixin, _mixins.commonMixin, _mixins.optionAwareMixin],\n\t  props: {\n\t    selectedOption: {\n\t      type: Object,\n\t      default: function _default() {\n\t        return { value: '', text: '' };\n\t      }\n\t    }\n\t  },\n\t  data: function data() {\n\t    return {\n\t      showMenu: false,\n\t      searchText: '',\n\t      mousedownState: false,\n\t      pointer: -1\n\t    };\n\t  },\n\t\n\t  watch: {\n\t    selectedOption: function selectedOption(newValue) {\n\t      if (newValue && newValue.value) {\n\t        this.pointer = this.filteredOptions.findIndex(function (option) {\n\t          return option.value === newValue.value;\n\t        });\n\t      } else {\n\t        this.pointer = -1;\n\t      }\n\t    }\n\t  },\n\t  computed: {\n\t    searchTextCustomAttr: function searchTextCustomAttr() {\n\t      if (this.selectedOption && this.selectedOption.value) {\n\t        return this.customAttr(this.selectedOption);\n\t      }\n\t      return '';\n\t    },\n\t    inputText: function inputText() {\n\t      if (this.searchText) {\n\t        return '';\n\t      } else {\n\t        var text = this.placeholder;\n\t        if (this.selectedOption.text) {\n\t          text = this.selectedOption.text;\n\t        }\n\t        return text;\n\t      }\n\t    },\n\t    customAttrs: function customAttrs() {\n\t      var _this = this;\n\t\n\t      try {\n\t        if (Array.isArray(this.options)) {\n\t          return this.options.map(function (o) {\n\t            return _this.customAttr(o);\n\t          });\n\t        }\n\t      } catch (e) {}\n\t      return [];\n\t    },\n\t    textClass: function textClass() {\n\t      if (!this.selectedOption.text && this.placeholder) {\n\t        return 'default';\n\t      } else {\n\t        return '';\n\t      }\n\t    },\n\t    menuClass: function menuClass() {\n\t      return {\n\t        visible: this.showMenu,\n\t        hidden: !this.showMenu\n\t      };\n\t    },\n\t    menuStyle: function menuStyle() {\n\t      return {\n\t        display: this.showMenu ? 'block' : 'none'\n\t      };\n\t    },\n\t    filteredOptions: function filteredOptions() {\n\t      var _this2 = this;\n\t\n\t      if (this.searchText) {\n\t        return this.options.filter(function (option) {\n\t          try {\n\t            return _this2.filterPredicate(option.text, _this2.searchText);\n\t          } catch (e) {\n\t            return true;\n\t          }\n\t        });\n\t      } else {\n\t        return this.options;\n\t      }\n\t    }\n\t  },\n\t  methods: {\n\t    deleteTextOrItem: function deleteTextOrItem() {\n\t      if (!this.searchText && this.selectedOption) {\n\t        this.selectItem({});\n\t        this.openOptions();\n\t      }\n\t    },\n\t    openOptions: function openOptions() {\n\t      _common2.default.openOptions(this);\n\t    },\n\t    blurInput: function blurInput() {\n\t      _common2.default.blurInput(this);\n\t    },\n\t    closeOptions: function closeOptions() {\n\t      _common2.default.closeOptions(this);\n\t    },\n\t    prevItem: function prevItem() {\n\t      _common2.default.prevItem(this);\n\t    },\n\t    nextItem: function nextItem() {\n\t      _common2.default.nextItem(this);\n\t    },\n\t    enterItem: function enterItem() {\n\t      _common2.default.enterItem(this);\n\t    },\n\t    pointerSet: function pointerSet(index) {\n\t      _common2.default.pointerSet(this, index);\n\t    },\n\t    pointerAdjust: function pointerAdjust() {\n\t      _common2.default.pointerAdjust(this);\n\t    },\n\t    mousedownItem: function mousedownItem() {\n\t      _common2.default.mousedownItem(this);\n\t    },\n\t    selectItem: function selectItem(option) {\n\t      this.searchText = '';\n\t      this.closeOptions();\n\t      this.$emit('select', option);\n\t      if (option.value === option.text) {\n\t        this.searchText = option.value;\n\t      }\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _keys = __webpack_require__(19);\n\t\n\tvar _keys2 = _interopRequireDefault(_keys);\n\t\n\tvar _BasicSelect = __webpack_require__(44);\n\t\n\tvar _BasicSelect2 = _interopRequireDefault(_BasicSelect);\n\t\n\tvar _mixins = __webpack_require__(6);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  mixins: [_mixins.commonMixin],\n\t  render: function render(createElement) {\n\t    var _this = this;\n\t\n\t    return createElement(_BasicSelect2.default, {\n\t      props: {\n\t        id: this.id,\n\t        name: this.name,\n\t        options: this.options,\n\t        selectedOption: this.item,\n\t        isError: this.isError,\n\t        isDisabled: this.isDisabled,\n\t        placeholder: this.placeholder,\n\t        filterPredicate: this.filterPredicate\n\t      },\n\t      on: {\n\t        select: this.onSelect,\n\t        searchchange: function searchchange(searchText) {\n\t          return _this.$emit('searchchange', searchText);\n\t        }\n\t      }\n\t    });\n\t  },\n\t  props: {\n\t    list: {\n\t      type: Array\n\t    },\n\t    optionValue: {\n\t      type: String\n\t    },\n\t    optionText: {\n\t      type: String\n\t    },\n\t    customText: {\n\t      type: Function\n\t    },\n\t    selectedItem: {\n\t      type: Object\n\t    }\n\t  },\n\t  computed: {\n\t    options: function options() {\n\t      var _this2 = this;\n\t\n\t      return this.list.map(function (e, i) {\n\t        return { value: e[_this2.optionValue], text: _this2.buildText(e) };\n\t      });\n\t    },\n\t    item: function item() {\n\t      if (this.selectedItem) {\n\t        return { value: this.selectedItem[this.optionValue], text: this.buildText(this.selectedItem) };\n\t      } else {\n\t        return { value: '', text: '' };\n\t      }\n\t    }\n\t  },\n\t  methods: {\n\t    buildText: function buildText(e) {\n\t      if (e[this.optionValue] !== undefined) {\n\t        if (this.customText) {\n\t          return this.customText(e);\n\t        } else {\n\t          return e[this.optionText];\n\t        }\n\t      } else {\n\t        return '';\n\t      }\n\t    },\n\t    onSelect: function onSelect(option) {\n\t      var _this3 = this;\n\t\n\t      if ((0, _keys2.default)(option).length === 0 && option.constructor === Object) {\n\t        this.$emit('select', option);\n\t      } else {\n\t        var item = this.list.find(function (e, i) {\n\t          return e[_this3.optionValue] === option.value;\n\t        });\n\t        this.$emit('select', item);\n\t      }\n\t    }\n\t  },\n\t  components: {\n\t    BasicSelect: _BasicSelect2.default\n\t  }\n\t};\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _keys = __webpack_require__(19);\n\t\n\tvar _keys2 = _interopRequireDefault(_keys);\n\t\n\tvar _typeof2 = __webpack_require__(33);\n\t\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\t\n\tvar _ModelSelect = __webpack_require__(45);\n\t\n\tvar _ModelSelect2 = _interopRequireDefault(_ModelSelect);\n\t\n\tvar _mixins = __webpack_require__(6);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  mixins: [_mixins.commonMixin],\n\t  render: function render(createElement) {\n\t    var _this = this;\n\t\n\t    return createElement(_ModelSelect2.default, {\n\t      props: {\n\t        id: this.id,\n\t        name: this.name,\n\t        options: this.options,\n\t        value: this.innerValue,\n\t        isError: this.isError,\n\t        isDisabled: this.isDisabled,\n\t        placeholder: this.placeholder,\n\t        filterPredicate: this.filterPredicate\n\t      },\n\t      on: {\n\t        input: this.onInput,\n\t        searchchange: function searchchange(searchText) {\n\t          return _this.$emit('searchchange', searchText);\n\t        }\n\t      }\n\t    });\n\t  },\n\t  props: {\n\t    list: {\n\t      type: Array\n\t    },\n\t    optionValue: {\n\t      type: String\n\t    },\n\t    optionText: {\n\t      type: String\n\t    },\n\t    customText: {\n\t      type: Function\n\t    },\n\t\n\t    value: {\n\t      type: [String, Number, Object, Boolean]\n\t    }\n\t  },\n\t  computed: {\n\t    options: function options() {\n\t      var _this2 = this;\n\t\n\t      return this.list.map(function (e) {\n\t        return { value: e[_this2.optionValue], text: _this2.buildText(e) };\n\t      });\n\t    },\n\t    innerValue: function innerValue() {\n\t      if (!this.value) {\n\t        return this.value;\n\t      } else if ((0, _typeof3.default)(this.value) === 'object') {\n\t        if (this.value) {\n\t          return { value: this.value[this.optionValue], text: this.buildText(this.value) };\n\t        } else {\n\t          return { value: '', text: '' };\n\t        }\n\t      } else {\n\t        return this.value;\n\t      }\n\t    }\n\t  },\n\t  methods: {\n\t    buildText: function buildText(e) {\n\t      if (e[this.optionValue] !== undefined) {\n\t        if (this.customText) {\n\t          return this.customText(e);\n\t        } else {\n\t          return e[this.optionText];\n\t        }\n\t      } else {\n\t        return '';\n\t      }\n\t    },\n\t    onInput: function onInput(option) {\n\t      var _this3 = this;\n\t\n\t      if (option === undefined) {\n\t        return this.$emit('input', '');\n\t      }\n\t      if ((0, _keys2.default)(option).length === 0 && option.constructor === Object) {\n\t        this.$emit('input', option);\n\t      } else if ((typeof option === 'undefined' ? 'undefined' : (0, _typeof3.default)(option)) === 'object') {\n\t        var item = this.list.find(function (e) {\n\t          return e[_this3.optionValue] === option.value;\n\t        });\n\t        this.$emit('input', item);\n\t      } else {\n\t        this.$emit('input', option);\n\t      }\n\t    }\n\t  },\n\t  components: {\n\t    ModelSelect: _ModelSelect2.default\n\t  }\n\t};\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof2 = __webpack_require__(33);\n\t\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\t\n\tvar _common = __webpack_require__(18);\n\t\n\tvar _common2 = _interopRequireDefault(_common);\n\t\n\tvar _mixins = __webpack_require__(6);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  mixins: [_mixins.baseMixin, _mixins.commonMixin, _mixins.optionAwareMixin],\n\t  props: {\n\t    value: {\n\t      type: [String, Number, Object, Boolean]\n\t    }\n\t  },\n\t  data: function data() {\n\t    return {\n\t      showMenu: false,\n\t      searchText: '',\n\t      mousedownState: false,\n\t      pointer: -1\n\t    };\n\t  },\n\t\n\t  watch: {\n\t    value: function value(newValue) {\n\t      var _this = this;\n\t\n\t      this.pointer = this.filteredOptions.findIndex(function (option) {\n\t        return option.value === _this.optionValue(newValue);\n\t      });\n\t    }\n\t  },\n\t  computed: {\n\t    searchTextCustomAttr: function searchTextCustomAttr() {\n\t      if (this.selectedOption && this.selectedOption.value) {\n\t        return this.customAttr(this.selectedOption);\n\t      }\n\t      return '';\n\t    },\n\t    inputText: function inputText() {\n\t      if (this.searchText) {\n\t        return '';\n\t      } else {\n\t        var text = this.placeholder;\n\t        if (this.selectedOption) {\n\t          text = this.selectedOption.text;\n\t        }\n\t        return text;\n\t      }\n\t    },\n\t    customAttrs: function customAttrs() {\n\t      var _this2 = this;\n\t\n\t      try {\n\t        if (Array.isArray(this.options)) {\n\t          return this.options.map(function (o) {\n\t            return _this2.customAttr(o);\n\t          });\n\t        }\n\t      } catch (e) {}\n\t      return [];\n\t    },\n\t    textClass: function textClass() {\n\t      if (!this.selectedOption && this.placeholder) {\n\t        return 'default';\n\t      } else {\n\t        return '';\n\t      }\n\t    },\n\t    menuClass: function menuClass() {\n\t      return {\n\t        visible: this.showMenu,\n\t        hidden: !this.showMenu\n\t      };\n\t    },\n\t    menuStyle: function menuStyle() {\n\t      return {\n\t        display: this.showMenu ? 'block' : 'none'\n\t      };\n\t    },\n\t    filteredOptions: function filteredOptions() {\n\t      var _this3 = this;\n\t\n\t      if (this.searchText) {\n\t        return this.options.filter(function (option) {\n\t          try {\n\t            return _this3.filterPredicate(option.text, _this3.searchText);\n\t          } catch (e) {\n\t            return true;\n\t          }\n\t        });\n\t      } else {\n\t        return this.options;\n\t      }\n\t    },\n\t    selectedOption: function selectedOption() {\n\t      var _this4 = this;\n\t\n\t      return this.options.find(function (option) {\n\t        return option.value === _this4.optionValue(_this4.value);\n\t      });\n\t    }\n\t  },\n\t  methods: {\n\t    deleteTextOrItem: function deleteTextOrItem() {\n\t      if (!this.searchText && this.value) {\n\t        this.selectItem({});\n\t        this.openOptions();\n\t      }\n\t    },\n\t    openOptions: function openOptions() {\n\t      _common2.default.openOptions(this);\n\t    },\n\t    blurInput: function blurInput() {\n\t      _common2.default.blurInput(this);\n\t    },\n\t    closeOptions: function closeOptions() {\n\t      _common2.default.closeOptions(this);\n\t    },\n\t    prevItem: function prevItem() {\n\t      _common2.default.prevItem(this);\n\t    },\n\t    nextItem: function nextItem() {\n\t      _common2.default.nextItem(this);\n\t    },\n\t    enterItem: function enterItem() {\n\t      _common2.default.enterItem(this);\n\t    },\n\t    pointerSet: function pointerSet(index) {\n\t      _common2.default.pointerSet(this, index);\n\t    },\n\t    pointerAdjust: function pointerAdjust() {\n\t      _common2.default.pointerAdjust(this);\n\t    },\n\t    mousedownItem: function mousedownItem() {\n\t      _common2.default.mousedownItem(this);\n\t    },\n\t    selectItem: function selectItem(option) {\n\t      this.searchText = '';\n\t      this.closeOptions();\n\t      if ((0, _typeof3.default)(this.value) === 'object' && this.value) {\n\t        this.$emit('input', option);\n\t      } else {\n\t        this.$emit('input', option.value);\n\t        if (option.value === option.text) {\n\t          this.searchText = option.value;\n\t        }\n\t      }\n\t    },\n\t    optionValue: function optionValue(value) {\n\t      if ((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === 'object' && value !== null) {\n\t        return value.value;\n\t      } else {\n\t        return value;\n\t      }\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _keys = __webpack_require__(19);\n\t\n\tvar _keys2 = _interopRequireDefault(_keys);\n\t\n\tvar _MultiSelect = __webpack_require__(46);\n\t\n\tvar _MultiSelect2 = _interopRequireDefault(_MultiSelect);\n\t\n\tvar _mixins = __webpack_require__(6);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  mixins: [_mixins.commonMixin],\n\t  render: function render(createElement) {\n\t    var _this = this;\n\t\n\t    return createElement(_MultiSelect2.default, {\n\t      props: {\n\t        id: this.id,\n\t        name: this.name,\n\t        options: this.options,\n\t        selectedOptions: this.items,\n\t        isError: this.isError,\n\t        isDisabled: this.isDisabled,\n\t        placeholder: this.placeholder,\n\t        filterPredicate: this.filterPredicate\n\t      },\n\t      on: {\n\t        select: this.onSelect,\n\t        searchchange: function searchchange(searchText) {\n\t          return _this.$emit('searchchange', searchText);\n\t        }\n\t      }\n\t    });\n\t  },\n\t  props: {\n\t    list: {\n\t      type: Array\n\t    },\n\t    optionValue: {\n\t      type: String\n\t    },\n\t    optionText: {\n\t      type: String\n\t    },\n\t    customText: {\n\t      type: Function\n\t    },\n\t    selectedItems: {\n\t      type: Array\n\t    }\n\t  },\n\t  computed: {\n\t    options: function options() {\n\t      var _this2 = this;\n\t\n\t      return this.list.map(function (e) {\n\t        return { value: e[_this2.optionValue], text: _this2.buildText(e) };\n\t      });\n\t    },\n\t    items: function items() {\n\t      var _this3 = this;\n\t\n\t      return this.selectedItems.map(function (e) {\n\t        return { value: e[_this3.optionValue], text: _this3.buildText(e) };\n\t      });\n\t    }\n\t  },\n\t  methods: {\n\t    buildText: function buildText(e) {\n\t      if (e[this.optionValue] !== undefined) {\n\t        if (this.customText) {\n\t          return this.customText(e);\n\t        } else {\n\t          return e[this.optionText];\n\t        }\n\t      } else {\n\t        return '';\n\t      }\n\t    },\n\t    onSelect: function onSelect(options, option) {\n\t      var _this4 = this;\n\t\n\t      if ((0, _keys2.default)(option).length === 0 && option.constructor === Object) {\n\t        this.$emit('select', options, option);\n\t      } else {\n\t        var items = this.list.filter(function (e, i) {\n\t          return options.find(function (o, i) {\n\t            return e[_this4.optionValue] === o.value;\n\t          });\n\t        });\n\t        var item = this.list.find(function (e) {\n\t          return e[_this4.optionValue] === option.value;\n\t        });\n\t        this.$emit('select', items, item);\n\t      }\n\t    }\n\t  },\n\t  components: {\n\t    MultiSelect: _MultiSelect2.default\n\t  }\n\t};\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _common = __webpack_require__(18);\n\t\n\tvar _common2 = _interopRequireDefault(_common);\n\t\n\tvar _mixins = __webpack_require__(6);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  mixins: [_mixins.baseMixin, _mixins.commonMixin, _mixins.optionAwareMixin],\n\t  props: {\n\t    selectedOptions: {\n\t      type: Array\n\t    },\n\t    cleanSearch: {\n\t      type: Boolean,\n\t      default: true\n\t    },\n\t    hideSelectedOptions: {\n\t      type: Boolean,\n\t      default: false\n\t    }\n\t  },\n\t  data: function data() {\n\t    return {\n\t      showMenu: false,\n\t      searchText: '',\n\t      mousedownState: false,\n\t      pointer: -1\n\t    };\n\t  },\n\t\n\t  watch: {\n\t    selectedOptions: function selectedOptions() {\n\t      this.pointer = -1;\n\t    }\n\t  },\n\t  computed: {\n\t    inputText: function inputText() {\n\t      if (this.searchText) {\n\t        return '';\n\t      } else {\n\t        return this.placeholder;\n\t      }\n\t    },\n\t    textClass: function textClass() {\n\t      if (this.placeholder) {\n\t        return 'default';\n\t      } else {\n\t        return '';\n\t      }\n\t    },\n\t    inputWidth: function inputWidth() {\n\t      return {\n\t        width: (this.searchText.length + 1) * 8 + 20 + 'px'\n\t      };\n\t    },\n\t    menuClass: function menuClass() {\n\t      return {\n\t        visible: this.showMenu,\n\t        hidden: !this.showMenu\n\t      };\n\t    },\n\t    menuStyle: function menuStyle() {\n\t      return {\n\t        display: this.showMenu ? 'block' : 'none'\n\t      };\n\t    },\n\t    nonSelectOptions: function nonSelectOptions() {\n\t      var _this = this;\n\t\n\t      return this.options.filter(function (el) {\n\t        return _this.selectedOptions.findIndex(function (o) {\n\t          return o.value === el.value;\n\t        }) === -1;\n\t      });\n\t    },\n\t    filteredOptions: function filteredOptions() {\n\t      var _this2 = this;\n\t\n\t      if (this.searchText) {\n\t        return this.nonSelectOptions.filter(function (option) {\n\t          try {\n\t            if (_this2.cleanSearch) {\n\t              return _this2.filterPredicate(_this2.accentsTidy(option.text), _this2.searchText);\n\t            } else {\n\t              return _this2.filterPredicate(option.text, _this2.searchText);\n\t            }\n\t          } catch (e) {\n\t            return true;\n\t          }\n\t        });\n\t      } else {\n\t        return this.nonSelectOptions;\n\t      }\n\t    }\n\t  },\n\t  methods: {\n\t    deleteTextOrLastItem: function deleteTextOrLastItem() {\n\t      if (!this.searchText && this.selectedOptions.length > 0) {\n\t        this.deleteItem(this.selectedOptions[this.selectedOptions.length - 1]);\n\t      }\n\t    },\n\t    openOptions: function openOptions() {\n\t      _common2.default.openOptions(this);\n\t    },\n\t    blurInput: function blurInput() {\n\t      _common2.default.blurInput(this);\n\t    },\n\t    closeOptions: function closeOptions() {\n\t      _common2.default.closeOptions(this);\n\t    },\n\t    prevItem: function prevItem() {\n\t      _common2.default.prevItem(this);\n\t      this.closeOptions();\n\t      this.openOptions();\n\t    },\n\t    nextItem: function nextItem() {\n\t      _common2.default.nextItem(this);\n\t      this.closeOptions();\n\t      this.openOptions();\n\t    },\n\t    enterItem: function enterItem() {\n\t      _common2.default.enterItem(this);\n\t    },\n\t    pointerSet: function pointerSet(index) {\n\t      _common2.default.pointerSet(this, index);\n\t    },\n\t    pointerAdjust: function pointerAdjust() {\n\t      _common2.default.pointerAdjust(this);\n\t    },\n\t    mousedownItem: function mousedownItem() {\n\t      _common2.default.mousedownItem(this);\n\t    },\n\t    selectItem: function selectItem(option) {\n\t      var tempSelectedOptions = this.selectedOptions.concat(option);\n\t      var selectedOptions = tempSelectedOptions.filter(function (el, idx) {\n\t        return tempSelectedOptions.indexOf(el) === idx;\n\t      });\n\t      this.closeOptions();\n\t      this.searchText = '';\n\t      this.$emit('select', selectedOptions, option, 'insert');\n\t    },\n\t    deleteItem: function deleteItem(option) {\n\t      var selectedOptions = this.selectedOptions.filter(function (o) {\n\t        return o.value !== option.value;\n\t      });\n\t      this.$emit('select', selectedOptions, option, 'delete');\n\t    },\n\t    accentsTidy: function accentsTidy(s) {\n\t      var r = s.toString().toLowerCase();\n\t      r = r.replace(new RegExp('[]', 'g'), 'a');\n\t      r = r.replace(new RegExp('', 'g'), 'ae');\n\t      r = r.replace(new RegExp('', 'g'), 'c');\n\t      r = r.replace(new RegExp('[]', 'g'), 'e');\n\t      r = r.replace(new RegExp('[]', 'g'), 'i');\n\t      r = r.replace(new RegExp('', 'g'), 'n');\n\t      r = r.replace(new RegExp('[]', 'g'), 'o');\n\t      r = r.replace(new RegExp('', 'g'), 'oe');\n\t      r = r.replace(new RegExp('[]', 'g'), 'u');\n\t      r = r.replace(new RegExp('[]', 'g'), 'y');\n\t      return r;\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 53 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = {\n\t  watch: {\n\t    filteredOptions: function filteredOptions() {\n\t      this.pointerAdjust();\n\t    },\n\t    searchText: function searchText() {\n\t      this.$emit('searchchange', this.searchText);\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _utils = __webpack_require__(56);\n\t\n\texports.default = {\n\t  props: {\n\t    id: {\n\t      default: null\n\t    },\n\t    name: {\n\t      type: String,\n\t      default: ''\n\t    },\n\t    isError: {\n\t      type: Boolean,\n\t      default: false\n\t    },\n\t    customAttr: {\n\t      type: Function,\n\t      default: function _default() {\n\t        return '';\n\t      }\n\t    },\n\t    isDisabled: {\n\t      type: Boolean,\n\t      default: false\n\t    },\n\t    placeholder: {\n\t      type: String,\n\t      default: ''\n\t    },\n\t    filterPredicate: {\n\t      type: Function,\n\t      default: function _default(text, inputText) {\n\t        return text.match((0, _utils.escapedRegExp)(inputText));\n\t      }\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 55 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = {\n\t  props: {\n\t    customAttr: {\n\t      type: Function,\n\t      default: function _default() {\n\t        return '';\n\t      }\n\t    },\n\t    options: {\n\t      type: Array\n\t    }\n\t  }\n\t};\n\n/***/ },\n/* 56 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.escapedRegExp = escapedRegExp;\n\tfunction escapedRegExp(str) {\n\t  return new RegExp(str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'i');\n\t}\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(60), __esModule: true };\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(61), __esModule: true };\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(83);\n\tmodule.exports = __webpack_require__(11).Object.keys;\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(86);\n\t__webpack_require__(84);\n\t__webpack_require__(87);\n\t__webpack_require__(88);\n\tmodule.exports = __webpack_require__(11).Symbol;\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(85);\n\t__webpack_require__(89);\n\tmodule.exports = __webpack_require__(32).f('iterator');\n\n/***/ },\n/* 62 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n\t  return it;\n\t};\n\n/***/ },\n/* 63 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(){ /* empty */ };\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// false -> Array#indexOf\n\t// true  -> Array#includes\n\tvar toIObject = __webpack_require__(3)\n\t  , toLength  = __webpack_require__(81)\n\t  , toIndex   = __webpack_require__(80);\n\tmodule.exports = function(IS_INCLUDES){\n\t  return function($this, el, fromIndex){\n\t    var O      = toIObject($this)\n\t      , length = toLength(O.length)\n\t      , index  = toIndex(fromIndex, length)\n\t      , value;\n\t    // Array#includes uses SameValueZero equality algorithm\n\t    if(IS_INCLUDES && el != el)while(length > index){\n\t      value = O[index++];\n\t      if(value != value)return true;\n\t    // Array#toIndex ignores holes, Array#includes - not\n\t    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n\t      if(O[index] === el)return IS_INCLUDES || index || 0;\n\t    } return !IS_INCLUDES && -1;\n\t  };\n\t};\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// optional / simple context binding\n\tvar aFunction = __webpack_require__(62);\n\tmodule.exports = function(fn, that, length){\n\t  aFunction(fn);\n\t  if(that === undefined)return fn;\n\t  switch(length){\n\t    case 1: return function(a){\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function(a, b){\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function(a, b, c){\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function(/* ...args */){\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// all enumerable object keys, includes symbols\n\tvar getKeys = __webpack_require__(13)\n\t  , gOPS    = __webpack_require__(40)\n\t  , pIE     = __webpack_require__(25);\n\tmodule.exports = function(it){\n\t  var result     = getKeys(it)\n\t    , getSymbols = gOPS.f;\n\t  if(getSymbols){\n\t    var symbols = getSymbols(it)\n\t      , isEnum  = pIE.f\n\t      , i       = 0\n\t      , key;\n\t    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);\n\t  } return result;\n\t};\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1).document && document.documentElement;\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar cof = __webpack_require__(34);\n\tmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n\t  return cof(it) == 'String' ? it.split('') : Object(it);\n\t};\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.2.2 IsArray(argument)\n\tvar cof = __webpack_require__(34);\n\tmodule.exports = Array.isArray || function isArray(arg){\n\t  return cof(arg) == 'Array';\n\t};\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar create         = __webpack_require__(38)\n\t  , descriptor     = __webpack_require__(16)\n\t  , setToStringTag = __webpack_require__(26)\n\t  , IteratorPrototype = {};\n\t\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\t__webpack_require__(8)(IteratorPrototype, __webpack_require__(10)('iterator'), function(){ return this; });\n\t\n\tmodule.exports = function(Constructor, NAME, next){\n\t  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n\t  setToStringTag(Constructor, NAME + ' Iterator');\n\t};\n\n/***/ },\n/* 71 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(done, value){\n\t  return {value: value, done: !!done};\n\t};\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getKeys   = __webpack_require__(13)\n\t  , toIObject = __webpack_require__(3);\n\tmodule.exports = function(object, el){\n\t  var O      = toIObject(object)\n\t    , keys   = getKeys(O)\n\t    , length = keys.length\n\t    , index  = 0\n\t    , key;\n\t  while(length > index)if(O[key = keys[index++]] === el)return key;\n\t};\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar META     = __webpack_require__(17)('meta')\n\t  , isObject = __webpack_require__(15)\n\t  , has      = __webpack_require__(2)\n\t  , setDesc  = __webpack_require__(9).f\n\t  , id       = 0;\n\tvar isExtensible = Object.isExtensible || function(){\n\t  return true;\n\t};\n\tvar FREEZE = !__webpack_require__(12)(function(){\n\t  return isExtensible(Object.preventExtensions({}));\n\t});\n\tvar setMeta = function(it){\n\t  setDesc(it, META, {value: {\n\t    i: 'O' + ++id, // object ID\n\t    w: {}          // weak collections IDs\n\t  }});\n\t};\n\tvar fastKey = function(it, create){\n\t  // return primitive with prefix\n\t  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n\t  if(!has(it, META)){\n\t    // can't set metadata to uncaught frozen object\n\t    if(!isExtensible(it))return 'F';\n\t    // not necessary to add metadata\n\t    if(!create)return 'E';\n\t    // add missing metadata\n\t    setMeta(it);\n\t  // return object ID\n\t  } return it[META].i;\n\t};\n\tvar getWeak = function(it, create){\n\t  if(!has(it, META)){\n\t    // can't set metadata to uncaught frozen object\n\t    if(!isExtensible(it))return true;\n\t    // not necessary to add metadata\n\t    if(!create)return false;\n\t    // add missing metadata\n\t    setMeta(it);\n\t  // return hash weak collections IDs\n\t  } return it[META].w;\n\t};\n\t// add metadata on freeze-family methods calling\n\tvar onFreeze = function(it){\n\t  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);\n\t  return it;\n\t};\n\tvar meta = module.exports = {\n\t  KEY:      META,\n\t  NEED:     false,\n\t  fastKey:  fastKey,\n\t  getWeak:  getWeak,\n\t  onFreeze: onFreeze\n\t};\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP       = __webpack_require__(9)\n\t  , anObject = __webpack_require__(14)\n\t  , getKeys  = __webpack_require__(13);\n\t\n\tmodule.exports = __webpack_require__(7) ? Object.defineProperties : function defineProperties(O, Properties){\n\t  anObject(O);\n\t  var keys   = getKeys(Properties)\n\t    , length = keys.length\n\t    , i = 0\n\t    , P;\n\t  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n\t  return O;\n\t};\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar pIE            = __webpack_require__(25)\n\t  , createDesc     = __webpack_require__(16)\n\t  , toIObject      = __webpack_require__(3)\n\t  , toPrimitive    = __webpack_require__(30)\n\t  , has            = __webpack_require__(2)\n\t  , IE8_DOM_DEFINE = __webpack_require__(36)\n\t  , gOPD           = Object.getOwnPropertyDescriptor;\n\t\n\texports.f = __webpack_require__(7) ? gOPD : function getOwnPropertyDescriptor(O, P){\n\t  O = toIObject(O);\n\t  P = toPrimitive(P, true);\n\t  if(IE8_DOM_DEFINE)try {\n\t    return gOPD(O, P);\n\t  } catch(e){ /* empty */ }\n\t  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);\n\t};\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n\tvar toIObject = __webpack_require__(3)\n\t  , gOPN      = __webpack_require__(39).f\n\t  , toString  = {}.toString;\n\t\n\tvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n\t  ? Object.getOwnPropertyNames(window) : [];\n\t\n\tvar getWindowNames = function(it){\n\t  try {\n\t    return gOPN(it);\n\t  } catch(e){\n\t    return windowNames.slice();\n\t  }\n\t};\n\t\n\tmodule.exports.f = function getOwnPropertyNames(it){\n\t  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n\t};\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\n\tvar has         = __webpack_require__(2)\n\t  , toObject    = __webpack_require__(43)\n\t  , IE_PROTO    = __webpack_require__(27)('IE_PROTO')\n\t  , ObjectProto = Object.prototype;\n\t\n\tmodule.exports = Object.getPrototypeOf || function(O){\n\t  O = toObject(O);\n\t  if(has(O, IE_PROTO))return O[IE_PROTO];\n\t  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n\t    return O.constructor.prototype;\n\t  } return O instanceof Object ? ObjectProto : null;\n\t};\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// most Object methods by ES6 should accept primitives\n\tvar $export = __webpack_require__(22)\n\t  , core    = __webpack_require__(11)\n\t  , fails   = __webpack_require__(12);\n\tmodule.exports = function(KEY, exec){\n\t  var fn  = (core.Object || {})[KEY] || Object[KEY]\n\t    , exp = {};\n\t  exp[KEY] = exec(fn);\n\t  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);\n\t};\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(29)\n\t  , defined   = __webpack_require__(20);\n\t// true  -> String#at\n\t// false -> String#codePointAt\n\tmodule.exports = function(TO_STRING){\n\t  return function(that, pos){\n\t    var s = String(defined(that))\n\t      , i = toInteger(pos)\n\t      , l = s.length\n\t      , a, b;\n\t    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n\t    a = s.charCodeAt(i);\n\t    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n\t      ? TO_STRING ? s.charAt(i) : a\n\t      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n\t  };\n\t};\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(29)\n\t  , max       = Math.max\n\t  , min       = Math.min;\n\tmodule.exports = function(index, length){\n\t  index = toInteger(index);\n\t  return index < 0 ? max(index + length, 0) : min(index, length);\n\t};\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.15 ToLength\n\tvar toInteger = __webpack_require__(29)\n\t  , min       = Math.min;\n\tmodule.exports = function(it){\n\t  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n\t};\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar addToUnscopables = __webpack_require__(63)\n\t  , step             = __webpack_require__(71)\n\t  , Iterators        = __webpack_require__(23)\n\t  , toIObject        = __webpack_require__(3);\n\t\n\t// 22.1.3.4 Array.prototype.entries()\n\t// 22.1.3.13 Array.prototype.keys()\n\t// 22.1.3.29 Array.prototype.values()\n\t// 22.1.3.30 Array.prototype[@@iterator]()\n\tmodule.exports = __webpack_require__(37)(Array, 'Array', function(iterated, kind){\n\t  this._t = toIObject(iterated); // target\n\t  this._i = 0;                   // next index\n\t  this._k = kind;                // kind\n\t// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , kind  = this._k\n\t    , index = this._i++;\n\t  if(!O || index >= O.length){\n\t    this._t = undefined;\n\t    return step(1);\n\t  }\n\t  if(kind == 'keys'  )return step(0, index);\n\t  if(kind == 'values')return step(0, O[index]);\n\t  return step(0, [index, O[index]]);\n\t}, 'values');\n\t\n\t// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n\tIterators.Arguments = Iterators.Array;\n\t\n\taddToUnscopables('keys');\n\taddToUnscopables('values');\n\taddToUnscopables('entries');\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.14 Object.keys(O)\n\tvar toObject = __webpack_require__(43)\n\t  , $keys    = __webpack_require__(13);\n\t\n\t__webpack_require__(78)('keys', function(){\n\t  return function keys(it){\n\t    return $keys(toObject(it));\n\t  };\n\t});\n\n/***/ },\n/* 84 */\n/***/ function(module, exports) {\n\n\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $at  = __webpack_require__(79)(true);\n\t\n\t// 21.1.3.27 String.prototype[@@iterator]()\n\t__webpack_require__(37)(String, 'String', function(iterated){\n\t  this._t = String(iterated); // target\n\t  this._i = 0;                // next index\n\t// 21.1.5.2.1 %StringIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , index = this._i\n\t    , point;\n\t  if(index >= O.length)return {value: undefined, done: true};\n\t  point = $at(O, index);\n\t  this._i += point.length;\n\t  return {value: point, done: false};\n\t});\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// ECMAScript 6 symbols shim\n\tvar global         = __webpack_require__(1)\n\t  , has            = __webpack_require__(2)\n\t  , DESCRIPTORS    = __webpack_require__(7)\n\t  , $export        = __webpack_require__(22)\n\t  , redefine       = __webpack_require__(42)\n\t  , META           = __webpack_require__(73).KEY\n\t  , $fails         = __webpack_require__(12)\n\t  , shared         = __webpack_require__(28)\n\t  , setToStringTag = __webpack_require__(26)\n\t  , uid            = __webpack_require__(17)\n\t  , wks            = __webpack_require__(10)\n\t  , wksExt         = __webpack_require__(32)\n\t  , wksDefine      = __webpack_require__(31)\n\t  , keyOf          = __webpack_require__(72)\n\t  , enumKeys       = __webpack_require__(66)\n\t  , isArray        = __webpack_require__(69)\n\t  , anObject       = __webpack_require__(14)\n\t  , toIObject      = __webpack_require__(3)\n\t  , toPrimitive    = __webpack_require__(30)\n\t  , createDesc     = __webpack_require__(16)\n\t  , _create        = __webpack_require__(38)\n\t  , gOPNExt        = __webpack_require__(76)\n\t  , $GOPD          = __webpack_require__(75)\n\t  , $DP            = __webpack_require__(9)\n\t  , $keys          = __webpack_require__(13)\n\t  , gOPD           = $GOPD.f\n\t  , dP             = $DP.f\n\t  , gOPN           = gOPNExt.f\n\t  , $Symbol        = global.Symbol\n\t  , $JSON          = global.JSON\n\t  , _stringify     = $JSON && $JSON.stringify\n\t  , PROTOTYPE      = 'prototype'\n\t  , HIDDEN         = wks('_hidden')\n\t  , TO_PRIMITIVE   = wks('toPrimitive')\n\t  , isEnum         = {}.propertyIsEnumerable\n\t  , SymbolRegistry = shared('symbol-registry')\n\t  , AllSymbols     = shared('symbols')\n\t  , OPSymbols      = shared('op-symbols')\n\t  , ObjectProto    = Object[PROTOTYPE]\n\t  , USE_NATIVE     = typeof $Symbol == 'function'\n\t  , QObject        = global.QObject;\n\t// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\n\tvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\t\n\t// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\n\tvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n\t  return _create(dP({}, 'a', {\n\t    get: function(){ return dP(this, 'a', {value: 7}).a; }\n\t  })).a != 7;\n\t}) ? function(it, key, D){\n\t  var protoDesc = gOPD(ObjectProto, key);\n\t  if(protoDesc)delete ObjectProto[key];\n\t  dP(it, key, D);\n\t  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);\n\t} : dP;\n\t\n\tvar wrap = function(tag){\n\t  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n\t  sym._k = tag;\n\t  return sym;\n\t};\n\t\n\tvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){\n\t  return typeof it == 'symbol';\n\t} : function(it){\n\t  return it instanceof $Symbol;\n\t};\n\t\n\tvar $defineProperty = function defineProperty(it, key, D){\n\t  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);\n\t  anObject(it);\n\t  key = toPrimitive(key, true);\n\t  anObject(D);\n\t  if(has(AllSymbols, key)){\n\t    if(!D.enumerable){\n\t      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));\n\t      it[HIDDEN][key] = true;\n\t    } else {\n\t      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n\t      D = _create(D, {enumerable: createDesc(0, false)});\n\t    } return setSymbolDesc(it, key, D);\n\t  } return dP(it, key, D);\n\t};\n\tvar $defineProperties = function defineProperties(it, P){\n\t  anObject(it);\n\t  var keys = enumKeys(P = toIObject(P))\n\t    , i    = 0\n\t    , l = keys.length\n\t    , key;\n\t  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n\t  return it;\n\t};\n\tvar $create = function create(it, P){\n\t  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n\t};\n\tvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n\t  var E = isEnum.call(this, key = toPrimitive(key, true));\n\t  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;\n\t  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n\t};\n\tvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n\t  it  = toIObject(it);\n\t  key = toPrimitive(key, true);\n\t  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;\n\t  var D = gOPD(it, key);\n\t  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n\t  return D;\n\t};\n\tvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n\t  var names  = gOPN(toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i){\n\t    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);\n\t  } return result;\n\t};\n\tvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n\t  var IS_OP  = it === ObjectProto\n\t    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i){\n\t    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);\n\t  } return result;\n\t};\n\t\n\t// 19.4.1.1 Symbol([description])\n\tif(!USE_NATIVE){\n\t  $Symbol = function Symbol(){\n\t    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');\n\t    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n\t    var $set = function(value){\n\t      if(this === ObjectProto)$set.call(OPSymbols, value);\n\t      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n\t      setSymbolDesc(this, tag, createDesc(1, value));\n\t    };\n\t    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});\n\t    return wrap(tag);\n\t  };\n\t  redefine($Symbol[PROTOTYPE], 'toString', function toString(){\n\t    return this._k;\n\t  });\n\t\n\t  $GOPD.f = $getOwnPropertyDescriptor;\n\t  $DP.f   = $defineProperty;\n\t  __webpack_require__(39).f = gOPNExt.f = $getOwnPropertyNames;\n\t  __webpack_require__(25).f  = $propertyIsEnumerable;\n\t  __webpack_require__(40).f = $getOwnPropertySymbols;\n\t\n\t  if(DESCRIPTORS && !__webpack_require__(24)){\n\t    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n\t  }\n\t\n\t  wksExt.f = function(name){\n\t    return wrap(wks(name));\n\t  }\n\t}\n\t\n\t$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});\n\t\n\tfor(var symbols = (\n\t  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n\t  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n\t).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);\n\t\n\tfor(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);\n\t\n\t$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n\t  // 19.4.2.1 Symbol.for(key)\n\t  'for': function(key){\n\t    return has(SymbolRegistry, key += '')\n\t      ? SymbolRegistry[key]\n\t      : SymbolRegistry[key] = $Symbol(key);\n\t  },\n\t  // 19.4.2.5 Symbol.keyFor(sym)\n\t  keyFor: function keyFor(key){\n\t    if(isSymbol(key))return keyOf(SymbolRegistry, key);\n\t    throw TypeError(key + ' is not a symbol!');\n\t  },\n\t  useSetter: function(){ setter = true; },\n\t  useSimple: function(){ setter = false; }\n\t});\n\t\n\t$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n\t  // 19.1.2.2 Object.create(O [, Properties])\n\t  create: $create,\n\t  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n\t  defineProperty: $defineProperty,\n\t  // 19.1.2.3 Object.defineProperties(O, Properties)\n\t  defineProperties: $defineProperties,\n\t  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n\t  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n\t  // 19.1.2.7 Object.getOwnPropertyNames(O)\n\t  getOwnPropertyNames: $getOwnPropertyNames,\n\t  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n\t  getOwnPropertySymbols: $getOwnPropertySymbols\n\t});\n\t\n\t// 24.3.2 JSON.stringify(value [, replacer [, space]])\n\t$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){\n\t  var S = $Symbol();\n\t  // MS Edge converts symbol values to JSON as {}\n\t  // WebKit converts symbol values to JSON as null\n\t  // V8 throws on boxed symbols\n\t  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n\t})), 'JSON', {\n\t  stringify: function stringify(it){\n\t    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n\t    var args = [it]\n\t      , i    = 1\n\t      , replacer, $replacer;\n\t    while(arguments.length > i)args.push(arguments[i++]);\n\t    replacer = args[1];\n\t    if(typeof replacer == 'function')$replacer = replacer;\n\t    if($replacer || !isArray(replacer))replacer = function(key, value){\n\t      if($replacer)value = $replacer.call(this, key, value);\n\t      if(!isSymbol(value))return value;\n\t    };\n\t    args[1] = replacer;\n\t    return _stringify.apply($JSON, args);\n\t  }\n\t});\n\t\n\t// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n\t$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(8)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n\t// 19.4.3.5 Symbol.prototype[@@toStringTag]\n\tsetToStringTag($Symbol, 'Symbol');\n\t// 20.2.1.9 Math[@@toStringTag]\n\tsetToStringTag(Math, 'Math', true);\n\t// 24.3.3 JSON[@@toStringTag]\n\tsetToStringTag(global.JSON, 'JSON', true);\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(31)('asyncIterator');\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(31)('observable');\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(82);\n\tvar global        = __webpack_require__(1)\n\t  , hide          = __webpack_require__(8)\n\t  , Iterators     = __webpack_require__(23)\n\t  , TO_STRING_TAG = __webpack_require__(10)('toStringTag');\n\t\n\tfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n\t  var NAME       = collections[i]\n\t    , Collection = global[NAME]\n\t    , proto      = Collection && Collection.prototype;\n\t  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n\t  Iterators[NAME] = Iterators.Array;\n\t}\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(4)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/* Menu Item Hover */\\n.ui.dropdown .menu > .item:hover {\\n  background: none transparent !important;\\n}\\n\\n/* Menu Item Hover for Key event */\\n.ui.dropdown .menu > .item.current {\\n  background: rgba(0, 0, 0, 0.05) !important;\\n}\\n\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 91 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(4)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"/*!\\n * # Semantic UI 2.2.3 - Dropdown\\n * http://github.com/semantic-org/semantic-ui/\\n *\\n *\\n * Released under the MIT license\\n * http://opensource.org/licenses/MIT\\n *\\n */\\n\\n\\n/*******************************\\n            Dropdown\\n*******************************/\\n.ui.dropdown[data-v-3a0c7bea] {\\n  cursor: pointer;\\n  position: relative;\\n  display: inline-block;\\n  outline: none;\\n  text-align: left;\\n  -webkit-transition: box-shadow 0.1s ease, width 0.1s ease;\\n  transition: box-shadow 0.1s ease, width 0.1s ease;\\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\n}\\n\\n\\n/*******************************\\n            Content\\n*******************************/\\n\\n\\n/*--------------\\n      Menu\\n---------------*/\\n.ui.dropdown .menu[data-v-3a0c7bea] {\\n  cursor: auto;\\n  position: absolute;\\n  display: none;\\n  outline: none;\\n  top: 100%;\\n  min-width: -webkit-max-content;\\n  min-width: -moz-max-content;\\n  min-width: max-content;\\n  margin: 0em;\\n  padding: 0em 0em;\\n  background: #FFFFFF;\\n  font-size: 1em;\\n  text-shadow: none;\\n  text-align: left;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n  border: 1px solid rgba(34, 36, 38, 0.15);\\n  border-radius: 0.28571429rem;\\n  -webkit-transition: opacity 0.1s ease;\\n  transition: opacity 0.1s ease;\\n  z-index: 11;\\n  will-change: transform, opacity;\\n}\\n.ui.dropdown .menu > *[data-v-3a0c7bea] {\\n  white-space: nowrap;\\n}\\n\\n/*--------------\\n  Hidden Input\\n---------------*/\\n.ui.dropdown > input[data-v-3a0c7bea]:not(.search):first-child,\\n.ui.dropdown > select[data-v-3a0c7bea] {\\n  display: none !important;\\n}\\n\\n/*--------------\\n Dropdown Icon\\n---------------*/\\n.ui.dropdown > .dropdown.icon[data-v-3a0c7bea] {\\n  position: relative;\\n  width: auto;\\n  font-size: 0.85714286em;\\n  margin: 0em 0em 0em 1em;\\n}\\n.ui.dropdown .menu > .item .dropdown.icon[data-v-3a0c7bea] {\\n  width: auto;\\n  float: right;\\n  margin: 0em 0em 0em 1em;\\n}\\n.ui.dropdown .menu > .item .dropdown.icon + .text[data-v-3a0c7bea] {\\n  margin-right: 1em;\\n}\\n\\n/*--------------\\n      Text\\n---------------*/\\n.ui.dropdown > .text[data-v-3a0c7bea] {\\n  display: inline-block;\\n  -webkit-transition: none;\\n  transition: none;\\n}\\n\\n/*--------------\\n    Menu Item\\n---------------*/\\n.ui.dropdown .menu > .item[data-v-3a0c7bea] {\\n  position: relative;\\n  cursor: pointer;\\n  display: block;\\n  border: none;\\n  height: auto;\\n  text-align: left;\\n  border-top: none;\\n  line-height: 1em;\\n  color: rgba(0, 0, 0, 0.87);\\n  padding: 0.78571429rem 1.14285714rem !important;\\n  font-size: 1rem;\\n  text-transform: none;\\n  font-weight: normal;\\n  box-shadow: none;\\n  -webkit-touch-callout: none;\\n}\\n.ui.dropdown .menu > .item[data-v-3a0c7bea]:first-child {\\n  border-top-width: 0px;\\n}\\n\\n/*--------------\\n  Floated Content\\n---------------*/\\n.ui.dropdown > .text > [class*=\\\"right floated\\\"][data-v-3a0c7bea],\\n.ui.dropdown .menu .item > [class*=\\\"right floated\\\"][data-v-3a0c7bea] {\\n  float: right !important;\\n  margin-right: 0em !important;\\n  margin-left: 1em !important;\\n}\\n.ui.dropdown > .text > [class*=\\\"left floated\\\"][data-v-3a0c7bea],\\n.ui.dropdown .menu .item > [class*=\\\"left floated\\\"][data-v-3a0c7bea] {\\n  float: left !important;\\n  margin-left: 0em !important;\\n  margin-right: 1em !important;\\n}\\n.ui.dropdown .menu .item > .icon.floated[data-v-3a0c7bea],\\n.ui.dropdown .menu .item > .flag.floated[data-v-3a0c7bea],\\n.ui.dropdown .menu .item > .image.floated[data-v-3a0c7bea],\\n.ui.dropdown .menu .item > img.floated[data-v-3a0c7bea] {\\n  margin-top: 0em;\\n}\\n\\n/*--------------\\n  Menu Divider\\n---------------*/\\n.ui.dropdown .menu > .header[data-v-3a0c7bea] {\\n  margin: 1rem 0rem 0.75rem;\\n  padding: 0em 1.14285714rem;\\n  color: rgba(0, 0, 0, 0.85);\\n  font-size: 0.78571429em;\\n  font-weight: bold;\\n  text-transform: uppercase;\\n}\\n.ui.dropdown .menu > .divider[data-v-3a0c7bea] {\\n  border-top: 1px solid rgba(34, 36, 38, 0.1);\\n  height: 0em;\\n  margin: 0.5em 0em;\\n}\\n.ui.dropdown .menu > .input[data-v-3a0c7bea] {\\n  width: auto;\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  margin: 1.14285714rem 0.78571429rem;\\n  min-width: 10rem;\\n}\\n.ui.dropdown .menu > .header + .input[data-v-3a0c7bea] {\\n  margin-top: 0em;\\n}\\n.ui.dropdown .menu > .input:not(.transparent) input[data-v-3a0c7bea] {\\n  padding: 0.5em 1em;\\n}\\n.ui.dropdown .menu > .input:not(.transparent) .button[data-v-3a0c7bea],\\n.ui.dropdown .menu > .input:not(.transparent) .icon[data-v-3a0c7bea],\\n.ui.dropdown .menu > .input:not(.transparent) .label[data-v-3a0c7bea] {\\n  padding-top: 0.5em;\\n  padding-bottom: 0.5em;\\n}\\n\\n/*-----------------\\n  Item Description\\n-------------------*/\\n.ui.dropdown > .text > .description[data-v-3a0c7bea],\\n.ui.dropdown .menu > .item > .description[data-v-3a0c7bea] {\\n  float: right;\\n  margin: 0em 0em 0em 1em;\\n  color: rgba(0, 0, 0, 0.4);\\n}\\n\\n/*-----------------\\n       Message\\n-------------------*/\\n.ui.dropdown .menu > .message[data-v-3a0c7bea] {\\n  padding: 0.78571429rem 1.14285714rem;\\n  font-weight: normal;\\n}\\n.ui.dropdown .menu > .message[data-v-3a0c7bea]:not(.ui) {\\n  color: rgba(0, 0, 0, 0.4);\\n}\\n\\n/*--------------\\n    Sub Menu\\n---------------*/\\n.ui.dropdown .menu .menu[data-v-3a0c7bea] {\\n  top: 0% !important;\\n  left: 100% !important;\\n  right: auto !important;\\n  margin: 0em 0em 0em -0.5em !important;\\n  border-radius: 0.28571429rem !important;\\n  z-index: 21 !important;\\n}\\n\\n/* Hide Arrow */\\n.ui.dropdown .menu .menu[data-v-3a0c7bea]:after {\\n  display: none;\\n}\\n\\n/*--------------\\n   Sub Elements\\n---------------*/\\n\\n\\n/* Icons / Flags / Labels / Image */\\n.ui.dropdown > .text > .icon[data-v-3a0c7bea],\\n.ui.dropdown > .text > .label[data-v-3a0c7bea],\\n.ui.dropdown > .text > .flag[data-v-3a0c7bea],\\n.ui.dropdown > .text > img[data-v-3a0c7bea],\\n.ui.dropdown > .text > .image[data-v-3a0c7bea] {\\n  margin-top: 0em;\\n}\\n.ui.dropdown .menu > .item > .icon[data-v-3a0c7bea],\\n.ui.dropdown .menu > .item > .label[data-v-3a0c7bea],\\n.ui.dropdown .menu > .item > .flag[data-v-3a0c7bea],\\n.ui.dropdown .menu > .item > .image[data-v-3a0c7bea],\\n.ui.dropdown .menu > .item > img[data-v-3a0c7bea] {\\n  margin-top: 0em;\\n}\\n.ui.dropdown > .text > .icon[data-v-3a0c7bea],\\n.ui.dropdown > .text > .label[data-v-3a0c7bea],\\n.ui.dropdown > .text > .flag[data-v-3a0c7bea],\\n.ui.dropdown > .text > img[data-v-3a0c7bea],\\n.ui.dropdown > .text > .image[data-v-3a0c7bea],\\n.ui.dropdown .menu > .item > .icon[data-v-3a0c7bea],\\n.ui.dropdown .menu > .item > .label[data-v-3a0c7bea],\\n.ui.dropdown .menu > .item > .flag[data-v-3a0c7bea],\\n.ui.dropdown .menu > .item > .image[data-v-3a0c7bea],\\n.ui.dropdown .menu > .item > img[data-v-3a0c7bea] {\\n  margin-left: 0em;\\n  float: none;\\n  margin-right: 0.78571429rem;\\n}\\n\\n/*--------------\\n     Image\\n---------------*/\\n.ui.dropdown > .text > img[data-v-3a0c7bea],\\n.ui.dropdown > .text > .image[data-v-3a0c7bea],\\n.ui.dropdown .menu > .item > .image[data-v-3a0c7bea],\\n.ui.dropdown .menu > .item > img[data-v-3a0c7bea] {\\n  display: inline-block;\\n  vertical-align: middle;\\n  width: auto;\\n  max-height: 2em;\\n}\\n\\n\\n/*******************************\\n            Coupling\\n*******************************/\\n\\n\\n/*--------------\\n      Menu\\n---------------*/\\n\\n\\n/* Remove Menu Item Divider */\\n.ui.dropdown .ui.menu > .item[data-v-3a0c7bea]:before,\\n.ui.menu .ui.dropdown .menu > .item[data-v-3a0c7bea]:before {\\n  display: none;\\n}\\n\\n/* Prevent Menu Item Border */\\n.ui.menu .ui.dropdown .menu .active.item[data-v-3a0c7bea] {\\n  border-left: none;\\n}\\n\\n/* Automatically float dropdown menu right on last menu item */\\n.ui.menu .right.menu .dropdown:last-child .menu[data-v-3a0c7bea],\\n.ui.menu .right.dropdown.item .menu[data-v-3a0c7bea],\\n.ui.buttons > .ui.dropdown:last-child .menu[data-v-3a0c7bea] {\\n  left: auto;\\n  right: 0em;\\n}\\n\\n/*--------------\\n      Label\\n---------------*/\\n\\n\\n/* Dropdown Menu */\\n.ui.label.dropdown .menu[data-v-3a0c7bea] {\\n  min-width: 100%;\\n}\\n\\n/*--------------\\n     Button\\n---------------*/\\n\\n\\n/* No Margin On Icon Button */\\n.ui.dropdown.icon.button > .dropdown.icon[data-v-3a0c7bea] {\\n  margin: 0em;\\n}\\n.ui.button.dropdown .menu[data-v-3a0c7bea] {\\n  min-width: 100%;\\n}\\n\\n\\n/*******************************\\n              Types\\n*******************************/\\n\\n\\n/*--------------\\n    Selection\\n---------------*/\\n\\n\\n/* Displays like a select box */\\n.ui.selection.dropdown[data-v-3a0c7bea] {\\n  cursor: pointer;\\n  word-wrap: break-word;\\n  line-height: 1em;\\n  white-space: normal;\\n  outline: 0;\\n  -webkit-transform: rotateZ(0deg);\\n      -ms-transform: rotate(0deg);\\n          transform: rotateZ(0deg);\\n  min-width: 14em;\\n  min-height: 2.7142em;\\n  background: #FFFFFF;\\n  display: inline-block;\\n  padding: 0.78571429em 2.1em 0.78571429em 1em;\\n  color: rgba(0, 0, 0, 0.87);\\n  box-shadow: none;\\n  border: 1px solid rgba(34, 36, 38, 0.15);\\n  border-radius: 0.28571429rem;\\n  -webkit-transition: box-shadow 0.1s ease, width 0.1s ease;\\n  transition: box-shadow 0.1s ease, width 0.1s ease;\\n}\\n.ui.selection.dropdown.visible[data-v-3a0c7bea],\\n.ui.selection.dropdown.active[data-v-3a0c7bea] {\\n  z-index: 10;\\n}\\nselect.ui.dropdown[data-v-3a0c7bea] {\\n  height: 38px;\\n  padding: 0.5em;\\n  border: 1px solid rgba(34, 36, 38, 0.15);\\n  visibility: visible;\\n}\\n.ui.selection.dropdown > .search.icon[data-v-3a0c7bea],\\n.ui.selection.dropdown > .delete.icon[data-v-3a0c7bea],\\n.ui.selection.dropdown > .dropdown.icon[data-v-3a0c7bea] {\\n  cursor: pointer;\\n  position: absolute;\\n  width: auto;\\n  height: auto;\\n  line-height: 1.2142em;\\n  top: 0.78571429em;\\n  right: 1em;\\n  z-index: 3;\\n  margin: -0.78571429em;\\n  padding: 0.78571429em;\\n  opacity: 0.8;\\n  -webkit-transition: opacity 0.1s ease;\\n  transition: opacity 0.1s ease;\\n}\\n\\n/* Compact */\\n.ui.compact.selection.dropdown[data-v-3a0c7bea] {\\n  min-width: 0px;\\n}\\n\\n/*  Selection Menu */\\n.ui.selection.dropdown .menu[data-v-3a0c7bea] {\\n  overflow-x: hidden;\\n  overflow-y: auto;\\n  -webkit-backface-visibility: hidden;\\n          backface-visibility: hidden;\\n  -webkit-overflow-scrolling: touch;\\n  border-top-width: 0px !important;\\n  width: auto;\\n  outline: none;\\n  margin: 0px -1px;\\n  min-width: calc(100% +  2px );\\n  width: calc(100% +  2px );\\n  border-radius: 0em 0em 0.28571429rem 0.28571429rem;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n  -webkit-transition: opacity 0.1s ease;\\n  transition: opacity 0.1s ease;\\n}\\n.ui.selection.dropdown .menu[data-v-3a0c7bea]:after,\\n.ui.selection.dropdown .menu[data-v-3a0c7bea]:before {\\n  display: none;\\n}\\n\\n/*--------------\\n    Message\\n---------------*/\\n.ui.selection.dropdown .menu > .message[data-v-3a0c7bea] {\\n  padding: 0.78571429rem 1.14285714rem;\\n}\\n@media only screen and (max-width: 767px) {\\n.ui.selection.dropdown .menu[data-v-3a0c7bea] {\\n    max-height: 8.01428571rem;\\n}\\n}\\n@media only screen and (min-width: 768px) {\\n.ui.selection.dropdown .menu[data-v-3a0c7bea] {\\n    max-height: 10.68571429rem;\\n}\\n}\\n@media only screen and (min-width: 992px) {\\n.ui.selection.dropdown .menu[data-v-3a0c7bea] {\\n    max-height: 16.02857143rem;\\n}\\n}\\n@media only screen and (min-width: 1920px) {\\n.ui.selection.dropdown .menu[data-v-3a0c7bea] {\\n    max-height: 21.37142857rem;\\n}\\n}\\n\\n/* Menu Item */\\n.ui.selection.dropdown .menu > .item[data-v-3a0c7bea] {\\n  border-top: 1px solid #FAFAFA;\\n  padding: 0.78571429rem 1.14285714rem !important;\\n  white-space: normal;\\n  word-wrap: normal;\\n}\\n\\n/* User Item */\\n.ui.selection.dropdown .menu > .hidden.addition.item[data-v-3a0c7bea] {\\n  display: none;\\n}\\n\\n/* Hover */\\n.ui.selection.dropdown[data-v-3a0c7bea]:hover {\\n  border-color: rgba(34, 36, 38, 0.35);\\n  box-shadow: none;\\n}\\n\\n/* Active */\\n.ui.selection.active.dropdown[data-v-3a0c7bea] {\\n  border-color: #96C8DA;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n}\\n.ui.selection.active.dropdown .menu[data-v-3a0c7bea] {\\n  border-color: #96C8DA;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n}\\n\\n/* Focus */\\n.ui.selection.dropdown[data-v-3a0c7bea]:focus {\\n  border-color: #96C8DA;\\n  box-shadow: none;\\n}\\n.ui.selection.dropdown:focus .menu[data-v-3a0c7bea] {\\n  border-color: #96C8DA;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n}\\n\\n/* Visible */\\n.ui.selection.visible.dropdown > .text[data-v-3a0c7bea]:not(.default) {\\n  font-weight: normal;\\n  color: rgba(0, 0, 0, 0.8);\\n}\\n\\n/* Visible Hover */\\n.ui.selection.active.dropdown[data-v-3a0c7bea]:hover {\\n  border-color: #96C8DA;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n}\\n.ui.selection.active.dropdown:hover .menu[data-v-3a0c7bea] {\\n  border-color: #96C8DA;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n}\\n\\n/* Dropdown Icon */\\n.ui.active.selection.dropdown > .dropdown.icon[data-v-3a0c7bea],\\n.ui.visible.selection.dropdown > .dropdown.icon[data-v-3a0c7bea] {\\n  opacity: 1;\\n  z-index: 3;\\n}\\n\\n/* Connecting Border */\\n.ui.active.selection.dropdown[data-v-3a0c7bea] {\\n  border-bottom-left-radius: 0em !important;\\n  border-bottom-right-radius: 0em !important;\\n}\\n\\n/* Empty Connecting Border */\\n.ui.active.empty.selection.dropdown[data-v-3a0c7bea] {\\n  border-radius: 0.28571429rem !important;\\n  box-shadow: none !important;\\n}\\n.ui.active.empty.selection.dropdown .menu[data-v-3a0c7bea] {\\n  border: none !important;\\n  box-shadow: none !important;\\n}\\n\\n/*--------------\\n   Searchable\\n---------------*/\\n\\n\\n/* Search Selection */\\n.ui.search.dropdown[data-v-3a0c7bea] {\\n  min-width: '';\\n}\\n\\n/* Search Dropdown */\\n.ui.search.dropdown > input.search[data-v-3a0c7bea] {\\n  background: none transparent !important;\\n  border: none !important;\\n  box-shadow: none !important;\\n  cursor: text;\\n  top: 0em;\\n  left: 1px;\\n  width: 100%;\\n  outline: none;\\n  -webkit-tap-highlight-color: rgba(255, 255, 255, 0);\\n  padding: inherit;\\n}\\n\\n/* Text Layering */\\n.ui.search.dropdown > input.search[data-v-3a0c7bea] {\\n  position: absolute;\\n  z-index: 2;\\n}\\n.ui.search.dropdown > .text[data-v-3a0c7bea] {\\n  cursor: text;\\n  position: relative;\\n  left: 1px;\\n  z-index: 3;\\n}\\n\\n/* Search Selection */\\n.ui.search.selection.dropdown > input.search[data-v-3a0c7bea] {\\n  line-height: 1.2142em;\\n  padding: 0.67861429em 2.1em 0.67861429em 1em;\\n}\\n\\n/* Used to size multi select input to character width */\\n.ui.search.selection.dropdown > span.sizer[data-v-3a0c7bea] {\\n  line-height: 1.2142em;\\n  padding: 0.67861429em 2.1em 0.67861429em 1em;\\n  display: none;\\n  white-space: pre;\\n}\\n\\n/* Active/Visible Search */\\n.ui.search.dropdown.active > input.search[data-v-3a0c7bea],\\n.ui.search.dropdown.visible > input.search[data-v-3a0c7bea] {\\n  cursor: auto;\\n}\\n.ui.search.dropdown.active > .text[data-v-3a0c7bea],\\n.ui.search.dropdown.visible > .text[data-v-3a0c7bea] {\\n  pointer-events: none;\\n}\\n\\n/* Filtered Text */\\n.ui.active.search.dropdown input.search:focus + .text .icon[data-v-3a0c7bea],\\n.ui.active.search.dropdown input.search:focus + .text .flag[data-v-3a0c7bea] {\\n  opacity: 0.45;\\n}\\n.ui.active.search.dropdown input.search:focus + .text[data-v-3a0c7bea] {\\n  color: rgba(115, 115, 115, 0.87) !important;\\n}\\n\\n/* Search Menu */\\n.ui.search.dropdown .menu[data-v-3a0c7bea] {\\n  overflow-x: hidden;\\n  overflow-y: auto;\\n  -webkit-backface-visibility: hidden;\\n          backface-visibility: hidden;\\n  -webkit-overflow-scrolling: touch;\\n}\\n@media only screen and (max-width: 767px) {\\n.ui.search.dropdown .menu[data-v-3a0c7bea] {\\n    max-height: 8.01428571rem;\\n}\\n}\\n@media only screen and (min-width: 768px) {\\n.ui.search.dropdown .menu[data-v-3a0c7bea] {\\n    max-height: 10.68571429rem;\\n}\\n}\\n@media only screen and (min-width: 992px) {\\n.ui.search.dropdown .menu[data-v-3a0c7bea] {\\n    max-height: 16.02857143rem;\\n}\\n}\\n@media only screen and (min-width: 1920px) {\\n.ui.search.dropdown .menu[data-v-3a0c7bea] {\\n    max-height: 21.37142857rem;\\n}\\n}\\n\\n/*--------------\\n    Multiple\\n---------------*/\\n\\n\\n/* Multiple Selection */\\n.ui.multiple.dropdown[data-v-3a0c7bea] {\\n  padding: 0.22620476em 2.1em 0.22620476em 0.35714286em;\\n}\\n.ui.multiple.dropdown .menu[data-v-3a0c7bea] {\\n  cursor: auto;\\n}\\n\\n/* Multiple Search Selection */\\n.ui.multiple.search.dropdown[data-v-3a0c7bea],\\n.ui.multiple.search.dropdown > input.search[data-v-3a0c7bea] {\\n  cursor: text;\\n}\\n\\n/* Selection Label */\\n.ui.multiple.dropdown > .label[data-v-3a0c7bea] {\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n      -ms-user-select: none;\\n          user-select: none;\\n  display: inline-block;\\n  vertical-align: top;\\n  white-space: normal;\\n  font-size: 1em;\\n  padding: 0.35714286em 0.78571429em;\\n  margin: 0.14285714rem 0.28571429rem 0.14285714rem 0em;\\n  box-shadow: 0px 0px 0px 1px rgba(34, 36, 38, 0.15) inset;\\n}\\n\\n/* Dropdown Icon */\\n.ui.multiple.dropdown .dropdown.icon[data-v-3a0c7bea] {\\n  margin: '';\\n  padding: '';\\n}\\n\\n/* Text */\\n.ui.multiple.dropdown > .text[data-v-3a0c7bea] {\\n  position: static;\\n  padding: 0;\\n  max-width: 100%;\\n  margin: 0.45240952em 0em 0.45240952em 0.64285714em;\\n  line-height: 1.21428571em;\\n}\\n.ui.multiple.dropdown > .label ~ input.search[data-v-3a0c7bea] {\\n  margin-left: 0.14285714em !important;\\n}\\n.ui.multiple.dropdown > .label ~ .text[data-v-3a0c7bea] {\\n  display: none;\\n}\\n\\n/*-----------------\\n  Multiple Search\\n-----------------*/\\n\\n\\n/* Prompt Text */\\n.ui.multiple.search.dropdown > .text[data-v-3a0c7bea] {\\n  display: inline-block;\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  padding: inherit;\\n  margin: 0.45240952em 0em 0.45240952em 0.64285714em;\\n  line-height: 1.21428571em;\\n}\\n.ui.multiple.search.dropdown > .label ~ .text[data-v-3a0c7bea] {\\n  display: none;\\n}\\n\\n/* Search */\\n.ui.multiple.search.dropdown > input.search[data-v-3a0c7bea] {\\n  position: static;\\n  padding: 0;\\n  max-width: 100%;\\n  margin: 0.45240952em 0em 0.45240952em 0.64285714em;\\n  width: 2.2em;\\n  line-height: 1.21428571em;\\n}\\n\\n/*--------------\\n     Inline\\n---------------*/\\n.ui.inline.dropdown[data-v-3a0c7bea] {\\n  cursor: pointer;\\n  display: inline-block;\\n  color: inherit;\\n}\\n.ui.inline.dropdown .dropdown.icon[data-v-3a0c7bea] {\\n  margin: 0em 0.5em 0em 0.21428571em;\\n  vertical-align: baseline;\\n}\\n.ui.inline.dropdown > .text[data-v-3a0c7bea] {\\n  font-weight: bold;\\n}\\n.ui.inline.dropdown .menu[data-v-3a0c7bea] {\\n  cursor: auto;\\n  margin-top: 0.21428571em;\\n  border-radius: 0.28571429rem;\\n}\\n\\n\\n/*******************************\\n            States\\n*******************************/\\n\\n\\n/*--------------------\\n        Active\\n----------------------*/\\n\\n\\n/* Menu Item Active */\\n.ui.dropdown .menu .active.item[data-v-3a0c7bea] {\\n  background: transparent;\\n  font-weight: bold;\\n  color: rgba(0, 0, 0, 0.95);\\n  box-shadow: none;\\n  z-index: 12;\\n}\\n\\n/*--------------------\\n        Hover\\n----------------------*/\\n\\n\\n/* Menu Item Hover */\\n.ui.dropdown .menu > .item[data-v-3a0c7bea]:hover {\\n  background: rgba(0, 0, 0, 0.05);\\n  color: rgba(0, 0, 0, 0.95);\\n  z-index: 13;\\n}\\n\\n/*--------------------\\n       Loading\\n---------------------*/\\n.ui.loading.dropdown > i.icon[data-v-3a0c7bea] {\\n  height: 1em !important;\\n  padding: 1.14285714em 1.07142857em !important;\\n}\\n.ui.loading.dropdown > i.icon[data-v-3a0c7bea]:before {\\n  position: absolute;\\n  content: '';\\n  top: 50%;\\n  left: 50%;\\n  margin: -0.64285714em 0em 0em -0.64285714em;\\n  width: 1.28571429em;\\n  height: 1.28571429em;\\n  border-radius: 500rem;\\n  border: 0.2em solid rgba(0, 0, 0, 0.1);\\n}\\n.ui.loading.dropdown > i.icon[data-v-3a0c7bea]:after {\\n  position: absolute;\\n  content: '';\\n  top: 50%;\\n  left: 50%;\\n  box-shadow: 0px 0px 0px 1px transparent;\\n  margin: -0.64285714em 0em 0em -0.64285714em;\\n  width: 1.28571429em;\\n  height: 1.28571429em;\\n  -webkit-animation: dropdown-spin 0.6s linear;\\n          animation: dropdown-spin 0.6s linear;\\n  -webkit-animation-iteration-count: infinite;\\n          animation-iteration-count: infinite;\\n  border-radius: 500rem;\\n  border-color: #767676 transparent transparent;\\n  border-style: solid;\\n  border-width: 0.2em;\\n}\\n\\n/* Coupling */\\n.ui.loading.dropdown.button > i.icon[data-v-3a0c7bea]:before,\\n.ui.loading.dropdown.button > i.icon[data-v-3a0c7bea]:after {\\n  display: none;\\n}\\n@-webkit-keyframes dropdown-spin {\\nfrom {\\n    -webkit-transform: rotate(0deg);\\n            transform: rotate(0deg);\\n}\\nto {\\n    -webkit-transform: rotate(360deg);\\n            transform: rotate(360deg);\\n}\\n}\\n@keyframes dropdown-spin {\\nfrom {\\n    -webkit-transform: rotate(0deg);\\n            transform: rotate(0deg);\\n}\\nto {\\n    -webkit-transform: rotate(360deg);\\n            transform: rotate(360deg);\\n}\\n}\\n\\n/*--------------------\\n     Default Text\\n----------------------*/\\n.ui.dropdown:not(.button) > .default.text[data-v-3a0c7bea],\\n.ui.default.dropdown:not(.button) > .text[data-v-3a0c7bea] {\\n  color: rgba(191, 191, 191, 0.87);\\n}\\n.ui.dropdown:not(.button) > input:focus + .default.text[data-v-3a0c7bea],\\n.ui.default.dropdown:not(.button) > input:focus + .text[data-v-3a0c7bea] {\\n  color: rgba(115, 115, 115, 0.87);\\n}\\n\\n/*--------------------\\n        Loading\\n----------------------*/\\n.ui.loading.dropdown > .text[data-v-3a0c7bea] {\\n  -webkit-transition: none;\\n  transition: none;\\n}\\n\\n/* Used To Check Position */\\n.ui.dropdown .loading.menu[data-v-3a0c7bea] {\\n  display: block;\\n  visibility: hidden;\\n  z-index: -1;\\n}\\n\\n/*--------------------\\n    Keyboard Select\\n----------------------*/\\n\\n\\n/* Selected Item */\\n.ui.dropdown.selected[data-v-3a0c7bea],\\n.ui.dropdown .menu .selected.item[data-v-3a0c7bea] {\\n  background: rgba(0, 0, 0, 0.03);\\n  color: rgba(0, 0, 0, 0.95);\\n}\\n\\n/*--------------------\\n    Search Filtered\\n----------------------*/\\n\\n\\n/* Filtered Item */\\n.ui.dropdown > .filtered.text[data-v-3a0c7bea] {\\n  visibility: hidden;\\n}\\n.ui.dropdown .filtered.item[data-v-3a0c7bea] {\\n  display: none !important;\\n}\\n\\n/*--------------------\\n        Error\\n----------------------*/\\n.ui.dropdown.error[data-v-3a0c7bea],\\n.ui.dropdown.error > .text[data-v-3a0c7bea],\\n.ui.dropdown.error > .default.text[data-v-3a0c7bea] {\\n  color: #9F3A38;\\n}\\n.ui.selection.dropdown.error[data-v-3a0c7bea] {\\n  background: #FFF6F6;\\n  border-color: #E0B4B4;\\n}\\n.ui.selection.dropdown.error[data-v-3a0c7bea]:hover {\\n  border-color: #E0B4B4;\\n}\\n.ui.dropdown.error > .menu[data-v-3a0c7bea],\\n.ui.dropdown.error > .menu .menu[data-v-3a0c7bea] {\\n  border-color: #E0B4B4;\\n}\\n.ui.dropdown.error > .menu > .item[data-v-3a0c7bea] {\\n  color: #9F3A38;\\n}\\n.ui.multiple.selection.error.dropdown > .label[data-v-3a0c7bea] {\\n  border-color: #E0B4B4;\\n}\\n\\n/* Item Hover */\\n.ui.dropdown.error > .menu > .item[data-v-3a0c7bea]:hover {\\n  background-color: #FFF2F2;\\n}\\n\\n/* Item Active */\\n.ui.dropdown.error > .menu .active.item[data-v-3a0c7bea] {\\n  background-color: #FDCFCF;\\n}\\n\\n/*--------------------\\n        Disabled\\n----------------------*/\\n\\n\\n/* Disabled */\\n.ui.disabled.dropdown[data-v-3a0c7bea],\\n.ui.dropdown .menu > .disabled.item[data-v-3a0c7bea] {\\n  cursor: default;\\n  pointer-events: none;\\n  opacity: 0.45;\\n}\\n\\n\\n/*******************************\\n           Variations\\n*******************************/\\n\\n\\n/*--------------\\n    Direction\\n---------------*/\\n\\n\\n/* Flyout Direction */\\n.ui.dropdown .menu[data-v-3a0c7bea] {\\n  left: 0px;\\n}\\n\\n/* Default Side (Right) */\\n.ui.dropdown .right.menu > .menu[data-v-3a0c7bea],\\n.ui.dropdown .menu .right.menu[data-v-3a0c7bea] {\\n  left: 100% !important;\\n  right: auto !important;\\n  border-radius: 0.28571429rem !important;\\n}\\n\\n/* Left Flyout Menu */\\n.ui.dropdown > .left.menu .menu[data-v-3a0c7bea],\\n.ui.dropdown .menu .left.menu[data-v-3a0c7bea] {\\n  left: auto !important;\\n  right: 100% !important;\\n  border-radius: 0.28571429rem !important;\\n}\\n.ui.dropdown .item .left.dropdown.icon[data-v-3a0c7bea],\\n.ui.dropdown .left.menu .item .dropdown.icon[data-v-3a0c7bea] {\\n  width: auto;\\n  float: left;\\n  margin: 0em 0.78571429rem 0em 0em;\\n}\\n.ui.dropdown .item .left.dropdown.icon[data-v-3a0c7bea],\\n.ui.dropdown .left.menu .item .dropdown.icon[data-v-3a0c7bea] {\\n  width: auto;\\n  float: left;\\n  margin: 0em 0.78571429rem 0em 0em;\\n}\\n.ui.dropdown .item .left.dropdown.icon + .text[data-v-3a0c7bea],\\n.ui.dropdown .left.menu .item .dropdown.icon + .text[data-v-3a0c7bea] {\\n  margin-left: 1em;\\n}\\n\\n/*--------------\\n     Upward\\n---------------*/\\n\\n\\n/* Upward Main Menu */\\n.ui.upward.dropdown > .menu[data-v-3a0c7bea] {\\n  top: auto;\\n  bottom: 100%;\\n  box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.08);\\n  border-radius: 0.28571429rem 0.28571429rem 0em 0em;\\n}\\n\\n/* Upward Sub Menu */\\n.ui.dropdown .upward.menu[data-v-3a0c7bea] {\\n  top: auto !important;\\n  bottom: 0 !important;\\n}\\n\\n/* Active Upward */\\n.ui.simple.upward.active.dropdown[data-v-3a0c7bea],\\n.ui.simple.upward.dropdown[data-v-3a0c7bea]:hover {\\n  border-radius: 0.28571429rem 0.28571429rem 0em 0em !important;\\n}\\n.ui.upward.dropdown.button:not(.pointing):not(.floating).active[data-v-3a0c7bea] {\\n  border-radius: 0.28571429rem 0.28571429rem 0em 0em;\\n}\\n\\n/* Selection */\\n.ui.upward.selection.dropdown .menu[data-v-3a0c7bea] {\\n  border-top-width: 1px !important;\\n  border-bottom-width: 0px !important;\\n  box-shadow: 0px -2px 3px 0px rgba(0, 0, 0, 0.08);\\n}\\n.ui.upward.selection.dropdown[data-v-3a0c7bea]:hover {\\n  box-shadow: 0px 0px 2px 0px rgba(0, 0, 0, 0.05);\\n}\\n\\n/* Active Upward */\\n.ui.active.upward.selection.dropdown[data-v-3a0c7bea] {\\n  border-radius: 0em 0em 0.28571429rem 0.28571429rem !important;\\n}\\n\\n/* Visible Upward */\\n.ui.upward.selection.dropdown.visible[data-v-3a0c7bea] {\\n  box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.08);\\n  border-radius: 0em 0em 0.28571429rem 0.28571429rem !important;\\n}\\n\\n/* Visible Hover Upward */\\n.ui.upward.active.selection.dropdown[data-v-3a0c7bea]:hover {\\n  box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.05);\\n}\\n.ui.upward.active.selection.dropdown:hover .menu[data-v-3a0c7bea] {\\n  box-shadow: 0px -2px 3px 0px rgba(0, 0, 0, 0.08);\\n}\\n\\n/*--------------\\n     Simple\\n---------------*/\\n\\n\\n/*  Selection Menu */\\n.ui.scrolling.dropdown .menu[data-v-3a0c7bea],\\n.ui.dropdown .scrolling.menu[data-v-3a0c7bea] {\\n  overflow-x: hidden;\\n  overflow-y: auto;\\n}\\n.ui.scrolling.dropdown .menu[data-v-3a0c7bea] {\\n  overflow-x: hidden;\\n  overflow-y: auto;\\n  -webkit-backface-visibility: hidden;\\n          backface-visibility: hidden;\\n  -webkit-overflow-scrolling: touch;\\n  min-width: 100% !important;\\n  width: auto !important;\\n}\\n.ui.dropdown .scrolling.menu[data-v-3a0c7bea] {\\n  position: static;\\n  overflow-y: auto;\\n  border: none;\\n  box-shadow: none !important;\\n  border-radius: 0 !important;\\n  margin: 0 !important;\\n  min-width: 100% !important;\\n  width: auto !important;\\n  border-top: 1px solid rgba(34, 36, 38, 0.15);\\n}\\n.ui.scrolling.dropdown .menu .item.item.item[data-v-3a0c7bea],\\n.ui.dropdown .scrolling.menu > .item.item.item[data-v-3a0c7bea] {\\n  border-top: none;\\n  padding-right: calc( 1.14285714rem  +  17px ) !important;\\n}\\n.ui.scrolling.dropdown .menu .item[data-v-3a0c7bea]:first-child,\\n.ui.dropdown .scrolling.menu .item[data-v-3a0c7bea]:first-child {\\n  border-top: none;\\n}\\n.ui.dropdown > .animating.menu .scrolling.menu[data-v-3a0c7bea],\\n.ui.dropdown > .visible.menu .scrolling.menu[data-v-3a0c7bea] {\\n  display: block;\\n}\\n\\n/* Scrollbar in IE */\\n@media all and (-ms-high-contrast: none) {\\n.ui.scrolling.dropdown .menu[data-v-3a0c7bea],\\n  .ui.dropdown .scrolling.menu[data-v-3a0c7bea] {\\n    min-width: calc(100% -  17px );\\n}\\n}\\n@media only screen and (max-width: 767px) {\\n.ui.scrolling.dropdown .menu[data-v-3a0c7bea],\\n  .ui.dropdown .scrolling.menu[data-v-3a0c7bea] {\\n    max-height: 10.28571429rem;\\n}\\n}\\n@media only screen and (min-width: 768px) {\\n.ui.scrolling.dropdown .menu[data-v-3a0c7bea],\\n  .ui.dropdown .scrolling.menu[data-v-3a0c7bea] {\\n    max-height: 15.42857143rem;\\n}\\n}\\n@media only screen and (min-width: 992px) {\\n.ui.scrolling.dropdown .menu[data-v-3a0c7bea],\\n  .ui.dropdown .scrolling.menu[data-v-3a0c7bea] {\\n    max-height: 20.57142857rem;\\n}\\n}\\n@media only screen and (min-width: 1920px) {\\n.ui.scrolling.dropdown .menu[data-v-3a0c7bea],\\n  .ui.dropdown .scrolling.menu[data-v-3a0c7bea] {\\n    max-height: 20.57142857rem;\\n}\\n}\\n\\n/*--------------\\n     Simple\\n---------------*/\\n\\n\\n/* Displays without javascript */\\n.ui.simple.dropdown .menu[data-v-3a0c7bea]:before,\\n.ui.simple.dropdown .menu[data-v-3a0c7bea]:after {\\n  display: none;\\n}\\n.ui.simple.dropdown .menu[data-v-3a0c7bea] {\\n  position: absolute;\\n  display: block;\\n  overflow: hidden;\\n  top: -9999px !important;\\n  opacity: 0;\\n  width: 0;\\n  height: 0;\\n  -webkit-transition: opacity 0.1s ease;\\n  transition: opacity 0.1s ease;\\n}\\n.ui.simple.active.dropdown[data-v-3a0c7bea],\\n.ui.simple.dropdown[data-v-3a0c7bea]:hover {\\n  border-bottom-left-radius: 0em !important;\\n  border-bottom-right-radius: 0em !important;\\n}\\n.ui.simple.active.dropdown > .menu[data-v-3a0c7bea],\\n.ui.simple.dropdown:hover > .menu[data-v-3a0c7bea] {\\n  overflow: visible;\\n  width: auto;\\n  height: auto;\\n  top: 100% !important;\\n  opacity: 1;\\n}\\n.ui.simple.dropdown > .menu > .item:active > .menu[data-v-3a0c7bea],\\n.ui.simple.dropdown:hover > .menu > .item:hover > .menu[data-v-3a0c7bea] {\\n  overflow: visible;\\n  width: auto;\\n  height: auto;\\n  top: 0% !important;\\n  left: 100% !important;\\n  opacity: 1;\\n}\\n.ui.simple.disabled.dropdown:hover .menu[data-v-3a0c7bea] {\\n  display: none;\\n  height: 0px;\\n  width: 0px;\\n  overflow: hidden;\\n}\\n\\n/* Visible */\\n.ui.simple.visible.dropdown > .menu[data-v-3a0c7bea] {\\n  display: block;\\n}\\n\\n/*--------------\\n      Fluid\\n---------------*/\\n.ui.fluid.dropdown[data-v-3a0c7bea] {\\n  display: block;\\n  width: 100%;\\n  min-width: 0em;\\n}\\n.ui.fluid.dropdown > .dropdown.icon[data-v-3a0c7bea] {\\n  float: right;\\n}\\n\\n/*--------------\\n    Floating\\n---------------*/\\n.ui.floating.dropdown .menu[data-v-3a0c7bea] {\\n  left: 0;\\n  right: auto;\\n  box-shadow: 0px 2px 4px 0px rgba(34, 36, 38, 0.12), 0px 2px 10px 0px rgba(34, 36, 38, 0.15) !important;\\n  border-radius: 0.28571429rem !important;\\n}\\n.ui.floating.dropdown > .menu[data-v-3a0c7bea] {\\n  margin-top: 0.5em !important;\\n  border-radius: 0.28571429rem !important;\\n}\\n\\n/*--------------\\n     Pointing\\n---------------*/\\n.ui.pointing.dropdown > .menu[data-v-3a0c7bea] {\\n  top: 100%;\\n  margin-top: 0.78571429rem;\\n  border-radius: 0.28571429rem;\\n}\\n.ui.pointing.dropdown > .menu[data-v-3a0c7bea]:after {\\n  display: block;\\n  position: absolute;\\n  pointer-events: none;\\n  content: '';\\n  visibility: visible;\\n  -webkit-transform: rotate(45deg);\\n      -ms-transform: rotate(45deg);\\n          transform: rotate(45deg);\\n  width: 0.5em;\\n  height: 0.5em;\\n  box-shadow: -1px -1px 0px 1px rgba(34, 36, 38, 0.15);\\n  background: #FFFFFF;\\n  z-index: 2;\\n}\\n.ui.pointing.dropdown > .menu[data-v-3a0c7bea]:after {\\n  top: -0.25em;\\n  left: 50%;\\n  margin: 0em 0em 0em -0.25em;\\n}\\n\\n/* Top Left Pointing */\\n.ui.top.left.pointing.dropdown > .menu[data-v-3a0c7bea] {\\n  top: 100%;\\n  bottom: auto;\\n  left: 0%;\\n  right: auto;\\n  margin: 1em 0em 0em;\\n}\\n.ui.top.left.pointing.dropdown > .menu[data-v-3a0c7bea] {\\n  top: 100%;\\n  bottom: auto;\\n  left: 0%;\\n  right: auto;\\n  margin: 1em 0em 0em;\\n}\\n.ui.top.left.pointing.dropdown > .menu[data-v-3a0c7bea]:after {\\n  top: -0.25em;\\n  left: 1em;\\n  right: auto;\\n  margin: 0em;\\n  -webkit-transform: rotate(45deg);\\n      -ms-transform: rotate(45deg);\\n          transform: rotate(45deg);\\n}\\n\\n/* Top Right  Pointing */\\n.ui.top.right.pointing.dropdown > .menu[data-v-3a0c7bea] {\\n  top: 100%;\\n  bottom: auto;\\n  right: 0%;\\n  left: auto;\\n  margin: 1em 0em 0em;\\n}\\n.ui.top.right.pointing.dropdown > .menu[data-v-3a0c7bea]:after {\\n  top: -0.25em;\\n  left: auto;\\n  right: 1em;\\n  margin: 0em;\\n  -webkit-transform: rotate(45deg);\\n      -ms-transform: rotate(45deg);\\n          transform: rotate(45deg);\\n}\\n\\n/* Left Pointing */\\n.ui.left.pointing.dropdown > .menu[data-v-3a0c7bea] {\\n  top: 0%;\\n  left: 100%;\\n  right: auto;\\n  margin: 0em 0em 0em 1em;\\n}\\n.ui.left.pointing.dropdown > .menu[data-v-3a0c7bea]:after {\\n  top: 1em;\\n  left: -0.25em;\\n  margin: 0em 0em 0em 0em;\\n  -webkit-transform: rotate(-45deg);\\n      -ms-transform: rotate(-45deg);\\n          transform: rotate(-45deg);\\n}\\n\\n/* Right Pointing */\\n.ui.right.pointing.dropdown > .menu[data-v-3a0c7bea] {\\n  top: 0%;\\n  left: auto;\\n  right: 100%;\\n  margin: 0em 1em 0em 0em;\\n}\\n.ui.right.pointing.dropdown > .menu[data-v-3a0c7bea]:after {\\n  top: 1em;\\n  left: auto;\\n  right: -0.25em;\\n  margin: 0em 0em 0em 0em;\\n  -webkit-transform: rotate(135deg);\\n      -ms-transform: rotate(135deg);\\n          transform: rotate(135deg);\\n}\\n\\n/* Bottom Pointing */\\n.ui.bottom.pointing.dropdown > .menu[data-v-3a0c7bea] {\\n  top: auto;\\n  bottom: 100%;\\n  left: 0%;\\n  right: auto;\\n  margin: 0em 0em 1em;\\n}\\n.ui.bottom.pointing.dropdown > .menu[data-v-3a0c7bea]:after {\\n  top: auto;\\n  bottom: -0.25em;\\n  right: auto;\\n  margin: 0em;\\n  -webkit-transform: rotate(-135deg);\\n      -ms-transform: rotate(-135deg);\\n          transform: rotate(-135deg);\\n}\\n\\n/* Reverse Sub-Menu Direction */\\n.ui.bottom.pointing.dropdown > .menu .menu[data-v-3a0c7bea] {\\n  top: auto !important;\\n  bottom: 0px !important;\\n}\\n\\n/* Bottom Left */\\n.ui.bottom.left.pointing.dropdown > .menu[data-v-3a0c7bea] {\\n  left: 0%;\\n  right: auto;\\n}\\n.ui.bottom.left.pointing.dropdown > .menu[data-v-3a0c7bea]:after {\\n  left: 1em;\\n  right: auto;\\n}\\n\\n/* Bottom Right */\\n.ui.bottom.right.pointing.dropdown > .menu[data-v-3a0c7bea] {\\n  right: 0%;\\n  left: auto;\\n}\\n.ui.bottom.right.pointing.dropdown > .menu[data-v-3a0c7bea]:after {\\n  left: auto;\\n  right: 1em;\\n}\\n\\n/* Upward pointing */\\n.ui.upward.pointing.dropdown > .menu[data-v-3a0c7bea],\\n.ui.upward.top.pointing.dropdown > .menu[data-v-3a0c7bea] {\\n  top: auto;\\n  bottom: 100%;\\n  margin: 0em 0em 0.78571429rem;\\n  border-radius: 0.28571429rem;\\n}\\n.ui.upward.pointing.dropdown > .menu[data-v-3a0c7bea]:after,\\n.ui.upward.top.pointing.dropdown > .menu[data-v-3a0c7bea]:after {\\n  top: 100%;\\n  bottom: auto;\\n  box-shadow: 1px 1px 0px 1px rgba(34, 36, 38, 0.15);\\n  margin: -0.25em 0em 0em;\\n}\\n\\n\\n/*******************************\\n         Theme Overrides\\n*******************************/\\n\\n\\n/* Dropdown Carets */\\n@font-face {\\n  font-family: 'Dropdown';\\n  src: url(data:application/x-font-ttf;charset=utf-8;base64,AAEAAAALAIAAAwAwT1MvMggjB5AAAAC8AAAAYGNtYXAPfuIIAAABHAAAAExnYXNwAAAAEAAAAWgAAAAIZ2x5Zjo82LgAAAFwAAABVGhlYWQAQ88bAAACxAAAADZoaGVhAwcB6QAAAvwAAAAkaG10eAS4ABIAAAMgAAAAIGxvY2EBNgDeAAADQAAAABJtYXhwAAoAFgAAA1QAAAAgbmFtZVcZpu4AAAN0AAABRXBvc3QAAwAAAAAEvAAAACAAAwIAAZAABQAAAUwBZgAAAEcBTAFmAAAA9QAZAIQAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADw2gHg/+D/4AHgACAAAAABAAAAAAAAAAAAAAAgAAAAAAACAAAAAwAAABQAAwABAAAAFAAEADgAAAAKAAgAAgACAAEAIPDa//3//wAAAAAAIPDX//3//wAB/+MPLQADAAEAAAAAAAAAAAAAAAEAAf//AA8AAQAAAAAAAAAAAAIAADc5AQAAAAABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAIABJQElABMAABM0NzY3BTYXFhUUDwEGJwYvASY1AAUGBwEACAUGBoAFCAcGgAUBEgcGBQEBAQcECQYHfwYBAQZ/BwYAAQAAAG4BJQESABMAADc0PwE2MzIfARYVFAcGIyEiJyY1AAWABgcIBYAGBgUI/wAHBgWABwaABQWABgcHBgUFBgcAAAABABIASQC3AW4AEwAANzQ/ATYXNhcWHQEUBwYnBi8BJjUSBoAFCAcFBgYFBwgFgAbbBwZ/BwEBBwQJ/wgEBwEBB38GBgAAAAABAAAASQClAW4AEwAANxE0NzYzMh8BFhUUDwEGIyInJjUABQYHCAWABgaABQgHBgVbAQAIBQYGgAUIBwWABgYFBwAAAAEAAAABAADZuaKOXw889QALAgAAAAAA0ABHWAAAAADQAEdYAAAAAAElAW4AAAAIAAIAAAAAAAAAAQAAAeD/4AAAAgAAAAAAASUAAQAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAABAAAAASUAAAElAAAAtwASALcAAAAAAAAACgAUAB4AQgBkAIgAqgAAAAEAAAAIABQAAQAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAOAK4AAQAAAAAAAQAOAAAAAQAAAAAAAgAOAEcAAQAAAAAAAwAOACQAAQAAAAAABAAOAFUAAQAAAAAABQAWAA4AAQAAAAAABgAHADIAAQAAAAAACgA0AGMAAwABBAkAAQAOAAAAAwABBAkAAgAOAEcAAwABBAkAAwAOACQAAwABBAkABAAOAFUAAwABBAkABQAWAA4AAwABBAkABgAOADkAAwABBAkACgA0AGMAaQBjAG8AbQBvAG8AbgBWAGUAcgBzAGkAbwBuACAAMQAuADAAaQBjAG8AbQBvAG8Abmljb21vb24AaQBjAG8AbQBvAG8AbgBSAGUAZwB1AGwAYQByAGkAYwBvAG0AbwBvAG4ARgBvAG4AdAAgAGcAZQBuAGUAcgBhAHQAZQBkACAAYgB5ACAASQBjAG8ATQBvAG8AbgAuAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=) format('truetype'), url(data:application/font-woff;charset=utf-8;base64,d09GRk9UVE8AAAVwAAoAAAAABSgAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABDRkYgAAAA9AAAAdkAAAHZLDXE/09TLzIAAALQAAAAYAAAAGAIIweQY21hcAAAAzAAAABMAAAATA9+4ghnYXNwAAADfAAAAAgAAAAIAAAAEGhlYWQAAAOEAAAANgAAADYAQ88baGhlYQAAA7wAAAAkAAAAJAMHAelobXR4AAAD4AAAACAAAAAgBLgAEm1heHAAAAQAAAAABgAAAAYACFAAbmFtZQAABAgAAAFFAAABRVcZpu5wb3N0AAAFUAAAACAAAAAgAAMAAAEABAQAAQEBCGljb21vb24AAQIAAQA6+BwC+BsD+BgEHgoAGVP/i4seCgAZU/+LiwwHi2v4lPh0BR0AAACIDx0AAACNER0AAAAJHQAAAdASAAkBAQgPERMWGyAlKmljb21vb25pY29tb29udTB1MXUyMHVGMEQ3dUYwRDh1RjBEOXVGMERBAAACAYkABgAIAgABAAQABwAKAA0AVgCfAOgBL/yUDvyUDvyUDvuUDvtvi/emFYuQjZCOjo+Pj42Qiwj3lIsFkIuQiY6Hj4iNhouGi4aJh4eHCPsU+xQFiIiGiYaLhouHjYeOCPsU9xQFiI+Jj4uQCA77b4v3FBWLkI2Pjo8I9xT3FAWPjo+NkIuQi5CJjogI9xT7FAWPh42Hi4aLhomHh4eIiIaJhosI+5SLBYaLh42HjoiPiY+LkAgO+92d928Vi5CNkI+OCPcU9xQFjo+QjZCLkIuPiY6Hj4iNhouGCIv7lAWLhomHh4iIh4eJhouGi4aNiI8I+xT3FAWHjomPi5AIDvvdi+YVi/eUBYuQjZCOjo+Pj42Qi5CLkImOhwj3FPsUBY+IjYaLhouGiYeHiAj7FPsUBYiHhomGi4aLh42Hj4iOiY+LkAgO+JQU+JQViwwKAAAAAAMCAAGQAAUAAAFMAWYAAABHAUwBZgAAAPUAGQCEAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA8NoB4P/g/+AB4AAgAAAAAQAAAAAAAAAAAAAAIAAAAAAAAgAAAAMAAAAUAAMAAQAAABQABAA4AAAACgAIAAIAAgABACDw2v/9//8AAAAAACDw1//9//8AAf/jDy0AAwABAAAAAAAAAAAAAAABAAH//wAPAAEAAAABAAA5emozXw889QALAgAAAAAA0ABHWAAAAADQAEdYAAAAAAElAW4AAAAIAAIAAAAAAAAAAQAAAeD/4AAAAgAAAAAAASUAAQAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAABAAAAASUAAAElAAAAtwASALcAAAAAUAAACAAAAAAADgCuAAEAAAAAAAEADgAAAAEAAAAAAAIADgBHAAEAAAAAAAMADgAkAAEAAAAAAAQADgBVAAEAAAAAAAUAFgAOAAEAAAAAAAYABwAyAAEAAAAAAAoANABjAAMAAQQJAAEADgAAAAMAAQQJAAIADgBHAAMAAQQJAAMADgAkAAMAAQQJAAQADgBVAAMAAQQJAAUAFgAOAAMAAQQJAAYADgA5AAMAAQQJAAoANABjAGkAYwBvAG0AbwBvAG4AVgBlAHIAcwBpAG8AbgAgADEALgAwAGkAYwBvAG0AbwBvAG5pY29tb29uAGkAYwBvAG0AbwBvAG4AUgBlAGcAdQBsAGEAcgBpAGMAbwBtAG8AbwBuAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) format('woff');\\n  font-weight: normal;\\n  font-style: normal;\\n}\\n.ui.dropdown > .dropdown.icon[data-v-3a0c7bea] {\\n  font-family: 'Dropdown';\\n  line-height: 1;\\n  height: 1em;\\n  width: 1.23em;\\n  -webkit-backface-visibility: hidden;\\n          backface-visibility: hidden;\\n  font-weight: normal;\\n  font-style: normal;\\n  text-align: center;\\n}\\n.ui.dropdown > .dropdown.icon[data-v-3a0c7bea] {\\n  width: auto;\\n}\\n.ui.dropdown > .dropdown.icon[data-v-3a0c7bea]:before {\\n  content: '\\\\F0D7';\\n}\\n\\n/* Sub Menu */\\n.ui.dropdown .menu .item .dropdown.icon[data-v-3a0c7bea]:before {\\n  content: '\\\\F0DA' ;\\n}\\n.ui.dropdown .item .left.dropdown.icon[data-v-3a0c7bea]:before,\\n.ui.dropdown .left.menu .item .dropdown.icon[data-v-3a0c7bea]:before {\\n  content: \\\"\\\\F0D9\\\" ;\\n}\\n\\n/* Vertical Menu Dropdown */\\n.ui.vertical.menu .dropdown.item > .dropdown.icon[data-v-3a0c7bea]:before {\\n  content: \\\"\\\\F0DA\\\" ;\\n}\\n/* Icons for Reference\\n.dropdown.down.icon {\\n  content: \\\"\\\\f0d7\\\";\\n}\\n.dropdown.up.icon {\\n  content: \\\"\\\\f0d8\\\";\\n}\\n.dropdown.left.icon {\\n  content: \\\"\\\\f0d9\\\";\\n}\\n.dropdown.icon.icon {\\n  content: \\\"\\\\f0da\\\";\\n}\\n*/\\n\\n\\n/*******************************\\n        User Overrides\\n*******************************/\\n\\n\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(4)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/* Menu Item Hover */\\n.ui.dropdown .menu > .item:hover {\\n  background: none transparent !important;\\n}\\n\\n/* Menu Item Hover for Key event */\\n.ui.dropdown .menu > .item.current {\\n  background: rgba(0, 0, 0, 0.05) !important;\\n}\\n\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(4)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"/*!\\n * # Semantic UI 2.2.3 - Dropdown\\n * http://github.com/semantic-org/semantic-ui/\\n *\\n *\\n * Released under the MIT license\\n * http://opensource.org/licenses/MIT\\n *\\n */\\n\\n\\n/*******************************\\n            Dropdown\\n*******************************/\\n.ui.dropdown[data-v-4030daa2] {\\n  cursor: pointer;\\n  position: relative;\\n  display: inline-block;\\n  outline: none;\\n  text-align: left;\\n  -webkit-transition: box-shadow 0.1s ease, width 0.1s ease;\\n  transition: box-shadow 0.1s ease, width 0.1s ease;\\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\n}\\n\\n\\n/*******************************\\n            Content\\n*******************************/\\n\\n\\n/*--------------\\n      Menu\\n---------------*/\\n.ui.dropdown .menu[data-v-4030daa2] {\\n  cursor: auto;\\n  position: absolute;\\n  display: none;\\n  outline: none;\\n  top: 100%;\\n  min-width: -webkit-max-content;\\n  min-width: -moz-max-content;\\n  min-width: max-content;\\n  margin: 0em;\\n  padding: 0em 0em;\\n  background: #FFFFFF;\\n  font-size: 1em;\\n  text-shadow: none;\\n  text-align: left;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n  border: 1px solid rgba(34, 36, 38, 0.15);\\n  border-radius: 0.28571429rem;\\n  -webkit-transition: opacity 0.1s ease;\\n  transition: opacity 0.1s ease;\\n  z-index: 11;\\n  will-change: transform, opacity;\\n}\\n.ui.dropdown .menu > *[data-v-4030daa2] {\\n  white-space: nowrap;\\n}\\n\\n/*--------------\\n  Hidden Input\\n---------------*/\\n.ui.dropdown > input[data-v-4030daa2]:not(.search):first-child,\\n.ui.dropdown > select[data-v-4030daa2] {\\n  display: none !important;\\n}\\n\\n/*--------------\\n Dropdown Icon\\n---------------*/\\n.ui.dropdown > .dropdown.icon[data-v-4030daa2] {\\n  position: relative;\\n  width: auto;\\n  font-size: 0.85714286em;\\n  margin: 0em 0em 0em 1em;\\n}\\n.ui.dropdown .menu > .item .dropdown.icon[data-v-4030daa2] {\\n  width: auto;\\n  float: right;\\n  margin: 0em 0em 0em 1em;\\n}\\n.ui.dropdown .menu > .item .dropdown.icon + .text[data-v-4030daa2] {\\n  margin-right: 1em;\\n}\\n\\n/*--------------\\n      Text\\n---------------*/\\n.ui.dropdown > .text[data-v-4030daa2] {\\n  display: inline-block;\\n  -webkit-transition: none;\\n  transition: none;\\n}\\n\\n/*--------------\\n    Menu Item\\n---------------*/\\n.ui.dropdown .menu > .item[data-v-4030daa2] {\\n  position: relative;\\n  cursor: pointer;\\n  display: block;\\n  border: none;\\n  height: auto;\\n  text-align: left;\\n  border-top: none;\\n  line-height: 1em;\\n  color: rgba(0, 0, 0, 0.87);\\n  padding: 0.78571429rem 1.14285714rem !important;\\n  font-size: 1rem;\\n  text-transform: none;\\n  font-weight: normal;\\n  box-shadow: none;\\n  -webkit-touch-callout: none;\\n}\\n.ui.dropdown .menu > .item[data-v-4030daa2]:first-child {\\n  border-top-width: 0px;\\n}\\n\\n/*--------------\\n  Floated Content\\n---------------*/\\n.ui.dropdown > .text > [class*=\\\"right floated\\\"][data-v-4030daa2],\\n.ui.dropdown .menu .item > [class*=\\\"right floated\\\"][data-v-4030daa2] {\\n  float: right !important;\\n  margin-right: 0em !important;\\n  margin-left: 1em !important;\\n}\\n.ui.dropdown > .text > [class*=\\\"left floated\\\"][data-v-4030daa2],\\n.ui.dropdown .menu .item > [class*=\\\"left floated\\\"][data-v-4030daa2] {\\n  float: left !important;\\n  margin-left: 0em !important;\\n  margin-right: 1em !important;\\n}\\n.ui.dropdown .menu .item > .icon.floated[data-v-4030daa2],\\n.ui.dropdown .menu .item > .flag.floated[data-v-4030daa2],\\n.ui.dropdown .menu .item > .image.floated[data-v-4030daa2],\\n.ui.dropdown .menu .item > img.floated[data-v-4030daa2] {\\n  margin-top: 0em;\\n}\\n\\n/*--------------\\n  Menu Divider\\n---------------*/\\n.ui.dropdown .menu > .header[data-v-4030daa2] {\\n  margin: 1rem 0rem 0.75rem;\\n  padding: 0em 1.14285714rem;\\n  color: rgba(0, 0, 0, 0.85);\\n  font-size: 0.78571429em;\\n  font-weight: bold;\\n  text-transform: uppercase;\\n}\\n.ui.dropdown .menu > .divider[data-v-4030daa2] {\\n  border-top: 1px solid rgba(34, 36, 38, 0.1);\\n  height: 0em;\\n  margin: 0.5em 0em;\\n}\\n.ui.dropdown .menu > .input[data-v-4030daa2] {\\n  width: auto;\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  margin: 1.14285714rem 0.78571429rem;\\n  min-width: 10rem;\\n}\\n.ui.dropdown .menu > .header + .input[data-v-4030daa2] {\\n  margin-top: 0em;\\n}\\n.ui.dropdown .menu > .input:not(.transparent) input[data-v-4030daa2] {\\n  padding: 0.5em 1em;\\n}\\n.ui.dropdown .menu > .input:not(.transparent) .button[data-v-4030daa2],\\n.ui.dropdown .menu > .input:not(.transparent) .icon[data-v-4030daa2],\\n.ui.dropdown .menu > .input:not(.transparent) .label[data-v-4030daa2] {\\n  padding-top: 0.5em;\\n  padding-bottom: 0.5em;\\n}\\n\\n/*-----------------\\n  Item Description\\n-------------------*/\\n.ui.dropdown > .text > .description[data-v-4030daa2],\\n.ui.dropdown .menu > .item > .description[data-v-4030daa2] {\\n  float: right;\\n  margin: 0em 0em 0em 1em;\\n  color: rgba(0, 0, 0, 0.4);\\n}\\n\\n/*-----------------\\n       Message\\n-------------------*/\\n.ui.dropdown .menu > .message[data-v-4030daa2] {\\n  padding: 0.78571429rem 1.14285714rem;\\n  font-weight: normal;\\n}\\n.ui.dropdown .menu > .message[data-v-4030daa2]:not(.ui) {\\n  color: rgba(0, 0, 0, 0.4);\\n}\\n\\n/*--------------\\n    Sub Menu\\n---------------*/\\n.ui.dropdown .menu .menu[data-v-4030daa2] {\\n  top: 0% !important;\\n  left: 100% !important;\\n  right: auto !important;\\n  margin: 0em 0em 0em -0.5em !important;\\n  border-radius: 0.28571429rem !important;\\n  z-index: 21 !important;\\n}\\n\\n/* Hide Arrow */\\n.ui.dropdown .menu .menu[data-v-4030daa2]:after {\\n  display: none;\\n}\\n\\n/*--------------\\n   Sub Elements\\n---------------*/\\n\\n\\n/* Icons / Flags / Labels / Image */\\n.ui.dropdown > .text > .icon[data-v-4030daa2],\\n.ui.dropdown > .text > .label[data-v-4030daa2],\\n.ui.dropdown > .text > .flag[data-v-4030daa2],\\n.ui.dropdown > .text > img[data-v-4030daa2],\\n.ui.dropdown > .text > .image[data-v-4030daa2] {\\n  margin-top: 0em;\\n}\\n.ui.dropdown .menu > .item > .icon[data-v-4030daa2],\\n.ui.dropdown .menu > .item > .label[data-v-4030daa2],\\n.ui.dropdown .menu > .item > .flag[data-v-4030daa2],\\n.ui.dropdown .menu > .item > .image[data-v-4030daa2],\\n.ui.dropdown .menu > .item > img[data-v-4030daa2] {\\n  margin-top: 0em;\\n}\\n.ui.dropdown > .text > .icon[data-v-4030daa2],\\n.ui.dropdown > .text > .label[data-v-4030daa2],\\n.ui.dropdown > .text > .flag[data-v-4030daa2],\\n.ui.dropdown > .text > img[data-v-4030daa2],\\n.ui.dropdown > .text > .image[data-v-4030daa2],\\n.ui.dropdown .menu > .item > .icon[data-v-4030daa2],\\n.ui.dropdown .menu > .item > .label[data-v-4030daa2],\\n.ui.dropdown .menu > .item > .flag[data-v-4030daa2],\\n.ui.dropdown .menu > .item > .image[data-v-4030daa2],\\n.ui.dropdown .menu > .item > img[data-v-4030daa2] {\\n  margin-left: 0em;\\n  float: none;\\n  margin-right: 0.78571429rem;\\n}\\n\\n/*--------------\\n     Image\\n---------------*/\\n.ui.dropdown > .text > img[data-v-4030daa2],\\n.ui.dropdown > .text > .image[data-v-4030daa2],\\n.ui.dropdown .menu > .item > .image[data-v-4030daa2],\\n.ui.dropdown .menu > .item > img[data-v-4030daa2] {\\n  display: inline-block;\\n  vertical-align: middle;\\n  width: auto;\\n  max-height: 2em;\\n}\\n\\n\\n/*******************************\\n            Coupling\\n*******************************/\\n\\n\\n/*--------------\\n      Menu\\n---------------*/\\n\\n\\n/* Remove Menu Item Divider */\\n.ui.dropdown .ui.menu > .item[data-v-4030daa2]:before,\\n.ui.menu .ui.dropdown .menu > .item[data-v-4030daa2]:before {\\n  display: none;\\n}\\n\\n/* Prevent Menu Item Border */\\n.ui.menu .ui.dropdown .menu .active.item[data-v-4030daa2] {\\n  border-left: none;\\n}\\n\\n/* Automatically float dropdown menu right on last menu item */\\n.ui.menu .right.menu .dropdown:last-child .menu[data-v-4030daa2],\\n.ui.menu .right.dropdown.item .menu[data-v-4030daa2],\\n.ui.buttons > .ui.dropdown:last-child .menu[data-v-4030daa2] {\\n  left: auto;\\n  right: 0em;\\n}\\n\\n/*--------------\\n      Label\\n---------------*/\\n\\n\\n/* Dropdown Menu */\\n.ui.label.dropdown .menu[data-v-4030daa2] {\\n  min-width: 100%;\\n}\\n\\n/*--------------\\n     Button\\n---------------*/\\n\\n\\n/* No Margin On Icon Button */\\n.ui.dropdown.icon.button > .dropdown.icon[data-v-4030daa2] {\\n  margin: 0em;\\n}\\n.ui.button.dropdown .menu[data-v-4030daa2] {\\n  min-width: 100%;\\n}\\n\\n\\n/*******************************\\n              Types\\n*******************************/\\n\\n\\n/*--------------\\n    Selection\\n---------------*/\\n\\n\\n/* Displays like a select box */\\n.ui.selection.dropdown[data-v-4030daa2] {\\n  cursor: pointer;\\n  word-wrap: break-word;\\n  line-height: 1em;\\n  white-space: normal;\\n  outline: 0;\\n  -webkit-transform: rotateZ(0deg);\\n      -ms-transform: rotate(0deg);\\n          transform: rotateZ(0deg);\\n  min-width: 14em;\\n  min-height: 2.7142em;\\n  background: #FFFFFF;\\n  display: inline-block;\\n  padding: 0.78571429em 2.1em 0.78571429em 1em;\\n  color: rgba(0, 0, 0, 0.87);\\n  box-shadow: none;\\n  border: 1px solid rgba(34, 36, 38, 0.15);\\n  border-radius: 0.28571429rem;\\n  -webkit-transition: box-shadow 0.1s ease, width 0.1s ease;\\n  transition: box-shadow 0.1s ease, width 0.1s ease;\\n}\\n.ui.selection.dropdown.visible[data-v-4030daa2],\\n.ui.selection.dropdown.active[data-v-4030daa2] {\\n  z-index: 10;\\n}\\nselect.ui.dropdown[data-v-4030daa2] {\\n  height: 38px;\\n  padding: 0.5em;\\n  border: 1px solid rgba(34, 36, 38, 0.15);\\n  visibility: visible;\\n}\\n.ui.selection.dropdown > .search.icon[data-v-4030daa2],\\n.ui.selection.dropdown > .delete.icon[data-v-4030daa2],\\n.ui.selection.dropdown > .dropdown.icon[data-v-4030daa2] {\\n  cursor: pointer;\\n  position: absolute;\\n  width: auto;\\n  height: auto;\\n  line-height: 1.2142em;\\n  top: 0.78571429em;\\n  right: 1em;\\n  z-index: 3;\\n  margin: -0.78571429em;\\n  padding: 0.78571429em;\\n  opacity: 0.8;\\n  -webkit-transition: opacity 0.1s ease;\\n  transition: opacity 0.1s ease;\\n}\\n\\n/* Compact */\\n.ui.compact.selection.dropdown[data-v-4030daa2] {\\n  min-width: 0px;\\n}\\n\\n/*  Selection Menu */\\n.ui.selection.dropdown .menu[data-v-4030daa2] {\\n  overflow-x: hidden;\\n  overflow-y: auto;\\n  -webkit-backface-visibility: hidden;\\n          backface-visibility: hidden;\\n  -webkit-overflow-scrolling: touch;\\n  border-top-width: 0px !important;\\n  width: auto;\\n  outline: none;\\n  margin: 0px -1px;\\n  min-width: calc(100% +  2px );\\n  width: calc(100% +  2px );\\n  border-radius: 0em 0em 0.28571429rem 0.28571429rem;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n  -webkit-transition: opacity 0.1s ease;\\n  transition: opacity 0.1s ease;\\n}\\n.ui.selection.dropdown .menu[data-v-4030daa2]:after,\\n.ui.selection.dropdown .menu[data-v-4030daa2]:before {\\n  display: none;\\n}\\n\\n/*--------------\\n    Message\\n---------------*/\\n.ui.selection.dropdown .menu > .message[data-v-4030daa2] {\\n  padding: 0.78571429rem 1.14285714rem;\\n}\\n@media only screen and (max-width: 767px) {\\n.ui.selection.dropdown .menu[data-v-4030daa2] {\\n    max-height: 8.01428571rem;\\n}\\n}\\n@media only screen and (min-width: 768px) {\\n.ui.selection.dropdown .menu[data-v-4030daa2] {\\n    max-height: 10.68571429rem;\\n}\\n}\\n@media only screen and (min-width: 992px) {\\n.ui.selection.dropdown .menu[data-v-4030daa2] {\\n    max-height: 16.02857143rem;\\n}\\n}\\n@media only screen and (min-width: 1920px) {\\n.ui.selection.dropdown .menu[data-v-4030daa2] {\\n    max-height: 21.37142857rem;\\n}\\n}\\n\\n/* Menu Item */\\n.ui.selection.dropdown .menu > .item[data-v-4030daa2] {\\n  border-top: 1px solid #FAFAFA;\\n  padding: 0.78571429rem 1.14285714rem !important;\\n  white-space: normal;\\n  word-wrap: normal;\\n}\\n\\n/* User Item */\\n.ui.selection.dropdown .menu > .hidden.addition.item[data-v-4030daa2] {\\n  display: none;\\n}\\n\\n/* Hover */\\n.ui.selection.dropdown[data-v-4030daa2]:hover {\\n  border-color: rgba(34, 36, 38, 0.35);\\n  box-shadow: none;\\n}\\n\\n/* Active */\\n.ui.selection.active.dropdown[data-v-4030daa2] {\\n  border-color: #96C8DA;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n}\\n.ui.selection.active.dropdown .menu[data-v-4030daa2] {\\n  border-color: #96C8DA;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n}\\n\\n/* Focus */\\n.ui.selection.dropdown[data-v-4030daa2]:focus {\\n  border-color: #96C8DA;\\n  box-shadow: none;\\n}\\n.ui.selection.dropdown:focus .menu[data-v-4030daa2] {\\n  border-color: #96C8DA;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n}\\n\\n/* Visible */\\n.ui.selection.visible.dropdown > .text[data-v-4030daa2]:not(.default) {\\n  font-weight: normal;\\n  color: rgba(0, 0, 0, 0.8);\\n}\\n\\n/* Visible Hover */\\n.ui.selection.active.dropdown[data-v-4030daa2]:hover {\\n  border-color: #96C8DA;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n}\\n.ui.selection.active.dropdown:hover .menu[data-v-4030daa2] {\\n  border-color: #96C8DA;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n}\\n\\n/* Dropdown Icon */\\n.ui.active.selection.dropdown > .dropdown.icon[data-v-4030daa2],\\n.ui.visible.selection.dropdown > .dropdown.icon[data-v-4030daa2] {\\n  opacity: 1;\\n  z-index: 3;\\n}\\n\\n/* Connecting Border */\\n.ui.active.selection.dropdown[data-v-4030daa2] {\\n  border-bottom-left-radius: 0em !important;\\n  border-bottom-right-radius: 0em !important;\\n}\\n\\n/* Empty Connecting Border */\\n.ui.active.empty.selection.dropdown[data-v-4030daa2] {\\n  border-radius: 0.28571429rem !important;\\n  box-shadow: none !important;\\n}\\n.ui.active.empty.selection.dropdown .menu[data-v-4030daa2] {\\n  border: none !important;\\n  box-shadow: none !important;\\n}\\n\\n/*--------------\\n   Searchable\\n---------------*/\\n\\n\\n/* Search Selection */\\n.ui.search.dropdown[data-v-4030daa2] {\\n  min-width: '';\\n}\\n\\n/* Search Dropdown */\\n.ui.search.dropdown > input.search[data-v-4030daa2] {\\n  background: none transparent !important;\\n  border: none !important;\\n  box-shadow: none !important;\\n  cursor: text;\\n  top: 0em;\\n  left: 1px;\\n  width: 100%;\\n  outline: none;\\n  -webkit-tap-highlight-color: rgba(255, 255, 255, 0);\\n  padding: inherit;\\n}\\n\\n/* Text Layering */\\n.ui.search.dropdown > input.search[data-v-4030daa2] {\\n  position: absolute;\\n  z-index: 2;\\n}\\n.ui.search.dropdown > .text[data-v-4030daa2] {\\n  cursor: text;\\n  position: relative;\\n  left: 1px;\\n  z-index: 3;\\n}\\n\\n/* Search Selection */\\n.ui.search.selection.dropdown > input.search[data-v-4030daa2] {\\n  line-height: 1.2142em;\\n  padding: 0.67861429em 2.1em 0.67861429em 1em;\\n}\\n\\n/* Used to size multi select input to character width */\\n.ui.search.selection.dropdown > span.sizer[data-v-4030daa2] {\\n  line-height: 1.2142em;\\n  padding: 0.67861429em 2.1em 0.67861429em 1em;\\n  display: none;\\n  white-space: pre;\\n}\\n\\n/* Active/Visible Search */\\n.ui.search.dropdown.active > input.search[data-v-4030daa2],\\n.ui.search.dropdown.visible > input.search[data-v-4030daa2] {\\n  cursor: auto;\\n}\\n.ui.search.dropdown.active > .text[data-v-4030daa2],\\n.ui.search.dropdown.visible > .text[data-v-4030daa2] {\\n  pointer-events: none;\\n}\\n\\n/* Filtered Text */\\n.ui.active.search.dropdown input.search:focus + .text .icon[data-v-4030daa2],\\n.ui.active.search.dropdown input.search:focus + .text .flag[data-v-4030daa2] {\\n  opacity: 0.45;\\n}\\n.ui.active.search.dropdown input.search:focus + .text[data-v-4030daa2] {\\n  color: rgba(115, 115, 115, 0.87) !important;\\n}\\n\\n/* Search Menu */\\n.ui.search.dropdown .menu[data-v-4030daa2] {\\n  overflow-x: hidden;\\n  overflow-y: auto;\\n  -webkit-backface-visibility: hidden;\\n          backface-visibility: hidden;\\n  -webkit-overflow-scrolling: touch;\\n}\\n@media only screen and (max-width: 767px) {\\n.ui.search.dropdown .menu[data-v-4030daa2] {\\n    max-height: 8.01428571rem;\\n}\\n}\\n@media only screen and (min-width: 768px) {\\n.ui.search.dropdown .menu[data-v-4030daa2] {\\n    max-height: 10.68571429rem;\\n}\\n}\\n@media only screen and (min-width: 992px) {\\n.ui.search.dropdown .menu[data-v-4030daa2] {\\n    max-height: 16.02857143rem;\\n}\\n}\\n@media only screen and (min-width: 1920px) {\\n.ui.search.dropdown .menu[data-v-4030daa2] {\\n    max-height: 21.37142857rem;\\n}\\n}\\n\\n/*--------------\\n    Multiple\\n---------------*/\\n\\n\\n/* Multiple Selection */\\n.ui.multiple.dropdown[data-v-4030daa2] {\\n  padding: 0.22620476em 2.1em 0.22620476em 0.35714286em;\\n}\\n.ui.multiple.dropdown .menu[data-v-4030daa2] {\\n  cursor: auto;\\n}\\n\\n/* Multiple Search Selection */\\n.ui.multiple.search.dropdown[data-v-4030daa2],\\n.ui.multiple.search.dropdown > input.search[data-v-4030daa2] {\\n  cursor: text;\\n}\\n\\n/* Selection Label */\\n.ui.multiple.dropdown > .label[data-v-4030daa2] {\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n      -ms-user-select: none;\\n          user-select: none;\\n  display: inline-block;\\n  vertical-align: top;\\n  white-space: normal;\\n  font-size: 1em;\\n  padding: 0.35714286em 0.78571429em;\\n  margin: 0.14285714rem 0.28571429rem 0.14285714rem 0em;\\n  box-shadow: 0px 0px 0px 1px rgba(34, 36, 38, 0.15) inset;\\n}\\n\\n/* Dropdown Icon */\\n.ui.multiple.dropdown .dropdown.icon[data-v-4030daa2] {\\n  margin: '';\\n  padding: '';\\n}\\n\\n/* Text */\\n.ui.multiple.dropdown > .text[data-v-4030daa2] {\\n  position: static;\\n  padding: 0;\\n  max-width: 100%;\\n  margin: 0.45240952em 0em 0.45240952em 0.64285714em;\\n  line-height: 1.21428571em;\\n}\\n.ui.multiple.dropdown > .label ~ input.search[data-v-4030daa2] {\\n  margin-left: 0.14285714em !important;\\n}\\n.ui.multiple.dropdown > .label ~ .text[data-v-4030daa2] {\\n  display: none;\\n}\\n\\n/*-----------------\\n  Multiple Search\\n-----------------*/\\n\\n\\n/* Prompt Text */\\n.ui.multiple.search.dropdown > .text[data-v-4030daa2] {\\n  display: inline-block;\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  padding: inherit;\\n  margin: 0.45240952em 0em 0.45240952em 0.64285714em;\\n  line-height: 1.21428571em;\\n}\\n.ui.multiple.search.dropdown > .label ~ .text[data-v-4030daa2] {\\n  display: none;\\n}\\n\\n/* Search */\\n.ui.multiple.search.dropdown > input.search[data-v-4030daa2] {\\n  position: static;\\n  padding: 0;\\n  max-width: 100%;\\n  margin: 0.45240952em 0em 0.45240952em 0.64285714em;\\n  width: 2.2em;\\n  line-height: 1.21428571em;\\n}\\n\\n/*--------------\\n     Inline\\n---------------*/\\n.ui.inline.dropdown[data-v-4030daa2] {\\n  cursor: pointer;\\n  display: inline-block;\\n  color: inherit;\\n}\\n.ui.inline.dropdown .dropdown.icon[data-v-4030daa2] {\\n  margin: 0em 0.5em 0em 0.21428571em;\\n  vertical-align: baseline;\\n}\\n.ui.inline.dropdown > .text[data-v-4030daa2] {\\n  font-weight: bold;\\n}\\n.ui.inline.dropdown .menu[data-v-4030daa2] {\\n  cursor: auto;\\n  margin-top: 0.21428571em;\\n  border-radius: 0.28571429rem;\\n}\\n\\n\\n/*******************************\\n            States\\n*******************************/\\n\\n\\n/*--------------------\\n        Active\\n----------------------*/\\n\\n\\n/* Menu Item Active */\\n.ui.dropdown .menu .active.item[data-v-4030daa2] {\\n  background: transparent;\\n  font-weight: bold;\\n  color: rgba(0, 0, 0, 0.95);\\n  box-shadow: none;\\n  z-index: 12;\\n}\\n\\n/*--------------------\\n        Hover\\n----------------------*/\\n\\n\\n/* Menu Item Hover */\\n.ui.dropdown .menu > .item[data-v-4030daa2]:hover {\\n  background: rgba(0, 0, 0, 0.05);\\n  color: rgba(0, 0, 0, 0.95);\\n  z-index: 13;\\n}\\n\\n/*--------------------\\n       Loading\\n---------------------*/\\n.ui.loading.dropdown > i.icon[data-v-4030daa2] {\\n  height: 1em !important;\\n  padding: 1.14285714em 1.07142857em !important;\\n}\\n.ui.loading.dropdown > i.icon[data-v-4030daa2]:before {\\n  position: absolute;\\n  content: '';\\n  top: 50%;\\n  left: 50%;\\n  margin: -0.64285714em 0em 0em -0.64285714em;\\n  width: 1.28571429em;\\n  height: 1.28571429em;\\n  border-radius: 500rem;\\n  border: 0.2em solid rgba(0, 0, 0, 0.1);\\n}\\n.ui.loading.dropdown > i.icon[data-v-4030daa2]:after {\\n  position: absolute;\\n  content: '';\\n  top: 50%;\\n  left: 50%;\\n  box-shadow: 0px 0px 0px 1px transparent;\\n  margin: -0.64285714em 0em 0em -0.64285714em;\\n  width: 1.28571429em;\\n  height: 1.28571429em;\\n  -webkit-animation: dropdown-spin 0.6s linear;\\n          animation: dropdown-spin 0.6s linear;\\n  -webkit-animation-iteration-count: infinite;\\n          animation-iteration-count: infinite;\\n  border-radius: 500rem;\\n  border-color: #767676 transparent transparent;\\n  border-style: solid;\\n  border-width: 0.2em;\\n}\\n\\n/* Coupling */\\n.ui.loading.dropdown.button > i.icon[data-v-4030daa2]:before,\\n.ui.loading.dropdown.button > i.icon[data-v-4030daa2]:after {\\n  display: none;\\n}\\n@-webkit-keyframes dropdown-spin {\\nfrom {\\n    -webkit-transform: rotate(0deg);\\n            transform: rotate(0deg);\\n}\\nto {\\n    -webkit-transform: rotate(360deg);\\n            transform: rotate(360deg);\\n}\\n}\\n@keyframes dropdown-spin {\\nfrom {\\n    -webkit-transform: rotate(0deg);\\n            transform: rotate(0deg);\\n}\\nto {\\n    -webkit-transform: rotate(360deg);\\n            transform: rotate(360deg);\\n}\\n}\\n\\n/*--------------------\\n     Default Text\\n----------------------*/\\n.ui.dropdown:not(.button) > .default.text[data-v-4030daa2],\\n.ui.default.dropdown:not(.button) > .text[data-v-4030daa2] {\\n  color: rgba(191, 191, 191, 0.87);\\n}\\n.ui.dropdown:not(.button) > input:focus + .default.text[data-v-4030daa2],\\n.ui.default.dropdown:not(.button) > input:focus + .text[data-v-4030daa2] {\\n  color: rgba(115, 115, 115, 0.87);\\n}\\n\\n/*--------------------\\n        Loading\\n----------------------*/\\n.ui.loading.dropdown > .text[data-v-4030daa2] {\\n  -webkit-transition: none;\\n  transition: none;\\n}\\n\\n/* Used To Check Position */\\n.ui.dropdown .loading.menu[data-v-4030daa2] {\\n  display: block;\\n  visibility: hidden;\\n  z-index: -1;\\n}\\n\\n/*--------------------\\n    Keyboard Select\\n----------------------*/\\n\\n\\n/* Selected Item */\\n.ui.dropdown.selected[data-v-4030daa2],\\n.ui.dropdown .menu .selected.item[data-v-4030daa2] {\\n  background: rgba(0, 0, 0, 0.03);\\n  color: rgba(0, 0, 0, 0.95);\\n}\\n\\n/*--------------------\\n    Search Filtered\\n----------------------*/\\n\\n\\n/* Filtered Item */\\n.ui.dropdown > .filtered.text[data-v-4030daa2] {\\n  visibility: hidden;\\n}\\n.ui.dropdown .filtered.item[data-v-4030daa2] {\\n  display: none !important;\\n}\\n\\n/*--------------------\\n        Error\\n----------------------*/\\n.ui.dropdown.error[data-v-4030daa2],\\n.ui.dropdown.error > .text[data-v-4030daa2],\\n.ui.dropdown.error > .default.text[data-v-4030daa2] {\\n  color: #9F3A38;\\n}\\n.ui.selection.dropdown.error[data-v-4030daa2] {\\n  background: #FFF6F6;\\n  border-color: #E0B4B4;\\n}\\n.ui.selection.dropdown.error[data-v-4030daa2]:hover {\\n  border-color: #E0B4B4;\\n}\\n.ui.dropdown.error > .menu[data-v-4030daa2],\\n.ui.dropdown.error > .menu .menu[data-v-4030daa2] {\\n  border-color: #E0B4B4;\\n}\\n.ui.dropdown.error > .menu > .item[data-v-4030daa2] {\\n  color: #9F3A38;\\n}\\n.ui.multiple.selection.error.dropdown > .label[data-v-4030daa2] {\\n  border-color: #E0B4B4;\\n}\\n\\n/* Item Hover */\\n.ui.dropdown.error > .menu > .item[data-v-4030daa2]:hover {\\n  background-color: #FFF2F2;\\n}\\n\\n/* Item Active */\\n.ui.dropdown.error > .menu .active.item[data-v-4030daa2] {\\n  background-color: #FDCFCF;\\n}\\n\\n/*--------------------\\n        Disabled\\n----------------------*/\\n\\n\\n/* Disabled */\\n.ui.disabled.dropdown[data-v-4030daa2],\\n.ui.dropdown .menu > .disabled.item[data-v-4030daa2] {\\n  cursor: default;\\n  pointer-events: none;\\n  opacity: 0.45;\\n}\\n\\n\\n/*******************************\\n           Variations\\n*******************************/\\n\\n\\n/*--------------\\n    Direction\\n---------------*/\\n\\n\\n/* Flyout Direction */\\n.ui.dropdown .menu[data-v-4030daa2] {\\n  left: 0px;\\n}\\n\\n/* Default Side (Right) */\\n.ui.dropdown .right.menu > .menu[data-v-4030daa2],\\n.ui.dropdown .menu .right.menu[data-v-4030daa2] {\\n  left: 100% !important;\\n  right: auto !important;\\n  border-radius: 0.28571429rem !important;\\n}\\n\\n/* Left Flyout Menu */\\n.ui.dropdown > .left.menu .menu[data-v-4030daa2],\\n.ui.dropdown .menu .left.menu[data-v-4030daa2] {\\n  left: auto !important;\\n  right: 100% !important;\\n  border-radius: 0.28571429rem !important;\\n}\\n.ui.dropdown .item .left.dropdown.icon[data-v-4030daa2],\\n.ui.dropdown .left.menu .item .dropdown.icon[data-v-4030daa2] {\\n  width: auto;\\n  float: left;\\n  margin: 0em 0.78571429rem 0em 0em;\\n}\\n.ui.dropdown .item .left.dropdown.icon[data-v-4030daa2],\\n.ui.dropdown .left.menu .item .dropdown.icon[data-v-4030daa2] {\\n  width: auto;\\n  float: left;\\n  margin: 0em 0.78571429rem 0em 0em;\\n}\\n.ui.dropdown .item .left.dropdown.icon + .text[data-v-4030daa2],\\n.ui.dropdown .left.menu .item .dropdown.icon + .text[data-v-4030daa2] {\\n  margin-left: 1em;\\n}\\n\\n/*--------------\\n     Upward\\n---------------*/\\n\\n\\n/* Upward Main Menu */\\n.ui.upward.dropdown > .menu[data-v-4030daa2] {\\n  top: auto;\\n  bottom: 100%;\\n  box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.08);\\n  border-radius: 0.28571429rem 0.28571429rem 0em 0em;\\n}\\n\\n/* Upward Sub Menu */\\n.ui.dropdown .upward.menu[data-v-4030daa2] {\\n  top: auto !important;\\n  bottom: 0 !important;\\n}\\n\\n/* Active Upward */\\n.ui.simple.upward.active.dropdown[data-v-4030daa2],\\n.ui.simple.upward.dropdown[data-v-4030daa2]:hover {\\n  border-radius: 0.28571429rem 0.28571429rem 0em 0em !important;\\n}\\n.ui.upward.dropdown.button:not(.pointing):not(.floating).active[data-v-4030daa2] {\\n  border-radius: 0.28571429rem 0.28571429rem 0em 0em;\\n}\\n\\n/* Selection */\\n.ui.upward.selection.dropdown .menu[data-v-4030daa2] {\\n  border-top-width: 1px !important;\\n  border-bottom-width: 0px !important;\\n  box-shadow: 0px -2px 3px 0px rgba(0, 0, 0, 0.08);\\n}\\n.ui.upward.selection.dropdown[data-v-4030daa2]:hover {\\n  box-shadow: 0px 0px 2px 0px rgba(0, 0, 0, 0.05);\\n}\\n\\n/* Active Upward */\\n.ui.active.upward.selection.dropdown[data-v-4030daa2] {\\n  border-radius: 0em 0em 0.28571429rem 0.28571429rem !important;\\n}\\n\\n/* Visible Upward */\\n.ui.upward.selection.dropdown.visible[data-v-4030daa2] {\\n  box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.08);\\n  border-radius: 0em 0em 0.28571429rem 0.28571429rem !important;\\n}\\n\\n/* Visible Hover Upward */\\n.ui.upward.active.selection.dropdown[data-v-4030daa2]:hover {\\n  box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.05);\\n}\\n.ui.upward.active.selection.dropdown:hover .menu[data-v-4030daa2] {\\n  box-shadow: 0px -2px 3px 0px rgba(0, 0, 0, 0.08);\\n}\\n\\n/*--------------\\n     Simple\\n---------------*/\\n\\n\\n/*  Selection Menu */\\n.ui.scrolling.dropdown .menu[data-v-4030daa2],\\n.ui.dropdown .scrolling.menu[data-v-4030daa2] {\\n  overflow-x: hidden;\\n  overflow-y: auto;\\n}\\n.ui.scrolling.dropdown .menu[data-v-4030daa2] {\\n  overflow-x: hidden;\\n  overflow-y: auto;\\n  -webkit-backface-visibility: hidden;\\n          backface-visibility: hidden;\\n  -webkit-overflow-scrolling: touch;\\n  min-width: 100% !important;\\n  width: auto !important;\\n}\\n.ui.dropdown .scrolling.menu[data-v-4030daa2] {\\n  position: static;\\n  overflow-y: auto;\\n  border: none;\\n  box-shadow: none !important;\\n  border-radius: 0 !important;\\n  margin: 0 !important;\\n  min-width: 100% !important;\\n  width: auto !important;\\n  border-top: 1px solid rgba(34, 36, 38, 0.15);\\n}\\n.ui.scrolling.dropdown .menu .item.item.item[data-v-4030daa2],\\n.ui.dropdown .scrolling.menu > .item.item.item[data-v-4030daa2] {\\n  border-top: none;\\n  padding-right: calc( 1.14285714rem  +  17px ) !important;\\n}\\n.ui.scrolling.dropdown .menu .item[data-v-4030daa2]:first-child,\\n.ui.dropdown .scrolling.menu .item[data-v-4030daa2]:first-child {\\n  border-top: none;\\n}\\n.ui.dropdown > .animating.menu .scrolling.menu[data-v-4030daa2],\\n.ui.dropdown > .visible.menu .scrolling.menu[data-v-4030daa2] {\\n  display: block;\\n}\\n\\n/* Scrollbar in IE */\\n@media all and (-ms-high-contrast: none) {\\n.ui.scrolling.dropdown .menu[data-v-4030daa2],\\n  .ui.dropdown .scrolling.menu[data-v-4030daa2] {\\n    min-width: calc(100% -  17px );\\n}\\n}\\n@media only screen and (max-width: 767px) {\\n.ui.scrolling.dropdown .menu[data-v-4030daa2],\\n  .ui.dropdown .scrolling.menu[data-v-4030daa2] {\\n    max-height: 10.28571429rem;\\n}\\n}\\n@media only screen and (min-width: 768px) {\\n.ui.scrolling.dropdown .menu[data-v-4030daa2],\\n  .ui.dropdown .scrolling.menu[data-v-4030daa2] {\\n    max-height: 15.42857143rem;\\n}\\n}\\n@media only screen and (min-width: 992px) {\\n.ui.scrolling.dropdown .menu[data-v-4030daa2],\\n  .ui.dropdown .scrolling.menu[data-v-4030daa2] {\\n    max-height: 20.57142857rem;\\n}\\n}\\n@media only screen and (min-width: 1920px) {\\n.ui.scrolling.dropdown .menu[data-v-4030daa2],\\n  .ui.dropdown .scrolling.menu[data-v-4030daa2] {\\n    max-height: 20.57142857rem;\\n}\\n}\\n\\n/*--------------\\n     Simple\\n---------------*/\\n\\n\\n/* Displays without javascript */\\n.ui.simple.dropdown .menu[data-v-4030daa2]:before,\\n.ui.simple.dropdown .menu[data-v-4030daa2]:after {\\n  display: none;\\n}\\n.ui.simple.dropdown .menu[data-v-4030daa2] {\\n  position: absolute;\\n  display: block;\\n  overflow: hidden;\\n  top: -9999px !important;\\n  opacity: 0;\\n  width: 0;\\n  height: 0;\\n  -webkit-transition: opacity 0.1s ease;\\n  transition: opacity 0.1s ease;\\n}\\n.ui.simple.active.dropdown[data-v-4030daa2],\\n.ui.simple.dropdown[data-v-4030daa2]:hover {\\n  border-bottom-left-radius: 0em !important;\\n  border-bottom-right-radius: 0em !important;\\n}\\n.ui.simple.active.dropdown > .menu[data-v-4030daa2],\\n.ui.simple.dropdown:hover > .menu[data-v-4030daa2] {\\n  overflow: visible;\\n  width: auto;\\n  height: auto;\\n  top: 100% !important;\\n  opacity: 1;\\n}\\n.ui.simple.dropdown > .menu > .item:active > .menu[data-v-4030daa2],\\n.ui.simple.dropdown:hover > .menu > .item:hover > .menu[data-v-4030daa2] {\\n  overflow: visible;\\n  width: auto;\\n  height: auto;\\n  top: 0% !important;\\n  left: 100% !important;\\n  opacity: 1;\\n}\\n.ui.simple.disabled.dropdown:hover .menu[data-v-4030daa2] {\\n  display: none;\\n  height: 0px;\\n  width: 0px;\\n  overflow: hidden;\\n}\\n\\n/* Visible */\\n.ui.simple.visible.dropdown > .menu[data-v-4030daa2] {\\n  display: block;\\n}\\n\\n/*--------------\\n      Fluid\\n---------------*/\\n.ui.fluid.dropdown[data-v-4030daa2] {\\n  display: block;\\n  width: 100%;\\n  min-width: 0em;\\n}\\n.ui.fluid.dropdown > .dropdown.icon[data-v-4030daa2] {\\n  float: right;\\n}\\n\\n/*--------------\\n    Floating\\n---------------*/\\n.ui.floating.dropdown .menu[data-v-4030daa2] {\\n  left: 0;\\n  right: auto;\\n  box-shadow: 0px 2px 4px 0px rgba(34, 36, 38, 0.12), 0px 2px 10px 0px rgba(34, 36, 38, 0.15) !important;\\n  border-radius: 0.28571429rem !important;\\n}\\n.ui.floating.dropdown > .menu[data-v-4030daa2] {\\n  margin-top: 0.5em !important;\\n  border-radius: 0.28571429rem !important;\\n}\\n\\n/*--------------\\n     Pointing\\n---------------*/\\n.ui.pointing.dropdown > .menu[data-v-4030daa2] {\\n  top: 100%;\\n  margin-top: 0.78571429rem;\\n  border-radius: 0.28571429rem;\\n}\\n.ui.pointing.dropdown > .menu[data-v-4030daa2]:after {\\n  display: block;\\n  position: absolute;\\n  pointer-events: none;\\n  content: '';\\n  visibility: visible;\\n  -webkit-transform: rotate(45deg);\\n      -ms-transform: rotate(45deg);\\n          transform: rotate(45deg);\\n  width: 0.5em;\\n  height: 0.5em;\\n  box-shadow: -1px -1px 0px 1px rgba(34, 36, 38, 0.15);\\n  background: #FFFFFF;\\n  z-index: 2;\\n}\\n.ui.pointing.dropdown > .menu[data-v-4030daa2]:after {\\n  top: -0.25em;\\n  left: 50%;\\n  margin: 0em 0em 0em -0.25em;\\n}\\n\\n/* Top Left Pointing */\\n.ui.top.left.pointing.dropdown > .menu[data-v-4030daa2] {\\n  top: 100%;\\n  bottom: auto;\\n  left: 0%;\\n  right: auto;\\n  margin: 1em 0em 0em;\\n}\\n.ui.top.left.pointing.dropdown > .menu[data-v-4030daa2] {\\n  top: 100%;\\n  bottom: auto;\\n  left: 0%;\\n  right: auto;\\n  margin: 1em 0em 0em;\\n}\\n.ui.top.left.pointing.dropdown > .menu[data-v-4030daa2]:after {\\n  top: -0.25em;\\n  left: 1em;\\n  right: auto;\\n  margin: 0em;\\n  -webkit-transform: rotate(45deg);\\n      -ms-transform: rotate(45deg);\\n          transform: rotate(45deg);\\n}\\n\\n/* Top Right  Pointing */\\n.ui.top.right.pointing.dropdown > .menu[data-v-4030daa2] {\\n  top: 100%;\\n  bottom: auto;\\n  right: 0%;\\n  left: auto;\\n  margin: 1em 0em 0em;\\n}\\n.ui.top.right.pointing.dropdown > .menu[data-v-4030daa2]:after {\\n  top: -0.25em;\\n  left: auto;\\n  right: 1em;\\n  margin: 0em;\\n  -webkit-transform: rotate(45deg);\\n      -ms-transform: rotate(45deg);\\n          transform: rotate(45deg);\\n}\\n\\n/* Left Pointing */\\n.ui.left.pointing.dropdown > .menu[data-v-4030daa2] {\\n  top: 0%;\\n  left: 100%;\\n  right: auto;\\n  margin: 0em 0em 0em 1em;\\n}\\n.ui.left.pointing.dropdown > .menu[data-v-4030daa2]:after {\\n  top: 1em;\\n  left: -0.25em;\\n  margin: 0em 0em 0em 0em;\\n  -webkit-transform: rotate(-45deg);\\n      -ms-transform: rotate(-45deg);\\n          transform: rotate(-45deg);\\n}\\n\\n/* Right Pointing */\\n.ui.right.pointing.dropdown > .menu[data-v-4030daa2] {\\n  top: 0%;\\n  left: auto;\\n  right: 100%;\\n  margin: 0em 1em 0em 0em;\\n}\\n.ui.right.pointing.dropdown > .menu[data-v-4030daa2]:after {\\n  top: 1em;\\n  left: auto;\\n  right: -0.25em;\\n  margin: 0em 0em 0em 0em;\\n  -webkit-transform: rotate(135deg);\\n      -ms-transform: rotate(135deg);\\n          transform: rotate(135deg);\\n}\\n\\n/* Bottom Pointing */\\n.ui.bottom.pointing.dropdown > .menu[data-v-4030daa2] {\\n  top: auto;\\n  bottom: 100%;\\n  left: 0%;\\n  right: auto;\\n  margin: 0em 0em 1em;\\n}\\n.ui.bottom.pointing.dropdown > .menu[data-v-4030daa2]:after {\\n  top: auto;\\n  bottom: -0.25em;\\n  right: auto;\\n  margin: 0em;\\n  -webkit-transform: rotate(-135deg);\\n      -ms-transform: rotate(-135deg);\\n          transform: rotate(-135deg);\\n}\\n\\n/* Reverse Sub-Menu Direction */\\n.ui.bottom.pointing.dropdown > .menu .menu[data-v-4030daa2] {\\n  top: auto !important;\\n  bottom: 0px !important;\\n}\\n\\n/* Bottom Left */\\n.ui.bottom.left.pointing.dropdown > .menu[data-v-4030daa2] {\\n  left: 0%;\\n  right: auto;\\n}\\n.ui.bottom.left.pointing.dropdown > .menu[data-v-4030daa2]:after {\\n  left: 1em;\\n  right: auto;\\n}\\n\\n/* Bottom Right */\\n.ui.bottom.right.pointing.dropdown > .menu[data-v-4030daa2] {\\n  right: 0%;\\n  left: auto;\\n}\\n.ui.bottom.right.pointing.dropdown > .menu[data-v-4030daa2]:after {\\n  left: auto;\\n  right: 1em;\\n}\\n\\n/* Upward pointing */\\n.ui.upward.pointing.dropdown > .menu[data-v-4030daa2],\\n.ui.upward.top.pointing.dropdown > .menu[data-v-4030daa2] {\\n  top: auto;\\n  bottom: 100%;\\n  margin: 0em 0em 0.78571429rem;\\n  border-radius: 0.28571429rem;\\n}\\n.ui.upward.pointing.dropdown > .menu[data-v-4030daa2]:after,\\n.ui.upward.top.pointing.dropdown > .menu[data-v-4030daa2]:after {\\n  top: 100%;\\n  bottom: auto;\\n  box-shadow: 1px 1px 0px 1px rgba(34, 36, 38, 0.15);\\n  margin: -0.25em 0em 0em;\\n}\\n\\n\\n/*******************************\\n         Theme Overrides\\n*******************************/\\n\\n\\n/* Dropdown Carets */\\n@font-face {\\n  font-family: 'Dropdown';\\n  src: url(data:application/x-font-ttf;charset=utf-8;base64,AAEAAAALAIAAAwAwT1MvMggjB5AAAAC8AAAAYGNtYXAPfuIIAAABHAAAAExnYXNwAAAAEAAAAWgAAAAIZ2x5Zjo82LgAAAFwAAABVGhlYWQAQ88bAAACxAAAADZoaGVhAwcB6QAAAvwAAAAkaG10eAS4ABIAAAMgAAAAIGxvY2EBNgDeAAADQAAAABJtYXhwAAoAFgAAA1QAAAAgbmFtZVcZpu4AAAN0AAABRXBvc3QAAwAAAAAEvAAAACAAAwIAAZAABQAAAUwBZgAAAEcBTAFmAAAA9QAZAIQAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADw2gHg/+D/4AHgACAAAAABAAAAAAAAAAAAAAAgAAAAAAACAAAAAwAAABQAAwABAAAAFAAEADgAAAAKAAgAAgACAAEAIPDa//3//wAAAAAAIPDX//3//wAB/+MPLQADAAEAAAAAAAAAAAAAAAEAAf//AA8AAQAAAAAAAAAAAAIAADc5AQAAAAABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAIABJQElABMAABM0NzY3BTYXFhUUDwEGJwYvASY1AAUGBwEACAUGBoAFCAcGgAUBEgcGBQEBAQcECQYHfwYBAQZ/BwYAAQAAAG4BJQESABMAADc0PwE2MzIfARYVFAcGIyEiJyY1AAWABgcIBYAGBgUI/wAHBgWABwaABQWABgcHBgUFBgcAAAABABIASQC3AW4AEwAANzQ/ATYXNhcWHQEUBwYnBi8BJjUSBoAFCAcFBgYFBwgFgAbbBwZ/BwEBBwQJ/wgEBwEBB38GBgAAAAABAAAASQClAW4AEwAANxE0NzYzMh8BFhUUDwEGIyInJjUABQYHCAWABgaABQgHBgVbAQAIBQYGgAUIBwWABgYFBwAAAAEAAAABAADZuaKOXw889QALAgAAAAAA0ABHWAAAAADQAEdYAAAAAAElAW4AAAAIAAIAAAAAAAAAAQAAAeD/4AAAAgAAAAAAASUAAQAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAABAAAAASUAAAElAAAAtwASALcAAAAAAAAACgAUAB4AQgBkAIgAqgAAAAEAAAAIABQAAQAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAOAK4AAQAAAAAAAQAOAAAAAQAAAAAAAgAOAEcAAQAAAAAAAwAOACQAAQAAAAAABAAOAFUAAQAAAAAABQAWAA4AAQAAAAAABgAHADIAAQAAAAAACgA0AGMAAwABBAkAAQAOAAAAAwABBAkAAgAOAEcAAwABBAkAAwAOACQAAwABBAkABAAOAFUAAwABBAkABQAWAA4AAwABBAkABgAOADkAAwABBAkACgA0AGMAaQBjAG8AbQBvAG8AbgBWAGUAcgBzAGkAbwBuACAAMQAuADAAaQBjAG8AbQBvAG8Abmljb21vb24AaQBjAG8AbQBvAG8AbgBSAGUAZwB1AGwAYQByAGkAYwBvAG0AbwBvAG4ARgBvAG4AdAAgAGcAZQBuAGUAcgBhAHQAZQBkACAAYgB5ACAASQBjAG8ATQBvAG8AbgAuAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=) format('truetype'), url(data:application/font-woff;charset=utf-8;base64,d09GRk9UVE8AAAVwAAoAAAAABSgAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABDRkYgAAAA9AAAAdkAAAHZLDXE/09TLzIAAALQAAAAYAAAAGAIIweQY21hcAAAAzAAAABMAAAATA9+4ghnYXNwAAADfAAAAAgAAAAIAAAAEGhlYWQAAAOEAAAANgAAADYAQ88baGhlYQAAA7wAAAAkAAAAJAMHAelobXR4AAAD4AAAACAAAAAgBLgAEm1heHAAAAQAAAAABgAAAAYACFAAbmFtZQAABAgAAAFFAAABRVcZpu5wb3N0AAAFUAAAACAAAAAgAAMAAAEABAQAAQEBCGljb21vb24AAQIAAQA6+BwC+BsD+BgEHgoAGVP/i4seCgAZU/+LiwwHi2v4lPh0BR0AAACIDx0AAACNER0AAAAJHQAAAdASAAkBAQgPERMWGyAlKmljb21vb25pY29tb29udTB1MXUyMHVGMEQ3dUYwRDh1RjBEOXVGMERBAAACAYkABgAIAgABAAQABwAKAA0AVgCfAOgBL/yUDvyUDvyUDvuUDvtvi/emFYuQjZCOjo+Pj42Qiwj3lIsFkIuQiY6Hj4iNhouGi4aJh4eHCPsU+xQFiIiGiYaLhouHjYeOCPsU9xQFiI+Jj4uQCA77b4v3FBWLkI2Pjo8I9xT3FAWPjo+NkIuQi5CJjogI9xT7FAWPh42Hi4aLhomHh4eIiIaJhosI+5SLBYaLh42HjoiPiY+LkAgO+92d928Vi5CNkI+OCPcU9xQFjo+QjZCLkIuPiY6Hj4iNhouGCIv7lAWLhomHh4iIh4eJhouGi4aNiI8I+xT3FAWHjomPi5AIDvvdi+YVi/eUBYuQjZCOjo+Pj42Qi5CLkImOhwj3FPsUBY+IjYaLhouGiYeHiAj7FPsUBYiHhomGi4aLh42Hj4iOiY+LkAgO+JQU+JQViwwKAAAAAAMCAAGQAAUAAAFMAWYAAABHAUwBZgAAAPUAGQCEAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA8NoB4P/g/+AB4AAgAAAAAQAAAAAAAAAAAAAAIAAAAAAAAgAAAAMAAAAUAAMAAQAAABQABAA4AAAACgAIAAIAAgABACDw2v/9//8AAAAAACDw1//9//8AAf/jDy0AAwABAAAAAAAAAAAAAAABAAH//wAPAAEAAAABAAA5emozXw889QALAgAAAAAA0ABHWAAAAADQAEdYAAAAAAElAW4AAAAIAAIAAAAAAAAAAQAAAeD/4AAAAgAAAAAAASUAAQAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAABAAAAASUAAAElAAAAtwASALcAAAAAUAAACAAAAAAADgCuAAEAAAAAAAEADgAAAAEAAAAAAAIADgBHAAEAAAAAAAMADgAkAAEAAAAAAAQADgBVAAEAAAAAAAUAFgAOAAEAAAAAAAYABwAyAAEAAAAAAAoANABjAAMAAQQJAAEADgAAAAMAAQQJAAIADgBHAAMAAQQJAAMADgAkAAMAAQQJAAQADgBVAAMAAQQJAAUAFgAOAAMAAQQJAAYADgA5AAMAAQQJAAoANABjAGkAYwBvAG0AbwBvAG4AVgBlAHIAcwBpAG8AbgAgADEALgAwAGkAYwBvAG0AbwBvAG5pY29tb29uAGkAYwBvAG0AbwBvAG4AUgBlAGcAdQBsAGEAcgBpAGMAbwBtAG8AbwBuAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) format('woff');\\n  font-weight: normal;\\n  font-style: normal;\\n}\\n.ui.dropdown > .dropdown.icon[data-v-4030daa2] {\\n  font-family: 'Dropdown';\\n  line-height: 1;\\n  height: 1em;\\n  width: 1.23em;\\n  -webkit-backface-visibility: hidden;\\n          backface-visibility: hidden;\\n  font-weight: normal;\\n  font-style: normal;\\n  text-align: center;\\n}\\n.ui.dropdown > .dropdown.icon[data-v-4030daa2] {\\n  width: auto;\\n}\\n.ui.dropdown > .dropdown.icon[data-v-4030daa2]:before {\\n  content: '\\\\F0D7';\\n}\\n\\n/* Sub Menu */\\n.ui.dropdown .menu .item .dropdown.icon[data-v-4030daa2]:before {\\n  content: '\\\\F0DA' ;\\n}\\n.ui.dropdown .item .left.dropdown.icon[data-v-4030daa2]:before,\\n.ui.dropdown .left.menu .item .dropdown.icon[data-v-4030daa2]:before {\\n  content: \\\"\\\\F0D9\\\" ;\\n}\\n\\n/* Vertical Menu Dropdown */\\n.ui.vertical.menu .dropdown.item > .dropdown.icon[data-v-4030daa2]:before {\\n  content: \\\"\\\\F0DA\\\" ;\\n}\\n/* Icons for Reference\\n.dropdown.down.icon {\\n  content: \\\"\\\\f0d7\\\";\\n}\\n.dropdown.up.icon {\\n  content: \\\"\\\\f0d8\\\";\\n}\\n.dropdown.left.icon {\\n  content: \\\"\\\\f0d9\\\";\\n}\\n.dropdown.icon.icon {\\n  content: \\\"\\\\f0da\\\";\\n}\\n*/\\n\\n\\n/*******************************\\n        User Overrides\\n*******************************/\\n\\n\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(4)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/* Menu Item Hover for Key event */\\n.ui.dropdown .menu > .item.current {\\n  background: rgba(0, 0, 0, 0.05);\\n}\\n\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(4)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"/*!\\n * # Semantic UI 2.2.3 - Dropdown\\n * http://github.com/semantic-org/semantic-ui/\\n *\\n *\\n * Released under the MIT license\\n * http://opensource.org/licenses/MIT\\n *\\n */\\n\\n\\n/*******************************\\n            Dropdown\\n*******************************/\\n.ui.dropdown[data-v-a3dbfc0c] {\\n  cursor: pointer;\\n  position: relative;\\n  display: inline-block;\\n  outline: none;\\n  text-align: left;\\n  -webkit-transition: box-shadow 0.1s ease, width 0.1s ease;\\n  transition: box-shadow 0.1s ease, width 0.1s ease;\\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\n}\\n\\n\\n/*******************************\\n            Content\\n*******************************/\\n\\n\\n/*--------------\\n      Menu\\n---------------*/\\n.ui.dropdown .menu[data-v-a3dbfc0c] {\\n  cursor: auto;\\n  position: absolute;\\n  display: none;\\n  outline: none;\\n  top: 100%;\\n  min-width: -webkit-max-content;\\n  min-width: -moz-max-content;\\n  min-width: max-content;\\n  margin: 0em;\\n  padding: 0em 0em;\\n  background: #FFFFFF;\\n  font-size: 1em;\\n  text-shadow: none;\\n  text-align: left;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n  border: 1px solid rgba(34, 36, 38, 0.15);\\n  border-radius: 0.28571429rem;\\n  -webkit-transition: opacity 0.1s ease;\\n  transition: opacity 0.1s ease;\\n  z-index: 11;\\n  will-change: transform, opacity;\\n}\\n.ui.dropdown .menu > *[data-v-a3dbfc0c] {\\n  white-space: nowrap;\\n}\\n\\n/*--------------\\n  Hidden Input\\n---------------*/\\n.ui.dropdown > input[data-v-a3dbfc0c]:not(.search):first-child,\\n.ui.dropdown > select[data-v-a3dbfc0c] {\\n  display: none !important;\\n}\\n\\n/*--------------\\n Dropdown Icon\\n---------------*/\\n.ui.dropdown > .dropdown.icon[data-v-a3dbfc0c] {\\n  position: relative;\\n  width: auto;\\n  font-size: 0.85714286em;\\n  margin: 0em 0em 0em 1em;\\n}\\n.ui.dropdown .menu > .item .dropdown.icon[data-v-a3dbfc0c] {\\n  width: auto;\\n  float: right;\\n  margin: 0em 0em 0em 1em;\\n}\\n.ui.dropdown .menu > .item .dropdown.icon + .text[data-v-a3dbfc0c] {\\n  margin-right: 1em;\\n}\\n\\n/*--------------\\n      Text\\n---------------*/\\n.ui.dropdown > .text[data-v-a3dbfc0c] {\\n  display: inline-block;\\n  -webkit-transition: none;\\n  transition: none;\\n}\\n\\n/*--------------\\n    Menu Item\\n---------------*/\\n.ui.dropdown .menu > .item[data-v-a3dbfc0c] {\\n  position: relative;\\n  cursor: pointer;\\n  display: block;\\n  border: none;\\n  height: auto;\\n  text-align: left;\\n  border-top: none;\\n  line-height: 1em;\\n  color: rgba(0, 0, 0, 0.87);\\n  padding: 0.78571429rem 1.14285714rem !important;\\n  font-size: 1rem;\\n  text-transform: none;\\n  font-weight: normal;\\n  box-shadow: none;\\n  -webkit-touch-callout: none;\\n}\\n.ui.dropdown .menu > .item[data-v-a3dbfc0c]:first-child {\\n  border-top-width: 0px;\\n}\\n\\n/*--------------\\n  Floated Content\\n---------------*/\\n.ui.dropdown > .text > [class*=\\\"right floated\\\"][data-v-a3dbfc0c],\\n.ui.dropdown .menu .item > [class*=\\\"right floated\\\"][data-v-a3dbfc0c] {\\n  float: right !important;\\n  margin-right: 0em !important;\\n  margin-left: 1em !important;\\n}\\n.ui.dropdown > .text > [class*=\\\"left floated\\\"][data-v-a3dbfc0c],\\n.ui.dropdown .menu .item > [class*=\\\"left floated\\\"][data-v-a3dbfc0c] {\\n  float: left !important;\\n  margin-left: 0em !important;\\n  margin-right: 1em !important;\\n}\\n.ui.dropdown .menu .item > .icon.floated[data-v-a3dbfc0c],\\n.ui.dropdown .menu .item > .flag.floated[data-v-a3dbfc0c],\\n.ui.dropdown .menu .item > .image.floated[data-v-a3dbfc0c],\\n.ui.dropdown .menu .item > img.floated[data-v-a3dbfc0c] {\\n  margin-top: 0em;\\n}\\n\\n/*--------------\\n  Menu Divider\\n---------------*/\\n.ui.dropdown .menu > .header[data-v-a3dbfc0c] {\\n  margin: 1rem 0rem 0.75rem;\\n  padding: 0em 1.14285714rem;\\n  color: rgba(0, 0, 0, 0.85);\\n  font-size: 0.78571429em;\\n  font-weight: bold;\\n  text-transform: uppercase;\\n}\\n.ui.dropdown .menu > .divider[data-v-a3dbfc0c] {\\n  border-top: 1px solid rgba(34, 36, 38, 0.1);\\n  height: 0em;\\n  margin: 0.5em 0em;\\n}\\n.ui.dropdown .menu > .input[data-v-a3dbfc0c] {\\n  width: auto;\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  margin: 1.14285714rem 0.78571429rem;\\n  min-width: 10rem;\\n}\\n.ui.dropdown .menu > .header + .input[data-v-a3dbfc0c] {\\n  margin-top: 0em;\\n}\\n.ui.dropdown .menu > .input:not(.transparent) input[data-v-a3dbfc0c] {\\n  padding: 0.5em 1em;\\n}\\n.ui.dropdown .menu > .input:not(.transparent) .button[data-v-a3dbfc0c],\\n.ui.dropdown .menu > .input:not(.transparent) .icon[data-v-a3dbfc0c],\\n.ui.dropdown .menu > .input:not(.transparent) .label[data-v-a3dbfc0c] {\\n  padding-top: 0.5em;\\n  padding-bottom: 0.5em;\\n}\\n\\n/*-----------------\\n  Item Description\\n-------------------*/\\n.ui.dropdown > .text > .description[data-v-a3dbfc0c],\\n.ui.dropdown .menu > .item > .description[data-v-a3dbfc0c] {\\n  float: right;\\n  margin: 0em 0em 0em 1em;\\n  color: rgba(0, 0, 0, 0.4);\\n}\\n\\n/*-----------------\\n       Message\\n-------------------*/\\n.ui.dropdown .menu > .message[data-v-a3dbfc0c] {\\n  padding: 0.78571429rem 1.14285714rem;\\n  font-weight: normal;\\n}\\n.ui.dropdown .menu > .message[data-v-a3dbfc0c]:not(.ui) {\\n  color: rgba(0, 0, 0, 0.4);\\n}\\n\\n/*--------------\\n    Sub Menu\\n---------------*/\\n.ui.dropdown .menu .menu[data-v-a3dbfc0c] {\\n  top: 0% !important;\\n  left: 100% !important;\\n  right: auto !important;\\n  margin: 0em 0em 0em -0.5em !important;\\n  border-radius: 0.28571429rem !important;\\n  z-index: 21 !important;\\n}\\n\\n/* Hide Arrow */\\n.ui.dropdown .menu .menu[data-v-a3dbfc0c]:after {\\n  display: none;\\n}\\n\\n/*--------------\\n   Sub Elements\\n---------------*/\\n\\n\\n/* Icons / Flags / Labels / Image */\\n.ui.dropdown > .text > .icon[data-v-a3dbfc0c],\\n.ui.dropdown > .text > .label[data-v-a3dbfc0c],\\n.ui.dropdown > .text > .flag[data-v-a3dbfc0c],\\n.ui.dropdown > .text > img[data-v-a3dbfc0c],\\n.ui.dropdown > .text > .image[data-v-a3dbfc0c] {\\n  margin-top: 0em;\\n}\\n.ui.dropdown .menu > .item > .icon[data-v-a3dbfc0c],\\n.ui.dropdown .menu > .item > .label[data-v-a3dbfc0c],\\n.ui.dropdown .menu > .item > .flag[data-v-a3dbfc0c],\\n.ui.dropdown .menu > .item > .image[data-v-a3dbfc0c],\\n.ui.dropdown .menu > .item > img[data-v-a3dbfc0c] {\\n  margin-top: 0em;\\n}\\n.ui.dropdown > .text > .icon[data-v-a3dbfc0c],\\n.ui.dropdown > .text > .label[data-v-a3dbfc0c],\\n.ui.dropdown > .text > .flag[data-v-a3dbfc0c],\\n.ui.dropdown > .text > img[data-v-a3dbfc0c],\\n.ui.dropdown > .text > .image[data-v-a3dbfc0c],\\n.ui.dropdown .menu > .item > .icon[data-v-a3dbfc0c],\\n.ui.dropdown .menu > .item > .label[data-v-a3dbfc0c],\\n.ui.dropdown .menu > .item > .flag[data-v-a3dbfc0c],\\n.ui.dropdown .menu > .item > .image[data-v-a3dbfc0c],\\n.ui.dropdown .menu > .item > img[data-v-a3dbfc0c] {\\n  margin-left: 0em;\\n  float: none;\\n  margin-right: 0.78571429rem;\\n}\\n\\n/*--------------\\n     Image\\n---------------*/\\n.ui.dropdown > .text > img[data-v-a3dbfc0c],\\n.ui.dropdown > .text > .image[data-v-a3dbfc0c],\\n.ui.dropdown .menu > .item > .image[data-v-a3dbfc0c],\\n.ui.dropdown .menu > .item > img[data-v-a3dbfc0c] {\\n  display: inline-block;\\n  vertical-align: middle;\\n  width: auto;\\n  max-height: 2em;\\n}\\n\\n\\n/*******************************\\n            Coupling\\n*******************************/\\n\\n\\n/*--------------\\n      Menu\\n---------------*/\\n\\n\\n/* Remove Menu Item Divider */\\n.ui.dropdown .ui.menu > .item[data-v-a3dbfc0c]:before,\\n.ui.menu .ui.dropdown .menu > .item[data-v-a3dbfc0c]:before {\\n  display: none;\\n}\\n\\n/* Prevent Menu Item Border */\\n.ui.menu .ui.dropdown .menu .active.item[data-v-a3dbfc0c] {\\n  border-left: none;\\n}\\n\\n/* Automatically float dropdown menu right on last menu item */\\n.ui.menu .right.menu .dropdown:last-child .menu[data-v-a3dbfc0c],\\n.ui.menu .right.dropdown.item .menu[data-v-a3dbfc0c],\\n.ui.buttons > .ui.dropdown:last-child .menu[data-v-a3dbfc0c] {\\n  left: auto;\\n  right: 0em;\\n}\\n\\n/*--------------\\n      Label\\n---------------*/\\n\\n\\n/* Dropdown Menu */\\n.ui.label.dropdown .menu[data-v-a3dbfc0c] {\\n  min-width: 100%;\\n}\\n\\n/*--------------\\n     Button\\n---------------*/\\n\\n\\n/* No Margin On Icon Button */\\n.ui.dropdown.icon.button > .dropdown.icon[data-v-a3dbfc0c] {\\n  margin: 0em;\\n}\\n.ui.button.dropdown .menu[data-v-a3dbfc0c] {\\n  min-width: 100%;\\n}\\n\\n\\n/*******************************\\n              Types\\n*******************************/\\n\\n\\n/*--------------\\n    Selection\\n---------------*/\\n\\n\\n/* Displays like a select box */\\n.ui.selection.dropdown[data-v-a3dbfc0c] {\\n  cursor: pointer;\\n  word-wrap: break-word;\\n  line-height: 1em;\\n  white-space: normal;\\n  outline: 0;\\n  -webkit-transform: rotateZ(0deg);\\n      -ms-transform: rotate(0deg);\\n          transform: rotateZ(0deg);\\n  min-width: 14em;\\n  min-height: 2.7142em;\\n  background: #FFFFFF;\\n  display: inline-block;\\n  padding: 0.78571429em 2.1em 0.78571429em 1em;\\n  color: rgba(0, 0, 0, 0.87);\\n  box-shadow: none;\\n  border: 1px solid rgba(34, 36, 38, 0.15);\\n  border-radius: 0.28571429rem;\\n  -webkit-transition: box-shadow 0.1s ease, width 0.1s ease;\\n  transition: box-shadow 0.1s ease, width 0.1s ease;\\n}\\n.ui.selection.dropdown.visible[data-v-a3dbfc0c],\\n.ui.selection.dropdown.active[data-v-a3dbfc0c] {\\n  z-index: 10;\\n}\\nselect.ui.dropdown[data-v-a3dbfc0c] {\\n  height: 38px;\\n  padding: 0.5em;\\n  border: 1px solid rgba(34, 36, 38, 0.15);\\n  visibility: visible;\\n}\\n.ui.selection.dropdown > .search.icon[data-v-a3dbfc0c],\\n.ui.selection.dropdown > .delete.icon[data-v-a3dbfc0c],\\n.ui.selection.dropdown > .dropdown.icon[data-v-a3dbfc0c] {\\n  cursor: pointer;\\n  position: absolute;\\n  width: auto;\\n  height: auto;\\n  line-height: 1.2142em;\\n  top: 0.78571429em;\\n  right: 1em;\\n  z-index: 3;\\n  margin: -0.78571429em;\\n  padding: 0.78571429em;\\n  opacity: 0.8;\\n  -webkit-transition: opacity 0.1s ease;\\n  transition: opacity 0.1s ease;\\n}\\n\\n/* Compact */\\n.ui.compact.selection.dropdown[data-v-a3dbfc0c] {\\n  min-width: 0px;\\n}\\n\\n/*  Selection Menu */\\n.ui.selection.dropdown .menu[data-v-a3dbfc0c] {\\n  overflow-x: hidden;\\n  overflow-y: auto;\\n  -webkit-backface-visibility: hidden;\\n          backface-visibility: hidden;\\n  -webkit-overflow-scrolling: touch;\\n  border-top-width: 0px !important;\\n  width: auto;\\n  outline: none;\\n  margin: 0px -1px;\\n  min-width: calc(100% +  2px );\\n  width: calc(100% +  2px );\\n  border-radius: 0em 0em 0.28571429rem 0.28571429rem;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n  -webkit-transition: opacity 0.1s ease;\\n  transition: opacity 0.1s ease;\\n}\\n.ui.selection.dropdown .menu[data-v-a3dbfc0c]:after,\\n.ui.selection.dropdown .menu[data-v-a3dbfc0c]:before {\\n  display: none;\\n}\\n\\n/*--------------\\n    Message\\n---------------*/\\n.ui.selection.dropdown .menu > .message[data-v-a3dbfc0c] {\\n  padding: 0.78571429rem 1.14285714rem;\\n}\\n@media only screen and (max-width: 767px) {\\n.ui.selection.dropdown .menu[data-v-a3dbfc0c] {\\n    max-height: 8.01428571rem;\\n}\\n}\\n@media only screen and (min-width: 768px) {\\n.ui.selection.dropdown .menu[data-v-a3dbfc0c] {\\n    max-height: 10.68571429rem;\\n}\\n}\\n@media only screen and (min-width: 992px) {\\n.ui.selection.dropdown .menu[data-v-a3dbfc0c] {\\n    max-height: 16.02857143rem;\\n}\\n}\\n@media only screen and (min-width: 1920px) {\\n.ui.selection.dropdown .menu[data-v-a3dbfc0c] {\\n    max-height: 21.37142857rem;\\n}\\n}\\n\\n/* Menu Item */\\n.ui.selection.dropdown .menu > .item[data-v-a3dbfc0c] {\\n  border-top: 1px solid #FAFAFA;\\n  padding: 0.78571429rem 1.14285714rem !important;\\n  white-space: normal;\\n  word-wrap: normal;\\n}\\n\\n/* User Item */\\n.ui.selection.dropdown .menu > .hidden.addition.item[data-v-a3dbfc0c] {\\n  display: none;\\n}\\n\\n/* Hover */\\n.ui.selection.dropdown[data-v-a3dbfc0c]:hover {\\n  border-color: rgba(34, 36, 38, 0.35);\\n  box-shadow: none;\\n}\\n\\n/* Active */\\n.ui.selection.active.dropdown[data-v-a3dbfc0c] {\\n  border-color: #96C8DA;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n}\\n.ui.selection.active.dropdown .menu[data-v-a3dbfc0c] {\\n  border-color: #96C8DA;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n}\\n\\n/* Focus */\\n.ui.selection.dropdown[data-v-a3dbfc0c]:focus {\\n  border-color: #96C8DA;\\n  box-shadow: none;\\n}\\n.ui.selection.dropdown:focus .menu[data-v-a3dbfc0c] {\\n  border-color: #96C8DA;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n}\\n\\n/* Visible */\\n.ui.selection.visible.dropdown > .text[data-v-a3dbfc0c]:not(.default) {\\n  font-weight: normal;\\n  color: rgba(0, 0, 0, 0.8);\\n}\\n\\n/* Visible Hover */\\n.ui.selection.active.dropdown[data-v-a3dbfc0c]:hover {\\n  border-color: #96C8DA;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n}\\n.ui.selection.active.dropdown:hover .menu[data-v-a3dbfc0c] {\\n  border-color: #96C8DA;\\n  box-shadow: 0px 2px 3px 0px rgba(34, 36, 38, 0.15);\\n}\\n\\n/* Dropdown Icon */\\n.ui.active.selection.dropdown > .dropdown.icon[data-v-a3dbfc0c],\\n.ui.visible.selection.dropdown > .dropdown.icon[data-v-a3dbfc0c] {\\n  opacity: 1;\\n  z-index: 3;\\n}\\n\\n/* Connecting Border */\\n.ui.active.selection.dropdown[data-v-a3dbfc0c] {\\n  border-bottom-left-radius: 0em !important;\\n  border-bottom-right-radius: 0em !important;\\n}\\n\\n/* Empty Connecting Border */\\n.ui.active.empty.selection.dropdown[data-v-a3dbfc0c] {\\n  border-radius: 0.28571429rem !important;\\n  box-shadow: none !important;\\n}\\n.ui.active.empty.selection.dropdown .menu[data-v-a3dbfc0c] {\\n  border: none !important;\\n  box-shadow: none !important;\\n}\\n\\n/*--------------\\n   Searchable\\n---------------*/\\n\\n\\n/* Search Selection */\\n.ui.search.dropdown[data-v-a3dbfc0c] {\\n  min-width: '';\\n}\\n\\n/* Search Dropdown */\\n.ui.search.dropdown > input.search[data-v-a3dbfc0c] {\\n  background: none transparent !important;\\n  border: none !important;\\n  box-shadow: none !important;\\n  cursor: text;\\n  top: 0em;\\n  left: 1px;\\n  width: 100%;\\n  outline: none;\\n  -webkit-tap-highlight-color: rgba(255, 255, 255, 0);\\n  padding: inherit;\\n}\\n\\n/* Text Layering */\\n.ui.search.dropdown > input.search[data-v-a3dbfc0c] {\\n  position: absolute;\\n  z-index: 2;\\n}\\n.ui.search.dropdown > .text[data-v-a3dbfc0c] {\\n  cursor: text;\\n  position: relative;\\n  left: 1px;\\n  z-index: 3;\\n}\\n\\n/* Search Selection */\\n.ui.search.selection.dropdown > input.search[data-v-a3dbfc0c] {\\n  line-height: 1.2142em;\\n  padding: 0.67861429em 2.1em 0.67861429em 1em;\\n}\\n\\n/* Used to size multi select input to character width */\\n.ui.search.selection.dropdown > span.sizer[data-v-a3dbfc0c] {\\n  line-height: 1.2142em;\\n  padding: 0.67861429em 2.1em 0.67861429em 1em;\\n  display: none;\\n  white-space: pre;\\n}\\n\\n/* Active/Visible Search */\\n.ui.search.dropdown.active > input.search[data-v-a3dbfc0c],\\n.ui.search.dropdown.visible > input.search[data-v-a3dbfc0c] {\\n  cursor: auto;\\n}\\n.ui.search.dropdown.active > .text[data-v-a3dbfc0c],\\n.ui.search.dropdown.visible > .text[data-v-a3dbfc0c] {\\n  pointer-events: none;\\n}\\n\\n/* Filtered Text */\\n.ui.active.search.dropdown input.search:focus + .text .icon[data-v-a3dbfc0c],\\n.ui.active.search.dropdown input.search:focus + .text .flag[data-v-a3dbfc0c] {\\n  opacity: 0.45;\\n}\\n.ui.active.search.dropdown input.search:focus + .text[data-v-a3dbfc0c] {\\n  color: rgba(115, 115, 115, 0.87) !important;\\n}\\n\\n/* Search Menu */\\n.ui.search.dropdown .menu[data-v-a3dbfc0c] {\\n  overflow-x: hidden;\\n  overflow-y: auto;\\n  -webkit-backface-visibility: hidden;\\n          backface-visibility: hidden;\\n  -webkit-overflow-scrolling: touch;\\n}\\n@media only screen and (max-width: 767px) {\\n.ui.search.dropdown .menu[data-v-a3dbfc0c] {\\n    max-height: 8.01428571rem;\\n}\\n}\\n@media only screen and (min-width: 768px) {\\n.ui.search.dropdown .menu[data-v-a3dbfc0c] {\\n    max-height: 10.68571429rem;\\n}\\n}\\n@media only screen and (min-width: 992px) {\\n.ui.search.dropdown .menu[data-v-a3dbfc0c] {\\n    max-height: 16.02857143rem;\\n}\\n}\\n@media only screen and (min-width: 1920px) {\\n.ui.search.dropdown .menu[data-v-a3dbfc0c] {\\n    max-height: 21.37142857rem;\\n}\\n}\\n\\n/*--------------\\n    Multiple\\n---------------*/\\n\\n\\n/* Multiple Selection */\\n.ui.multiple.dropdown[data-v-a3dbfc0c] {\\n  padding: 0.22620476em 2.1em 0.22620476em 0.35714286em;\\n}\\n.ui.multiple.dropdown .menu[data-v-a3dbfc0c] {\\n  cursor: auto;\\n}\\n\\n/* Multiple Search Selection */\\n.ui.multiple.search.dropdown[data-v-a3dbfc0c],\\n.ui.multiple.search.dropdown > input.search[data-v-a3dbfc0c] {\\n  cursor: text;\\n}\\n\\n/* Selection Label */\\n.ui.multiple.dropdown > .label[data-v-a3dbfc0c] {\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n      -ms-user-select: none;\\n          user-select: none;\\n  display: inline-block;\\n  vertical-align: top;\\n  white-space: normal;\\n  font-size: 1em;\\n  padding: 0.35714286em 0.78571429em;\\n  margin: 0.14285714rem 0.28571429rem 0.14285714rem 0em;\\n  box-shadow: 0px 0px 0px 1px rgba(34, 36, 38, 0.15) inset;\\n}\\n\\n/* Dropdown Icon */\\n.ui.multiple.dropdown .dropdown.icon[data-v-a3dbfc0c] {\\n  margin: '';\\n  padding: '';\\n}\\n\\n/* Text */\\n.ui.multiple.dropdown > .text[data-v-a3dbfc0c] {\\n  position: static;\\n  padding: 0;\\n  max-width: 100%;\\n  margin: 0.45240952em 0em 0.45240952em 0.64285714em;\\n  line-height: 1.21428571em;\\n}\\n.ui.multiple.dropdown > .label ~ input.search[data-v-a3dbfc0c] {\\n  margin-left: 0.14285714em !important;\\n}\\n.ui.multiple.dropdown > .label ~ .text[data-v-a3dbfc0c] {\\n  display: none;\\n}\\n\\n/*-----------------\\n  Multiple Search\\n-----------------*/\\n\\n\\n/* Prompt Text */\\n.ui.multiple.search.dropdown > .text[data-v-a3dbfc0c] {\\n  display: inline-block;\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  padding: inherit;\\n  margin: 0.45240952em 0em 0.45240952em 0.64285714em;\\n  line-height: 1.21428571em;\\n}\\n.ui.multiple.search.dropdown > .label ~ .text[data-v-a3dbfc0c] {\\n  display: none;\\n}\\n\\n/* Search */\\n.ui.multiple.search.dropdown > input.search[data-v-a3dbfc0c] {\\n  position: static;\\n  padding: 0;\\n  max-width: 100%;\\n  margin: 0.45240952em 0em 0.45240952em 0.64285714em;\\n  width: 2.2em;\\n  line-height: 1.21428571em;\\n}\\n\\n/*--------------\\n     Inline\\n---------------*/\\n.ui.inline.dropdown[data-v-a3dbfc0c] {\\n  cursor: pointer;\\n  display: inline-block;\\n  color: inherit;\\n}\\n.ui.inline.dropdown .dropdown.icon[data-v-a3dbfc0c] {\\n  margin: 0em 0.5em 0em 0.21428571em;\\n  vertical-align: baseline;\\n}\\n.ui.inline.dropdown > .text[data-v-a3dbfc0c] {\\n  font-weight: bold;\\n}\\n.ui.inline.dropdown .menu[data-v-a3dbfc0c] {\\n  cursor: auto;\\n  margin-top: 0.21428571em;\\n  border-radius: 0.28571429rem;\\n}\\n\\n\\n/*******************************\\n            States\\n*******************************/\\n\\n\\n/*--------------------\\n        Active\\n----------------------*/\\n\\n\\n/* Menu Item Active */\\n.ui.dropdown .menu .active.item[data-v-a3dbfc0c] {\\n  background: transparent;\\n  font-weight: bold;\\n  color: rgba(0, 0, 0, 0.95);\\n  box-shadow: none;\\n  z-index: 12;\\n}\\n\\n/*--------------------\\n        Hover\\n----------------------*/\\n\\n\\n/* Menu Item Hover */\\n.ui.dropdown .menu > .item[data-v-a3dbfc0c]:hover {\\n  background: rgba(0, 0, 0, 0.05);\\n  color: rgba(0, 0, 0, 0.95);\\n  z-index: 13;\\n}\\n\\n/*--------------------\\n       Loading\\n---------------------*/\\n.ui.loading.dropdown > i.icon[data-v-a3dbfc0c] {\\n  height: 1em !important;\\n  padding: 1.14285714em 1.07142857em !important;\\n}\\n.ui.loading.dropdown > i.icon[data-v-a3dbfc0c]:before {\\n  position: absolute;\\n  content: '';\\n  top: 50%;\\n  left: 50%;\\n  margin: -0.64285714em 0em 0em -0.64285714em;\\n  width: 1.28571429em;\\n  height: 1.28571429em;\\n  border-radius: 500rem;\\n  border: 0.2em solid rgba(0, 0, 0, 0.1);\\n}\\n.ui.loading.dropdown > i.icon[data-v-a3dbfc0c]:after {\\n  position: absolute;\\n  content: '';\\n  top: 50%;\\n  left: 50%;\\n  box-shadow: 0px 0px 0px 1px transparent;\\n  margin: -0.64285714em 0em 0em -0.64285714em;\\n  width: 1.28571429em;\\n  height: 1.28571429em;\\n  -webkit-animation: dropdown-spin 0.6s linear;\\n          animation: dropdown-spin 0.6s linear;\\n  -webkit-animation-iteration-count: infinite;\\n          animation-iteration-count: infinite;\\n  border-radius: 500rem;\\n  border-color: #767676 transparent transparent;\\n  border-style: solid;\\n  border-width: 0.2em;\\n}\\n\\n/* Coupling */\\n.ui.loading.dropdown.button > i.icon[data-v-a3dbfc0c]:before,\\n.ui.loading.dropdown.button > i.icon[data-v-a3dbfc0c]:after {\\n  display: none;\\n}\\n@-webkit-keyframes dropdown-spin {\\nfrom {\\n    -webkit-transform: rotate(0deg);\\n            transform: rotate(0deg);\\n}\\nto {\\n    -webkit-transform: rotate(360deg);\\n            transform: rotate(360deg);\\n}\\n}\\n@keyframes dropdown-spin {\\nfrom {\\n    -webkit-transform: rotate(0deg);\\n            transform: rotate(0deg);\\n}\\nto {\\n    -webkit-transform: rotate(360deg);\\n            transform: rotate(360deg);\\n}\\n}\\n\\n/*--------------------\\n     Default Text\\n----------------------*/\\n.ui.dropdown:not(.button) > .default.text[data-v-a3dbfc0c],\\n.ui.default.dropdown:not(.button) > .text[data-v-a3dbfc0c] {\\n  color: rgba(191, 191, 191, 0.87);\\n}\\n.ui.dropdown:not(.button) > input:focus + .default.text[data-v-a3dbfc0c],\\n.ui.default.dropdown:not(.button) > input:focus + .text[data-v-a3dbfc0c] {\\n  color: rgba(115, 115, 115, 0.87);\\n}\\n\\n/*--------------------\\n        Loading\\n----------------------*/\\n.ui.loading.dropdown > .text[data-v-a3dbfc0c] {\\n  -webkit-transition: none;\\n  transition: none;\\n}\\n\\n/* Used To Check Position */\\n.ui.dropdown .loading.menu[data-v-a3dbfc0c] {\\n  display: block;\\n  visibility: hidden;\\n  z-index: -1;\\n}\\n\\n/*--------------------\\n    Keyboard Select\\n----------------------*/\\n\\n\\n/* Selected Item */\\n.ui.dropdown.selected[data-v-a3dbfc0c],\\n.ui.dropdown .menu .selected.item[data-v-a3dbfc0c] {\\n  background: rgba(0, 0, 0, 0.03);\\n  color: rgba(0, 0, 0, 0.95);\\n}\\n\\n/*--------------------\\n    Search Filtered\\n----------------------*/\\n\\n\\n/* Filtered Item */\\n.ui.dropdown > .filtered.text[data-v-a3dbfc0c] {\\n  visibility: hidden;\\n}\\n.ui.dropdown .filtered.item[data-v-a3dbfc0c] {\\n  display: none !important;\\n}\\n\\n/*--------------------\\n        Error\\n----------------------*/\\n.ui.dropdown.error[data-v-a3dbfc0c],\\n.ui.dropdown.error > .text[data-v-a3dbfc0c],\\n.ui.dropdown.error > .default.text[data-v-a3dbfc0c] {\\n  color: #9F3A38;\\n}\\n.ui.selection.dropdown.error[data-v-a3dbfc0c] {\\n  background: #FFF6F6;\\n  border-color: #E0B4B4;\\n}\\n.ui.selection.dropdown.error[data-v-a3dbfc0c]:hover {\\n  border-color: #E0B4B4;\\n}\\n.ui.dropdown.error > .menu[data-v-a3dbfc0c],\\n.ui.dropdown.error > .menu .menu[data-v-a3dbfc0c] {\\n  border-color: #E0B4B4;\\n}\\n.ui.dropdown.error > .menu > .item[data-v-a3dbfc0c] {\\n  color: #9F3A38;\\n}\\n.ui.multiple.selection.error.dropdown > .label[data-v-a3dbfc0c] {\\n  border-color: #E0B4B4;\\n}\\n\\n/* Item Hover */\\n.ui.dropdown.error > .menu > .item[data-v-a3dbfc0c]:hover {\\n  background-color: #FFF2F2;\\n}\\n\\n/* Item Active */\\n.ui.dropdown.error > .menu .active.item[data-v-a3dbfc0c] {\\n  background-color: #FDCFCF;\\n}\\n\\n/*--------------------\\n        Disabled\\n----------------------*/\\n\\n\\n/* Disabled */\\n.ui.disabled.dropdown[data-v-a3dbfc0c],\\n.ui.dropdown .menu > .disabled.item[data-v-a3dbfc0c] {\\n  cursor: default;\\n  pointer-events: none;\\n  opacity: 0.45;\\n}\\n\\n\\n/*******************************\\n           Variations\\n*******************************/\\n\\n\\n/*--------------\\n    Direction\\n---------------*/\\n\\n\\n/* Flyout Direction */\\n.ui.dropdown .menu[data-v-a3dbfc0c] {\\n  left: 0px;\\n}\\n\\n/* Default Side (Right) */\\n.ui.dropdown .right.menu > .menu[data-v-a3dbfc0c],\\n.ui.dropdown .menu .right.menu[data-v-a3dbfc0c] {\\n  left: 100% !important;\\n  right: auto !important;\\n  border-radius: 0.28571429rem !important;\\n}\\n\\n/* Left Flyout Menu */\\n.ui.dropdown > .left.menu .menu[data-v-a3dbfc0c],\\n.ui.dropdown .menu .left.menu[data-v-a3dbfc0c] {\\n  left: auto !important;\\n  right: 100% !important;\\n  border-radius: 0.28571429rem !important;\\n}\\n.ui.dropdown .item .left.dropdown.icon[data-v-a3dbfc0c],\\n.ui.dropdown .left.menu .item .dropdown.icon[data-v-a3dbfc0c] {\\n  width: auto;\\n  float: left;\\n  margin: 0em 0.78571429rem 0em 0em;\\n}\\n.ui.dropdown .item .left.dropdown.icon[data-v-a3dbfc0c],\\n.ui.dropdown .left.menu .item .dropdown.icon[data-v-a3dbfc0c] {\\n  width: auto;\\n  float: left;\\n  margin: 0em 0.78571429rem 0em 0em;\\n}\\n.ui.dropdown .item .left.dropdown.icon + .text[data-v-a3dbfc0c],\\n.ui.dropdown .left.menu .item .dropdown.icon + .text[data-v-a3dbfc0c] {\\n  margin-left: 1em;\\n}\\n\\n/*--------------\\n     Upward\\n---------------*/\\n\\n\\n/* Upward Main Menu */\\n.ui.upward.dropdown > .menu[data-v-a3dbfc0c] {\\n  top: auto;\\n  bottom: 100%;\\n  box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.08);\\n  border-radius: 0.28571429rem 0.28571429rem 0em 0em;\\n}\\n\\n/* Upward Sub Menu */\\n.ui.dropdown .upward.menu[data-v-a3dbfc0c] {\\n  top: auto !important;\\n  bottom: 0 !important;\\n}\\n\\n/* Active Upward */\\n.ui.simple.upward.active.dropdown[data-v-a3dbfc0c],\\n.ui.simple.upward.dropdown[data-v-a3dbfc0c]:hover {\\n  border-radius: 0.28571429rem 0.28571429rem 0em 0em !important;\\n}\\n.ui.upward.dropdown.button:not(.pointing):not(.floating).active[data-v-a3dbfc0c] {\\n  border-radius: 0.28571429rem 0.28571429rem 0em 0em;\\n}\\n\\n/* Selection */\\n.ui.upward.selection.dropdown .menu[data-v-a3dbfc0c] {\\n  border-top-width: 1px !important;\\n  border-bottom-width: 0px !important;\\n  box-shadow: 0px -2px 3px 0px rgba(0, 0, 0, 0.08);\\n}\\n.ui.upward.selection.dropdown[data-v-a3dbfc0c]:hover {\\n  box-shadow: 0px 0px 2px 0px rgba(0, 0, 0, 0.05);\\n}\\n\\n/* Active Upward */\\n.ui.active.upward.selection.dropdown[data-v-a3dbfc0c] {\\n  border-radius: 0em 0em 0.28571429rem 0.28571429rem !important;\\n}\\n\\n/* Visible Upward */\\n.ui.upward.selection.dropdown.visible[data-v-a3dbfc0c] {\\n  box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.08);\\n  border-radius: 0em 0em 0.28571429rem 0.28571429rem !important;\\n}\\n\\n/* Visible Hover Upward */\\n.ui.upward.active.selection.dropdown[data-v-a3dbfc0c]:hover {\\n  box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 0.05);\\n}\\n.ui.upward.active.selection.dropdown:hover .menu[data-v-a3dbfc0c] {\\n  box-shadow: 0px -2px 3px 0px rgba(0, 0, 0, 0.08);\\n}\\n\\n/*--------------\\n     Simple\\n---------------*/\\n\\n\\n/*  Selection Menu */\\n.ui.scrolling.dropdown .menu[data-v-a3dbfc0c],\\n.ui.dropdown .scrolling.menu[data-v-a3dbfc0c] {\\n  overflow-x: hidden;\\n  overflow-y: auto;\\n}\\n.ui.scrolling.dropdown .menu[data-v-a3dbfc0c] {\\n  overflow-x: hidden;\\n  overflow-y: auto;\\n  -webkit-backface-visibility: hidden;\\n          backface-visibility: hidden;\\n  -webkit-overflow-scrolling: touch;\\n  min-width: 100% !important;\\n  width: auto !important;\\n}\\n.ui.dropdown .scrolling.menu[data-v-a3dbfc0c] {\\n  position: static;\\n  overflow-y: auto;\\n  border: none;\\n  box-shadow: none !important;\\n  border-radius: 0 !important;\\n  margin: 0 !important;\\n  min-width: 100% !important;\\n  width: auto !important;\\n  border-top: 1px solid rgba(34, 36, 38, 0.15);\\n}\\n.ui.scrolling.dropdown .menu .item.item.item[data-v-a3dbfc0c],\\n.ui.dropdown .scrolling.menu > .item.item.item[data-v-a3dbfc0c] {\\n  border-top: none;\\n  padding-right: calc( 1.14285714rem  +  17px ) !important;\\n}\\n.ui.scrolling.dropdown .menu .item[data-v-a3dbfc0c]:first-child,\\n.ui.dropdown .scrolling.menu .item[data-v-a3dbfc0c]:first-child {\\n  border-top: none;\\n}\\n.ui.dropdown > .animating.menu .scrolling.menu[data-v-a3dbfc0c],\\n.ui.dropdown > .visible.menu .scrolling.menu[data-v-a3dbfc0c] {\\n  display: block;\\n}\\n\\n/* Scrollbar in IE */\\n@media all and (-ms-high-contrast: none) {\\n.ui.scrolling.dropdown .menu[data-v-a3dbfc0c],\\n  .ui.dropdown .scrolling.menu[data-v-a3dbfc0c] {\\n    min-width: calc(100% -  17px );\\n}\\n}\\n@media only screen and (max-width: 767px) {\\n.ui.scrolling.dropdown .menu[data-v-a3dbfc0c],\\n  .ui.dropdown .scrolling.menu[data-v-a3dbfc0c] {\\n    max-height: 10.28571429rem;\\n}\\n}\\n@media only screen and (min-width: 768px) {\\n.ui.scrolling.dropdown .menu[data-v-a3dbfc0c],\\n  .ui.dropdown .scrolling.menu[data-v-a3dbfc0c] {\\n    max-height: 15.42857143rem;\\n}\\n}\\n@media only screen and (min-width: 992px) {\\n.ui.scrolling.dropdown .menu[data-v-a3dbfc0c],\\n  .ui.dropdown .scrolling.menu[data-v-a3dbfc0c] {\\n    max-height: 20.57142857rem;\\n}\\n}\\n@media only screen and (min-width: 1920px) {\\n.ui.scrolling.dropdown .menu[data-v-a3dbfc0c],\\n  .ui.dropdown .scrolling.menu[data-v-a3dbfc0c] {\\n    max-height: 20.57142857rem;\\n}\\n}\\n\\n/*--------------\\n     Simple\\n---------------*/\\n\\n\\n/* Displays without javascript */\\n.ui.simple.dropdown .menu[data-v-a3dbfc0c]:before,\\n.ui.simple.dropdown .menu[data-v-a3dbfc0c]:after {\\n  display: none;\\n}\\n.ui.simple.dropdown .menu[data-v-a3dbfc0c] {\\n  position: absolute;\\n  display: block;\\n  overflow: hidden;\\n  top: -9999px !important;\\n  opacity: 0;\\n  width: 0;\\n  height: 0;\\n  -webkit-transition: opacity 0.1s ease;\\n  transition: opacity 0.1s ease;\\n}\\n.ui.simple.active.dropdown[data-v-a3dbfc0c],\\n.ui.simple.dropdown[data-v-a3dbfc0c]:hover {\\n  border-bottom-left-radius: 0em !important;\\n  border-bottom-right-radius: 0em !important;\\n}\\n.ui.simple.active.dropdown > .menu[data-v-a3dbfc0c],\\n.ui.simple.dropdown:hover > .menu[data-v-a3dbfc0c] {\\n  overflow: visible;\\n  width: auto;\\n  height: auto;\\n  top: 100% !important;\\n  opacity: 1;\\n}\\n.ui.simple.dropdown > .menu > .item:active > .menu[data-v-a3dbfc0c],\\n.ui.simple.dropdown:hover > .menu > .item:hover > .menu[data-v-a3dbfc0c] {\\n  overflow: visible;\\n  width: auto;\\n  height: auto;\\n  top: 0% !important;\\n  left: 100% !important;\\n  opacity: 1;\\n}\\n.ui.simple.disabled.dropdown:hover .menu[data-v-a3dbfc0c] {\\n  display: none;\\n  height: 0px;\\n  width: 0px;\\n  overflow: hidden;\\n}\\n\\n/* Visible */\\n.ui.simple.visible.dropdown > .menu[data-v-a3dbfc0c] {\\n  display: block;\\n}\\n\\n/*--------------\\n      Fluid\\n---------------*/\\n.ui.fluid.dropdown[data-v-a3dbfc0c] {\\n  display: block;\\n  width: 100%;\\n  min-width: 0em;\\n}\\n.ui.fluid.dropdown > .dropdown.icon[data-v-a3dbfc0c] {\\n  float: right;\\n}\\n\\n/*--------------\\n    Floating\\n---------------*/\\n.ui.floating.dropdown .menu[data-v-a3dbfc0c] {\\n  left: 0;\\n  right: auto;\\n  box-shadow: 0px 2px 4px 0px rgba(34, 36, 38, 0.12), 0px 2px 10px 0px rgba(34, 36, 38, 0.15) !important;\\n  border-radius: 0.28571429rem !important;\\n}\\n.ui.floating.dropdown > .menu[data-v-a3dbfc0c] {\\n  margin-top: 0.5em !important;\\n  border-radius: 0.28571429rem !important;\\n}\\n\\n/*--------------\\n     Pointing\\n---------------*/\\n.ui.pointing.dropdown > .menu[data-v-a3dbfc0c] {\\n  top: 100%;\\n  margin-top: 0.78571429rem;\\n  border-radius: 0.28571429rem;\\n}\\n.ui.pointing.dropdown > .menu[data-v-a3dbfc0c]:after {\\n  display: block;\\n  position: absolute;\\n  pointer-events: none;\\n  content: '';\\n  visibility: visible;\\n  -webkit-transform: rotate(45deg);\\n      -ms-transform: rotate(45deg);\\n          transform: rotate(45deg);\\n  width: 0.5em;\\n  height: 0.5em;\\n  box-shadow: -1px -1px 0px 1px rgba(34, 36, 38, 0.15);\\n  background: #FFFFFF;\\n  z-index: 2;\\n}\\n.ui.pointing.dropdown > .menu[data-v-a3dbfc0c]:after {\\n  top: -0.25em;\\n  left: 50%;\\n  margin: 0em 0em 0em -0.25em;\\n}\\n\\n/* Top Left Pointing */\\n.ui.top.left.pointing.dropdown > .menu[data-v-a3dbfc0c] {\\n  top: 100%;\\n  bottom: auto;\\n  left: 0%;\\n  right: auto;\\n  margin: 1em 0em 0em;\\n}\\n.ui.top.left.pointing.dropdown > .menu[data-v-a3dbfc0c] {\\n  top: 100%;\\n  bottom: auto;\\n  left: 0%;\\n  right: auto;\\n  margin: 1em 0em 0em;\\n}\\n.ui.top.left.pointing.dropdown > .menu[data-v-a3dbfc0c]:after {\\n  top: -0.25em;\\n  left: 1em;\\n  right: auto;\\n  margin: 0em;\\n  -webkit-transform: rotate(45deg);\\n      -ms-transform: rotate(45deg);\\n          transform: rotate(45deg);\\n}\\n\\n/* Top Right  Pointing */\\n.ui.top.right.pointing.dropdown > .menu[data-v-a3dbfc0c] {\\n  top: 100%;\\n  bottom: auto;\\n  right: 0%;\\n  left: auto;\\n  margin: 1em 0em 0em;\\n}\\n.ui.top.right.pointing.dropdown > .menu[data-v-a3dbfc0c]:after {\\n  top: -0.25em;\\n  left: auto;\\n  right: 1em;\\n  margin: 0em;\\n  -webkit-transform: rotate(45deg);\\n      -ms-transform: rotate(45deg);\\n          transform: rotate(45deg);\\n}\\n\\n/* Left Pointing */\\n.ui.left.pointing.dropdown > .menu[data-v-a3dbfc0c] {\\n  top: 0%;\\n  left: 100%;\\n  right: auto;\\n  margin: 0em 0em 0em 1em;\\n}\\n.ui.left.pointing.dropdown > .menu[data-v-a3dbfc0c]:after {\\n  top: 1em;\\n  left: -0.25em;\\n  margin: 0em 0em 0em 0em;\\n  -webkit-transform: rotate(-45deg);\\n      -ms-transform: rotate(-45deg);\\n          transform: rotate(-45deg);\\n}\\n\\n/* Right Pointing */\\n.ui.right.pointing.dropdown > .menu[data-v-a3dbfc0c] {\\n  top: 0%;\\n  left: auto;\\n  right: 100%;\\n  margin: 0em 1em 0em 0em;\\n}\\n.ui.right.pointing.dropdown > .menu[data-v-a3dbfc0c]:after {\\n  top: 1em;\\n  left: auto;\\n  right: -0.25em;\\n  margin: 0em 0em 0em 0em;\\n  -webkit-transform: rotate(135deg);\\n      -ms-transform: rotate(135deg);\\n          transform: rotate(135deg);\\n}\\n\\n/* Bottom Pointing */\\n.ui.bottom.pointing.dropdown > .menu[data-v-a3dbfc0c] {\\n  top: auto;\\n  bottom: 100%;\\n  left: 0%;\\n  right: auto;\\n  margin: 0em 0em 1em;\\n}\\n.ui.bottom.pointing.dropdown > .menu[data-v-a3dbfc0c]:after {\\n  top: auto;\\n  bottom: -0.25em;\\n  right: auto;\\n  margin: 0em;\\n  -webkit-transform: rotate(-135deg);\\n      -ms-transform: rotate(-135deg);\\n          transform: rotate(-135deg);\\n}\\n\\n/* Reverse Sub-Menu Direction */\\n.ui.bottom.pointing.dropdown > .menu .menu[data-v-a3dbfc0c] {\\n  top: auto !important;\\n  bottom: 0px !important;\\n}\\n\\n/* Bottom Left */\\n.ui.bottom.left.pointing.dropdown > .menu[data-v-a3dbfc0c] {\\n  left: 0%;\\n  right: auto;\\n}\\n.ui.bottom.left.pointing.dropdown > .menu[data-v-a3dbfc0c]:after {\\n  left: 1em;\\n  right: auto;\\n}\\n\\n/* Bottom Right */\\n.ui.bottom.right.pointing.dropdown > .menu[data-v-a3dbfc0c] {\\n  right: 0%;\\n  left: auto;\\n}\\n.ui.bottom.right.pointing.dropdown > .menu[data-v-a3dbfc0c]:after {\\n  left: auto;\\n  right: 1em;\\n}\\n\\n/* Upward pointing */\\n.ui.upward.pointing.dropdown > .menu[data-v-a3dbfc0c],\\n.ui.upward.top.pointing.dropdown > .menu[data-v-a3dbfc0c] {\\n  top: auto;\\n  bottom: 100%;\\n  margin: 0em 0em 0.78571429rem;\\n  border-radius: 0.28571429rem;\\n}\\n.ui.upward.pointing.dropdown > .menu[data-v-a3dbfc0c]:after,\\n.ui.upward.top.pointing.dropdown > .menu[data-v-a3dbfc0c]:after {\\n  top: 100%;\\n  bottom: auto;\\n  box-shadow: 1px 1px 0px 1px rgba(34, 36, 38, 0.15);\\n  margin: -0.25em 0em 0em;\\n}\\n\\n\\n/*******************************\\n         Theme Overrides\\n*******************************/\\n\\n\\n/* Dropdown Carets */\\n@font-face {\\n  font-family: 'Dropdown';\\n  src: url(data:application/x-font-ttf;charset=utf-8;base64,AAEAAAALAIAAAwAwT1MvMggjB5AAAAC8AAAAYGNtYXAPfuIIAAABHAAAAExnYXNwAAAAEAAAAWgAAAAIZ2x5Zjo82LgAAAFwAAABVGhlYWQAQ88bAAACxAAAADZoaGVhAwcB6QAAAvwAAAAkaG10eAS4ABIAAAMgAAAAIGxvY2EBNgDeAAADQAAAABJtYXhwAAoAFgAAA1QAAAAgbmFtZVcZpu4AAAN0AAABRXBvc3QAAwAAAAAEvAAAACAAAwIAAZAABQAAAUwBZgAAAEcBTAFmAAAA9QAZAIQAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADw2gHg/+D/4AHgACAAAAABAAAAAAAAAAAAAAAgAAAAAAACAAAAAwAAABQAAwABAAAAFAAEADgAAAAKAAgAAgACAAEAIPDa//3//wAAAAAAIPDX//3//wAB/+MPLQADAAEAAAAAAAAAAAAAAAEAAf//AA8AAQAAAAAAAAAAAAIAADc5AQAAAAABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAIABJQElABMAABM0NzY3BTYXFhUUDwEGJwYvASY1AAUGBwEACAUGBoAFCAcGgAUBEgcGBQEBAQcECQYHfwYBAQZ/BwYAAQAAAG4BJQESABMAADc0PwE2MzIfARYVFAcGIyEiJyY1AAWABgcIBYAGBgUI/wAHBgWABwaABQWABgcHBgUFBgcAAAABABIASQC3AW4AEwAANzQ/ATYXNhcWHQEUBwYnBi8BJjUSBoAFCAcFBgYFBwgFgAbbBwZ/BwEBBwQJ/wgEBwEBB38GBgAAAAABAAAASQClAW4AEwAANxE0NzYzMh8BFhUUDwEGIyInJjUABQYHCAWABgaABQgHBgVbAQAIBQYGgAUIBwWABgYFBwAAAAEAAAABAADZuaKOXw889QALAgAAAAAA0ABHWAAAAADQAEdYAAAAAAElAW4AAAAIAAIAAAAAAAAAAQAAAeD/4AAAAgAAAAAAASUAAQAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAABAAAAASUAAAElAAAAtwASALcAAAAAAAAACgAUAB4AQgBkAIgAqgAAAAEAAAAIABQAAQAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAOAK4AAQAAAAAAAQAOAAAAAQAAAAAAAgAOAEcAAQAAAAAAAwAOACQAAQAAAAAABAAOAFUAAQAAAAAABQAWAA4AAQAAAAAABgAHADIAAQAAAAAACgA0AGMAAwABBAkAAQAOAAAAAwABBAkAAgAOAEcAAwABBAkAAwAOACQAAwABBAkABAAOAFUAAwABBAkABQAWAA4AAwABBAkABgAOADkAAwABBAkACgA0AGMAaQBjAG8AbQBvAG8AbgBWAGUAcgBzAGkAbwBuACAAMQAuADAAaQBjAG8AbQBvAG8Abmljb21vb24AaQBjAG8AbQBvAG8AbgBSAGUAZwB1AGwAYQByAGkAYwBvAG0AbwBvAG4ARgBvAG4AdAAgAGcAZQBuAGUAcgBhAHQAZQBkACAAYgB5ACAASQBjAG8ATQBvAG8AbgAuAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=) format('truetype'), url(data:application/font-woff;charset=utf-8;base64,d09GRk9UVE8AAAVwAAoAAAAABSgAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABDRkYgAAAA9AAAAdkAAAHZLDXE/09TLzIAAALQAAAAYAAAAGAIIweQY21hcAAAAzAAAABMAAAATA9+4ghnYXNwAAADfAAAAAgAAAAIAAAAEGhlYWQAAAOEAAAANgAAADYAQ88baGhlYQAAA7wAAAAkAAAAJAMHAelobXR4AAAD4AAAACAAAAAgBLgAEm1heHAAAAQAAAAABgAAAAYACFAAbmFtZQAABAgAAAFFAAABRVcZpu5wb3N0AAAFUAAAACAAAAAgAAMAAAEABAQAAQEBCGljb21vb24AAQIAAQA6+BwC+BsD+BgEHgoAGVP/i4seCgAZU/+LiwwHi2v4lPh0BR0AAACIDx0AAACNER0AAAAJHQAAAdASAAkBAQgPERMWGyAlKmljb21vb25pY29tb29udTB1MXUyMHVGMEQ3dUYwRDh1RjBEOXVGMERBAAACAYkABgAIAgABAAQABwAKAA0AVgCfAOgBL/yUDvyUDvyUDvuUDvtvi/emFYuQjZCOjo+Pj42Qiwj3lIsFkIuQiY6Hj4iNhouGi4aJh4eHCPsU+xQFiIiGiYaLhouHjYeOCPsU9xQFiI+Jj4uQCA77b4v3FBWLkI2Pjo8I9xT3FAWPjo+NkIuQi5CJjogI9xT7FAWPh42Hi4aLhomHh4eIiIaJhosI+5SLBYaLh42HjoiPiY+LkAgO+92d928Vi5CNkI+OCPcU9xQFjo+QjZCLkIuPiY6Hj4iNhouGCIv7lAWLhomHh4iIh4eJhouGi4aNiI8I+xT3FAWHjomPi5AIDvvdi+YVi/eUBYuQjZCOjo+Pj42Qi5CLkImOhwj3FPsUBY+IjYaLhouGiYeHiAj7FPsUBYiHhomGi4aLh42Hj4iOiY+LkAgO+JQU+JQViwwKAAAAAAMCAAGQAAUAAAFMAWYAAABHAUwBZgAAAPUAGQCEAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA8NoB4P/g/+AB4AAgAAAAAQAAAAAAAAAAAAAAIAAAAAAAAgAAAAMAAAAUAAMAAQAAABQABAA4AAAACgAIAAIAAgABACDw2v/9//8AAAAAACDw1//9//8AAf/jDy0AAwABAAAAAAAAAAAAAAABAAH//wAPAAEAAAABAAA5emozXw889QALAgAAAAAA0ABHWAAAAADQAEdYAAAAAAElAW4AAAAIAAIAAAAAAAAAAQAAAeD/4AAAAgAAAAAAASUAAQAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAABAAAAASUAAAElAAAAtwASALcAAAAAUAAACAAAAAAADgCuAAEAAAAAAAEADgAAAAEAAAAAAAIADgBHAAEAAAAAAAMADgAkAAEAAAAAAAQADgBVAAEAAAAAAAUAFgAOAAEAAAAAAAYABwAyAAEAAAAAAAoANABjAAMAAQQJAAEADgAAAAMAAQQJAAIADgBHAAMAAQQJAAMADgAkAAMAAQQJAAQADgBVAAMAAQQJAAUAFgAOAAMAAQQJAAYADgA5AAMAAQQJAAoANABjAGkAYwBvAG0AbwBvAG4AVgBlAHIAcwBpAG8AbgAgADEALgAwAGkAYwBvAG0AbwBvAG5pY29tb29uAGkAYwBvAG0AbwBvAG4AUgBlAGcAdQBsAGEAcgBpAGMAbwBtAG8AbwBuAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) format('woff');\\n  font-weight: normal;\\n  font-style: normal;\\n}\\n.ui.dropdown > .dropdown.icon[data-v-a3dbfc0c] {\\n  font-family: 'Dropdown';\\n  line-height: 1;\\n  height: 1em;\\n  width: 1.23em;\\n  -webkit-backface-visibility: hidden;\\n          backface-visibility: hidden;\\n  font-weight: normal;\\n  font-style: normal;\\n  text-align: center;\\n}\\n.ui.dropdown > .dropdown.icon[data-v-a3dbfc0c] {\\n  width: auto;\\n}\\n.ui.dropdown > .dropdown.icon[data-v-a3dbfc0c]:before {\\n  content: '\\\\F0D7';\\n}\\n\\n/* Sub Menu */\\n.ui.dropdown .menu .item .dropdown.icon[data-v-a3dbfc0c]:before {\\n  content: '\\\\F0DA' ;\\n}\\n.ui.dropdown .item .left.dropdown.icon[data-v-a3dbfc0c]:before,\\n.ui.dropdown .left.menu .item .dropdown.icon[data-v-a3dbfc0c]:before {\\n  content: \\\"\\\\F0D9\\\" ;\\n}\\n\\n/* Vertical Menu Dropdown */\\n.ui.vertical.menu .dropdown.item > .dropdown.icon[data-v-a3dbfc0c]:before {\\n  content: \\\"\\\\F0DA\\\" ;\\n}\\n/* Icons for Reference\\n.dropdown.down.icon {\\n  content: \\\"\\\\f0d7\\\";\\n}\\n.dropdown.up.icon {\\n  content: \\\"\\\\f0d8\\\";\\n}\\n.dropdown.left.icon {\\n  content: \\\"\\\\f0d9\\\";\\n}\\n.dropdown.icon.icon {\\n  content: \\\"\\\\f0da\\\";\\n}\\n*/\\n\\n\\n/*******************************\\n        User Overrides\\n*******************************/\\n\\n\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 96 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(4)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"/*!\\n * # Semantic UI 2.2.3 - Label\\n * http://github.com/semantic-org/semantic-ui/\\n *\\n *\\n * Released under the MIT license\\n * http://opensource.org/licenses/MIT\\n *\\n */\\n\\n\\n/*******************************\\n            Label\\n*******************************/\\n.ui.label[data-v-a3dbfc0c] {\\n  display: inline-block;\\n  line-height: 1;\\n  vertical-align: baseline;\\n  margin: 0em 0.14285714em;\\n  background-color: #E8E8E8;\\n  background-image: none;\\n  padding: 0.5833em 0.833em;\\n  color: rgba(0, 0, 0, 0.6);\\n  text-transform: none;\\n  font-weight: bold;\\n  border: 0px solid transparent;\\n  border-radius: 0.28571429rem;\\n  -webkit-transition: background 0.1s ease;\\n  transition: background 0.1s ease;\\n}\\n.ui.label[data-v-a3dbfc0c]:first-child {\\n  margin-left: 0em;\\n}\\n.ui.label[data-v-a3dbfc0c]:last-child {\\n  margin-right: 0em;\\n}\\n\\n/* Link */\\na.ui.label[data-v-a3dbfc0c] {\\n  cursor: pointer;\\n}\\n\\n/* Inside Link */\\n.ui.label > a[data-v-a3dbfc0c] {\\n  cursor: pointer;\\n  color: inherit;\\n  opacity: 0.5;\\n  -webkit-transition: 0.1s opacity ease;\\n  transition: 0.1s opacity ease;\\n}\\n.ui.label > a[data-v-a3dbfc0c]:hover {\\n  opacity: 1;\\n}\\n\\n/* Image */\\n.ui.label > img[data-v-a3dbfc0c] {\\n  width: auto !important;\\n  vertical-align: middle;\\n  height: 2.1666em !important;\\n}\\n\\n/* Icon */\\n.ui.label > .icon[data-v-a3dbfc0c] {\\n  width: auto;\\n  margin: 0em 0.75em 0em 0em;\\n}\\n\\n/* Detail */\\n.ui.label > .detail[data-v-a3dbfc0c] {\\n  display: inline-block;\\n  vertical-align: top;\\n  font-weight: bold;\\n  margin-left: 1em;\\n  opacity: 0.8;\\n}\\n.ui.label > .detail .icon[data-v-a3dbfc0c] {\\n  margin: 0em 0.25em 0em 0em;\\n}\\n\\n/* Removable label */\\n.ui.label > .close.icon[data-v-a3dbfc0c],\\n.ui.label > .delete.icon[data-v-a3dbfc0c] {\\n  cursor: pointer;\\n  margin-right: 0em;\\n  margin-left: 0.5em;\\n  font-size: 0.92857143em;\\n  opacity: 0.5;\\n  -webkit-transition: background 0.1s ease;\\n  transition: background 0.1s ease;\\n}\\n.ui.label > .delete.icon[data-v-a3dbfc0c]:hover {\\n  opacity: 1;\\n}\\n\\n/*-------------------\\n       Group\\n--------------------*/\\n.ui.labels > .label[data-v-a3dbfc0c] {\\n  margin: 0em 0.5em 0.5em 0em;\\n}\\n\\n/*-------------------\\n       Coupling\\n--------------------*/\\n.ui.header > .ui.label[data-v-a3dbfc0c] {\\n  margin-top: -0.29165em;\\n}\\n\\n/* Remove border radius on attached segment */\\n.ui.attached.segment > .ui.top.left.attached.label[data-v-a3dbfc0c],\\n.ui.bottom.attached.segment > .ui.top.left.attached.label[data-v-a3dbfc0c] {\\n  border-top-left-radius: 0;\\n}\\n.ui.attached.segment > .ui.top.right.attached.label[data-v-a3dbfc0c],\\n.ui.bottom.attached.segment > .ui.top.right.attached.label[data-v-a3dbfc0c] {\\n  border-top-right-radius: 0;\\n}\\n.ui.top.attached.segment > .ui.bottom.left.attached.label[data-v-a3dbfc0c] {\\n  border-bottom-left-radius: 0;\\n}\\n.ui.top.attached.segment > .ui.bottom.right.attached.label[data-v-a3dbfc0c] {\\n  border-bottom-right-radius: 0;\\n}\\n\\n/* Padding on next content after a label */\\n.ui.top.attached.label:first-child + [data-v-a3dbfc0c]:not(.attached),\\n.ui.top.attached.label + [class*=\\\"right floated\\\"] + *[data-v-a3dbfc0c] {\\n  margin-top: 2rem !important;\\n}\\n.ui.bottom.attached.label:first-child ~ [data-v-a3dbfc0c]:last-child:not(.attached) {\\n  margin-top: 0em;\\n  margin-bottom: 2rem !important;\\n}\\n\\n\\n/*******************************\\n             Types\\n*******************************/\\n.ui.image.label[data-v-a3dbfc0c] {\\n  width: auto !important;\\n  margin-top: 0em;\\n  margin-bottom: 0em;\\n  max-width: 9999px;\\n  vertical-align: baseline;\\n  text-transform: none;\\n  background: #E8E8E8;\\n  padding: 0.5833em 0.833em 0.5833em 0.5em;\\n  border-radius: 0.28571429rem;\\n  box-shadow: none;\\n}\\n.ui.image.label img[data-v-a3dbfc0c] {\\n  display: inline-block;\\n  vertical-align: top;\\n  height: 2.1666em;\\n  margin: -0.5833em 0.5em -0.5833em -0.5em;\\n  border-radius: 0.28571429rem 0em 0em 0.28571429rem;\\n}\\n.ui.image.label .detail[data-v-a3dbfc0c] {\\n  background: rgba(0, 0, 0, 0.1);\\n  margin: -0.5833em -0.833em -0.5833em 0.5em;\\n  padding: 0.5833em 0.833em;\\n  border-radius: 0em 0.28571429rem 0.28571429rem 0em;\\n}\\n\\n/*-------------------\\n         Tag\\n--------------------*/\\n.ui.tag.labels .label[data-v-a3dbfc0c],\\n.ui.tag.label[data-v-a3dbfc0c] {\\n  margin-left: 1em;\\n  position: relative;\\n  padding-left: 1.5em;\\n  padding-right: 1.5em;\\n  border-radius: 0em 0.28571429rem 0.28571429rem 0em;\\n  -webkit-transition: none;\\n  transition: none;\\n}\\n.ui.tag.labels .label[data-v-a3dbfc0c]:before,\\n.ui.tag.label[data-v-a3dbfc0c]:before {\\n  position: absolute;\\n  -webkit-transform: translateY(-50%) translateX(50%) rotate(-45deg);\\n      -ms-transform: translateY(-50%) translateX(50%) rotate(-45deg);\\n          transform: translateY(-50%) translateX(50%) rotate(-45deg);\\n  top: 50%;\\n  right: 100%;\\n  content: '';\\n  background-color: inherit;\\n  background-image: none;\\n  width: 1.56em;\\n  height: 1.56em;\\n  -webkit-transition: none;\\n  transition: none;\\n}\\n.ui.tag.labels .label[data-v-a3dbfc0c]:after,\\n.ui.tag.label[data-v-a3dbfc0c]:after {\\n  position: absolute;\\n  content: '';\\n  top: 50%;\\n  left: -0.25em;\\n  margin-top: -0.25em;\\n  background-color: #FFFFFF !important;\\n  width: 0.5em;\\n  height: 0.5em;\\n  box-shadow: 0 -1px 1px 0 rgba(0, 0, 0, 0.3);\\n  border-radius: 500rem;\\n}\\n\\n/*-------------------\\n    Corner Label\\n--------------------*/\\n.ui.corner.label[data-v-a3dbfc0c] {\\n  position: absolute;\\n  top: 0em;\\n  right: 0em;\\n  margin: 0em;\\n  padding: 0em;\\n  text-align: center;\\n  border-color: #E8E8E8;\\n  width: 4em;\\n  height: 4em;\\n  z-index: 1;\\n  -webkit-transition: border-color 0.1s ease;\\n  transition: border-color 0.1s ease;\\n}\\n\\n/* Icon Label */\\n.ui.corner.label[data-v-a3dbfc0c] {\\n  background-color: transparent !important;\\n}\\n.ui.corner.label[data-v-a3dbfc0c]:after {\\n  position: absolute;\\n  content: \\\"\\\";\\n  right: 0em;\\n  top: 0em;\\n  z-index: -1;\\n  width: 0em;\\n  height: 0em;\\n  background-color: transparent !important;\\n  border-top: 0em solid transparent;\\n  border-right: 4em solid transparent;\\n  border-bottom: 4em solid transparent;\\n  border-left: 0em solid transparent;\\n  border-right-color: inherit;\\n  -webkit-transition: border-color 0.1s ease;\\n  transition: border-color 0.1s ease;\\n}\\n.ui.corner.label .icon[data-v-a3dbfc0c] {\\n  cursor: default;\\n  position: relative;\\n  top: 0.64285714em;\\n  left: 0.78571429em;\\n  font-size: 1.14285714em;\\n  margin: 0em;\\n}\\n\\n/* Left Corner */\\n.ui.left.corner.label[data-v-a3dbfc0c],\\n.ui.left.corner.label[data-v-a3dbfc0c]:after {\\n  right: auto;\\n  left: 0em;\\n}\\n.ui.left.corner.label[data-v-a3dbfc0c]:after {\\n  border-top: 4em solid transparent;\\n  border-right: 4em solid transparent;\\n  border-bottom: 0em solid transparent;\\n  border-left: 0em solid transparent;\\n  border-top-color: inherit;\\n}\\n.ui.left.corner.label .icon[data-v-a3dbfc0c] {\\n  left: -0.78571429em;\\n}\\n\\n/* Segment */\\n.ui.segment > .ui.corner.label[data-v-a3dbfc0c] {\\n  top: -1px;\\n  right: -1px;\\n}\\n.ui.segment > .ui.left.corner.label[data-v-a3dbfc0c] {\\n  right: auto;\\n  left: -1px;\\n}\\n\\n/*-------------------\\n       Ribbon\\n--------------------*/\\n.ui.ribbon.label[data-v-a3dbfc0c] {\\n  position: relative;\\n  margin: 0em;\\n  min-width: -webkit-max-content;\\n  min-width: -moz-max-content;\\n  min-width: max-content;\\n  border-radius: 0em 0.28571429rem 0.28571429rem 0em;\\n  border-color: rgba(0, 0, 0, 0.15);\\n}\\n.ui.ribbon.label[data-v-a3dbfc0c]:after {\\n  position: absolute;\\n  content: '';\\n  top: 100%;\\n  left: 0%;\\n  background-color: transparent !important;\\n  border-style: solid;\\n  border-width: 0em 1.2em 1.2em 0em;\\n  border-color: transparent;\\n  border-right-color: inherit;\\n  width: 0em;\\n  height: 0em;\\n}\\n\\n/* Positioning */\\n.ui.ribbon.label[data-v-a3dbfc0c] {\\n  left: calc( -1rem  -  1.2em );\\n  margin-right: -1.2em;\\n  padding-left: calc( 1rem  +  1.2em );\\n  padding-right: 1.2em;\\n}\\n.ui[class*=\\\"right ribbon\\\"].label[data-v-a3dbfc0c] {\\n  left: calc(100% +  1rem  +  1.2em );\\n  padding-left: 1.2em;\\n  padding-right: calc( 1rem  +  1.2em );\\n}\\n\\n/* Right Ribbon */\\n.ui[class*=\\\"right ribbon\\\"].label[data-v-a3dbfc0c] {\\n  text-align: left;\\n  -webkit-transform: translateX(-100%);\\n      -ms-transform: translateX(-100%);\\n          transform: translateX(-100%);\\n  border-radius: 0.28571429rem 0em 0em 0.28571429rem;\\n}\\n.ui[class*=\\\"right ribbon\\\"].label[data-v-a3dbfc0c]:after {\\n  left: auto;\\n  right: 0%;\\n  border-style: solid;\\n  border-width: 1.2em 1.2em 0em 0em;\\n  border-color: transparent;\\n  border-top-color: inherit;\\n}\\n\\n/* Inside Table */\\n.ui.image > .ribbon.label[data-v-a3dbfc0c],\\n.ui.card .image > .ribbon.label[data-v-a3dbfc0c] {\\n  position: absolute;\\n  top: 1rem;\\n}\\n.ui.card .image > .ui.ribbon.label[data-v-a3dbfc0c],\\n.ui.image > .ui.ribbon.label[data-v-a3dbfc0c] {\\n  left: calc( 0.05rem  -  1.2em );\\n}\\n.ui.card .image > .ui[class*=\\\"right ribbon\\\"].label[data-v-a3dbfc0c],\\n.ui.image > .ui[class*=\\\"right ribbon\\\"].label[data-v-a3dbfc0c] {\\n  left: calc(100% +  -0.05rem  +  1.2em );\\n  padding-left: 0.833em;\\n}\\n\\n/* Inside Table */\\n.ui.table td > .ui.ribbon.label[data-v-a3dbfc0c] {\\n  left: calc( -0.78571429em  -  1.2em );\\n}\\n.ui.table td > .ui[class*=\\\"right ribbon\\\"].label[data-v-a3dbfc0c] {\\n  left: calc(100% +  0.78571429em  +  1.2em );\\n  padding-left: 0.833em;\\n}\\n\\n/*-------------------\\n      Attached\\n--------------------*/\\n.ui[class*=\\\"top attached\\\"].label[data-v-a3dbfc0c],\\n.ui.attached.label[data-v-a3dbfc0c] {\\n  width: 100%;\\n  position: absolute;\\n  margin: 0em;\\n  top: 0em;\\n  left: 0em;\\n  padding: 0.75em 1em;\\n  border-radius: 0.21428571rem 0.21428571rem 0em 0em;\\n}\\n.ui[class*=\\\"bottom attached\\\"].label[data-v-a3dbfc0c] {\\n  top: auto;\\n  bottom: 0em;\\n  border-radius: 0em 0em 0.21428571rem 0.21428571rem;\\n}\\n.ui[class*=\\\"top left attached\\\"].label[data-v-a3dbfc0c] {\\n  width: auto;\\n  margin-top: 0em !important;\\n  border-radius: 0.21428571rem 0em 0.28571429rem 0em;\\n}\\n.ui[class*=\\\"top right attached\\\"].label[data-v-a3dbfc0c] {\\n  width: auto;\\n  left: auto;\\n  right: 0em;\\n  border-radius: 0em 0.21428571rem 0em 0.28571429rem;\\n}\\n.ui[class*=\\\"bottom left attached\\\"].label[data-v-a3dbfc0c] {\\n  width: auto;\\n  top: auto;\\n  bottom: 0em;\\n  border-radius: 0em 0.28571429rem 0em 0.21428571rem;\\n}\\n.ui[class*=\\\"bottom right attached\\\"].label[data-v-a3dbfc0c] {\\n  top: auto;\\n  bottom: 0em;\\n  left: auto;\\n  right: 0em;\\n  width: auto;\\n  border-radius: 0.28571429rem 0em 0.21428571rem 0em;\\n}\\n\\n\\n/*******************************\\n             States\\n*******************************/\\n\\n\\n/*-------------------\\n      Disabled\\n--------------------*/\\n.ui.label.disabled[data-v-a3dbfc0c] {\\n  opacity: 0.5;\\n}\\n\\n/*-------------------\\n        Hover\\n--------------------*/\\na.ui.labels .label[data-v-a3dbfc0c]:hover,\\na.ui.label[data-v-a3dbfc0c]:hover {\\n  background-color: #E0E0E0;\\n  border-color: #E0E0E0;\\n  background-image: none;\\n  color: rgba(0, 0, 0, 0.8);\\n}\\n.ui.labels a.label[data-v-a3dbfc0c]:hover:before,\\na.ui.label[data-v-a3dbfc0c]:hover:before {\\n  color: rgba(0, 0, 0, 0.8);\\n}\\n\\n/*-------------------\\n        Active\\n--------------------*/\\n.ui.active.label[data-v-a3dbfc0c] {\\n  background-color: #D0D0D0;\\n  border-color: #D0D0D0;\\n  background-image: none;\\n  color: rgba(0, 0, 0, 0.95);\\n}\\n.ui.active.label[data-v-a3dbfc0c]:before {\\n  background-color: #D0D0D0;\\n  background-image: none;\\n  color: rgba(0, 0, 0, 0.95);\\n}\\n\\n/*-------------------\\n     Active Hover\\n--------------------*/\\na.ui.labels .active.label[data-v-a3dbfc0c]:hover,\\na.ui.active.label[data-v-a3dbfc0c]:hover {\\n  background-color: #C8C8C8;\\n  border-color: #C8C8C8;\\n  background-image: none;\\n  color: rgba(0, 0, 0, 0.95);\\n}\\n.ui.labels a.active.label[data-v-a3dbfc0c]:ActiveHover:before,\\na.ui.active.label[data-v-a3dbfc0c]:ActiveHover:before {\\n  background-color: #C8C8C8;\\n  background-image: none;\\n  color: rgba(0, 0, 0, 0.95);\\n}\\n\\n/*-------------------\\n      Visible\\n--------------------*/\\n.ui.labels.visible .label[data-v-a3dbfc0c],\\n.ui.label.visible[data-v-a3dbfc0c]:not(.dropdown) {\\n  display: inline-block !important;\\n}\\n\\n/*-------------------\\n      Hidden\\n--------------------*/\\n.ui.labels.hidden .label[data-v-a3dbfc0c],\\n.ui.label.hidden[data-v-a3dbfc0c] {\\n  display: none !important;\\n}\\n\\n\\n/*******************************\\n           Variations\\n*******************************/\\n\\n\\n/*-------------------\\n       Colors\\n--------------------*/\\n\\n\\n/*--- Red ---*/\\n.ui.red.labels .label[data-v-a3dbfc0c],\\n.ui.red.label[data-v-a3dbfc0c] {\\n  background-color: #DB2828 !important;\\n  border-color: #DB2828 !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Link */\\n.ui.red.labels .label[data-v-a3dbfc0c]:hover,\\na.ui.red.label[data-v-a3dbfc0c]:hover {\\n  background-color: #d01919 !important;\\n  border-color: #d01919 !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Corner */\\n.ui.red.corner.label[data-v-a3dbfc0c],\\n.ui.red.corner.label[data-v-a3dbfc0c]:hover {\\n  background-color: transparent !important;\\n}\\n\\n/* Ribbon */\\n.ui.red.ribbon.label[data-v-a3dbfc0c] {\\n  border-color: #b21e1e !important;\\n}\\n\\n/* Basic */\\n.ui.basic.red.label[data-v-a3dbfc0c] {\\n  background-color: #FFFFFF !important;\\n  color: #DB2828 !important;\\n  border-color: #DB2828 !important;\\n}\\n.ui.basic.red.labels a.label[data-v-a3dbfc0c]:hover,\\na.ui.basic.red.label[data-v-a3dbfc0c]:hover {\\n  background-color: #FFFFFF !important;\\n  color: #d01919 !important;\\n  border-color: #d01919 !important;\\n}\\n\\n/*--- Orange ---*/\\n.ui.orange.labels .label[data-v-a3dbfc0c],\\n.ui.orange.label[data-v-a3dbfc0c] {\\n  background-color: #F2711C !important;\\n  border-color: #F2711C !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Link */\\n.ui.orange.labels .label[data-v-a3dbfc0c]:hover,\\na.ui.orange.label[data-v-a3dbfc0c]:hover {\\n  background-color: #f26202 !important;\\n  border-color: #f26202 !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Corner */\\n.ui.orange.corner.label[data-v-a3dbfc0c],\\n.ui.orange.corner.label[data-v-a3dbfc0c]:hover {\\n  background-color: transparent !important;\\n}\\n\\n/* Ribbon */\\n.ui.orange.ribbon.label[data-v-a3dbfc0c] {\\n  border-color: #cf590c !important;\\n}\\n\\n/* Basic */\\n.ui.basic.orange.label[data-v-a3dbfc0c] {\\n  background-color: #FFFFFF !important;\\n  color: #F2711C !important;\\n  border-color: #F2711C !important;\\n}\\n.ui.basic.orange.labels a.label[data-v-a3dbfc0c]:hover,\\na.ui.basic.orange.label[data-v-a3dbfc0c]:hover {\\n  background-color: #FFFFFF !important;\\n  color: #f26202 !important;\\n  border-color: #f26202 !important;\\n}\\n\\n/*--- Yellow ---*/\\n.ui.yellow.labels .label[data-v-a3dbfc0c],\\n.ui.yellow.label[data-v-a3dbfc0c] {\\n  background-color: #FBBD08 !important;\\n  border-color: #FBBD08 !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Link */\\n.ui.yellow.labels .label[data-v-a3dbfc0c]:hover,\\na.ui.yellow.label[data-v-a3dbfc0c]:hover {\\n  background-color: #eaae00 !important;\\n  border-color: #eaae00 !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Corner */\\n.ui.yellow.corner.label[data-v-a3dbfc0c],\\n.ui.yellow.corner.label[data-v-a3dbfc0c]:hover {\\n  background-color: transparent !important;\\n}\\n\\n/* Ribbon */\\n.ui.yellow.ribbon.label[data-v-a3dbfc0c] {\\n  border-color: #cd9903 !important;\\n}\\n\\n/* Basic */\\n.ui.basic.yellow.label[data-v-a3dbfc0c] {\\n  background-color: #FFFFFF !important;\\n  color: #FBBD08 !important;\\n  border-color: #FBBD08 !important;\\n}\\n.ui.basic.yellow.labels a.label[data-v-a3dbfc0c]:hover,\\na.ui.basic.yellow.label[data-v-a3dbfc0c]:hover {\\n  background-color: #FFFFFF !important;\\n  color: #eaae00 !important;\\n  border-color: #eaae00 !important;\\n}\\n\\n/*--- Olive ---*/\\n.ui.olive.labels .label[data-v-a3dbfc0c],\\n.ui.olive.label[data-v-a3dbfc0c] {\\n  background-color: #B5CC18 !important;\\n  border-color: #B5CC18 !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Link */\\n.ui.olive.labels .label[data-v-a3dbfc0c]:hover,\\na.ui.olive.label[data-v-a3dbfc0c]:hover {\\n  background-color: #a7bd0d !important;\\n  border-color: #a7bd0d !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Corner */\\n.ui.olive.corner.label[data-v-a3dbfc0c],\\n.ui.olive.corner.label[data-v-a3dbfc0c]:hover {\\n  background-color: transparent !important;\\n}\\n\\n/* Ribbon */\\n.ui.olive.ribbon.label[data-v-a3dbfc0c] {\\n  border-color: #198f35 !important;\\n}\\n\\n/* Basic */\\n.ui.basic.olive.label[data-v-a3dbfc0c] {\\n  background-color: #FFFFFF !important;\\n  color: #B5CC18 !important;\\n  border-color: #B5CC18 !important;\\n}\\n.ui.basic.olive.labels a.label[data-v-a3dbfc0c]:hover,\\na.ui.basic.olive.label[data-v-a3dbfc0c]:hover {\\n  background-color: #FFFFFF !important;\\n  color: #a7bd0d !important;\\n  border-color: #a7bd0d !important;\\n}\\n\\n/*--- Green ---*/\\n.ui.green.labels .label[data-v-a3dbfc0c],\\n.ui.green.label[data-v-a3dbfc0c] {\\n  background-color: #21BA45 !important;\\n  border-color: #21BA45 !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Link */\\n.ui.green.labels .label[data-v-a3dbfc0c]:hover,\\na.ui.green.label[data-v-a3dbfc0c]:hover {\\n  background-color: #16ab39 !important;\\n  border-color: #16ab39 !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Corner */\\n.ui.green.corner.label[data-v-a3dbfc0c],\\n.ui.green.corner.label[data-v-a3dbfc0c]:hover {\\n  background-color: transparent !important;\\n}\\n\\n/* Ribbon */\\n.ui.green.ribbon.label[data-v-a3dbfc0c] {\\n  border-color: #198f35 !important;\\n}\\n\\n/* Basic */\\n.ui.basic.green.label[data-v-a3dbfc0c] {\\n  background-color: #FFFFFF !important;\\n  color: #21BA45 !important;\\n  border-color: #21BA45 !important;\\n}\\n.ui.basic.green.labels a.label[data-v-a3dbfc0c]:hover,\\na.ui.basic.green.label[data-v-a3dbfc0c]:hover {\\n  background-color: #FFFFFF !important;\\n  color: #16ab39 !important;\\n  border-color: #16ab39 !important;\\n}\\n\\n/*--- Teal ---*/\\n.ui.teal.labels .label[data-v-a3dbfc0c],\\n.ui.teal.label[data-v-a3dbfc0c] {\\n  background-color: #00B5AD !important;\\n  border-color: #00B5AD !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Link */\\n.ui.teal.labels .label[data-v-a3dbfc0c]:hover,\\na.ui.teal.label[data-v-a3dbfc0c]:hover {\\n  background-color: #009c95 !important;\\n  border-color: #009c95 !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Corner */\\n.ui.teal.corner.label[data-v-a3dbfc0c],\\n.ui.teal.corner.label[data-v-a3dbfc0c]:hover {\\n  background-color: transparent !important;\\n}\\n\\n/* Ribbon */\\n.ui.teal.ribbon.label[data-v-a3dbfc0c] {\\n  border-color: #00827c !important;\\n}\\n\\n/* Basic */\\n.ui.basic.teal.label[data-v-a3dbfc0c] {\\n  background-color: #FFFFFF !important;\\n  color: #00B5AD !important;\\n  border-color: #00B5AD !important;\\n}\\n.ui.basic.teal.labels a.label[data-v-a3dbfc0c]:hover,\\na.ui.basic.teal.label[data-v-a3dbfc0c]:hover {\\n  background-color: #FFFFFF !important;\\n  color: #009c95 !important;\\n  border-color: #009c95 !important;\\n}\\n\\n/*--- Blue ---*/\\n.ui.blue.labels .label[data-v-a3dbfc0c],\\n.ui.blue.label[data-v-a3dbfc0c] {\\n  background-color: #2185D0 !important;\\n  border-color: #2185D0 !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Link */\\n.ui.blue.labels .label[data-v-a3dbfc0c]:hover,\\na.ui.blue.label[data-v-a3dbfc0c]:hover {\\n  background-color: #1678c2 !important;\\n  border-color: #1678c2 !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Corner */\\n.ui.blue.corner.label[data-v-a3dbfc0c],\\n.ui.blue.corner.label[data-v-a3dbfc0c]:hover {\\n  background-color: transparent !important;\\n}\\n\\n/* Ribbon */\\n.ui.blue.ribbon.label[data-v-a3dbfc0c] {\\n  border-color: #1a69a4 !important;\\n}\\n\\n/* Basic */\\n.ui.basic.blue.label[data-v-a3dbfc0c] {\\n  background-color: #FFFFFF !important;\\n  color: #2185D0 !important;\\n  border-color: #2185D0 !important;\\n}\\n.ui.basic.blue.labels a.label[data-v-a3dbfc0c]:hover,\\na.ui.basic.blue.label[data-v-a3dbfc0c]:hover {\\n  background-color: #FFFFFF !important;\\n  color: #1678c2 !important;\\n  border-color: #1678c2 !important;\\n}\\n\\n/*--- Violet ---*/\\n.ui.violet.labels .label[data-v-a3dbfc0c],\\n.ui.violet.label[data-v-a3dbfc0c] {\\n  background-color: #6435C9 !important;\\n  border-color: #6435C9 !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Link */\\n.ui.violet.labels .label[data-v-a3dbfc0c]:hover,\\na.ui.violet.label[data-v-a3dbfc0c]:hover {\\n  background-color: #5829bb !important;\\n  border-color: #5829bb !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Corner */\\n.ui.violet.corner.label[data-v-a3dbfc0c],\\n.ui.violet.corner.label[data-v-a3dbfc0c]:hover {\\n  background-color: transparent !important;\\n}\\n\\n/* Ribbon */\\n.ui.violet.ribbon.label[data-v-a3dbfc0c] {\\n  border-color: #502aa1 !important;\\n}\\n\\n/* Basic */\\n.ui.basic.violet.label[data-v-a3dbfc0c] {\\n  background-color: #FFFFFF !important;\\n  color: #6435C9 !important;\\n  border-color: #6435C9 !important;\\n}\\n.ui.basic.violet.labels a.label[data-v-a3dbfc0c]:hover,\\na.ui.basic.violet.label[data-v-a3dbfc0c]:hover {\\n  background-color: #FFFFFF !important;\\n  color: #5829bb !important;\\n  border-color: #5829bb !important;\\n}\\n\\n/*--- Purple ---*/\\n.ui.purple.labels .label[data-v-a3dbfc0c],\\n.ui.purple.label[data-v-a3dbfc0c] {\\n  background-color: #A333C8 !important;\\n  border-color: #A333C8 !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Link */\\n.ui.purple.labels .label[data-v-a3dbfc0c]:hover,\\na.ui.purple.label[data-v-a3dbfc0c]:hover {\\n  background-color: #9627ba !important;\\n  border-color: #9627ba !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Corner */\\n.ui.purple.corner.label[data-v-a3dbfc0c],\\n.ui.purple.corner.label[data-v-a3dbfc0c]:hover {\\n  background-color: transparent !important;\\n}\\n\\n/* Ribbon */\\n.ui.purple.ribbon.label[data-v-a3dbfc0c] {\\n  border-color: #82299f !important;\\n}\\n\\n/* Basic */\\n.ui.basic.purple.label[data-v-a3dbfc0c] {\\n  background-color: #FFFFFF !important;\\n  color: #A333C8 !important;\\n  border-color: #A333C8 !important;\\n}\\n.ui.basic.purple.labels a.label[data-v-a3dbfc0c]:hover,\\na.ui.basic.purple.label[data-v-a3dbfc0c]:hover {\\n  background-color: #FFFFFF !important;\\n  color: #9627ba !important;\\n  border-color: #9627ba !important;\\n}\\n\\n/*--- Pink ---*/\\n.ui.pink.labels .label[data-v-a3dbfc0c],\\n.ui.pink.label[data-v-a3dbfc0c] {\\n  background-color: #E03997 !important;\\n  border-color: #E03997 !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Link */\\n.ui.pink.labels .label[data-v-a3dbfc0c]:hover,\\na.ui.pink.label[data-v-a3dbfc0c]:hover {\\n  background-color: #e61a8d !important;\\n  border-color: #e61a8d !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Corner */\\n.ui.pink.corner.label[data-v-a3dbfc0c],\\n.ui.pink.corner.label[data-v-a3dbfc0c]:hover {\\n  background-color: transparent !important;\\n}\\n\\n/* Ribbon */\\n.ui.pink.ribbon.label[data-v-a3dbfc0c] {\\n  border-color: #c71f7e !important;\\n}\\n\\n/* Basic */\\n.ui.basic.pink.label[data-v-a3dbfc0c] {\\n  background-color: #FFFFFF !important;\\n  color: #E03997 !important;\\n  border-color: #E03997 !important;\\n}\\n.ui.basic.pink.labels a.label[data-v-a3dbfc0c]:hover,\\na.ui.basic.pink.label[data-v-a3dbfc0c]:hover {\\n  background-color: #FFFFFF !important;\\n  color: #e61a8d !important;\\n  border-color: #e61a8d !important;\\n}\\n\\n/*--- Brown ---*/\\n.ui.brown.labels .label[data-v-a3dbfc0c],\\n.ui.brown.label[data-v-a3dbfc0c] {\\n  background-color: #A5673F !important;\\n  border-color: #A5673F !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Link */\\n.ui.brown.labels .label[data-v-a3dbfc0c]:hover,\\na.ui.brown.label[data-v-a3dbfc0c]:hover {\\n  background-color: #975b33 !important;\\n  border-color: #975b33 !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Corner */\\n.ui.brown.corner.label[data-v-a3dbfc0c],\\n.ui.brown.corner.label[data-v-a3dbfc0c]:hover {\\n  background-color: transparent !important;\\n}\\n\\n/* Ribbon */\\n.ui.brown.ribbon.label[data-v-a3dbfc0c] {\\n  border-color: #805031 !important;\\n}\\n\\n/* Basic */\\n.ui.basic.brown.label[data-v-a3dbfc0c] {\\n  background-color: #FFFFFF !important;\\n  color: #A5673F !important;\\n  border-color: #A5673F !important;\\n}\\n.ui.basic.brown.labels a.label[data-v-a3dbfc0c]:hover,\\na.ui.basic.brown.label[data-v-a3dbfc0c]:hover {\\n  background-color: #FFFFFF !important;\\n  color: #975b33 !important;\\n  border-color: #975b33 !important;\\n}\\n\\n/*--- Grey ---*/\\n.ui.grey.labels .label[data-v-a3dbfc0c],\\n.ui.grey.label[data-v-a3dbfc0c] {\\n  background-color: #767676 !important;\\n  border-color: #767676 !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Link */\\n.ui.grey.labels .label[data-v-a3dbfc0c]:hover,\\na.ui.grey.label[data-v-a3dbfc0c]:hover {\\n  background-color: #838383 !important;\\n  border-color: #838383 !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Corner */\\n.ui.grey.corner.label[data-v-a3dbfc0c],\\n.ui.grey.corner.label[data-v-a3dbfc0c]:hover {\\n  background-color: transparent !important;\\n}\\n\\n/* Ribbon */\\n.ui.grey.ribbon.label[data-v-a3dbfc0c] {\\n  border-color: #805031 !important;\\n}\\n\\n/* Basic */\\n.ui.basic.grey.label[data-v-a3dbfc0c] {\\n  background-color: #FFFFFF !important;\\n  color: #767676 !important;\\n  border-color: #767676 !important;\\n}\\n.ui.basic.grey.labels a.label[data-v-a3dbfc0c]:hover,\\na.ui.basic.grey.label[data-v-a3dbfc0c]:hover {\\n  background-color: #FFFFFF !important;\\n  color: #838383 !important;\\n  border-color: #838383 !important;\\n}\\n\\n/*--- Black ---*/\\n.ui.black.labels .label[data-v-a3dbfc0c],\\n.ui.black.label[data-v-a3dbfc0c] {\\n  background-color: #1B1C1D !important;\\n  border-color: #1B1C1D !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Link */\\n.ui.black.labels .label[data-v-a3dbfc0c]:hover,\\na.ui.black.label[data-v-a3dbfc0c]:hover {\\n  background-color: #27292a !important;\\n  border-color: #27292a !important;\\n  color: #FFFFFF !important;\\n}\\n\\n/* Corner */\\n.ui.black.corner.label[data-v-a3dbfc0c],\\n.ui.black.corner.label[data-v-a3dbfc0c]:hover {\\n  background-color: transparent !important;\\n}\\n\\n/* Ribbon */\\n.ui.black.ribbon.label[data-v-a3dbfc0c] {\\n  border-color: #805031 !important;\\n}\\n\\n/* Basic */\\n.ui.basic.black.label[data-v-a3dbfc0c] {\\n  background-color: #FFFFFF !important;\\n  color: #1B1C1D !important;\\n  border-color: #1B1C1D !important;\\n}\\n.ui.basic.black.labels a.label[data-v-a3dbfc0c]:hover,\\na.ui.basic.black.label[data-v-a3dbfc0c]:hover {\\n  background-color: #FFFFFF !important;\\n  color: #27292a !important;\\n  border-color: #27292a !important;\\n}\\n\\n/*-------------------\\n        Basic\\n--------------------*/\\n.ui.basic.label[data-v-a3dbfc0c] {\\n  background: none #FFFFFF;\\n  border: 1px solid rgba(34, 36, 38, 0.15);\\n  color: rgba(0, 0, 0, 0.87);\\n  box-shadow: none;\\n}\\n\\n/* Link */\\na.ui.basic.label[data-v-a3dbfc0c]:hover {\\n  text-decoration: none;\\n  background: none #FFFFFF;\\n  color: #1e70bf;\\n  box-shadow: 1px solid rgba(34, 36, 38, 0.15);\\n  box-shadow: none;\\n}\\n\\n/* Pointing */\\n.ui.basic.pointing.label[data-v-a3dbfc0c]:before {\\n  border-color: inherit;\\n}\\n\\n/*-------------------\\n       Fluid\\n--------------------*/\\n.ui.label.fluid[data-v-a3dbfc0c],\\n.ui.fluid.labels > .label[data-v-a3dbfc0c] {\\n  width: 100%;\\n  box-sizing: border-box;\\n}\\n\\n/*-------------------\\n       Inverted\\n--------------------*/\\n.ui.inverted.labels .label[data-v-a3dbfc0c],\\n.ui.inverted.label[data-v-a3dbfc0c] {\\n  color: rgba(255, 255, 255, 0.9) !important;\\n}\\n\\n/*-------------------\\n     Horizontal\\n--------------------*/\\n.ui.horizontal.labels .label[data-v-a3dbfc0c],\\n.ui.horizontal.label[data-v-a3dbfc0c] {\\n  margin: 0em 0.5em 0em 0em;\\n  padding: 0.4em 0.833em;\\n  min-width: 3em;\\n  text-align: center;\\n}\\n\\n/*-------------------\\n       Circular\\n--------------------*/\\n.ui.circular.labels .label[data-v-a3dbfc0c],\\n.ui.circular.label[data-v-a3dbfc0c] {\\n  min-width: 2em;\\n  min-height: 2em;\\n  padding: 0.5em !important;\\n  line-height: 1em;\\n  text-align: center;\\n  border-radius: 500rem;\\n}\\n.ui.empty.circular.labels .label[data-v-a3dbfc0c],\\n.ui.empty.circular.label[data-v-a3dbfc0c] {\\n  min-width: 0em;\\n  min-height: 0em;\\n  overflow: hidden;\\n  width: 0.5em;\\n  height: 0.5em;\\n  vertical-align: baseline;\\n}\\n\\n/*-------------------\\n       Pointing\\n--------------------*/\\n.ui.pointing.label[data-v-a3dbfc0c] {\\n  position: relative;\\n}\\n.ui.attached.pointing.label[data-v-a3dbfc0c] {\\n  position: absolute;\\n}\\n.ui.pointing.label[data-v-a3dbfc0c]:before {\\n  background-color: inherit;\\n  background-image: inherit;\\n  border-width: none;\\n  border-style: solid;\\n  border-color: inherit;\\n}\\n\\n/* Arrow */\\n.ui.pointing.label[data-v-a3dbfc0c]:before {\\n  position: absolute;\\n  content: '';\\n  -webkit-transform: rotate(45deg);\\n      -ms-transform: rotate(45deg);\\n          transform: rotate(45deg);\\n  background-image: none;\\n  z-index: 2;\\n  width: 0.6666em;\\n  height: 0.6666em;\\n  -webkit-transition: background 0.1s ease;\\n  transition: background 0.1s ease;\\n}\\n\\n/*--- Above ---*/\\n.ui.pointing.label[data-v-a3dbfc0c],\\n.ui[class*=\\\"pointing above\\\"].label[data-v-a3dbfc0c] {\\n  margin-top: 1em;\\n}\\n.ui.pointing.label[data-v-a3dbfc0c]:before,\\n.ui[class*=\\\"pointing above\\\"].label[data-v-a3dbfc0c]:before {\\n  border-width: 1px 0px 0px 1px;\\n  -webkit-transform: translateX(-50%) translateY(-50%) rotate(45deg);\\n      -ms-transform: translateX(-50%) translateY(-50%) rotate(45deg);\\n          transform: translateX(-50%) translateY(-50%) rotate(45deg);\\n  top: 0%;\\n  left: 50%;\\n}\\n\\n/*--- Below ---*/\\n.ui[class*=\\\"bottom pointing\\\"].label[data-v-a3dbfc0c],\\n.ui[class*=\\\"pointing below\\\"].label[data-v-a3dbfc0c] {\\n  margin-top: 0em;\\n  margin-bottom: 1em;\\n}\\n.ui[class*=\\\"bottom pointing\\\"].label[data-v-a3dbfc0c]:before,\\n.ui[class*=\\\"pointing below\\\"].label[data-v-a3dbfc0c]:before {\\n  border-width: 0px 1px 1px 0px;\\n  top: auto;\\n  right: auto;\\n  -webkit-transform: translateX(-50%) translateY(-50%) rotate(45deg);\\n      -ms-transform: translateX(-50%) translateY(-50%) rotate(45deg);\\n          transform: translateX(-50%) translateY(-50%) rotate(45deg);\\n  top: 100%;\\n  left: 50%;\\n}\\n\\n/*--- Left ---*/\\n.ui[class*=\\\"left pointing\\\"].label[data-v-a3dbfc0c] {\\n  margin-top: 0em;\\n  margin-left: 0.6666em;\\n}\\n.ui[class*=\\\"left pointing\\\"].label[data-v-a3dbfc0c]:before {\\n  border-width: 0px 0px 1px 1px;\\n  -webkit-transform: translateX(-50%) translateY(-50%) rotate(45deg);\\n      -ms-transform: translateX(-50%) translateY(-50%) rotate(45deg);\\n          transform: translateX(-50%) translateY(-50%) rotate(45deg);\\n  bottom: auto;\\n  right: auto;\\n  top: 50%;\\n  left: 0em;\\n}\\n\\n/*--- Right ---*/\\n.ui[class*=\\\"right pointing\\\"].label[data-v-a3dbfc0c] {\\n  margin-top: 0em;\\n  margin-right: 0.6666em;\\n}\\n.ui[class*=\\\"right pointing\\\"].label[data-v-a3dbfc0c]:before {\\n  border-width: 1px 1px 0px 0px;\\n  -webkit-transform: translateX(50%) translateY(-50%) rotate(45deg);\\n      -ms-transform: translateX(50%) translateY(-50%) rotate(45deg);\\n          transform: translateX(50%) translateY(-50%) rotate(45deg);\\n  top: 50%;\\n  right: 0%;\\n  bottom: auto;\\n  left: auto;\\n}\\n\\n/* Basic Pointing */\\n\\n/*--- Above ---*/\\n.ui.basic.pointing.label[data-v-a3dbfc0c]:before,\\n.ui.basic[class*=\\\"pointing above\\\"].label[data-v-a3dbfc0c]:before {\\n  margin-top: -1px;\\n}\\n\\n/*--- Below ---*/\\n.ui.basic[class*=\\\"bottom pointing\\\"].label[data-v-a3dbfc0c]:before,\\n.ui.basic[class*=\\\"pointing below\\\"].label[data-v-a3dbfc0c]:before {\\n  bottom: auto;\\n  top: 100%;\\n  margin-top: 1px;\\n}\\n\\n/*--- Left ---*/\\n.ui.basic[class*=\\\"left pointing\\\"].label[data-v-a3dbfc0c]:before {\\n  top: 50%;\\n  left: -1px;\\n}\\n\\n/*--- Right ---*/\\n.ui.basic[class*=\\\"right pointing\\\"].label[data-v-a3dbfc0c]:before {\\n  top: 50%;\\n  right: -1px;\\n}\\n\\n/*------------------\\n   Floating Label\\n-------------------*/\\n.ui.floating.label[data-v-a3dbfc0c] {\\n  position: absolute;\\n  z-index: 100;\\n  top: -1em;\\n  left: 100%;\\n  margin: 0em 0em 0em -1.5em !important;\\n}\\n\\n/*-------------------\\n        Sizes\\n--------------------*/\\n.ui.mini.labels .label[data-v-a3dbfc0c],\\n.ui.mini.label[data-v-a3dbfc0c] {\\n  font-size: 0.64285714rem;\\n}\\n.ui.tiny.labels .label[data-v-a3dbfc0c],\\n.ui.tiny.label[data-v-a3dbfc0c] {\\n  font-size: 0.71428571rem;\\n}\\n.ui.small.labels .label[data-v-a3dbfc0c],\\n.ui.small.label[data-v-a3dbfc0c] {\\n  font-size: 0.78571429rem;\\n}\\n.ui.labels .label[data-v-a3dbfc0c],\\n.ui.label[data-v-a3dbfc0c] {\\n  font-size: 0.85714286rem;\\n}\\n.ui.large.labels .label[data-v-a3dbfc0c],\\n.ui.large.label[data-v-a3dbfc0c] {\\n  font-size: 1rem;\\n}\\n.ui.big.labels .label[data-v-a3dbfc0c],\\n.ui.big.label[data-v-a3dbfc0c] {\\n  font-size: 1.28571429rem;\\n}\\n.ui.huge.labels .label[data-v-a3dbfc0c],\\n.ui.huge.label[data-v-a3dbfc0c] {\\n  font-size: 1.42857143rem;\\n}\\n.ui.massive.labels .label[data-v-a3dbfc0c],\\n.ui.massive.label[data-v-a3dbfc0c] {\\n  font-size: 1.71428571rem;\\n}\\n\\n\\n/*******************************\\n         Theme Overrides\\n*******************************/\\n\\n\\n\\n/*******************************\\n         Site Overrides\\n*******************************/\\n\\n\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_exports__, __vue_options__\n\tvar __vue_styles__ = {}\n\t\n\t/* script */\n\t__vue_exports__ = __webpack_require__(48)\n\t__vue_options__ = __vue_exports__ = __vue_exports__ || {}\n\tif (\n\t  typeof __vue_exports__.default === \"object\" ||\n\t  typeof __vue_exports__.default === \"function\"\n\t) {\n\t__vue_options__ = __vue_exports__ = __vue_exports__.default\n\t}\n\tif (typeof __vue_options__ === \"function\") {\n\t  __vue_options__ = __vue_options__.options\n\t}\n\t\n\t\n\tmodule.exports = __vue_exports__\n\n\n/***/ },\n/* 98 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_exports__, __vue_options__\n\tvar __vue_styles__ = {}\n\t\n\t/* script */\n\t__vue_exports__ = __webpack_require__(49)\n\t__vue_options__ = __vue_exports__ = __vue_exports__ || {}\n\tif (\n\t  typeof __vue_exports__.default === \"object\" ||\n\t  typeof __vue_exports__.default === \"function\"\n\t) {\n\t__vue_options__ = __vue_exports__ = __vue_exports__.default\n\t}\n\tif (typeof __vue_options__ === \"function\") {\n\t  __vue_options__ = __vue_options__.options\n\t}\n\t\n\t\n\tmodule.exports = __vue_exports__\n\n\n/***/ },\n/* 99 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_exports__, __vue_options__\n\tvar __vue_styles__ = {}\n\t\n\t/* script */\n\t__vue_exports__ = __webpack_require__(51)\n\t__vue_options__ = __vue_exports__ = __vue_exports__ || {}\n\tif (\n\t  typeof __vue_exports__.default === \"object\" ||\n\t  typeof __vue_exports__.default === \"function\"\n\t) {\n\t__vue_options__ = __vue_exports__ = __vue_exports__.default\n\t}\n\tif (typeof __vue_options__ === \"function\") {\n\t  __vue_options__ = __vue_options__.options\n\t}\n\t\n\t\n\tmodule.exports = __vue_exports__\n\n\n/***/ },\n/* 100 */\n/***/ function(module, exports) {\n\n\tmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n\t  return _c('div', {\n\t    staticClass: \"ui fluid search selection dropdown\",\n\t    class: {\n\t      'active visible': _vm.showMenu, 'error': _vm.isError, 'disabled': _vm.isDisabled\n\t    },\n\t    on: {\n\t      \"click\": _vm.openOptions,\n\t      \"focus\": _vm.openOptions\n\t    }\n\t  }, [_c('i', {\n\t    staticClass: \"dropdown icon\"\n\t  }), _vm._v(\" \"), _c('input', {\n\t    ref: \"input\",\n\t    staticClass: \"search\",\n\t    attrs: {\n\t      \"autocomplete\": \"off\",\n\t      \"tabindex\": \"0\",\n\t      \"id\": _vm.id,\n\t      \"name\": _vm.name\n\t    },\n\t    domProps: {\n\t      \"value\": _vm.searchText\n\t    },\n\t    on: {\n\t      \"input\": function($event) {\n\t        _vm.searchText = $event.target.value\n\t      },\n\t      \"focus\": function($event) {\n\t        $event.preventDefault();\n\t        _vm.openOptions($event)\n\t      },\n\t      \"keyup\": [function($event) {\n\t        if (_vm._k($event.keyCode, \"esc\", 27)) { return; }\n\t        _vm.closeOptions($event)\n\t      }, function($event) {\n\t        if (_vm._k($event.keyCode, \"enter\", 13)) { return; }\n\t        $event.preventDefault();\n\t        _vm.enterItem($event)\n\t      }],\n\t      \"blur\": _vm.blurInput,\n\t      \"keydown\": [function($event) {\n\t        if (_vm._k($event.keyCode, \"up\", 38)) { return; }\n\t        _vm.prevItem($event)\n\t      }, function($event) {\n\t        if (_vm._k($event.keyCode, \"down\", 40)) { return; }\n\t        _vm.nextItem($event)\n\t      }, function($event) {\n\t        if (_vm._k($event.keyCode, \"enter\", 13)) { return; }\n\t        $event.preventDefault();\n\t      }, function($event) {\n\t        if (_vm._k($event.keyCode, \"delete\", [8, 46])) { return; }\n\t        _vm.deleteTextOrItem($event)\n\t      }]\n\t    }\n\t  }), _vm._v(\" \"), _c('div', {\n\t    staticClass: \"text\",\n\t    class: _vm.textClass,\n\t    attrs: {\n\t      \"data-vss-custom-attr\": _vm.searchTextCustomAttr\n\t    }\n\t  }, [_vm._v(_vm._s(_vm.inputText) + \"\\n  \")]), _vm._v(\" \"), _c('div', {\n\t    ref: \"menu\",\n\t    staticClass: \"menu\",\n\t    class: _vm.menuClass,\n\t    style: (_vm.menuStyle),\n\t    attrs: {\n\t      \"tabindex\": \"-1\"\n\t    },\n\t    on: {\n\t      \"mousedown\": function($event) {\n\t        $event.preventDefault();\n\t      }\n\t    }\n\t  }, [_vm._l((_vm.filteredOptions), function(option, idx) {\n\t    return [_c('div', {\n\t      staticClass: \"item\",\n\t      class: {\n\t        'selected': option.selected, 'current': _vm.pointer === idx\n\t      },\n\t      attrs: {\n\t        \"data-vss-custom-attr\": _vm.customAttrs[idx] ? _vm.customAttrs[idx] : ''\n\t      },\n\t      on: {\n\t        \"click\": function($event) {\n\t          $event.stopPropagation();\n\t          _vm.selectItem(option)\n\t        },\n\t        \"mousedown\": _vm.mousedownItem,\n\t        \"mouseenter\": function($event) {\n\t          _vm.pointerSet(idx)\n\t        }\n\t      }\n\t    }, [_vm._v(\"\\n        \" + _vm._s(option.text) + \"\\n      \")])]\n\t  })], 2)])\n\t},staticRenderFns: []}\n\n/***/ },\n/* 101 */\n/***/ function(module, exports) {\n\n\tmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n\t  return _c('div', {\n\t    staticClass: \"ui fluid search selection dropdown\",\n\t    class: {\n\t      'active visible': _vm.showMenu, 'error': _vm.isError, 'disabled': _vm.isDisabled\n\t    },\n\t    on: {\n\t      \"click\": _vm.openOptions,\n\t      \"focus\": _vm.openOptions\n\t    }\n\t  }, [_c('i', {\n\t    staticClass: \"dropdown icon\"\n\t  }), _vm._v(\" \"), _c('input', {\n\t    ref: \"input\",\n\t    staticClass: \"search\",\n\t    attrs: {\n\t      \"autocomplete\": \"off\",\n\t      \"tabindex\": \"0\",\n\t      \"id\": _vm.id,\n\t      \"name\": _vm.name\n\t    },\n\t    domProps: {\n\t      \"value\": _vm.searchText\n\t    },\n\t    on: {\n\t      \"input\": function($event) {\n\t        _vm.searchText = $event.target.value\n\t      },\n\t      \"focus\": function($event) {\n\t        $event.preventDefault();\n\t        _vm.openOptions($event)\n\t      },\n\t      \"keyup\": [function($event) {\n\t        if (_vm._k($event.keyCode, \"esc\", 27)) { return; }\n\t        _vm.closeOptions($event)\n\t      }, function($event) {\n\t        if (_vm._k($event.keyCode, \"enter\", 13)) { return; }\n\t        $event.preventDefault();\n\t        _vm.enterItem($event)\n\t      }],\n\t      \"blur\": _vm.blurInput,\n\t      \"keydown\": [function($event) {\n\t        if (_vm._k($event.keyCode, \"up\", 38)) { return; }\n\t        _vm.prevItem($event)\n\t      }, function($event) {\n\t        if (_vm._k($event.keyCode, \"down\", 40)) { return; }\n\t        _vm.nextItem($event)\n\t      }, function($event) {\n\t        if (_vm._k($event.keyCode, \"enter\", 13)) { return; }\n\t        $event.preventDefault();\n\t      }, function($event) {\n\t        if (_vm._k($event.keyCode, \"delete\", [8, 46])) { return; }\n\t        _vm.deleteTextOrItem($event)\n\t      }]\n\t    }\n\t  }), _vm._v(\" \"), _c('div', {\n\t    staticClass: \"text\",\n\t    class: _vm.textClass,\n\t    attrs: {\n\t      \"data-vss-custom-attr\": _vm.searchTextCustomAttr\n\t    }\n\t  }, [_vm._v(_vm._s(_vm.inputText) + \"\\n  \")]), _vm._v(\" \"), _c('div', {\n\t    ref: \"menu\",\n\t    staticClass: \"menu\",\n\t    class: _vm.menuClass,\n\t    style: (_vm.menuStyle),\n\t    attrs: {\n\t      \"tabindex\": \"-1\"\n\t    },\n\t    on: {\n\t      \"mousedown\": function($event) {\n\t        $event.preventDefault();\n\t      }\n\t    }\n\t  }, [_vm._l((_vm.filteredOptions), function(option, idx) {\n\t    return [_c('div', {\n\t      staticClass: \"item\",\n\t      class: {\n\t        'selected': option.selected, 'current': _vm.pointer === idx\n\t      },\n\t      attrs: {\n\t        \"data-vss-custom-attr\": _vm.customAttrs[idx] ? _vm.customAttrs[idx] : ''\n\t      },\n\t      on: {\n\t        \"click\": function($event) {\n\t          $event.stopPropagation();\n\t          _vm.selectItem(option)\n\t        },\n\t        \"mousedown\": _vm.mousedownItem,\n\t        \"mouseenter\": function($event) {\n\t          _vm.pointerSet(idx)\n\t        }\n\t      }\n\t    }, [_vm._v(\"\\n        \" + _vm._s(option.text) + \"\\n      \")])]\n\t  })], 2)])\n\t},staticRenderFns: []}\n\n/***/ },\n/* 102 */\n/***/ function(module, exports) {\n\n\tmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n\t  return _c('div', {\n\t    staticClass: \"ui fluid multiple search selection dropdown\",\n\t    class: {\n\t      'active visible': _vm.showMenu, 'error': _vm.isError, 'disabled': _vm.isDisabled\n\t    },\n\t    on: {\n\t      \"click\": _vm.openOptions,\n\t      \"focus\": _vm.openOptions\n\t    }\n\t  }, [_c('i', {\n\t    staticClass: \"dropdown icon\"\n\t  }), _vm._v(\" \"), _vm._l((_vm.selectedOptions), function(option, idx) {\n\t    return (!_vm.hideSelectedOptions) ? [_c('a', {\n\t      staticClass: \"ui label transition visible\",\n\t      staticStyle: {\n\t        \"display\": \"inline-block !important\"\n\t      },\n\t      attrs: {\n\t        \"data-vss-custom-attr\": _vm.customAttr(option)\n\t      }\n\t    }, [_vm._v(\"\\n      \" + _vm._s(option.text)), _c('i', {\n\t      staticClass: \"delete icon\",\n\t      on: {\n\t        \"click\": function($event) {\n\t          _vm.deleteItem(option)\n\t        }\n\t      }\n\t    })])] : _vm._e()\n\t  }), _vm._v(\" \"), _c('input', {\n\t    directives: [{\n\t      name: \"model\",\n\t      rawName: \"v-model\",\n\t      value: (_vm.searchText),\n\t      expression: \"searchText\"\n\t    }],\n\t    ref: \"input\",\n\t    staticClass: \"search\",\n\t    style: (_vm.inputWidth),\n\t    attrs: {\n\t      \"autocomplete\": \"off\",\n\t      \"tabindex\": \"0\",\n\t      \"id\": _vm.id,\n\t      \"name\": _vm.name\n\t    },\n\t    domProps: {\n\t      \"value\": _vm._s(_vm.searchText)\n\t    },\n\t    on: {\n\t      \"focus\": function($event) {\n\t        $event.preventDefault();\n\t        _vm.openOptions($event)\n\t      },\n\t      \"keyup\": [function($event) {\n\t        if (_vm._k($event.keyCode, \"esc\", 27)) { return; }\n\t        _vm.closeOptions($event)\n\t      }, function($event) {\n\t        if (_vm._k($event.keyCode, \"enter\", 13)) { return; }\n\t        $event.preventDefault();\n\t        _vm.enterItem($event)\n\t      }],\n\t      \"blur\": _vm.blurInput,\n\t      \"keydown\": [function($event) {\n\t        if (_vm._k($event.keyCode, \"up\", 38)) { return; }\n\t        _vm.prevItem($event)\n\t      }, function($event) {\n\t        if (_vm._k($event.keyCode, \"down\", 40)) { return; }\n\t        _vm.nextItem($event)\n\t      }, function($event) {\n\t        if (_vm._k($event.keyCode, \"enter\", 13)) { return; }\n\t        $event.preventDefault();\n\t      }, function($event) {\n\t        if (_vm._k($event.keyCode, \"delete\", [8, 46])) { return; }\n\t        _vm.deleteTextOrLastItem($event)\n\t      }],\n\t      \"input\": function($event) {\n\t        if ($event.target.composing) { return; }\n\t        _vm.searchText = $event.target.value\n\t      }\n\t    }\n\t  }), _vm._v(\" \"), _c('div', {\n\t    staticClass: \"text\",\n\t    class: _vm.textClass\n\t  }, [_vm._v(_vm._s(_vm.inputText) + \"\\n  \")]), _vm._v(\" \"), _c('div', {\n\t    ref: \"menu\",\n\t    staticClass: \"menu\",\n\t    class: _vm.menuClass,\n\t    style: (_vm.menuStyle),\n\t    attrs: {\n\t      \"tabindex\": \"-1\"\n\t    },\n\t    on: {\n\t      \"mousedown\": function($event) {\n\t        $event.preventDefault();\n\t      }\n\t    }\n\t  }, [_vm._l((_vm.filteredOptions), function(option, idx) {\n\t    return [_c('div', {\n\t      staticClass: \"item\",\n\t      class: {\n\t        'selected': option.selected, 'current': _vm.pointer === idx\n\t      },\n\t      attrs: {\n\t        \"data-vss-custom-attr\": _vm.customAttr(option)\n\t      },\n\t      on: {\n\t        \"click\": function($event) {\n\t          $event.stopPropagation();\n\t          _vm.selectItem(option)\n\t        },\n\t        \"mousedown\": _vm.mousedownItem,\n\t        \"mouseenter\": function($event) {\n\t          _vm.pointerSet(idx)\n\t        }\n\t      }\n\t    }, [_vm._v(\"\\n        \" + _vm._s(option.text) + \"\\n      \")])]\n\t  })], 2)], 2)\n\t},staticRenderFns: []}\n\n/***/ },\n/* 103 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(90);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(5)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {}\n\n/***/ },\n/* 104 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(91);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(5)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {}\n\n/***/ },\n/* 105 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(92);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(5)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {}\n\n/***/ },\n/* 106 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(93);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(5)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {}\n\n/***/ },\n/* 107 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(94);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(5)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {}\n\n/***/ },\n/* 108 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(95);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(5)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {}\n\n/***/ },\n/* 109 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(96);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(5)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {}\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=vue-search-select.js.map\n\n//# sourceURL=webpack:///./node_modules/vue-search-select/publish/vue-search-select.js?");

/***/ }),

/***/ "./node_modules/vue/dist/vue.esm.js":
/*!******************************************!*\
  !*** ./node_modules/vue/dist/vue.esm.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!\n * Vue.js v2.6.10\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n// These helpers produce better VM code in JS engines due to their\n// explicitness and function inlining.\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n\n/**\n * Check if value is primitive.\n */\nfunction isPrimitive (value) {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    // $flow-disable-line\n    typeof value === 'symbol' ||\n    typeof value === 'boolean'\n  )\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Get the raw type string of a value, e.g., [object Object].\n */\nvar _toString = Object.prototype.toString;\n\nfunction toRawType (value) {\n  return _toString.call(value).slice(8, -1)\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex (val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\n}\n\nfunction isPromise (val) {\n  return (\n    isDef(val) &&\n    typeof val.then === 'function' &&\n    typeof val.catch === 'function'\n  )\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert an input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if an attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n/**\n * Remove an item from an array.\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether an object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n});\n\n/**\n * Simple bind polyfill for environments that do not support it,\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n * since native bind is now performant enough in most browsers.\n * But removing it would mean breaking code that was able to run in\n * PhantomJS 1.x, so this must be kept for backward compatibility.\n */\n\n/* istanbul ignore next */\nfunction polyfillBind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n\n  boundFn._length = fn.length;\n  return boundFn\n}\n\nfunction nativeBind (fn, ctx) {\n  return fn.bind(ctx)\n}\n\nvar bind = Function.prototype.bind\n  ? nativeBind\n  : polyfillBind;\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/* eslint-disable no-unused-vars */\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n */\nfunction noop (a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n\n/* eslint-enable no-unused-vars */\n\n/**\n * Return the same value.\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a string containing static keys from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime()\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\n/**\n * Return the first index at which a loosely equal value can be\n * found in the array (if value is a plain object, the array must\n * contain an object of the same shape), or -1 if it is not present.\n */\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated',\n  'errorCaptured',\n  'serverPrefetch'\n];\n\n/*  */\n\n\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  // $flow-disable-line\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"development\" !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"development\" !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  // $flow-disable-line\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Perform updates asynchronously. Intended to be used by Vue Test Utils\n   * This will significantly reduce performance if set to false.\n   */\n  async: true,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\n/**\n * unicode letters used for parsing html tags, component names and property paths.\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n */\nvar unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = new RegExp((\"[^\" + (unicodeRegExp.source) + \".$_\\\\d]\"));\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\nvar isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\nvar isPhantomJS = UA && /phantomjs/.test(UA);\nvar isFF = UA && UA.match(/firefox\\/(\\d+)/);\n\n// Firefox has a \"watch\" function on Object.prototype...\nvar nativeWatch = ({}).watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    })); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\nvar _Set;\n/* istanbul ignore if */ // $flow-disable-line\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = /*@__PURE__*/(function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar generateComponentTrace = (noop); // work around flow check\nvar formatComponentName = (noop);\n\nif (true) {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && (!config.silent)) {\n      console.error((\"[Vue warn]: \" + msg + trace));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var options = typeof vm === 'function' && vm.cid != null\n      ? vm.options\n      : vm._isVue\n        ? vm.$options || vm.constructor.options\n        : vm;\n    var name = options.name || options._componentTag;\n    var file = options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  if ( true && !config.async) {\n    // subs aren't sorted in scheduler if not running async\n    // we need to sort them now to make sure they fire in correct\n    // order\n    subs.sort(function (a, b) { return a.id - b.id; });\n  }\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// The current target watcher being evaluated.\n// This is globally unique because only one watcher\n// can be evaluated at a time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (target) {\n  targetStack.push(target);\n  Dep.target = target;\n}\n\nfunction popTarget () {\n  targetStack.pop();\n  Dep.target = targetStack[targetStack.length - 1];\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions,\n  asyncFactory\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.fnContext = undefined;\n  this.fnOptions = undefined;\n  this.fnScopeId = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: { configurable: true } };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function (text) {\n  if ( text === void 0 ) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    // #7975\n    // clone children array to avoid mutating original in case of cloning\n    // a child.\n    vnode.children && vnode.children.slice(),\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.fnContext = vnode.fnContext;\n  cloned.fnOptions = vnode.fnOptions;\n  cloned.fnScopeId = vnode.fnScopeId;\n  cloned.asyncMeta = vnode.asyncMeta;\n  cloned.isCloned = true;\n  return cloned\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\n\nvar methodsToPatch = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n];\n\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * In some cases we may want to disable observation inside a component's\n * update computation.\n */\nvar shouldObserve = true;\n\nfunction toggleObserving (value) {\n  shouldObserve = value;\n}\n\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    if (hasProto) {\n      protoAugment(value, arrayMethods);\n    } else {\n      copyAugment(value, arrayMethods, arrayKeys);\n    }\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through all properties and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment a target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment a target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    shouldObserve &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key];\n  }\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if ( true && customSetter) {\n        customSetter();\n      }\n      // #7981: for accessor properties without setter\n      if (getter && !setter) { return }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if ( true &&\n    (isUndef(target) || isPrimitive(target))\n  ) {\n    warn((\"Cannot set reactive property on undefined, null, or primitive value: \" + ((target))));\n  }\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n     true && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if ( true &&\n    (isUndef(target) || isPrimitive(target))\n  ) {\n    warn((\"Cannot delete reactive property on undefined, null, or primitive value: \" + ((target))));\n  }\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n     true && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (true) {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n\n  var keys = hasSymbol\n    ? Reflect.ownKeys(from)\n    : Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    // in case the object is already observed...\n    if (key === '__ob__') { continue }\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (\n      toVal !== fromVal &&\n      isPlainObject(toVal) &&\n      isPlainObject(fromVal)\n    ) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        typeof childVal === 'function' ? childVal.call(this, this) : childVal,\n        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\n      )\n    }\n  } else {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm, vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm, vm)\n        : parentVal;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n       true && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n\n      return parentVal\n    }\n    return mergeDataOrFn(parentVal, childVal)\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm)\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  var res = childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal;\n  return res\n    ? dedupeHooks(res)\n    : res\n}\n\nfunction dedupeHooks (hooks) {\n  var res = [];\n  for (var i = 0; i < hooks.length; i++) {\n    if (res.indexOf(hooks[i]) === -1) {\n      res.push(hooks[i]);\n    }\n  }\n  return res\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  var res = Object.create(parentVal || null);\n  if (childVal) {\n     true && assertObjectType(key, childVal, vm);\n    return extend(res, childVal)\n  } else {\n    return res\n  }\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (true) {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key$1 in childVal) {\n    var parent = ret[key$1];\n    var child = childVal[key$1];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key$1] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  if (childVal && \"development\" !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) { extend(ret, childVal); }\n  return ret\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    validateComponentName(key);\n  }\n}\n\nfunction validateComponentName (name) {\n  if (!new RegExp((\"^[a-zA-Z][\\\\-\\\\.0-9_\" + (unicodeRegExp.source) + \"]*$\")).test(name)) {\n    warn(\n      'Invalid component name: \"' + name + '\". Component names ' +\n      'should conform to valid custom element name in html5 specification.'\n    );\n  }\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\n    warn(\n      'Do not use built-in or reserved HTML elements as component ' +\n      'id: ' + name\n    );\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options, vm) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (true) {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  } else if (true) {\n    warn(\n      \"Invalid value for option \\\"props\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(props)) + \".\",\n      vm\n    );\n  }\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject (options, vm) {\n  var inject = options.inject;\n  if (!inject) { return }\n  var normalized = options.inject = {};\n  if (Array.isArray(inject)) {\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = { from: inject[i] };\n    }\n  } else if (isPlainObject(inject)) {\n    for (var key in inject) {\n      var val = inject[key];\n      normalized[key] = isPlainObject(val)\n        ? extend({ from: key }, val)\n        : { from: val };\n    }\n  } else if (true) {\n    warn(\n      \"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(inject)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def$$1 = dirs[key];\n      if (typeof def$$1 === 'function') {\n        dirs[key] = { bind: def$$1, update: def$$1 };\n      }\n    }\n  }\n}\n\nfunction assertObjectType (name, value, vm) {\n  if (!isPlainObject(value)) {\n    warn(\n      \"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" +\n      \"but got \" + (toRawType(value)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (true) {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child, vm);\n  normalizeInject(child, vm);\n  normalizeDirectives(child);\n\n  // Apply extends and mixins on the child options,\n  // but only if it is a raw options object that isn't\n  // the result of another mergeOptions call.\n  // Only merged options has the _base property.\n  if (!child._base) {\n    if (child.extends) {\n      parent = mergeOptions(parent, child.extends, vm);\n    }\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n  }\n\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if ( true && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\n\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // boolean casting\n  var booleanIndex = getTypeIndex(Boolean, prop.type);\n  if (booleanIndex > -1) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (value === '' || value === hyphenate(key)) {\n      // only cast empty string / same name to boolean if\n      // boolean has higher priority\n      var stringIndex = getTypeIndex(String, prop.type);\n      if (stringIndex < 0 || booleanIndex < stringIndex) {\n        value = true;\n      }\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldObserve = shouldObserve;\n    toggleObserving(true);\n    observe(value);\n    toggleObserving(prevShouldObserve);\n  }\n  if (\n    true\n  ) {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if ( true && isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n\n  if (!valid) {\n    warn(\n      getInvalidTypeMessage(name, value, expectedTypes),\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    // for primitive wrapper objects\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isSameType (a, b) {\n  return getType(a) === getType(b)\n}\n\nfunction getTypeIndex (type, expectedTypes) {\n  if (!Array.isArray(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1\n  }\n  for (var i = 0, len = expectedTypes.length; i < len; i++) {\n    if (isSameType(expectedTypes[i], type)) {\n      return i\n    }\n  }\n  return -1\n}\n\nfunction getInvalidTypeMessage (name, value, expectedTypes) {\n  var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" +\n    \" Expected \" + (expectedTypes.map(capitalize).join(', '));\n  var expectedType = expectedTypes[0];\n  var receivedType = toRawType(value);\n  var expectedValue = styleValue(value, expectedType);\n  var receivedValue = styleValue(value, receivedType);\n  // check if we need to specify expected value\n  if (expectedTypes.length === 1 &&\n      isExplicable(expectedType) &&\n      !isBoolean(expectedType, receivedType)) {\n    message += \" with value \" + expectedValue;\n  }\n  message += \", got \" + receivedType + \" \";\n  // check if we need to specify received value\n  if (isExplicable(receivedType)) {\n    message += \"with value \" + receivedValue + \".\";\n  }\n  return message\n}\n\nfunction styleValue (value, type) {\n  if (type === 'String') {\n    return (\"\\\"\" + value + \"\\\"\")\n  } else if (type === 'Number') {\n    return (\"\" + (Number(value)))\n  } else {\n    return (\"\" + value)\n  }\n}\n\nfunction isExplicable (value) {\n  var explicitTypes = ['string', 'number', 'boolean'];\n  return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })\n}\n\nfunction isBoolean () {\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n\n  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n  // See: https://github.com/vuejs/vuex/issues/1505\n  pushTarget();\n  try {\n    if (vm) {\n      var cur = vm;\n      while ((cur = cur.$parent)) {\n        var hooks = cur.$options.errorCaptured;\n        if (hooks) {\n          for (var i = 0; i < hooks.length; i++) {\n            try {\n              var capture = hooks[i].call(cur, err, vm, info) === false;\n              if (capture) { return }\n            } catch (e) {\n              globalHandleError(e, cur, 'errorCaptured hook');\n            }\n          }\n        }\n      }\n    }\n    globalHandleError(err, vm, info);\n  } finally {\n    popTarget();\n  }\n}\n\nfunction invokeWithErrorHandling (\n  handler,\n  context,\n  args,\n  vm,\n  info\n) {\n  var res;\n  try {\n    res = args ? handler.apply(context, args) : handler.call(context);\n    if (res && !res._isVue && isPromise(res) && !res._handled) {\n      res.catch(function (e) { return handleError(e, vm, info + \" (Promise/async)\"); });\n      // issue #9511\n      // avoid catch triggering multiple times when nested calls\n      res._handled = true;\n    }\n  } catch (e) {\n    handleError(e, vm, info);\n  }\n  return res\n}\n\nfunction globalHandleError (err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info)\n    } catch (e) {\n      // if the user intentionally throws the original error in the handler,\n      // do not log it twice\n      if (e !== err) {\n        logError(e, null, 'config.errorHandler');\n      }\n    }\n  }\n  logError(err, vm, info);\n}\n\nfunction logError (err, vm, info) {\n  if (true) {\n    warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n  }\n  /* istanbul ignore else */\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n    console.error(err);\n  } else {\n    throw err\n  }\n}\n\n/*  */\n\nvar isUsingMicroTask = false;\n\nvar callbacks = [];\nvar pending = false;\n\nfunction flushCallbacks () {\n  pending = false;\n  var copies = callbacks.slice(0);\n  callbacks.length = 0;\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n}\n\n// Here we have async deferring wrappers using microtasks.\n// In 2.5 we used (macro) tasks (in combination with microtasks).\n// However, it has subtle problems when state is changed right before repaint\n// (e.g. #6813, out-in transitions).\n// Also, using (macro) tasks in event handler would cause some weird behaviors\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n// So we now use microtasks everywhere, again.\n// A major drawback of this tradeoff is that there are some scenarios\n// where microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690, which have workarounds)\n// or even between bubbling of the same event (#6566).\nvar timerFunc;\n\n// The nextTick behavior leverages the microtask queue, which can be accessed\n// via either native Promise.then or MutationObserver.\n// MutationObserver has wider support, however it is seriously bugged in\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n// completely stops working after triggering a few times... so, if native\n// Promise is available, we will use it:\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n  timerFunc = function () {\n    p.then(flushCallbacks);\n    // In problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) { setTimeout(noop); }\n  };\n  isUsingMicroTask = true;\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (\n  isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]'\n)) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  var counter = 1;\n  var observer = new MutationObserver(flushCallbacks);\n  var textNode = document.createTextNode(String(counter));\n  observer.observe(textNode, {\n    characterData: true\n  });\n  timerFunc = function () {\n    counter = (counter + 1) % 2;\n    textNode.data = String(counter);\n  };\n  isUsingMicroTask = true;\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Techinically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = function () {\n    setImmediate(flushCallbacks);\n  };\n} else {\n  // Fallback to setTimeout.\n  timerFunc = function () {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\nfunction nextTick (cb, ctx) {\n  var _resolve;\n  callbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n  if (!pending) {\n    pending = true;\n    timerFunc();\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    })\n  }\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (true) {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      // perf.clearMeasures(name)\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (true) {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      'referenced during render. Make sure that this property is reactive, ' +\n      'either in the data option, or for class-based components, by ' +\n      'initializing the property. ' +\n      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',\n      target\n    );\n  };\n\n  var warnReservedPrefix = function (target, key) {\n    warn(\n      \"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" +\n      'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' +\n      'prevent conflicts with Vue internals' +\n      'See: https://vuejs.org/v2/api/#data',\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' && isNative(Proxy);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) ||\n        (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));\n      if (!has && !isAllowed) {\n        if (key in target.$data) { warnReservedPrefix(target, key); }\n        else { warnNonPresent(target, key); }\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        if (key in target.$data) { warnReservedPrefix(target, key); }\n        else { warnNonPresent(target, key); }\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar seenObjects = new _Set();\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nfunction traverse (val) {\n  _traverse(val, seenObjects);\n  seenObjects.clear();\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns, vm) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n      }\n    } else {\n      // return handler return value for single handlers\n      return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\")\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  createOnceHandler,\n  vm\n) {\n  var name, def$$1, cur, old, event;\n  for (name in on) {\n    def$$1 = cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n       true && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur, vm);\n      }\n      if (isTrue(event.once)) {\n        cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n      }\n      add(event.name, cur, event.capture, event.passive, event.params);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {});\n  }\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (true) {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, lastIndex, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    lastIndex = res.length - 1;\n    last = res[lastIndex];\n    //  nested\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i));\n        // merge adjacent text nodes\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + (c[0]).text);\n          c.shift();\n        }\n        res.push.apply(res, c);\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    toggleObserving(false);\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (true) {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {}\n    });\n    toggleObserving(true);\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol\n      ? Reflect.ownKeys(inject)\n      : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      // #6574 in case the inject object is observed...\n      if (key === '__ob__') { continue }\n      var provideKey = inject[key].from;\n      var source = vm;\n      while (source) {\n        if (source._provided && hasOwn(source._provided, provideKey)) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n      if (!source) {\n        if ('default' in inject[key]) {\n          var provideDefault = inject[key].default;\n          result[key] = typeof provideDefault === 'function'\n            ? provideDefault.call(vm)\n            : provideDefault;\n        } else if (true) {\n          warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n        }\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\n\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  if (!children || !children.length) {\n    return {}\n  }\n  var slots = {};\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data;\n    // remove slot attribute if the node is resolved as a Vue slot node\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    }\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.fnContext === context) &&\n      data && data.slot != null\n    ) {\n      var name = data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children || []);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      (slots.default || (slots.default = [])).push(child);\n    }\n  }\n  // ignore slots that contains only whitespace\n  for (var name$1 in slots) {\n    if (slots[name$1].every(isWhitespace)) {\n      delete slots[name$1];\n    }\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return (node.isComment && !node.asyncFactory) || node.text === ' '\n}\n\n/*  */\n\nfunction normalizeScopedSlots (\n  slots,\n  normalSlots,\n  prevSlots\n) {\n  var res;\n  var hasNormalSlots = Object.keys(normalSlots).length > 0;\n  var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n  var key = slots && slots.$key;\n  if (!slots) {\n    res = {};\n  } else if (slots._normalized) {\n    // fast path 1: child component re-render only, parent did not change\n    return slots._normalized\n  } else if (\n    isStable &&\n    prevSlots &&\n    prevSlots !== emptyObject &&\n    key === prevSlots.$key &&\n    !hasNormalSlots &&\n    !prevSlots.$hasNormal\n  ) {\n    // fast path 2: stable scoped slots w/ no normal slots to proxy,\n    // only need to normalize once\n    return prevSlots\n  } else {\n    res = {};\n    for (var key$1 in slots) {\n      if (slots[key$1] && key$1[0] !== '$') {\n        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n      }\n    }\n  }\n  // expose normal slots on scopedSlots\n  for (var key$2 in normalSlots) {\n    if (!(key$2 in res)) {\n      res[key$2] = proxyNormalSlot(normalSlots, key$2);\n    }\n  }\n  // avoriaz seems to mock a non-extensible $scopedSlots object\n  // and when that is passed down this would cause an error\n  if (slots && Object.isExtensible(slots)) {\n    (slots)._normalized = res;\n  }\n  def(res, '$stable', isStable);\n  def(res, '$key', key);\n  def(res, '$hasNormal', hasNormalSlots);\n  return res\n}\n\nfunction normalizeScopedSlot(normalSlots, key, fn) {\n  var normalized = function () {\n    var res = arguments.length ? fn.apply(null, arguments) : fn({});\n    res = res && typeof res === 'object' && !Array.isArray(res)\n      ? [res] // single vnode\n      : normalizeChildren(res);\n    return res && (\n      res.length === 0 ||\n      (res.length === 1 && res[0].isComment) // #9658\n    ) ? undefined\n      : res\n  };\n  // this is a slot using the new v-slot syntax without scope. although it is\n  // compiled as a scoped slot, render fn users would expect it to be present\n  // on this.$slots because the usage is semantically a normal slot.\n  if (fn.proxy) {\n    Object.defineProperty(normalSlots, key, {\n      get: normalized,\n      enumerable: true,\n      configurable: true\n    });\n  }\n  return normalized\n}\n\nfunction proxyNormalSlot(slots, key) {\n  return function () { return slots[key]; }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    if (hasSymbol && val[Symbol.iterator]) {\n      ret = [];\n      var iterator = val[Symbol.iterator]();\n      var result = iterator.next();\n      while (!result.done) {\n        ret.push(render(result.value, ret.length));\n        result = iterator.next();\n      }\n    } else {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n  }\n  if (!isDef(ret)) {\n    ret = [];\n  }\n  (ret)._isVList = true;\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  var nodes;\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      if ( true && !isObject(bindObject)) {\n        warn(\n          'slot v-bind without argument expects an Object',\n          this\n        );\n      }\n      props = extend(extend({}, bindObject), props);\n    }\n    nodes = scopedSlotFn(props) || fallback;\n  } else {\n    nodes = this.$slots[name] || fallback;\n  }\n\n  var target = props && props.slot;\n  if (target) {\n    return this.$createElement('template', { slot: target }, nodes)\n  } else {\n    return nodes\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\nfunction isKeyNotMatch (expect, actual) {\n  if (Array.isArray(expect)) {\n    return expect.indexOf(actual) === -1\n  } else {\n    return expect !== actual\n  }\n}\n\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInKeyCode,\n  eventKeyName,\n  builtInKeyName\n) {\n  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n    return isKeyNotMatch(builtInKeyName, eventKeyName)\n  } else if (mappedKeyCode) {\n    return isKeyNotMatch(mappedKeyCode, eventKeyCode)\n  } else if (eventKeyName) {\n    return hyphenate(eventKeyName) !== key\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp,\n  isSync\n) {\n  if (value) {\n    if (!isObject(value)) {\n       true && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function ( key ) {\n        if (\n          key === 'class' ||\n          key === 'style' ||\n          isReservedAttribute(key)\n        ) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        var camelizedKey = camelize(key);\n        var hyphenatedKey = hyphenate(key);\n        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[(\"update:\" + key)] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop( key );\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var cached = this._staticTrees || (this._staticTrees = []);\n  var tree = cached[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree.\n  if (tree && !isInFor) {\n    return tree\n  }\n  // otherwise, render a fresh tree.\n  tree = cached[index] = this.$options.staticRenderFns[index].call(\n    this._renderProxy,\n    null,\n    this // for render fns generated for functional component templates\n  );\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners (data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n       true && warn(\n        'v-on without argument expects an Object value',\n        this\n      );\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(existing, ours) : ours;\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res,\n  // the following are added in 2.6\n  hasDynamicKeys,\n  contentHashKey\n) {\n  res = res || { $stable: !hasDynamicKeys };\n  for (var i = 0; i < fns.length; i++) {\n    var slot = fns[i];\n    if (Array.isArray(slot)) {\n      resolveScopedSlots(slot, res, hasDynamicKeys);\n    } else if (slot) {\n      // marker for reverse proxying v-slot without scope on this.$slots\n      if (slot.proxy) {\n        slot.fn.proxy = true;\n      }\n      res[slot.key] = slot.fn;\n    }\n  }\n  if (contentHashKey) {\n    (res).$key = contentHashKey;\n  }\n  return res\n}\n\n/*  */\n\nfunction bindDynamicKeys (baseObj, values) {\n  for (var i = 0; i < values.length; i += 2) {\n    var key = values[i];\n    if (typeof key === 'string' && key) {\n      baseObj[values[i]] = values[i + 1];\n    } else if ( true && key !== '' && key !== null) {\n      // null is a speical value for explicitly removing a binding\n      warn(\n        (\"Invalid value for dynamic directive argument (expected string or null): \" + key),\n        this\n      );\n    }\n  }\n  return baseObj\n}\n\n// helper to dynamically append modifier runtime markers to event names.\n// ensure only append when value is already string, otherwise it will be cast\n// to string and cause the type check to miss.\nfunction prependModifier (value, symbol) {\n  return typeof value === 'string' ? symbol + value : value\n}\n\n/*  */\n\nfunction installRenderHelpers (target) {\n  target._o = markOnce;\n  target._n = toNumber;\n  target._s = toString;\n  target._l = renderList;\n  target._t = renderSlot;\n  target._q = looseEqual;\n  target._i = looseIndexOf;\n  target._m = renderStatic;\n  target._f = resolveFilter;\n  target._k = checkKeyCodes;\n  target._b = bindObjectProps;\n  target._v = createTextVNode;\n  target._e = createEmptyVNode;\n  target._u = resolveScopedSlots;\n  target._g = bindObjectListeners;\n  target._d = bindDynamicKeys;\n  target._p = prependModifier;\n}\n\n/*  */\n\nfunction FunctionalRenderContext (\n  data,\n  props,\n  children,\n  parent,\n  Ctor\n) {\n  var this$1 = this;\n\n  var options = Ctor.options;\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var contextVm;\n  if (hasOwn(parent, '_uid')) {\n    contextVm = Object.create(parent);\n    // $flow-disable-line\n    contextVm._original = parent;\n  } else {\n    // the context vm passed in is a functional context as well.\n    // in this case we want to make sure we are able to get a hold to the\n    // real context instance.\n    contextVm = parent;\n    // $flow-disable-line\n    parent = parent._original;\n  }\n  var isCompiled = isTrue(options._compiled);\n  var needNormalization = !isCompiled;\n\n  this.data = data;\n  this.props = props;\n  this.children = children;\n  this.parent = parent;\n  this.listeners = data.on || emptyObject;\n  this.injections = resolveInject(options.inject, parent);\n  this.slots = function () {\n    if (!this$1.$slots) {\n      normalizeScopedSlots(\n        data.scopedSlots,\n        this$1.$slots = resolveSlots(children, parent)\n      );\n    }\n    return this$1.$slots\n  };\n\n  Object.defineProperty(this, 'scopedSlots', ({\n    enumerable: true,\n    get: function get () {\n      return normalizeScopedSlots(data.scopedSlots, this.slots())\n    }\n  }));\n\n  // support for compiled functional template\n  if (isCompiled) {\n    // exposing $options for renderStatic()\n    this.$options = options;\n    // pre-resolve slots for renderSlot()\n    this.$slots = this.slots();\n    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n  }\n\n  if (options._scopeId) {\n    this._c = function (a, b, c, d) {\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n      if (vnode && !Array.isArray(vnode)) {\n        vnode.fnScopeId = options._scopeId;\n        vnode.fnContext = parent;\n      }\n      return vnode\n    };\n  } else {\n    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\n  }\n}\n\ninstallRenderHelpers(FunctionalRenderContext.prototype);\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  contextVm,\n  children\n) {\n  var options = Ctor.options;\n  var props = {};\n  var propOptions = options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n\n  var renderContext = new FunctionalRenderContext(\n    data,\n    props,\n    children,\n    contextVm,\n    Ctor\n  );\n\n  var vnode = options.render.call(null, renderContext._c, renderContext);\n\n  if (vnode instanceof VNode) {\n    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)\n  } else if (Array.isArray(vnode)) {\n    var vnodes = normalizeChildren(vnode) || [];\n    var res = new Array(vnodes.length);\n    for (var i = 0; i < vnodes.length; i++) {\n      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n    }\n    return res\n  }\n}\n\nfunction cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {\n  // #7817 clone node before setting fnContext, otherwise if the node is reused\n  // (e.g. it was from a cached normal slot) the fnContext causes named slots\n  // that should not be matched to match.\n  var clone = cloneVNode(vnode);\n  clone.fnContext = contextVm;\n  clone.fnOptions = options;\n  if (true) {\n    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n  }\n  if (data.slot) {\n    (clone.data || (clone.data = {})).slot = data.slot;\n  }\n  return clone\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n/*  */\n\n/*  */\n\n/*  */\n\n// inline hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (vnode, hydrating) {\n    if (\n      vnode.componentInstance &&\n      !vnode.componentInstance._isDestroyed &&\n      vnode.data.keepAlive\n    ) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    } else {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (true) {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // install component management hooks onto the placeholder node\n  installComponentHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n    asyncFactory\n  );\n\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent // activeInstance in lifecycle state\n) {\n  var options = {\n    _isComponent: true,\n    _parentVnode: vnode,\n    parent: parent\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnode.componentOptions.Ctor(options)\n}\n\nfunction installComponentHooks (data) {\n  var hooks = data.hook || (data.hook = {});\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var existing = hooks[key];\n    var toMerge = componentVNodeHooks[key];\n    if (existing !== toMerge && !(existing && existing._merged)) {\n      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n    }\n  }\n}\n\nfunction mergeHook$1 (f1, f2) {\n  var merged = function (a, b) {\n    // flow complains about extra args which is why we use any\n    f1(a, b);\n    f2(a, b);\n  };\n  merged._merged = true;\n  return merged\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input'\n  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  var existing = on[event];\n  var callback = data.model.callback;\n  if (isDef(existing)) {\n    if (\n      Array.isArray(existing)\n        ? existing.indexOf(callback) === -1\n        : existing !== callback\n    ) {\n      on[event] = [callback].concat(existing);\n    }\n  } else {\n    on[event] = callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n     true && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if ( true &&\n    isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n  ) {\n    {\n      warn(\n        'Avoid using non-primitive value as key, ' +\n        'use string/number value instead.',\n        context\n      );\n    }\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (Array.isArray(vnode)) {\n    return vnode\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) { applyNS(vnode, ns); }\n    if (isDef(data)) { registerDeepBindings(data); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns, force) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined;\n    force = true;\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && (\n        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n        applyNS(child, ns, force);\n      }\n    }\n  }\n}\n\n// ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\nfunction registerDeepBindings (data) {\n  if (isObject(data.style)) {\n    traverse(data.style);\n  }\n  if (isObject(data.class)) {\n    traverse(data.class);\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null; // v-once cached trees\n  var options = vm.$options;\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n\n  /* istanbul ignore else */\n  if (true) {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {}\n}\n\nvar currentRenderingInstance = null;\n\nfunction renderMixin (Vue) {\n  // install runtime convenience helpers\n  installRenderHelpers(Vue.prototype);\n\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var _parentVnode = ref._parentVnode;\n\n    if (_parentVnode) {\n      vm.$scopedSlots = normalizeScopedSlots(\n        _parentVnode.data.scopedSlots,\n        vm.$slots,\n        vm.$scopedSlots\n      );\n    }\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      // There's no need to maintain a stack becaues all render fns are called\n      // separately from one another. Nested component's render fns are called\n      // when parent component is patched.\n      currentRenderingInstance = vm;\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if ( true && vm.$options.renderError) {\n        try {\n          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n        } catch (e) {\n          handleError(e, vm, \"renderError\");\n          vnode = vm._vnode;\n        }\n      } else {\n        vnode = vm._vnode;\n      }\n    } finally {\n      currentRenderingInstance = null;\n    }\n    // if the returned array contains only a single node, allow it\n    if (Array.isArray(vnode) && vnode.length === 1) {\n      vnode = vnode[0];\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if ( true && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  if (\n    comp.__esModule ||\n    (hasSymbol && comp[Symbol.toStringTag] === 'Module')\n  ) {\n    comp = comp.default;\n  }\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction createAsyncPlaceholder (\n  factory,\n  data,\n  context,\n  children,\n  tag\n) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  var owner = currentRenderingInstance;\n  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n    // already pending\n    factory.owners.push(owner);\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (owner && !isDef(factory.owners)) {\n    var owners = factory.owners = [owner];\n    var sync = true;\n    var timerLoading = null;\n    var timerTimeout = null\n\n    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });\n\n    var forceRender = function (renderCompleted) {\n      for (var i = 0, l = owners.length; i < l; i++) {\n        (owners[i]).$forceUpdate();\n      }\n\n      if (renderCompleted) {\n        owners.length = 0;\n        if (timerLoading !== null) {\n          clearTimeout(timerLoading);\n          timerLoading = null;\n        }\n        if (timerTimeout !== null) {\n          clearTimeout(timerTimeout);\n          timerTimeout = null;\n        }\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender(true);\n      } else {\n        owners.length = 0;\n      }\n    });\n\n    var reject = once(function (reason) {\n       true && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender(true);\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (isPromise(res)) {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isPromise(res.component)) {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            timerLoading = setTimeout(function () {\n              timerLoading = null;\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender(false);\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          timerTimeout = setTimeout(function () {\n            timerTimeout = null;\n            if (isUndef(factory.resolved)) {\n              reject(\n                 true\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : undefined\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction isAsyncPlaceholder (node) {\n  return node.isComment && node.asyncFactory\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn) {\n  target.$on(event, fn);\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction createOnceHandler (event, fn) {\n  var _target = target;\n  return function onceHandler () {\n    var res = fn.apply(null, arguments);\n    if (res !== null) {\n      _target.$off(event, onceHandler);\n    }\n  }\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n  target = undefined;\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        vm.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        vm.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (!fn) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (true) {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      var info = \"event handler for \\\"\" + event + \"\\\"\";\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction setActiveInstance(vm) {\n  var prevActiveInstance = activeInstance;\n  activeInstance = vm;\n  return function () {\n    activeInstance = prevActiveInstance;\n  }\n}\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var restoreActiveInstance = setActiveInstance(vm);\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    restoreActiveInstance();\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // release circular reference (#6759)\n    if (vm.$vnode) {\n      vm.$vnode.parent = null;\n    }\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (true) {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if ( true && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((\"vue \" + name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((\"vue \" + name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, {\n    before: function before () {\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate');\n      }\n    }\n  }, true /* isRenderWatcher */);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  if (true) {\n    isUpdatingChildComponent = true;\n  }\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren.\n\n  // check if there are dynamic scopedSlots (hand-written or compiled but with\n  // dynamic slot names). Static scoped slots compiled from template has the\n  // \"$stable\" marker.\n  var newScopedSlots = parentVnode.data.scopedSlots;\n  var oldScopedSlots = vm.$scopedSlots;\n  var hasDynamicScopedSlot = !!(\n    (newScopedSlots && !newScopedSlots.$stable) ||\n    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\n    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)\n  );\n\n  // Any static slot children from the parent may have changed during parent's\n  // update. Dynamic scoped slots may also have changed. In such cases, a forced\n  // update is necessary to ensure correctness.\n  var needsForceUpdate = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    hasDynamicScopedSlot\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = parentVnode.data.attrs || emptyObject;\n  vm.$listeners = listeners || emptyObject;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    toggleObserving(false);\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      var propOptions = vm.$options.props; // wtf flow?\n      props[key] = validateProp(key, propOptions, propsData, vm);\n    }\n    toggleObserving(true);\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  listeners = listeners || emptyObject;\n  var oldListeners = vm.$options._parentListeners;\n  vm.$options._parentListeners = listeners;\n  updateComponentListeners(vm, listeners, oldListeners);\n\n  // resolve slots + force update if has children\n  if (needsForceUpdate) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (true) {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  // #7573 disable dep collection when invoking lifecycle hooks\n  pushTarget();\n  var handlers = vm.$options[hook];\n  var info = hook + \" hook\";\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n  popTarget();\n}\n\n/*  */\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (true) {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n// Async edge case #6566 requires saving the timestamp when event listeners are\n// attached. However, calling performance.now() has a perf overhead especially\n// if the page has thousands of event listeners. Instead, we take a timestamp\n// every time the scheduler flushes and use that for all event listeners\n// attached during that flush.\nvar currentFlushTimestamp = 0;\n\n// Async edge case fix requires storing an event listener's attach timestamp.\nvar getNow = Date.now;\n\n// Determine what event timestamp the browser is using. Annoyingly, the\n// timestamp can either be hi-res (relative to page load) or low-res\n// (relative to UNIX epoch), so in order to compare time we have to use the\n// same timestamp type when saving the flush timestamp.\n// All IE versions use low-res event timestamps, and have problematic clock\n// implementations (#9632)\nif (inBrowser && !isIE) {\n  var performance = window.performance;\n  if (\n    performance &&\n    typeof performance.now === 'function' &&\n    getNow() > document.createEvent('Event').timeStamp\n  ) {\n    // if the event timestamp, although evaluated AFTER the Date.now(), is\n    // smaller than it, it means the event is using a hi-res timestamp,\n    // and we need to use the hi-res version for event listener timestamps as\n    // well.\n    getNow = function () { return performance.now(); };\n  }\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  currentFlushTimestamp = getNow();\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    if (watcher.before) {\n      watcher.before();\n    }\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if ( true && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n\n      if ( true && !config.async) {\n        flushSchedulerQueue();\n        return\n      }\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\n\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options,\n  isRenderWatcher\n) {\n  this.vm = vm;\n  if (isRenderWatcher) {\n    vm._watcher = this;\n  }\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n    this.before = options.before;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression =  true\n    ? expOrFn.toString()\n    : undefined;\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = noop;\n       true && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this.deps[i];\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n  var i = this.deps.length;\n  while (i--) {\n    this.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].removeSub(this);\n    }\n    this.active = false;\n  }\n};\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  if (!isRoot) {\n    toggleObserving(false);\n  }\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (true) {\n      var hyphenatedKey = hyphenate(key);\n      if (isReservedAttribute(hyphenatedKey) ||\n          config.isReservedAttr(hyphenatedKey)) {\n        warn(\n          (\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (!isRoot && !isUpdatingChildComponent) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {}\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  toggleObserving(true);\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n     true && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (true) {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n          vm\n        );\n      }\n    }\n    if (props && hasOwn(props, key)) {\n       true && warn(\n        \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  // #7573 disable dep collection when invoking data getters\n  pushTarget();\n  try {\n    return data.call(vm, vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  } finally {\n    popTarget();\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  // $flow-disable-line\n  var watchers = vm._computedWatchers = Object.create(null);\n  // computed properties are just getters during SSR\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if ( true && getter == null) {\n      warn(\n        (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n        vm\n      );\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      );\n    }\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (true) {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (\n  target,\n  key,\n  userDef\n) {\n  var shouldCache = !isServerRendering();\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache\n      ? createComputedGetter(key)\n      : createGetterInvoker(userDef);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? shouldCache && userDef.cache !== false\n        ? createComputedGetter(key)\n        : createGetterInvoker(userDef.get)\n      : noop;\n    sharedPropertyDefinition.set = userDef.set || noop;\n  }\n  if ( true &&\n      sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(\n        (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n        this\n      );\n    };\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction createGetterInvoker(fn) {\n  return function computedGetter () {\n    return fn.call(this, this)\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    if (true) {\n      if (typeof methods[key] !== 'function') {\n        warn(\n          \"Method \\\"\" + key + \"\\\" has type \\\"\" + (typeof methods[key]) + \"\\\" in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n      if ((key in vm) && isReserved(key)) {\n        warn(\n          \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\n          \"Avoid defining component methods that start with _ or $.\"\n        );\n      }\n    }\n    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (\n  vm,\n  expOrFn,\n  handler,\n  options\n) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(expOrFn, handler, options)\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (true) {\n    dataDef.set = function () {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      try {\n        cb.call(vm, watcher.value);\n      } catch (error) {\n        handleError(error, vm, (\"callback for immediate watcher \\\"\" + (watcher.expression) + \"\\\"\"));\n      }\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nvar uid$3 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$3++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if ( true && config.performance && mark) {\n      startTag = \"vue-perf-start:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (true) {\n      initProxy(vm);\n    } else {}\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if ( true && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure((\"vue \" + (vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  var parentVnode = options._parentVnode;\n  opts.parent = options.parent;\n  opts._parentVnode = parentVnode;\n\n  var vnodeComponentOptions = parentVnode.componentOptions;\n  opts.propsData = vnodeComponentOptions.propsData;\n  opts._parentListeners = vnodeComponentOptions.listeners;\n  opts._renderChildren = vnodeComponentOptions.children;\n  opts._componentTag = vnodeComponentOptions.tag;\n\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = latest[key];\n    }\n  }\n  return modified\n}\n\nfunction Vue (options) {\n  if ( true &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue);\nstateMixin(Vue);\neventsMixin(Vue);\nlifecycleMixin(Vue);\nrenderMixin(Vue);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if ( true && name) {\n      validateComponentName(name);\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if ( true && type === 'component') {\n          validateComponentName(id);\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\n\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (keepAliveInstance, filter) {\n  var cache = keepAliveInstance.cache;\n  var keys = keepAliveInstance.keys;\n  var _vnode = keepAliveInstance._vnode;\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode);\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (\n  cache,\n  key,\n  keys,\n  current\n) {\n  var cached$$1 = cache[key];\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n    cached$$1.componentInstance.$destroy();\n  }\n  cache[key] = null;\n  remove(keys, key);\n}\n\nvar patternTypes = [String, RegExp, Array];\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n    this.keys = [];\n  },\n\n  destroyed: function destroyed () {\n    for (var key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys);\n    }\n  },\n\n  mounted: function mounted () {\n    var this$1 = this;\n\n    this.$watch('include', function (val) {\n      pruneCache(this$1, function (name) { return matches(val, name); });\n    });\n    this.$watch('exclude', function (val) {\n      pruneCache(this$1, function (name) { return !matches(val, name); });\n    });\n  },\n\n  render: function render () {\n    var slot = this.$slots.default;\n    var vnode = getFirstComponentChild(slot);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      var ref = this;\n      var include = ref.include;\n      var exclude = ref.exclude;\n      if (\n        // not included\n        (include && (!name || !matches(include, name))) ||\n        // excluded\n        (exclude && name && matches(exclude, name))\n      ) {\n        return vnode\n      }\n\n      var ref$1 = this;\n      var cache = ref$1.cache;\n      var keys = ref$1.keys;\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance;\n        // make current key freshest\n        remove(keys, key);\n        keys.push(key);\n      } else {\n        cache[key] = vnode;\n        keys.push(key);\n        // prune oldest entry\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\n        }\n      }\n\n      vnode.data.keepAlive = true;\n    }\n    return vnode || (slot && slot[0])\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (true) {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  // 2.6 explicit observable API\n  Vue.observable = function (obj) {\n    observe(obj);\n    return obj\n  };\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue);\n\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n});\n\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n});\n\nVue.version = '2.6.10';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select,progress');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\nvar convertEnumeratedValue = function (key, value) {\n  return isFalsyAttrValue(value) || value === 'false'\n    ? 'false'\n    // allow arbitrary string value for contenteditable\n    : key === 'contenteditable' && isValidContentEditableValue(value)\n      ? value\n      : 'true'\n};\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction renderClass (\n  staticClass,\n  dynamicClass\n) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value)\n  }\n  if (isObject(value)) {\n    return stringifyObject(value)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction stringifyArray (value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) { res += ' '; }\n      res += stringified;\n    }\n  }\n  return res\n}\n\nfunction stringifyObject (value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) { res += ' '; }\n      res += key;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template,blockquote,iframe,tfoot'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n       true && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setStyleScope (node, scopeId) {\n  node.setAttribute(scopeId, '');\n}\n\nvar nodeOps = /*#__PURE__*/Object.freeze({\n  createElement: createElement$1,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setStyleScope: setStyleScope\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!isDef(key)) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function isUnknownElement$$1 (vnode, inVPre) {\n    return (\n      !inVPre &&\n      !vnode.ns &&\n      !(\n        config.ignoredElements.length &&\n        config.ignoredElements.some(function (ignore) {\n          return isRegExp(ignore)\n            ? ignore.test(vnode.tag)\n            : ignore === vnode.tag\n        })\n      ) &&\n      config.isUnknownElement(vnode.tag)\n    )\n  }\n\n  var creatingElmInVPre = 0;\n\n  function createElm (\n    vnode,\n    insertedVnodeQueue,\n    parentElm,\n    refElm,\n    nested,\n    ownerArray,\n    index\n  ) {\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // This vnode was used in a previous render!\n      // now it's used as a new node, overwriting its elm would cause\n      // potential patch errors down the road when it's used as an insertion\n      // reference node. Instead, we clone the node on-demand before creating\n      // associated DOM element for it.\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (true) {\n        if (data && data.pre) {\n          creatingElmInVPre++;\n        }\n        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if ( true && data && data.pre) {\n        creatingElmInVPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        insert(parentElm, vnode.elm, refElm);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (nodeOps.parentNode(ref$$1) === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      if (true) {\n        checkDuplicateKeys(children);\n      }\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.fnScopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    } else {\n      var ancestor = vnode;\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setStyleScope(vnode.elm, i);\n        }\n        ancestor = ancestor.parent;\n      }\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      i !== vnode.fnContext &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    if (true) {\n      checkDuplicateKeys(newCh);\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n        } else {\n          vnodeToMove = oldCh[idxInOld];\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          }\n        }\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function checkDuplicateKeys (children) {\n    var seenKeys = {};\n    for (var i = 0; i < children.length; i++) {\n      var vnode = children[i];\n      var key = vnode.key;\n      if (isDef(key)) {\n        if (seenKeys[key]) {\n          warn(\n            (\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\"),\n            vnode.context\n          );\n        } else {\n          seenKeys[key] = true;\n        }\n      }\n    }\n  }\n\n  function findIdxInOld (node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n      if (isDef(c) && sameVnode(node, c)) { return i }\n    }\n  }\n\n  function patchVnode (\n    oldVnode,\n    vnode,\n    insertedVnodeQueue,\n    ownerArray,\n    index,\n    removeOnly\n  ) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // clone reused vnode\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (true) {\n          checkDuplicateKeys(ch);\n        }\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var hydrationBailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  // Note: style is excluded because it relies on initial clone for future\n  // deep updates (#7063).\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\n    var i;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    inVPre = inVPre || (data && data.pre);\n    vnode.elm = elm;\n\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.isAsyncPlaceholder = true;\n      return true\n    }\n    // assert node match\n    if (true) {\n      if (!assertNodeMatch(elm, vnode, inVPre)) {\n        return false\n      }\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if ( true &&\n                typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('server innerHTML: ', i);\n                console.warn('client innerHTML: ', elm.innerHTML);\n              }\n              return false\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                childrenMatch = false;\n                break\n              }\n              childNode = childNode.nextSibling;\n            }\n            // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if ( true &&\n                typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n              }\n              return false\n            }\n          }\n        }\n      }\n      if (isDef(data)) {\n        var fullInvoke = false;\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            fullInvoke = true;\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n        if (!fullInvoke && data['class']) {\n          // ensure collecting deps for deep class bindings for future updates\n          traverse(data['class']);\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode, inVPre) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || (\n        !isUnknownElement$$1(vnode, inVPre) &&\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (true) {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm = nodeOps.parentNode(oldElm);\n\n        // create new node\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        // update parent placeholder node element, recursively\n        if (isDef(vnode.parent)) {\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n            ancestor.elm = vnode.elm;\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n              var insert = ancestor.data.hook.insert;\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            } else {\n              registerRef(ancestor);\n            }\n            ancestor = ancestor.parent;\n          }\n        }\n\n        // destroy old node\n        if (isDef(parentElm)) {\n          removeVnodes(parentElm, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      dir.oldArg = oldDir.arg;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    // $flow-disable-line\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      // $flow-disable-line\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  // $flow-disable-line\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\n  /* istanbul ignore if */\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (el.tagName.indexOf('-') > -1) {\n    baseSetAttr(el, key, value);\n  } else if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n        ? 'true'\n        : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, convertEnumeratedValue(key, value));\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    baseSetAttr(el, key, value);\n  }\n}\n\nfunction baseSetAttr (el, key, value) {\n  if (isFalsyAttrValue(value)) {\n    el.removeAttribute(key);\n  } else {\n    // #7138: IE10 & 11 fires input event when setting placeholder on\n    // <textarea>... block the first input event and remove the blocker\n    // immediately.\n    /* istanbul ignore if */\n    if (\n      isIE && !isIE9 &&\n      el.tagName === 'TEXTAREA' &&\n      key === 'placeholder' && value !== '' && !el.__ieph\n    ) {\n      var blocker = function (e) {\n        e.stopImmediatePropagation();\n        el.removeEventListener('input', blocker);\n      };\n      el.addEventListener('input', blocker);\n      // $flow-disable-line\n      el.__ieph = true; /* IE placeholder patched */\n    }\n    el.setAttribute(key, value);\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args))\n  }\n}\n\n/*  */\n\n\n\n/* eslint-disable no-unused-vars */\nfunction baseWarn (msg, range) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n/* eslint-enable no-unused-vars */\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value, range, dynamic) {\n  (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n  el.plain = false;\n}\n\nfunction addAttr (el, name, value, range, dynamic) {\n  var attrs = dynamic\n    ? (el.dynamicAttrs || (el.dynamicAttrs = []))\n    : (el.attrs || (el.attrs = []));\n  attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n  el.plain = false;\n}\n\n// add a raw attr (use this in preTransforms)\nfunction addRawAttr (el, name, value, range) {\n  el.attrsMap[name] = value;\n  el.attrsList.push(rangeSetItem({ name: name, value: value }, range));\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  isDynamicArg,\n  modifiers,\n  range\n) {\n  (el.directives || (el.directives = [])).push(rangeSetItem({\n    name: name,\n    rawName: rawName,\n    value: value,\n    arg: arg,\n    isDynamicArg: isDynamicArg,\n    modifiers: modifiers\n  }, range));\n  el.plain = false;\n}\n\nfunction prependModifierMarker (symbol, name, dynamic) {\n  return dynamic\n    ? (\"_p(\" + name + \",\\\"\" + symbol + \"\\\")\")\n    : symbol + name // mark the event as captured\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn,\n  range,\n  dynamic\n) {\n  modifiers = modifiers || emptyObject;\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n     true && warn &&\n    modifiers.prevent && modifiers.passive\n  ) {\n    warn(\n      'passive and prevent can\\'t be used together. ' +\n      'Passive handler can\\'t prevent default event.',\n      range\n    );\n  }\n\n  // normalize click.right and click.middle since they don't actually fire\n  // this is technically browser-specific, but at least for now browsers are\n  // the only target envs that have right/middle clicks.\n  if (modifiers.right) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'contextmenu';\n      delete modifiers.right;\n    }\n  } else if (modifiers.middle) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'mouseup';\n    }\n  }\n\n  // check capture modifier\n  if (modifiers.capture) {\n    delete modifiers.capture;\n    name = prependModifierMarker('!', name, dynamic);\n  }\n  if (modifiers.once) {\n    delete modifiers.once;\n    name = prependModifierMarker('~', name, dynamic);\n  }\n  /* istanbul ignore if */\n  if (modifiers.passive) {\n    delete modifiers.passive;\n    name = prependModifierMarker('&', name, dynamic);\n  }\n\n  var events;\n  if (modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n\n  var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);\n  if (modifiers !== emptyObject) {\n    newHandler.modifiers = modifiers;\n  }\n\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n\n  el.plain = false;\n}\n\nfunction getRawBindingAttr (\n  el,\n  name\n) {\n  return el.rawAttrsMap[':' + name] ||\n    el.rawAttrsMap['v-bind:' + name] ||\n    el.rawAttrsMap[name]\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\n// note: this only removes the attr from the Array (attrsList) so that it\n// doesn't get processed by processAttrs.\n// By default it does NOT remove it from the map (attrsMap) because the map is\n// needed during codegen.\nfunction getAndRemoveAttr (\n  el,\n  name,\n  removeFromMap\n) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  if (removeFromMap) {\n    delete el.attrsMap[name];\n  }\n  return val\n}\n\nfunction getAndRemoveAttrByRegex (\n  el,\n  name\n) {\n  var list = el.attrsList;\n  for (var i = 0, l = list.length; i < l; i++) {\n    var attr = list[i];\n    if (name.test(attr.name)) {\n      list.splice(i, 1);\n      return attr\n    }\n  }\n}\n\nfunction rangeSetItem (\n  item,\n  range\n) {\n  if (range) {\n    if (range.start != null) {\n      item.start = range.start;\n    }\n    if (range.end != null) {\n      item.end = range.end;\n    }\n  }\n  return item\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n      \"? \" + baseValueExpression + \".trim()\" +\n      \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: JSON.stringify(value),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var res = parseModel(value);\n  if (res.key === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return (\"$set(\" + (res.exp) + \", \" + (res.key) + \", \" + assignment + \")\")\n  }\n}\n\n/**\n * Parse a v-model expression into a base path and a final key segment.\n * Handles both dot-path and possible square brackets.\n *\n * Possible cases:\n *\n * - test\n * - test[key]\n * - test[test1[key]]\n * - test[\"a\"][key]\n * - xxx.test[a[a].test1[key]]\n * - test.xxx.a[\"asa\"][test1[key]]\n *\n */\n\nvar len, str, chr, index$1, expressionPos, expressionEndPos;\n\n\n\nfunction parseModel (val) {\n  // Fix https://github.com/vuejs/vue/pull/7730\n  // allow v-model=\"obj.val \" (trailing whitespace)\n  val = val.trim();\n  len = val.length;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    index$1 = val.lastIndexOf('.');\n    if (index$1 > -1) {\n      return {\n        exp: val.slice(0, index$1),\n        key: '\"' + val.slice(index$1 + 1) + '\"'\n      }\n    } else {\n      return {\n        exp: val,\n        key: null\n      }\n    }\n  }\n\n  str = val;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.slice(0, expressionPos),\n    key: val.slice(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (true) {\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\",\n        el.rawAttrsMap['v-model']\n      );\n    }\n  }\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (true) {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.',\n      el.rawAttrsMap['v-model']\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n    \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n      trueValueBinding === 'true'\n        ? (\":(\" + value + \")\")\n        : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n    )\n  );\n  addHandler(el, 'change',\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$el.checked){$$i<0&&(\" + (genAssignmentCode(value, '$$a.concat([$$v])')) + \")}\" +\n      \"else{$$i>-1&&(\" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + \")}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n\n  // warn if v-bind:value conflicts with v-model\n  // except for inputs with v-bind:type\n  if (true) {\n    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (value$1 && !typeBinding) {\n      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n      warn$1(\n        binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" +\n        'because the latter already expands to a value binding internally',\n        el.rawAttrsMap[binding]\n      );\n    }\n  }\n\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    var event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  // This was originally intended to fix #4521 but no longer necessary\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n  /* istanbul ignore if */\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction createOnceHandler$1 (event, handler, capture) {\n  var _target = target$1; // save current target element in closure\n  return function onceHandler () {\n    var res = handler.apply(null, arguments);\n    if (res !== null) {\n      remove$2(event, onceHandler, capture, _target);\n    }\n  }\n}\n\n// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n// implementation and does not fire microtasks in between event propagation, so\n// safe to exclude.\nvar useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\nfunction add$1 (\n  name,\n  handler,\n  capture,\n  passive\n) {\n  // async edge case #6566: inner click event triggers patch, event handler\n  // attached to outer element during patch, and triggered again. This\n  // happens because browsers fire microtask ticks between event propagation.\n  // the solution is simple: we save the timestamp when a handler is attached,\n  // and the handler would only fire if the event passed to it was fired\n  // AFTER it was attached.\n  if (useMicrotaskFix) {\n    var attachedTimestamp = currentFlushTimestamp;\n    var original = handler;\n    handler = original._wrapper = function (e) {\n      if (\n        // no bubbling, should always fire.\n        // this is just a safety net in case event.timeStamp is unreliable in\n        // certain weird environments...\n        e.target === e.currentTarget ||\n        // event is fired after handler attachment\n        e.timeStamp >= attachedTimestamp ||\n        // bail for environments that have buggy event.timeStamp implementations\n        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n        // #9681 QtWebEngine event.timeStamp is negative value\n        e.timeStamp <= 0 ||\n        // #9448 bail if event is fired in another document in a multi-page\n        // electron/nw.js app, since event.timeStamp will be using a different\n        // starting reference\n        e.target.ownerDocument !== document\n      ) {\n        return original.apply(this, arguments)\n      }\n    };\n  }\n  target$1.addEventListener(\n    name,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  name,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(\n    name,\n    handler._wrapper || handler,\n    capture\n  );\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n  target$1 = undefined;\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nvar svgContainer;\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (!(key in props)) {\n      elm[key] = '';\n    }\n  }\n\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n      // #6601 work around Chrome version <= 55 bug where single textNode\n      // replaced by innerHTML/textContent retains its parentNode property\n      if (elm.childNodes.length === 1) {\n        elm.removeChild(elm.childNodes[0]);\n      }\n    }\n\n    if (key === 'value' && elm.tagName !== 'PROGRESS') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, strCur)) {\n        elm.value = strCur;\n      }\n    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n      // IE doesn't support innerHTML for SVG elements\n      svgContainer = svgContainer || document.createElement('div');\n      svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n      var svg = svgContainer.firstChild;\n      while (elm.firstChild) {\n        elm.removeChild(elm.firstChild);\n      }\n      while (svg.firstChild) {\n        elm.appendChild(svg.firstChild);\n      }\n    } else if (\n      // skip the update if old and new VDOM state is the same.\n      // `value` is handled separately because the DOM value may be temporarily\n      // out of sync with VDOM state due to focus, composition and modifiers.\n      // This  #4521 by skipping the unnecesarry `checked` update.\n      cur !== oldProps[key]\n    ) {\n      // some property updates can throw\n      // e.g. `value` on <progress> w/ non-finite value\n      try {\n        elm[key] = cur;\n      } catch (e) {}\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (elm, checkVal) {\n  return (!elm.composing && (\n    elm.tagName === 'OPTION' ||\n    isNotInFocusAndDirty(elm, checkVal) ||\n    isDirtyWithModifiers(elm, checkVal)\n  ))\n}\n\nfunction isNotInFocusAndDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\n  return notInFocus && elm.value !== checkVal\n}\n\nfunction isDirtyWithModifiers (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers)) {\n    if (modifiers.number) {\n      return toNumber(value) !== toNumber(newVal)\n    }\n    if (modifiers.trim) {\n      return value.trim() !== newVal.trim()\n    }\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (\n        childNode && childNode.data &&\n        (styleData = normalizeStyleData(childNode.data))\n      ) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in emptyStyle)) {\n    return prop\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\nvar whitespaceRE = /\\s+/;\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser\n  ? window.requestAnimationFrame\n    ? window.requestAnimationFrame.bind(window)\n    : setTimeout\n  : /* istanbul ignore next */ function (fn) { return fn(); };\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  // JSDOM may return undefined for transition properties\n  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n// in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n// as a floor function) causing unexpected behaviors\nfunction toMs (s) {\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    context = transitionNode.context;\n    transitionNode = transitionNode.parent;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if ( true && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode, 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled) {\n        addTransitionClass(el, toClass);\n        if (!userWantsControl) {\n          if (isValidDuration(explicitEnterDuration)) {\n            setTimeout(cb, explicitEnterDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data) || el.nodeType !== 1) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb)) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if ( true && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show && el.parentNode) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled) {\n          addTransitionClass(el, leaveToClass);\n          if (!userWantsControl) {\n            if (isValidDuration(explicitLeaveDuration)) {\n              setTimeout(cb, explicitLeaveDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar directive = {\n  inserted: function inserted (el, binding, vnode, oldVnode) {\n    if (vnode.tag === 'select') {\n      // #6903\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n          directive.componentUpdated(el, binding, vnode);\n        });\n      } else {\n        setSelected(el, binding, vnode.context);\n      }\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        el.addEventListener('compositionstart', onCompositionStart);\n        el.addEventListener('compositionend', onCompositionEnd);\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple\n          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n     true && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  return options.every(function (o) { return !looseEqual(o, value); })\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (!value === !oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: directive,\n  show: show\n};\n\n/*  */\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\n\nvar isVShowDirective = function (d) { return d.name === 'show'; };\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(isNotTextNode);\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if ( true && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if ( true &&\n      mode && mode !== 'in-out' && mode !== 'out-in'\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? child.isComment\n        ? id + 'comment'\n        : id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n      child.data.show = true;\n    }\n\n    if (\n      oldChild &&\n      oldChild.data &&\n      !isSameChild(child, oldChild) &&\n      !isAsyncPlaceholder(oldChild) &&\n      // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\n    ) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data);\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild\n        }\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  beforeMount: function beforeMount () {\n    var this$1 = this;\n\n    var update = this._update;\n    this._update = function (vnode, hydrating) {\n      var restoreActiveInstance = setActiveInstance(this$1);\n      // force removing pass\n      this$1.__patch__(\n        this$1._vnode,\n        this$1.kept,\n        false, // hydrating\n        true // removeOnly (!important, avoids unnecessary moves)\n      );\n      this$1._vnode = this$1.kept;\n      restoreActiveInstance();\n      update.call(this$1, vnode, hydrating);\n    };\n  },\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (true) {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    // assign to this to avoid being removed in tree-shaking\n    // $flow-disable-line\n    this._reflow = document.body.offsetHeight;\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (e && e.target !== el) {\n            return\n          }\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue.config.mustUseProp = mustUseProp;\nVue.config.isReservedTag = isReservedTag;\nVue.config.isReservedAttr = isReservedAttr;\nVue.config.getTagNamespace = getTagNamespace;\nVue.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue.options.directives, platformDirectives);\nextend(Vue.options.components, platformComponents);\n\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nif (inBrowser) {\n  setTimeout(function () {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue);\n      } else if (\n        true\n      ) {\n        console[console.info ? 'info' : 'log'](\n          'Download the Vue Devtools extension for a better development experience:\\n' +\n          'https://github.com/vuejs/vue-devtools'\n        );\n      }\n    }\n    if ( true &&\n      config.productionTip !== false &&\n      typeof console !== 'undefined'\n    ) {\n      console[console.info ? 'info' : 'log'](\n        \"You are running Vue in development mode.\\n\" +\n        \"Make sure to turn on production mode when deploying for production.\\n\" +\n        \"See more tips at https://vuejs.org/guide/deployment.html\"\n      );\n    }\n  }, 0);\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\n\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var rawTokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, tokenValue;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      rawTokens.push(tokenValue = text.slice(lastIndex, index));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    rawTokens.push({ '@binding': exp });\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    rawTokens.push(tokenValue = text.slice(lastIndex));\n    tokens.push(JSON.stringify(tokenValue));\n  }\n  return {\n    expression: tokens.join('+'),\n    tokens: rawTokens\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if ( true && staticClass) {\n    var res = parseText(staticClass, options.delimiters);\n    if (res) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.',\n        el.rawAttrsMap['class']\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (true) {\n      var res = parseText(staticStyle, options.delimiters);\n      if (res) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.',\n          el.rawAttrsMap['style']\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n};\n\n/*  */\n\nvar decoder;\n\nvar he = {\n  decode: function decode (html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent\n  }\n};\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n// Regular Expressions for parsing tags and attributes\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + (unicodeRegExp.source) + \"]*\";\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\nvar startTagOpen = new RegExp((\"^<\" + qnameCapture));\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\"));\nvar doctype = /^<!DOCTYPE [^>]+>/i;\n// #7298: escape - to avoid being pased as HTML comment when inlined in page\nvar comment = /^<!\\--/;\nvar conditionalComment = /^<!\\[/;\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n',\n  '&#9;': '\\t',\n  '&#39;': \"'\"\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;\n\n// #5992\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\nvar shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n            }\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n            advance(1);\n          }\n          continue\n        }\n      }\n\n      var text = (void 0), rest = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (\n          !endTag.test(rest) &&\n          !startTagOpen.test(rest) &&\n          !comment.test(rest) &&\n          !conditionalComment.test(rest)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n      }\n\n      if (text) {\n        advance(text.length);\n      }\n\n      if (options.chars && text) {\n        options.chars(text, index - text.length, index);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if ( true && !stack.length && options.warn) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"), { start: index + html.length });\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n        attr.start = index;\n        advance(attr[0].length);\n        attr.end = index;\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      var value = args[3] || args[4] || args[5] || '';\n      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n        ? options.shouldDecodeNewlinesForHref\n        : options.shouldDecodeNewlines;\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      };\n      if ( true && options.outputSourceRange) {\n        attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n        attrs[i].end = args.end;\n      }\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if ( true &&\n          (i > pos || !tagName) &&\n          options.warn\n        ) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\"),\n            { start: stack[i].start, end: stack[i].end }\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\nvar forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nvar stripParensRE = /^\\(|\\)$/g;\nvar dynamicArgRE = /^\\[.*\\]$/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^\\.|^v-bind:/;\nvar modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\n\nvar slotRE = /^v-slot(:|$)|^#/;\n\nvar lineBreakRE = /[\\r\\n]/;\nvar whitespaceRE$1 = /\\s+/g;\n\nvar invalidAttributeRE = /[\\s\"'<>\\/=]/;\n\nvar decodeHTMLCached = cached(he.decode);\n\nvar emptySlotScopeToken = \"_empty_\";\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\nvar maybeComponent;\n\nfunction createASTElement (\n  tag,\n  attrs,\n  parent\n) {\n  return {\n    type: 1,\n    tag: tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    rawAttrsMap: {},\n    parent: parent,\n    children: []\n  }\n}\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  var isReservedTag = options.isReservedTag || no;\n  maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var whitespaceOption = options.whitespace;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg, range) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg, range);\n    }\n  }\n\n  function closeElement (element) {\n    trimEndingWhitespace(element);\n    if (!inVPre && !element.processed) {\n      element = processElement(element, options);\n    }\n    // tree management\n    if (!stack.length && element !== root) {\n      // allow root elements with v-if, v-else-if and v-else\n      if (root.if && (element.elseif || element.else)) {\n        if (true) {\n          checkRootConstraints(element);\n        }\n        addIfCondition(root, {\n          exp: element.elseif,\n          block: element\n        });\n      } else if (true) {\n        warnOnce(\n          \"Component template should contain exactly one root element. \" +\n          \"If you are using v-if on multiple elements, \" +\n          \"use v-else-if to chain them instead.\",\n          { start: element.start }\n        );\n      }\n    }\n    if (currentParent && !element.forbidden) {\n      if (element.elseif || element.else) {\n        processIfConditions(element, currentParent);\n      } else {\n        if (element.slotScope) {\n          // scoped slot\n          // keep it in the children list so that v-else(-if) conditions can\n          // find it as the prev node.\n          var name = element.slotTarget || '\"default\"'\n          ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        }\n        currentParent.children.push(element);\n        element.parent = currentParent;\n      }\n    }\n\n    // final children cleanup\n    // filter out scoped slots\n    element.children = element.children.filter(function (c) { return !(c).slotScope; });\n    // remove trailing whitespace node again\n    trimEndingWhitespace(element);\n\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n    // apply post-transforms\n    for (var i = 0; i < postTransforms.length; i++) {\n      postTransforms[i](element, options);\n    }\n  }\n\n  function trimEndingWhitespace (el) {\n    // remove trailing whitespace node\n    if (!inPre) {\n      var lastNode;\n      while (\n        (lastNode = el.children[el.children.length - 1]) &&\n        lastNode.type === 3 &&\n        lastNode.text === ' '\n      ) {\n        el.children.pop();\n      }\n    }\n  }\n\n  function checkRootConstraints (el) {\n    if (el.tag === 'slot' || el.tag === 'template') {\n      warnOnce(\n        \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n        'contain multiple nodes.',\n        { start: el.start }\n      );\n    }\n    if (el.attrsMap.hasOwnProperty('v-for')) {\n      warnOnce(\n        'Cannot use v-for on stateful component root element because ' +\n        'it renders multiple elements.',\n        el.rawAttrsMap['v-for']\n      );\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n    shouldKeepComment: options.comments,\n    outputSourceRange: options.outputSourceRange,\n    start: function start (tag, attrs, unary, start$1, end) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = createASTElement(tag, attrs, currentParent);\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (true) {\n        if (options.outputSourceRange) {\n          element.start = start$1;\n          element.end = end;\n          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n            cumulated[attr.name] = attr;\n            return cumulated\n          }, {});\n        }\n        attrs.forEach(function (attr) {\n          if (invalidAttributeRE.test(attr.name)) {\n            warn$2(\n              \"Invalid dynamic argument expression: attribute names cannot contain \" +\n              \"spaces, quotes, <, >, / or =.\",\n              {\n                start: attr.start + attr.name.indexOf(\"[\"),\n                end: attr.start + attr.name.length\n              }\n            );\n          }\n        });\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n         true && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.',\n          { start: element.start }\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        element = preTransforms[i](element, options) || element;\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else if (!element.processed) {\n        // structural directives\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n      }\n\n      if (!root) {\n        root = element;\n        if (true) {\n          checkRootConstraints(root);\n        }\n      }\n\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        closeElement(element);\n      }\n    },\n\n    end: function end (tag, start, end$1) {\n      var element = stack[stack.length - 1];\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      if ( true && options.outputSourceRange) {\n        element.end = end$1;\n      }\n      closeElement(element);\n    },\n\n    chars: function chars (text, start, end) {\n      if (!currentParent) {\n        if (true) {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.',\n              { start: start }\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\"),\n              { start: start }\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      if (inPre || text.trim()) {\n        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n      } else if (!children.length) {\n        // remove the whitespace-only node right after an opening tag\n        text = '';\n      } else if (whitespaceOption) {\n        if (whitespaceOption === 'condense') {\n          // in condense mode, remove the whitespace node if it contains\n          // line break, otherwise condense to a single space\n          text = lineBreakRE.test(text) ? '' : ' ';\n        } else {\n          text = ' ';\n        }\n      } else {\n        text = preserveWhitespace ? ' ' : '';\n      }\n      if (text) {\n        if (!inPre && whitespaceOption === 'condense') {\n          // condense consecutive whitespaces into single space\n          text = text.replace(whitespaceRE$1, ' ');\n        }\n        var res;\n        var child;\n        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n          child = {\n            type: 2,\n            expression: res.expression,\n            tokens: res.tokens,\n            text: text\n          };\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          child = {\n            type: 3,\n            text: text\n          };\n        }\n        if (child) {\n          if ( true && options.outputSourceRange) {\n            child.start = start;\n            child.end = end;\n          }\n          children.push(child);\n        }\n      }\n    },\n    comment: function comment (text, start, end) {\n      // adding anyting as a sibling to the root node is forbidden\n      // comments should still be allowed, but ignored\n      if (currentParent) {\n        var child = {\n          type: 3,\n          text: text,\n          isComment: true\n        };\n        if ( true && options.outputSourceRange) {\n          child.start = start;\n          child.end = end;\n        }\n        currentParent.children.push(child);\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var list = el.attrsList;\n  var len = list.length;\n  if (len) {\n    var attrs = el.attrs = new Array(len);\n    for (var i = 0; i < len; i++) {\n      attrs[i] = {\n        name: list[i].name,\n        value: JSON.stringify(list[i].value)\n      };\n      if (list[i].start != null) {\n        attrs[i].start = list[i].start;\n        attrs[i].end = list[i].end;\n      }\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processElement (\n  element,\n  options\n) {\n  processKey(element);\n\n  // determine whether this is a plain element after\n  // removing structural attributes\n  element.plain = (\n    !element.key &&\n    !element.scopedSlots &&\n    !element.attrsList.length\n  );\n\n  processRef(element);\n  processSlotContent(element);\n  processSlotOutlet(element);\n  processComponent(element);\n  for (var i = 0; i < transforms.length; i++) {\n    element = transforms[i](element, options) || element;\n  }\n  processAttrs(element);\n  return element\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (true) {\n      if (el.tag === 'template') {\n        warn$2(\n          \"<template> cannot be keyed. Place the key on real elements instead.\",\n          getRawBindingAttr(el, 'key')\n        );\n      }\n      if (el.for) {\n        var iterator = el.iterator2 || el.iterator1;\n        var parent = el.parent;\n        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n          warn$2(\n            \"Do not use v-for index as key on <transition-group> children, \" +\n            \"this is the same as not using keys.\",\n            getRawBindingAttr(el, 'key'),\n            true /* tip */\n          );\n        }\n      }\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var res = parseFor(exp);\n    if (res) {\n      extend(el, res);\n    } else if (true) {\n      warn$2(\n        (\"Invalid v-for expression: \" + exp),\n        el.rawAttrsMap['v-for']\n      );\n    }\n  }\n}\n\n\n\nfunction parseFor (exp) {\n  var inMatch = exp.match(forAliasRE);\n  if (!inMatch) { return }\n  var res = {};\n  res.for = inMatch[2].trim();\n  var alias = inMatch[1].trim().replace(stripParensRE, '');\n  var iteratorMatch = alias.match(forIteratorRE);\n  if (iteratorMatch) {\n    res.alias = alias.replace(forIteratorRE, '').trim();\n    res.iterator1 = iteratorMatch[1].trim();\n    if (iteratorMatch[2]) {\n      res.iterator2 = iteratorMatch[2].trim();\n    }\n  } else {\n    res.alias = alias;\n  }\n  return res\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (true) {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\",\n      el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if ( true && children[i].text !== ' ') {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\",\n          children[i]\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\n// handle content being passed to a component as slot,\n// e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\nfunction processSlotContent (el) {\n  var slotScope;\n  if (el.tag === 'template') {\n    slotScope = getAndRemoveAttr(el, 'scope');\n    /* istanbul ignore if */\n    if ( true && slotScope) {\n      warn$2(\n        \"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" +\n        \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" +\n        \"can also be used on plain elements in addition to <template> to \" +\n        \"denote scoped slots.\",\n        el.rawAttrsMap['scope'],\n        true\n      );\n    }\n    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n  } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\n    /* istanbul ignore if */\n    if ( true && el.attrsMap['v-for']) {\n      warn$2(\n        \"Ambiguous combined usage of slot-scope and v-for on <\" + (el.tag) + \"> \" +\n        \"(v-for takes higher priority). Use a wrapper <template> for the \" +\n        \"scoped slot to make it clearer.\",\n        el.rawAttrsMap['slot-scope'],\n        true\n      );\n    }\n    el.slotScope = slotScope;\n  }\n\n  // slot=\"xxx\"\n  var slotTarget = getBindingAttr(el, 'slot');\n  if (slotTarget) {\n    el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);\n    // preserve slot as an attribute for native shadow DOM compat\n    // only for non-scoped slots.\n    if (el.tag !== 'template' && !el.slotScope) {\n      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n    }\n  }\n\n  // 2.6 v-slot syntax\n  {\n    if (el.tag === 'template') {\n      // v-slot on <template>\n      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n      if (slotBinding) {\n        if (true) {\n          if (el.slotTarget || el.slotScope) {\n            warn$2(\n              \"Unexpected mixed usage of different slot syntaxes.\",\n              el\n            );\n          }\n          if (el.parent && !maybeComponent(el.parent)) {\n            warn$2(\n              \"<template v-slot> can only appear at the root level inside \" +\n              \"the receiving the component\",\n              el\n            );\n          }\n        }\n        var ref = getSlotName(slotBinding);\n        var name = ref.name;\n        var dynamic = ref.dynamic;\n        el.slotTarget = name;\n        el.slotTargetDynamic = dynamic;\n        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n      }\n    } else {\n      // v-slot on component, denotes default slot\n      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n      if (slotBinding$1) {\n        if (true) {\n          if (!maybeComponent(el)) {\n            warn$2(\n              \"v-slot can only be used on components or <template>.\",\n              slotBinding$1\n            );\n          }\n          if (el.slotScope || el.slotTarget) {\n            warn$2(\n              \"Unexpected mixed usage of different slot syntaxes.\",\n              el\n            );\n          }\n          if (el.scopedSlots) {\n            warn$2(\n              \"To avoid scope ambiguity, the default slot should also use \" +\n              \"<template> syntax when there are other named slots.\",\n              slotBinding$1\n            );\n          }\n        }\n        // add the component's children to its default slot\n        var slots = el.scopedSlots || (el.scopedSlots = {});\n        var ref$1 = getSlotName(slotBinding$1);\n        var name$1 = ref$1.name;\n        var dynamic$1 = ref$1.dynamic;\n        var slotContainer = slots[name$1] = createASTElement('template', [], el);\n        slotContainer.slotTarget = name$1;\n        slotContainer.slotTargetDynamic = dynamic$1;\n        slotContainer.children = el.children.filter(function (c) {\n          if (!c.slotScope) {\n            c.parent = slotContainer;\n            return true\n          }\n        });\n        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;\n        // remove children as they are returned from scopedSlots now\n        el.children = [];\n        // mark el non-plain so data gets generated\n        el.plain = false;\n      }\n    }\n  }\n}\n\nfunction getSlotName (binding) {\n  var name = binding.name.replace(slotRE, '');\n  if (!name) {\n    if (binding.name[0] !== '#') {\n      name = 'default';\n    } else if (true) {\n      warn$2(\n        \"v-slot shorthand syntax requires a slot name.\",\n        binding\n      );\n    }\n  }\n  return dynamicArgRE.test(name)\n    // dynamic [name]\n    ? { name: name.slice(1, -1), dynamic: true }\n    // static name\n    : { name: (\"\\\"\" + name + \"\\\"\"), dynamic: false }\n}\n\n// handle <slot/> outlets\nfunction processSlotOutlet (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if ( true && el.key) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\",\n        getRawBindingAttr(el, 'key')\n      );\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name.replace(dirRE, ''));\n      // support .foo shorthand syntax for the .prop modifier\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isDynamic = dynamicArgRE.test(name);\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n        if (\n           true &&\n          value.trim().length === 0\n        ) {\n          warn$2(\n            (\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\")\n          );\n        }\n        if (modifiers) {\n          if (modifiers.prop && !isDynamic) {\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel && !isDynamic) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            syncGen = genAssignmentCode(value, \"$event\");\n            if (!isDynamic) {\n              addHandler(\n                el,\n                (\"update:\" + (camelize(name))),\n                syncGen,\n                null,\n                false,\n                warn$2,\n                list[i]\n              );\n              if (hyphenate(name) !== camelize(name)) {\n                addHandler(\n                  el,\n                  (\"update:\" + (hyphenate(name))),\n                  syncGen,\n                  null,\n                  false,\n                  warn$2,\n                  list[i]\n                );\n              }\n            } else {\n              // handler w/ dynamic event name\n              addHandler(\n                el,\n                (\"\\\"update:\\\"+(\" + name + \")\"),\n                syncGen,\n                null,\n                false,\n                warn$2,\n                list[i],\n                true // dynamic\n              );\n            }\n          }\n        }\n        if ((modifiers && modifiers.prop) || (\n          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n        )) {\n          addProp(el, name, value, list[i], isDynamic);\n        } else {\n          addAttr(el, name, value, list[i], isDynamic);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        isDynamic = dynamicArgRE.test(name);\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        isDynamic = false;\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n          if (dynamicArgRE.test(arg)) {\n            arg = arg.slice(1, -1);\n            isDynamic = true;\n          }\n        }\n        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n        if ( true && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (true) {\n        var res = parseText(value, delimiters);\n        if (res) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.',\n            list[i]\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value), list[i]);\n      // #6887 firefox doesn't update muted state if set via attribute\n      // even immediately after element creation\n      if (!el.component &&\n          name === 'muted' &&\n          platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n        addProp(el, name, 'true', list[i]);\n      }\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n       true &&\n      map[attrs[i].name] && !isIE && !isEdge\n    ) {\n      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\",\n        el.rawAttrsMap['v-model']\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nfunction preTransformNode (el, options) {\n  if (el.tag === 'input') {\n    var map = el.attrsMap;\n    if (!map['v-model']) {\n      return\n    }\n\n    var typeBinding;\n    if (map[':type'] || map['v-bind:type']) {\n      typeBinding = getBindingAttr(el, 'type');\n    }\n    if (!map.type && !typeBinding && map['v-bind']) {\n      typeBinding = \"(\" + (map['v-bind']) + \").type\";\n    }\n\n    if (typeBinding) {\n      var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n      var ifConditionExtra = ifCondition ? (\"&&(\" + ifCondition + \")\") : \"\";\n      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n      // 1. checkbox\n      var branch0 = cloneASTElement(el);\n      // process for on the main node\n      processFor(branch0);\n      addRawAttr(branch0, 'type', 'checkbox');\n      processElement(branch0, options);\n      branch0.processed = true; // prevent it from double-processed\n      branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n      addIfCondition(branch0, {\n        exp: branch0.if,\n        block: branch0\n      });\n      // 2. add radio else-if condition\n      var branch1 = cloneASTElement(el);\n      getAndRemoveAttr(branch1, 'v-for', true);\n      addRawAttr(branch1, 'type', 'radio');\n      processElement(branch1, options);\n      addIfCondition(branch0, {\n        exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n        block: branch1\n      });\n      // 3. other\n      var branch2 = cloneASTElement(el);\n      getAndRemoveAttr(branch2, 'v-for', true);\n      addRawAttr(branch2, ':type', typeBinding);\n      processElement(branch2, options);\n      addIfCondition(branch0, {\n        exp: ifCondition,\n        block: branch2\n      });\n\n      if (hasElse) {\n        branch0.else = true;\n      } else if (elseIfCondition) {\n        branch0.elseif = elseIfCondition;\n      }\n\n      return branch0\n    }\n  }\n}\n\nfunction cloneASTElement (el) {\n  return createASTElement(el.tag, el.attrsList.slice(), el.parent)\n}\n\nvar model$1 = {\n  preTransformNode: preTransformNode\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1,\n  model$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"), dir);\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"), dir);\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*(?:[\\w$]+)?\\s*\\(/;\nvar fnInvokeRE = /\\([^)]*?\\);*$/;\nvar simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\n\n// KeyboardEvent.keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// KeyboardEvent.key aliases\nvar keyNames = {\n  // #7880: IE11 and Edge use `Esc` for Escape key name.\n  esc: ['Esc', 'Escape'],\n  tab: 'Tab',\n  enter: 'Enter',\n  // #9112: IE11 uses `Spacebar` for Space key name.\n  space: [' ', 'Spacebar'],\n  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n  up: ['Up', 'ArrowUp'],\n  left: ['Left', 'ArrowLeft'],\n  right: ['Right', 'ArrowRight'],\n  down: ['Down', 'ArrowDown'],\n  // #9112: IE11 uses `Del` for Delete key name.\n  'delete': ['Backspace', 'Delete', 'Del']\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative\n) {\n  var prefix = isNative ? 'nativeOn:' : 'on:';\n  var staticHandlers = \"\";\n  var dynamicHandlers = \"\";\n  for (var name in events) {\n    var handlerCode = genHandler(events[name]);\n    if (events[name] && events[name].dynamic) {\n      dynamicHandlers += name + \",\" + handlerCode + \",\";\n    } else {\n      staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n    }\n  }\n  staticHandlers = \"{\" + (staticHandlers.slice(0, -1)) + \"}\";\n  if (dynamicHandlers) {\n    return prefix + \"_d(\" + staticHandlers + \",[\" + (dynamicHandlers.slice(0, -1)) + \"])\"\n  } else {\n    return prefix + staticHandlers\n  }\n}\n\nfunction genHandler (handler) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n  if (!handler.modifiers) {\n    if (isMethodPath || isFunctionExpression) {\n      return handler.value\n    }\n    return (\"function($event){\" + (isFunctionInvocation ? (\"return \" + (handler.value)) : handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else if (key === 'exact') {\n        var modifiers = (handler.modifiers);\n        genModifierCode += genGuard(\n          ['ctrl', 'shift', 'alt', 'meta']\n            .filter(function (keyModifier) { return !modifiers[keyModifier]; })\n            .map(function (keyModifier) { return (\"$event.\" + keyModifier + \"Key\"); })\n            .join('||')\n        );\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? (\"return \" + (handler.value) + \"($event)\")\n      : isFunctionExpression\n        ? (\"return (\" + (handler.value) + \")($event)\")\n        : isFunctionInvocation\n          ? (\"return \" + (handler.value))\n          : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\n    // make sure the key filters only apply to KeyboardEvents\n    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n    // key events that do not have keyCode property...\n    \"if(!$event.type.indexOf('key')&&\" +\n    (keys.map(genFilterCode).join('&&')) + \")return null;\"\n  )\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var keyCode = keyCodes[key];\n  var keyName = keyNames[key];\n  return (\n    \"_k($event.keyCode,\" +\n    (JSON.stringify(key)) + \",\" +\n    (JSON.stringify(keyCode)) + \",\" +\n    \"$event.key,\" +\n    \"\" + (JSON.stringify(keyName)) +\n    \")\"\n  )\n}\n\n/*  */\n\nfunction on (el, dir) {\n  if ( true && dir.modifiers) {\n    warn(\"v-on without argument does not support modifiers.\");\n  }\n  el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n\n\n\n\nvar CodegenState = function CodegenState (options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n  this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n  this.onceId = 0;\n  this.staticRenderFns = [];\n  this.pre = false;\n};\n\n\n\nfunction generate (\n  ast,\n  options\n) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: state.staticRenderFns\n  }\n}\n\nfunction genElement (el, state) {\n  if (el.parent) {\n    el.pre = el.pre || el.parent.pre;\n  }\n\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data;\n      if (!el.plain || (el.pre && state.maybeComponent(el))) {\n        data = genData$2(el, state);\n      }\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el, state) {\n  el.staticProcessed = true;\n  // Some elements (templates) need to behave differently inside of a v-pre\n  // node.  All pre nodes are static roots, so we can use this as a location to\n  // wrap a state change and reset it upon exiting the pre node.\n  var originalPreState = state.pre;\n  if (el.pre) {\n    state.pre = el.pre;\n  }\n  state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n  state.pre = originalPreState;\n  return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el, state) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n       true && state.warn(\n        \"v-once can only be used inside v-for that is keyed. \",\n        el.rawAttrsMap['v-once']\n      );\n      return genElement(el, state)\n    }\n    return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + \",\" + key + \")\")\n  } else {\n    return genStatic(el, state)\n  }\n}\n\nfunction genIf (\n  el,\n  state,\n  altGen,\n  altEmpty\n) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n}\n\nfunction genIfConditions (\n  conditions,\n  state,\n  altGen,\n  altEmpty\n) {\n  if (!conditions.length) {\n    return altEmpty || '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return altGen\n      ? altGen(el, state)\n      : el.once\n        ? genOnce(el, state)\n        : genElement(el, state)\n  }\n}\n\nfunction genFor (\n  el,\n  state,\n  altGen,\n  altHelper\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if ( true &&\n    state.maybeComponent(el) &&\n    el.tag !== 'slot' &&\n    el.tag !== 'template' &&\n    !el.key\n  ) {\n    state.warn(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      el.rawAttrsMap['v-for'],\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return (altHelper || '_l') + \"((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + ((altGen || genElement)(el, state)) +\n    '})'\n}\n\nfunction genData$2 (el, state) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el, state);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:\" + (genProps(el.attrs)) + \",\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:\" + (genProps(el.props)) + \",\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true)) + \",\";\n  }\n  // slot target\n  // only for non-scoped slots\n  if (el.slotTarget && !el.slotScope) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el, el.scopedSlots, state)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind dynamic argument wrap\n  // v-bind with dynamic arguments must be applied using the same v-bind object\n  // merge helper so that class/style/mustUseProp attrs are handled correctly.\n  if (el.dynamicAttrs) {\n    data = \"_b(\" + data + \",\\\"\" + (el.tag) + \"\\\",\" + (genProps(el.dynamicAttrs)) + \")\";\n  }\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  // v-on data wrap\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n  return data\n}\n\nfunction genDirectives (el, state) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\" + (dir.isDynamicArg ? dir.arg : (\"\\\"\" + (dir.arg) + \"\\\"\"))) : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el, state) {\n  var ast = el.children[0];\n  if ( true && (\n    el.children.length !== 1 || ast.type !== 1\n  )) {\n    state.warn(\n      'Inline-template components must have exactly one child element.',\n      { start: el.start }\n    );\n  }\n  if (ast && ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (\n  el,\n  slots,\n  state\n) {\n  // by default scoped slots are considered \"stable\", this allows child\n  // components with only scoped slots to skip forced updates from parent.\n  // but in some cases we have to bail-out of this optimization\n  // for example if the slot contains dynamic names, has v-if or v-for on them...\n  var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {\n    var slot = slots[key];\n    return (\n      slot.slotTargetDynamic ||\n      slot.if ||\n      slot.for ||\n      containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n    )\n  });\n\n  // #9534: if a component with scoped slots is inside a conditional branch,\n  // it's possible for the same component to be reused but with different\n  // compiled slot content. To avoid that, we generate a unique key based on\n  // the generated code of all the slot contents.\n  var needsKey = !!el.if;\n\n  // OR when it is inside another scoped slot or v-for (the reactivity may be\n  // disconnected due to the intermediate scope variable)\n  // #9438, #9506\n  // TODO: this can be further optimized by properly analyzing in-scope bindings\n  // and skip force updating ones that do not actually use scope variables.\n  if (!needsForceUpdate) {\n    var parent = el.parent;\n    while (parent) {\n      if (\n        (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||\n        parent.for\n      ) {\n        needsForceUpdate = true;\n        break\n      }\n      if (parent.if) {\n        needsKey = true;\n      }\n      parent = parent.parent;\n    }\n  }\n\n  var generatedSlots = Object.keys(slots)\n    .map(function (key) { return genScopedSlot(slots[key], state); })\n    .join(',');\n\n  return (\"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? (\",null,false,\" + (hash(generatedSlots))) : \"\") + \")\")\n}\n\nfunction hash(str) {\n  var hash = 5381;\n  var i = str.length;\n  while(i) {\n    hash = (hash * 33) ^ str.charCodeAt(--i);\n  }\n  return hash >>> 0\n}\n\nfunction containsSlotChild (el) {\n  if (el.type === 1) {\n    if (el.tag === 'slot') {\n      return true\n    }\n    return el.children.some(containsSlotChild)\n  }\n  return false\n}\n\nfunction genScopedSlot (\n  el,\n  state\n) {\n  var isLegacySyntax = el.attrsMap['slot-scope'];\n  if (el.if && !el.ifProcessed && !isLegacySyntax) {\n    return genIf(el, state, genScopedSlot, \"null\")\n  }\n  if (el.for && !el.forProcessed) {\n    return genFor(el, state, genScopedSlot)\n  }\n  var slotScope = el.slotScope === emptySlotScopeToken\n    ? \"\"\n    : String(el.slotScope);\n  var fn = \"function(\" + slotScope + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? el.if && isLegacySyntax\n        ? (\"(\" + (el.if) + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\")\n        : genChildren(el, state) || 'undefined'\n      : genElement(el, state)) + \"}\";\n  // reverse proxy v-slot without scope on this.$slots\n  var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n  return (\"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\")\n}\n\nfunction genChildren (\n  el,\n  state,\n  checkSkip,\n  altGenElement,\n  altGenNode\n) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      var normalizationType = checkSkip\n        ? state.maybeComponent(el$1) ? \",1\" : \",0\"\n        : \"\";\n      return (\"\" + ((altGenElement || genElement)(el$1, state)) + normalizationType)\n    }\n    var normalizationType$1 = checkSkip\n      ? getNormalizationType(children, state.maybeComponent)\n      : 0;\n    var gen = altGenNode || genNode;\n    return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType$1 ? (\",\" + normalizationType$1) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (\n  children,\n  maybeComponent\n) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction genNode (node, state) {\n  if (node.type === 1) {\n    return genElement(node, state)\n  } else if (node.type === 3 && node.isComment) {\n    return genComment(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genComment (comment) {\n  return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n}\n\nfunction genSlot (el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs || el.dynamicAttrs\n    ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({\n        // slot props are camelized\n        name: camelize(attr.name),\n        value: attr.value,\n        dynamic: attr.dynamic\n      }); }))\n    : null;\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (\n  componentName,\n  el,\n  state\n) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var staticProps = \"\";\n  var dynamicProps = \"\";\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    var value = transformSpecialNewlines(prop.value);\n    if (prop.dynamic) {\n      dynamicProps += (prop.name) + \",\" + value + \",\";\n    } else {\n      staticProps += \"\\\"\" + (prop.name) + \"\\\":\" + value + \",\";\n    }\n  }\n  staticProps = \"{\" + (staticProps.slice(0, -1)) + \"}\";\n  if (dynamicProps) {\n    return (\"_d(\" + staticProps + \",[\" + (dynamicProps.slice(0, -1)) + \"])\")\n  } else {\n    return staticProps\n  }\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast, warn) {\n  if (ast) {\n    checkNode(ast, warn);\n  }\n}\n\nfunction checkNode (node, warn) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          var range = node.rawAttrsMap[name];\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), warn, range);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], warn);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, warn, node);\n  }\n}\n\nfunction checkEvent (exp, text, warn, range) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    warn(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim()),\n      range\n    );\n  }\n  checkExpression(exp, text, warn, range);\n}\n\nfunction checkFor (node, text, warn, range) {\n  checkExpression(node.for || '', text, warn, range);\n  checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n}\n\nfunction checkIdentifier (\n  ident,\n  type,\n  text,\n  warn,\n  range\n) {\n  if (typeof ident === 'string') {\n    try {\n      new Function((\"var \" + ident + \"=_\"));\n    } catch (e) {\n      warn((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())), range);\n    }\n  }\n}\n\nfunction checkExpression (exp, text, warn, range) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      warn(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\"\\n  Raw expression: \" + (text.trim()),\n        range\n      );\n    } else {\n      warn(\n        \"invalid expression: \" + (e.message) + \" in\\n\\n\" +\n        \"    \" + exp + \"\\n\\n\" +\n        \"  Raw expression: \" + (text.trim()) + \"\\n\",\n        range\n      );\n    }\n  }\n}\n\n/*  */\n\nvar range = 2;\n\nfunction generateCodeFrame (\n  source,\n  start,\n  end\n) {\n  if ( start === void 0 ) start = 0;\n  if ( end === void 0 ) end = source.length;\n\n  var lines = source.split(/\\r?\\n/);\n  var count = 0;\n  var res = [];\n  for (var i = 0; i < lines.length; i++) {\n    count += lines[i].length + 1;\n    if (count >= start) {\n      for (var j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) { continue }\n        res.push((\"\" + (j + 1) + (repeat$1(\" \", 3 - String(j + 1).length)) + \"|  \" + (lines[j])));\n        var lineLength = lines[j].length;\n        if (j === i) {\n          // push underline\n          var pad = start - (count - lineLength) + 1;\n          var length = end > count ? lineLength - pad : end - start;\n          res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n        } else if (j > i) {\n          if (end > count) {\n            var length$1 = Math.min(end - count, lineLength);\n            res.push(\"   |  \" + repeat$1(\"^\", length$1));\n          }\n          count += lineLength + 1;\n        }\n      }\n      break\n    }\n  }\n  return res.join('\\n')\n}\n\nfunction repeat$1 (str, n) {\n  var result = '';\n  if (n > 0) {\n    while (true) { // eslint-disable-line\n      if (n & 1) { result += str; }\n      n >>>= 1;\n      if (n <= 0) { break }\n      str += str;\n    }\n  }\n  return result\n}\n\n/*  */\n\n\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompileToFunctionFn (compile) {\n  var cache = Object.create(null);\n\n  return function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = extend({}, options);\n    var warn$$1 = options.warn || warn;\n    delete options.warn;\n\n    /* istanbul ignore if */\n    if (true) {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn$$1(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (cache[key]) {\n      return cache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (true) {\n      if (compiled.errors && compiled.errors.length) {\n        if (options.outputSourceRange) {\n          compiled.errors.forEach(function (e) {\n            warn$$1(\n              \"Error compiling template:\\n\\n\" + (e.msg) + \"\\n\\n\" +\n              generateCodeFrame(template, e.start, e.end),\n              vm\n            );\n          });\n        } else {\n          warn$$1(\n            \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n            compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n            vm\n          );\n        }\n      }\n      if (compiled.tips && compiled.tips.length) {\n        if (options.outputSourceRange) {\n          compiled.tips.forEach(function (e) { return tip(e.msg, vm); });\n        } else {\n          compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n        }\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors)\n    });\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (true) {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn$$1(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (cache[key] = res)\n  }\n}\n\n/*  */\n\nfunction createCompilerCreator (baseCompile) {\n  return function createCompiler (baseOptions) {\n    function compile (\n      template,\n      options\n    ) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n\n      var warn = function (msg, range, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        if ( true && options.outputSourceRange) {\n          // $flow-disable-line\n          var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n\n          warn = function (msg, range, tip) {\n            var data = { msg: msg };\n            if (range) {\n              if (range.start != null) {\n                data.start = range.start + leadingSpaceLength;\n              }\n              if (range.end != null) {\n                data.end = range.end + leadingSpaceLength;\n              }\n            }\n            (tip ? tips : errors).push(data);\n          };\n        }\n        // merge custom modules\n        if (options.modules) {\n          finalOptions.modules =\n            (baseOptions.modules || []).concat(options.modules);\n        }\n        // merge custom directives\n        if (options.directives) {\n          finalOptions.directives = extend(\n            Object.create(baseOptions.directives || null),\n            options.directives\n          );\n        }\n        // copy other options\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      finalOptions.warn = warn;\n\n      var compiled = baseCompile(template.trim(), finalOptions);\n      if (true) {\n        detectErrors(compiled.ast, warn);\n      }\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n  }\n}\n\n/*  */\n\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\nvar createCompiler = createCompilerCreator(function baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  if (options.optimize !== false) {\n    optimize(ast, options);\n  }\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n});\n\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compile = ref$1.compile;\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nvar div;\nfunction getShouldDecode (href) {\n  div = div || document.createElement('div');\n  div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n  return div.innerHTML.indexOf('&#10;') > 0\n}\n\n// #3663: IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n// #6828: chrome encodes content in a[href]\nvar shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue.prototype.$mount;\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n     true && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if ( true && !template) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (true) {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if ( true && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        outputSourceRange: \"development\" !== 'production',\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if ( true && config.performance && mark) {\n        mark('compile end');\n        measure((\"vue \" + (this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue.compile = compileToFunctions;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Vue);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:///./node_modules/vue/dist/vue.esm.js?");

/***/ }),

/***/ "./node_modules/vuedraggable/dist/vuedraggable.common.js":
/*!***************************************************************!*\
  !*** ./node_modules/vuedraggable/dist/vuedraggable.common.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"fb15\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"02f4\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(\"4588\");\nvar defined = __webpack_require__(\"be13\");\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n\n/***/ }),\n\n/***/ \"0390\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar at = __webpack_require__(\"02f4\")(true);\n\n // `AdvanceStringIndex` abstract operation\n// https://tc39.github.io/ecma262/#sec-advancestringindex\nmodule.exports = function (S, index, unicode) {\n  return index + (unicode ? at(S, index).length : 1);\n};\n\n\n/***/ }),\n\n/***/ \"07e3\":\n/***/ (function(module, exports) {\n\nvar hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\n\n/***/ }),\n\n/***/ \"0bfb\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// 21.2.5.3 get RegExp.prototype.flags\nvar anObject = __webpack_require__(\"cb7c\");\nmodule.exports = function () {\n  var that = anObject(this);\n  var result = '';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.unicode) result += 'u';\n  if (that.sticky) result += 'y';\n  return result;\n};\n\n\n/***/ }),\n\n/***/ \"0fc9\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(\"3a38\");\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n/***/ }),\n\n/***/ \"1654\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $at = __webpack_require__(\"71c1\")(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\n__webpack_require__(\"30f1\")(String, 'String', function (iterated) {\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var index = this._i;\n  var point;\n  if (index >= O.length) return { value: undefined, done: true };\n  point = $at(O, index);\n  this._i += point.length;\n  return { value: point, done: false };\n});\n\n\n/***/ }),\n\n/***/ \"1691\":\n/***/ (function(module, exports) {\n\n// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n\n/***/ }),\n\n/***/ \"1af6\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)\nvar $export = __webpack_require__(\"63b6\");\n\n$export($export.S, 'Array', { isArray: __webpack_require__(\"9003\") });\n\n\n/***/ }),\n\n/***/ \"1bc3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __webpack_require__(\"f772\");\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n/***/ }),\n\n/***/ \"1ec9\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"f772\");\nvar document = __webpack_require__(\"e53d\").document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n\n\n/***/ }),\n\n/***/ \"20fd\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $defineProperty = __webpack_require__(\"d9f6\");\nvar createDesc = __webpack_require__(\"aebd\");\n\nmodule.exports = function (object, index, value) {\n  if (index in object) $defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};\n\n\n/***/ }),\n\n/***/ \"214f\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n__webpack_require__(\"b0c5\");\nvar redefine = __webpack_require__(\"2aba\");\nvar hide = __webpack_require__(\"32e9\");\nvar fails = __webpack_require__(\"79e5\");\nvar defined = __webpack_require__(\"be13\");\nvar wks = __webpack_require__(\"2b4c\");\nvar regexpExec = __webpack_require__(\"520a\");\n\nvar SPECIES = wks('species');\n\nvar REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {\n  // #replace needs built-in support for named groups.\n  // #match works fine because it just return the exec results, even if it has\n  // a \"grops\" property.\n  var re = /./;\n  re.exec = function () {\n    var result = [];\n    result.groups = { a: '7' };\n    return result;\n  };\n  return ''.replace(re, '$<a>') !== '7';\n});\n\nvar SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {\n  // Chrome 51 has a buggy \"split\" implementation when RegExp#exec !== nativeExec\n  var re = /(?:)/;\n  var originalExec = re.exec;\n  re.exec = function () { return originalExec.apply(this, arguments); };\n  var result = 'ab'.split(re);\n  return result.length === 2 && result[0] === 'a' && result[1] === 'b';\n})();\n\nmodule.exports = function (KEY, length, exec) {\n  var SYMBOL = wks(KEY);\n\n  var DELEGATES_TO_SYMBOL = !fails(function () {\n    // String methods call symbol-named RegEp methods\n    var O = {};\n    O[SYMBOL] = function () { return 7; };\n    return ''[KEY](O) != 7;\n  });\n\n  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {\n    // Symbol-named RegExp methods call .exec\n    var execCalled = false;\n    var re = /a/;\n    re.exec = function () { execCalled = true; return null; };\n    if (KEY === 'split') {\n      // RegExp[@@split] doesn't call the regex's exec method, but first creates\n      // a new one. We need to return the patched regex when creating the new one.\n      re.constructor = {};\n      re.constructor[SPECIES] = function () { return re; };\n    }\n    re[SYMBOL]('');\n    return !execCalled;\n  }) : undefined;\n\n  if (\n    !DELEGATES_TO_SYMBOL ||\n    !DELEGATES_TO_EXEC ||\n    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||\n    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)\n  ) {\n    var nativeRegExpMethod = /./[SYMBOL];\n    var fns = exec(\n      defined,\n      SYMBOL,\n      ''[KEY],\n      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {\n        if (regexp.exec === regexpExec) {\n          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n            // The native String method already delegates to @@method (this\n            // polyfilled function), leasing to infinite recursion.\n            // We avoid it by directly calling the native @@method method.\n            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };\n          }\n          return { done: true, value: nativeMethod.call(str, regexp, arg2) };\n        }\n        return { done: false };\n      }\n    );\n    var strfn = fns[0];\n    var rxfn = fns[1];\n\n    redefine(String.prototype, KEY, strfn);\n    hide(RegExp.prototype, SYMBOL, length == 2\n      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n      ? function (string, arg) { return rxfn.call(string, this, arg); }\n      // 21.2.5.6 RegExp.prototype[@@match](string)\n      // 21.2.5.9 RegExp.prototype[@@search](string)\n      : function (string) { return rxfn.call(string, this); }\n    );\n  }\n};\n\n\n/***/ }),\n\n/***/ \"230e\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"d3f4\");\nvar document = __webpack_require__(\"7726\").document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n\n\n/***/ }),\n\n/***/ \"23c6\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = __webpack_require__(\"2d95\");\nvar TAG = __webpack_require__(\"2b4c\")('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n\n/***/ }),\n\n/***/ \"241e\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.13 ToObject(argument)\nvar defined = __webpack_require__(\"25eb\");\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n\n\n/***/ }),\n\n/***/ \"25eb\":\n/***/ (function(module, exports) {\n\n// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n/***/ }),\n\n/***/ \"294c\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n\n\n/***/ }),\n\n/***/ \"2aba\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"7726\");\nvar hide = __webpack_require__(\"32e9\");\nvar has = __webpack_require__(\"69a8\");\nvar SRC = __webpack_require__(\"ca5a\")('src');\nvar $toString = __webpack_require__(\"fa5b\");\nvar TO_STRING = 'toString';\nvar TPL = ('' + $toString).split(TO_STRING);\n\n__webpack_require__(\"8378\").inspectSource = function (it) {\n  return $toString.call(it);\n};\n\n(module.exports = function (O, key, val, safe) {\n  var isFunction = typeof val == 'function';\n  if (isFunction) has(val, 'name') || hide(val, 'name', key);\n  if (O[key] === val) return;\n  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if (O === global) {\n    O[key] = val;\n  } else if (!safe) {\n    delete O[key];\n    hide(O, key, val);\n  } else if (O[key]) {\n    O[key] = val;\n  } else {\n    hide(O, key, val);\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString() {\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n\n\n/***/ }),\n\n/***/ \"2b4c\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar store = __webpack_require__(\"5537\")('wks');\nvar uid = __webpack_require__(\"ca5a\");\nvar Symbol = __webpack_require__(\"7726\").Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n\n/***/ }),\n\n/***/ \"2d00\":\n/***/ (function(module, exports) {\n\nmodule.exports = false;\n\n\n/***/ }),\n\n/***/ \"2d95\":\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n\n/***/ }),\n\n/***/ \"2fdb\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// 21.1.3.7 String.prototype.includes(searchString, position = 0)\n\nvar $export = __webpack_require__(\"5ca1\");\nvar context = __webpack_require__(\"d2c8\");\nvar INCLUDES = 'includes';\n\n$export($export.P + $export.F * __webpack_require__(\"5147\")(INCLUDES), 'String', {\n  includes: function includes(searchString /* , position = 0 */) {\n    return !!~context(this, searchString, INCLUDES)\n      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n\n/***/ }),\n\n/***/ \"30f1\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar LIBRARY = __webpack_require__(\"b8e3\");\nvar $export = __webpack_require__(\"63b6\");\nvar redefine = __webpack_require__(\"9138\");\nvar hide = __webpack_require__(\"35e8\");\nvar Iterators = __webpack_require__(\"481b\");\nvar $iterCreate = __webpack_require__(\"8f60\");\nvar setToStringTag = __webpack_require__(\"45f2\");\nvar getPrototypeOf = __webpack_require__(\"53e2\");\nvar ITERATOR = __webpack_require__(\"5168\")('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n\n/***/ }),\n\n/***/ \"32a6\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.14 Object.keys(O)\nvar toObject = __webpack_require__(\"241e\");\nvar $keys = __webpack_require__(\"c3a1\");\n\n__webpack_require__(\"ce7e\")('keys', function () {\n  return function keys(it) {\n    return $keys(toObject(it));\n  };\n});\n\n\n/***/ }),\n\n/***/ \"32e9\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dP = __webpack_require__(\"86cc\");\nvar createDesc = __webpack_require__(\"4630\");\nmodule.exports = __webpack_require__(\"9e1e\") ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n/***/ }),\n\n/***/ \"32fc\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar document = __webpack_require__(\"e53d\").document;\nmodule.exports = document && document.documentElement;\n\n\n/***/ }),\n\n/***/ \"335c\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = __webpack_require__(\"6b4c\");\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n/***/ }),\n\n/***/ \"355d\":\n/***/ (function(module, exports) {\n\nexports.f = {}.propertyIsEnumerable;\n\n\n/***/ }),\n\n/***/ \"35e8\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dP = __webpack_require__(\"d9f6\");\nvar createDesc = __webpack_require__(\"aebd\");\nmodule.exports = __webpack_require__(\"8e60\") ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n/***/ }),\n\n/***/ \"36c3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = __webpack_require__(\"335c\");\nvar defined = __webpack_require__(\"25eb\");\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n\n\n/***/ }),\n\n/***/ \"3702\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// check on default Array iterator\nvar Iterators = __webpack_require__(\"481b\");\nvar ITERATOR = __webpack_require__(\"5168\")('iterator');\nvar ArrayProto = Array.prototype;\n\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n\n\n/***/ }),\n\n/***/ \"3a38\":\n/***/ (function(module, exports) {\n\n// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n/***/ }),\n\n/***/ \"40c3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = __webpack_require__(\"6b4c\");\nvar TAG = __webpack_require__(\"5168\")('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n\n/***/ }),\n\n/***/ \"4588\":\n/***/ (function(module, exports) {\n\n// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n/***/ }),\n\n/***/ \"45f2\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar def = __webpack_require__(\"d9f6\").f;\nvar has = __webpack_require__(\"07e3\");\nvar TAG = __webpack_require__(\"5168\")('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n\n\n/***/ }),\n\n/***/ \"4630\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n/***/ }),\n\n/***/ \"469f\":\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(\"6c1c\");\n__webpack_require__(\"1654\");\nmodule.exports = __webpack_require__(\"7d7b\");\n\n\n/***/ }),\n\n/***/ \"481b\":\n/***/ (function(module, exports) {\n\nmodule.exports = {};\n\n\n/***/ }),\n\n/***/ \"4aa6\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(\"dc62\");\n\n/***/ }),\n\n/***/ \"4bf8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.13 ToObject(argument)\nvar defined = __webpack_require__(\"be13\");\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n\n\n/***/ }),\n\n/***/ \"4ee1\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ITERATOR = __webpack_require__(\"5168\")('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function () { SAFE_CLOSING = true; };\n  // eslint-disable-next-line no-throw-literal\n  Array.from(riter, function () { throw 2; });\n} catch (e) { /* empty */ }\n\nmodule.exports = function (exec, skipClosing) {\n  if (!skipClosing && !SAFE_CLOSING) return false;\n  var safe = false;\n  try {\n    var arr = [7];\n    var iter = arr[ITERATOR]();\n    iter.next = function () { return { done: safe = true }; };\n    arr[ITERATOR] = function () { return iter; };\n    exec(arr);\n  } catch (e) { /* empty */ }\n  return safe;\n};\n\n\n/***/ }),\n\n/***/ \"50ed\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n\n\n/***/ }),\n\n/***/ \"5147\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar MATCH = __webpack_require__(\"2b4c\")('match');\nmodule.exports = function (KEY) {\n  var re = /./;\n  try {\n    '/./'[KEY](re);\n  } catch (e) {\n    try {\n      re[MATCH] = false;\n      return !'/./'[KEY](re);\n    } catch (f) { /* empty */ }\n  } return true;\n};\n\n\n/***/ }),\n\n/***/ \"5168\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar store = __webpack_require__(\"dbdb\")('wks');\nvar uid = __webpack_require__(\"62a0\");\nvar Symbol = __webpack_require__(\"e53d\").Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n\n/***/ }),\n\n/***/ \"5176\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(\"51b6\");\n\n/***/ }),\n\n/***/ \"51b6\":\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(\"a3c3\");\nmodule.exports = __webpack_require__(\"584a\").Object.assign;\n\n\n/***/ }),\n\n/***/ \"520a\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar regexpFlags = __webpack_require__(\"0bfb\");\n\nvar nativeExec = RegExp.prototype.exec;\n// This always refers to the native implementation, because the\n// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,\n// which loads this file before patching the method.\nvar nativeReplace = String.prototype.replace;\n\nvar patchedExec = nativeExec;\n\nvar LAST_INDEX = 'lastIndex';\n\nvar UPDATES_LAST_INDEX_WRONG = (function () {\n  var re1 = /a/,\n      re2 = /b*/g;\n  nativeExec.call(re1, 'a');\n  nativeExec.call(re2, 'a');\n  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;\n})();\n\n// nonparticipating capturing group, copied from es5-shim's String#split patch.\nvar NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;\n\nvar PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;\n\nif (PATCH) {\n  patchedExec = function exec(str) {\n    var re = this;\n    var lastIndex, reCopy, match, i;\n\n    if (NPCG_INCLUDED) {\n      reCopy = new RegExp('^' + re.source + '$(?!\\\\s)', regexpFlags.call(re));\n    }\n    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];\n\n    match = nativeExec.call(re, str);\n\n    if (UPDATES_LAST_INDEX_WRONG && match) {\n      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;\n    }\n    if (NPCG_INCLUDED && match && match.length > 1) {\n      // Fix browsers whose `exec` methods don't consistently return `undefined`\n      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\n      // eslint-disable-next-line no-loop-func\n      nativeReplace.call(match[0], reCopy, function () {\n        for (i = 1; i < arguments.length - 2; i++) {\n          if (arguments[i] === undefined) match[i] = undefined;\n        }\n      });\n    }\n\n    return match;\n  };\n}\n\nmodule.exports = patchedExec;\n\n\n/***/ }),\n\n/***/ \"53e2\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = __webpack_require__(\"07e3\");\nvar toObject = __webpack_require__(\"241e\");\nvar IE_PROTO = __webpack_require__(\"5559\")('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\n\n/***/ }),\n\n/***/ \"549b\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ctx = __webpack_require__(\"d864\");\nvar $export = __webpack_require__(\"63b6\");\nvar toObject = __webpack_require__(\"241e\");\nvar call = __webpack_require__(\"b0dc\");\nvar isArrayIter = __webpack_require__(\"3702\");\nvar toLength = __webpack_require__(\"b447\");\nvar createProperty = __webpack_require__(\"20fd\");\nvar getIterFn = __webpack_require__(\"7cd6\");\n\n$export($export.S + $export.F * !__webpack_require__(\"4ee1\")(function (iter) { Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n    var O = toObject(arrayLike);\n    var C = typeof this == 'function' ? this : Array;\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var index = 0;\n    var iterFn = getIterFn(O);\n    var length, result, step, iterator;\n    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {\n      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {\n        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = toLength(O.length);\n      for (result = new C(length); length > index; index++) {\n        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n\n\n/***/ }),\n\n/***/ \"54a1\":\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(\"6c1c\");\n__webpack_require__(\"1654\");\nmodule.exports = __webpack_require__(\"95d5\");\n\n\n/***/ }),\n\n/***/ \"5537\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar core = __webpack_require__(\"8378\");\nvar global = __webpack_require__(\"7726\");\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: core.version,\n  mode: __webpack_require__(\"2d00\") ? 'pure' : 'global',\n  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'\n});\n\n\n/***/ }),\n\n/***/ \"5559\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar shared = __webpack_require__(\"dbdb\")('keys');\nvar uid = __webpack_require__(\"62a0\");\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n\n\n/***/ }),\n\n/***/ \"584a\":\n/***/ (function(module, exports) {\n\nvar core = module.exports = { version: '2.6.5' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n\n\n/***/ }),\n\n/***/ \"5b4e\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = __webpack_require__(\"36c3\");\nvar toLength = __webpack_require__(\"b447\");\nvar toAbsoluteIndex = __webpack_require__(\"0fc9\");\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n/***/ }),\n\n/***/ \"5ca1\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"7726\");\nvar core = __webpack_require__(\"8378\");\nvar hide = __webpack_require__(\"32e9\");\nvar redefine = __webpack_require__(\"2aba\");\nvar ctx = __webpack_require__(\"9b43\");\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n  var key, own, out, exp;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if (target) redefine(target, key, out, type & $export.U);\n    // export\n    if (exports[key] != out) hide(exports, key, exp);\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n\n\n/***/ }),\n\n/***/ \"5d73\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(\"469f\");\n\n/***/ }),\n\n/***/ \"5f1b\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar classof = __webpack_require__(\"23c6\");\nvar builtinExec = RegExp.prototype.exec;\n\n // `RegExpExec` abstract operation\n// https://tc39.github.io/ecma262/#sec-regexpexec\nmodule.exports = function (R, S) {\n  var exec = R.exec;\n  if (typeof exec === 'function') {\n    var result = exec.call(R, S);\n    if (typeof result !== 'object') {\n      throw new TypeError('RegExp exec method returned something other than an Object or null');\n    }\n    return result;\n  }\n  if (classof(R) !== 'RegExp') {\n    throw new TypeError('RegExp#exec called on incompatible receiver');\n  }\n  return builtinExec.call(R, S);\n};\n\n\n/***/ }),\n\n/***/ \"626a\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = __webpack_require__(\"2d95\");\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n/***/ }),\n\n/***/ \"62a0\":\n/***/ (function(module, exports) {\n\nvar id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n/***/ }),\n\n/***/ \"63b6\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"e53d\");\nvar core = __webpack_require__(\"584a\");\nvar ctx = __webpack_require__(\"d864\");\nvar hide = __webpack_require__(\"35e8\");\nvar has = __webpack_require__(\"07e3\");\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var IS_WRAP = type & $export.W;\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE];\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];\n  var key, own, out;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if (own && has(exports, key)) continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function (C) {\n      var F = function (a, b, c) {\n        if (this instanceof C) {\n          switch (arguments.length) {\n            case 0: return new C();\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if (IS_PROTO) {\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n\n\n/***/ }),\n\n/***/ \"6762\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// https://github.com/tc39/Array.prototype.includes\nvar $export = __webpack_require__(\"5ca1\");\nvar $includes = __webpack_require__(\"c366\")(true);\n\n$export($export.P, 'Array', {\n  includes: function includes(el /* , fromIndex = 0 */) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n__webpack_require__(\"9c6c\")('includes');\n\n\n/***/ }),\n\n/***/ \"6821\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = __webpack_require__(\"626a\");\nvar defined = __webpack_require__(\"be13\");\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n\n\n/***/ }),\n\n/***/ \"69a8\":\n/***/ (function(module, exports) {\n\nvar hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\n\n/***/ }),\n\n/***/ \"6a99\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __webpack_require__(\"d3f4\");\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n/***/ }),\n\n/***/ \"6b4c\":\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n\n/***/ }),\n\n/***/ \"6c1c\":\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(\"c367\");\nvar global = __webpack_require__(\"e53d\");\nvar hide = __webpack_require__(\"35e8\");\nvar Iterators = __webpack_require__(\"481b\");\nvar TO_STRING_TAG = __webpack_require__(\"5168\")('toStringTag');\n\nvar DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +\n  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +\n  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +\n  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +\n  'TextTrackList,TouchList').split(',');\n\nfor (var i = 0; i < DOMIterables.length; i++) {\n  var NAME = DOMIterables[i];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n\n\n/***/ }),\n\n/***/ \"71c1\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(\"3a38\");\nvar defined = __webpack_require__(\"25eb\");\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n\n/***/ }),\n\n/***/ \"7726\":\n/***/ (function(module, exports) {\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n\n\n/***/ }),\n\n/***/ \"774e\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(\"d2d5\");\n\n/***/ }),\n\n/***/ \"77f1\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(\"4588\");\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n/***/ }),\n\n/***/ \"794b\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = !__webpack_require__(\"8e60\") && !__webpack_require__(\"294c\")(function () {\n  return Object.defineProperty(__webpack_require__(\"1ec9\")('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n/***/ }),\n\n/***/ \"79aa\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n/***/ }),\n\n/***/ \"79e5\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n\n\n/***/ }),\n\n/***/ \"7cd6\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar classof = __webpack_require__(\"40c3\");\nvar ITERATOR = __webpack_require__(\"5168\")('iterator');\nvar Iterators = __webpack_require__(\"481b\");\nmodule.exports = __webpack_require__(\"584a\").getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n\n/***/ }),\n\n/***/ \"7d7b\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(\"e4ae\");\nvar get = __webpack_require__(\"7cd6\");\nmodule.exports = __webpack_require__(\"584a\").getIterator = function (it) {\n  var iterFn = get(it);\n  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');\n  return anObject(iterFn.call(it));\n};\n\n\n/***/ }),\n\n/***/ \"7e90\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dP = __webpack_require__(\"d9f6\");\nvar anObject = __webpack_require__(\"e4ae\");\nvar getKeys = __webpack_require__(\"c3a1\");\n\nmodule.exports = __webpack_require__(\"8e60\") ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n\n/***/ }),\n\n/***/ \"8378\":\n/***/ (function(module, exports) {\n\nvar core = module.exports = { version: '2.6.5' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n\n\n/***/ }),\n\n/***/ \"8436\":\n/***/ (function(module, exports) {\n\nmodule.exports = function () { /* empty */ };\n\n\n/***/ }),\n\n/***/ \"86cc\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(\"cb7c\");\nvar IE8_DOM_DEFINE = __webpack_require__(\"c69a\");\nvar toPrimitive = __webpack_require__(\"6a99\");\nvar dP = Object.defineProperty;\n\nexports.f = __webpack_require__(\"9e1e\") ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n/***/ }),\n\n/***/ \"8aae\":\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(\"32a6\");\nmodule.exports = __webpack_require__(\"584a\").Object.keys;\n\n\n/***/ }),\n\n/***/ \"8e60\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(\"294c\")(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n/***/ }),\n\n/***/ \"8f60\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar create = __webpack_require__(\"a159\");\nvar descriptor = __webpack_require__(\"aebd\");\nvar setToStringTag = __webpack_require__(\"45f2\");\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n__webpack_require__(\"35e8\")(IteratorPrototype, __webpack_require__(\"5168\")('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n\n/***/ }),\n\n/***/ \"9003\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.2.2 IsArray(argument)\nvar cof = __webpack_require__(\"6b4c\");\nmodule.exports = Array.isArray || function isArray(arg) {\n  return cof(arg) == 'Array';\n};\n\n\n/***/ }),\n\n/***/ \"9138\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(\"35e8\");\n\n\n/***/ }),\n\n/***/ \"9306\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys = __webpack_require__(\"c3a1\");\nvar gOPS = __webpack_require__(\"9aa9\");\nvar pIE = __webpack_require__(\"355d\");\nvar toObject = __webpack_require__(\"241e\");\nvar IObject = __webpack_require__(\"335c\");\nvar $assign = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || __webpack_require__(\"294c\")(function () {\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line no-undef\n  var S = Symbol();\n  var K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function (k) { B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\n  var T = toObject(target);\n  var aLen = arguments.length;\n  var index = 1;\n  var getSymbols = gOPS.f;\n  var isEnum = pIE.f;\n  while (aLen > index) {\n    var S = IObject(arguments[index++]);\n    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];\n  } return T;\n} : $assign;\n\n\n/***/ }),\n\n/***/ \"9427\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $export = __webpack_require__(\"63b6\");\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n$export($export.S, 'Object', { create: __webpack_require__(\"a159\") });\n\n\n/***/ }),\n\n/***/ \"95d5\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar classof = __webpack_require__(\"40c3\");\nvar ITERATOR = __webpack_require__(\"5168\")('iterator');\nvar Iterators = __webpack_require__(\"481b\");\nmodule.exports = __webpack_require__(\"584a\").isIterable = function (it) {\n  var O = Object(it);\n  return O[ITERATOR] !== undefined\n    || '@@iterator' in O\n    // eslint-disable-next-line no-prototype-builtins\n    || Iterators.hasOwnProperty(classof(O));\n};\n\n\n/***/ }),\n\n/***/ \"9aa9\":\n/***/ (function(module, exports) {\n\nexports.f = Object.getOwnPropertySymbols;\n\n\n/***/ }),\n\n/***/ \"9b43\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// optional / simple context binding\nvar aFunction = __webpack_require__(\"d8e8\");\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n\n/***/ }),\n\n/***/ \"9c6c\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = __webpack_require__(\"2b4c\")('unscopables');\nvar ArrayProto = Array.prototype;\nif (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(\"32e9\")(ArrayProto, UNSCOPABLES, {});\nmodule.exports = function (key) {\n  ArrayProto[UNSCOPABLES][key] = true;\n};\n\n\n/***/ }),\n\n/***/ \"9def\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.15 ToLength\nvar toInteger = __webpack_require__(\"4588\");\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n/***/ }),\n\n/***/ \"9e1e\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(\"79e5\")(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n/***/ }),\n\n/***/ \"a159\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = __webpack_require__(\"e4ae\");\nvar dPs = __webpack_require__(\"7e90\");\nvar enumBugKeys = __webpack_require__(\"1691\");\nvar IE_PROTO = __webpack_require__(\"5559\")('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = __webpack_require__(\"1ec9\")('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  __webpack_require__(\"32fc\").appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n\n/***/ }),\n\n/***/ \"a352\":\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! sortablejs */ \"./node_modules/sortablejs/Sortable.js\");\n\n/***/ }),\n\n/***/ \"a3c3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.3.1 Object.assign(target, source)\nvar $export = __webpack_require__(\"63b6\");\n\n$export($export.S + $export.F, 'Object', { assign: __webpack_require__(\"9306\") });\n\n\n/***/ }),\n\n/***/ \"a481\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar anObject = __webpack_require__(\"cb7c\");\nvar toObject = __webpack_require__(\"4bf8\");\nvar toLength = __webpack_require__(\"9def\");\nvar toInteger = __webpack_require__(\"4588\");\nvar advanceStringIndex = __webpack_require__(\"0390\");\nvar regExpExec = __webpack_require__(\"5f1b\");\nvar max = Math.max;\nvar min = Math.min;\nvar floor = Math.floor;\nvar SUBSTITUTION_SYMBOLS = /\\$([$&`']|\\d\\d?|<[^>]*>)/g;\nvar SUBSTITUTION_SYMBOLS_NO_NAMED = /\\$([$&`']|\\d\\d?)/g;\n\nvar maybeToString = function (it) {\n  return it === undefined ? it : String(it);\n};\n\n// @@replace logic\n__webpack_require__(\"214f\")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {\n  return [\n    // `String.prototype.replace` method\n    // https://tc39.github.io/ecma262/#sec-string.prototype.replace\n    function replace(searchValue, replaceValue) {\n      var O = defined(this);\n      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];\n      return fn !== undefined\n        ? fn.call(searchValue, O, replaceValue)\n        : $replace.call(String(O), searchValue, replaceValue);\n    },\n    // `RegExp.prototype[@@replace]` method\n    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace\n    function (regexp, replaceValue) {\n      var res = maybeCallNative($replace, regexp, this, replaceValue);\n      if (res.done) return res.value;\n\n      var rx = anObject(regexp);\n      var S = String(this);\n      var functionalReplace = typeof replaceValue === 'function';\n      if (!functionalReplace) replaceValue = String(replaceValue);\n      var global = rx.global;\n      if (global) {\n        var fullUnicode = rx.unicode;\n        rx.lastIndex = 0;\n      }\n      var results = [];\n      while (true) {\n        var result = regExpExec(rx, S);\n        if (result === null) break;\n        results.push(result);\n        if (!global) break;\n        var matchStr = String(result[0]);\n        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n      }\n      var accumulatedResult = '';\n      var nextSourcePosition = 0;\n      for (var i = 0; i < results.length; i++) {\n        result = results[i];\n        var matched = String(result[0]);\n        var position = max(min(toInteger(result.index), S.length), 0);\n        var captures = [];\n        // NOTE: This is equivalent to\n        //   captures = result.slice(1).map(maybeToString)\n        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in\n        // the slice polyfill when slicing native arrays) \"doesn't work\" in safari 9 and\n        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.\n        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));\n        var namedCaptures = result.groups;\n        if (functionalReplace) {\n          var replacerArgs = [matched].concat(captures, position, S);\n          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);\n          var replacement = String(replaceValue.apply(undefined, replacerArgs));\n        } else {\n          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);\n        }\n        if (position >= nextSourcePosition) {\n          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;\n          nextSourcePosition = position + matched.length;\n        }\n      }\n      return accumulatedResult + S.slice(nextSourcePosition);\n    }\n  ];\n\n    // https://tc39.github.io/ecma262/#sec-getsubstitution\n  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {\n    var tailPos = position + matched.length;\n    var m = captures.length;\n    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;\n    if (namedCaptures !== undefined) {\n      namedCaptures = toObject(namedCaptures);\n      symbols = SUBSTITUTION_SYMBOLS;\n    }\n    return $replace.call(replacement, symbols, function (match, ch) {\n      var capture;\n      switch (ch.charAt(0)) {\n        case '$': return '$';\n        case '&': return matched;\n        case '`': return str.slice(0, position);\n        case \"'\": return str.slice(tailPos);\n        case '<':\n          capture = namedCaptures[ch.slice(1, -1)];\n          break;\n        default: // \\d\\d?\n          var n = +ch;\n          if (n === 0) return match;\n          if (n > m) {\n            var f = floor(n / 10);\n            if (f === 0) return match;\n            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);\n            return match;\n          }\n          capture = captures[n - 1];\n      }\n      return capture === undefined ? '' : capture;\n    });\n  }\n});\n\n\n/***/ }),\n\n/***/ \"a4bb\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(\"8aae\");\n\n/***/ }),\n\n/***/ \"a745\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(\"f410\");\n\n/***/ }),\n\n/***/ \"aae3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.2.8 IsRegExp(argument)\nvar isObject = __webpack_require__(\"d3f4\");\nvar cof = __webpack_require__(\"2d95\");\nvar MATCH = __webpack_require__(\"2b4c\")('match');\nmodule.exports = function (it) {\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');\n};\n\n\n/***/ }),\n\n/***/ \"aebd\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n/***/ }),\n\n/***/ \"b0c5\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar regexpExec = __webpack_require__(\"520a\");\n__webpack_require__(\"5ca1\")({\n  target: 'RegExp',\n  proto: true,\n  forced: regexpExec !== /./.exec\n}, {\n  exec: regexpExec\n});\n\n\n/***/ }),\n\n/***/ \"b0dc\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// call something on iterator step with safe closing on error\nvar anObject = __webpack_require__(\"e4ae\");\nmodule.exports = function (iterator, fn, value, entries) {\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (e) {\n    var ret = iterator['return'];\n    if (ret !== undefined) anObject(ret.call(iterator));\n    throw e;\n  }\n};\n\n\n/***/ }),\n\n/***/ \"b447\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.15 ToLength\nvar toInteger = __webpack_require__(\"3a38\");\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n/***/ }),\n\n/***/ \"b8e3\":\n/***/ (function(module, exports) {\n\nmodule.exports = true;\n\n\n/***/ }),\n\n/***/ \"be13\":\n/***/ (function(module, exports) {\n\n// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n/***/ }),\n\n/***/ \"c366\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = __webpack_require__(\"6821\");\nvar toLength = __webpack_require__(\"9def\");\nvar toAbsoluteIndex = __webpack_require__(\"77f1\");\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n/***/ }),\n\n/***/ \"c367\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar addToUnscopables = __webpack_require__(\"8436\");\nvar step = __webpack_require__(\"50ed\");\nvar Iterators = __webpack_require__(\"481b\");\nvar toIObject = __webpack_require__(\"36c3\");\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = __webpack_require__(\"30f1\")(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n/***/ }),\n\n/***/ \"c3a1\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = __webpack_require__(\"e6f3\");\nvar enumBugKeys = __webpack_require__(\"1691\");\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n\n\n/***/ }),\n\n/***/ \"c649\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return insertNodeAt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return camelize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return console; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return removeNode; });\n/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"a481\");\n/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var F_source_vuedraggable_node_modules_babel_runtime_corejs2_core_js_object_create__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"4aa6\");\n/* harmony import */ var F_source_vuedraggable_node_modules_babel_runtime_corejs2_core_js_object_create__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(F_source_vuedraggable_node_modules_babel_runtime_corejs2_core_js_object_create__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nfunction getConsole() {\n  if (typeof window !== \"undefined\") {\n    return window.console;\n  }\n\n  return global.console;\n}\n\nvar console = getConsole();\n\nfunction cached(fn) {\n  var cache = F_source_vuedraggable_node_modules_babel_runtime_corejs2_core_js_object_create__WEBPACK_IMPORTED_MODULE_1___default()(null);\n\n  return function cachedFn(str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\n\nvar regex = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(regex, function (_, c) {\n    return c ? c.toUpperCase() : \"\";\n  });\n});\n\nfunction removeNode(node) {\n  if (node.parentElement !== null) {\n    node.parentElement.removeChild(node);\n  }\n}\n\nfunction insertNodeAt(fatherNode, node, position) {\n  var refNode = position === 0 ? fatherNode.children[0] : fatherNode.children[position - 1].nextSibling;\n  fatherNode.insertBefore(node, refNode);\n}\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"c8ba\")))\n\n/***/ }),\n\n/***/ \"c69a\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = !__webpack_require__(\"9e1e\") && !__webpack_require__(\"79e5\")(function () {\n  return Object.defineProperty(__webpack_require__(\"230e\")('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n/***/ }),\n\n/***/ \"c8ba\":\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n\n/***/ \"c8bb\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(\"54a1\");\n\n/***/ }),\n\n/***/ \"ca5a\":\n/***/ (function(module, exports) {\n\nvar id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n/***/ }),\n\n/***/ \"cb7c\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"d3f4\");\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n/***/ }),\n\n/***/ \"ce7e\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// most Object methods by ES6 should accept primitives\nvar $export = __webpack_require__(\"63b6\");\nvar core = __webpack_require__(\"584a\");\nvar fails = __webpack_require__(\"294c\");\nmodule.exports = function (KEY, exec) {\n  var fn = (core.Object || {})[KEY] || Object[KEY];\n  var exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);\n};\n\n\n/***/ }),\n\n/***/ \"d2c8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// helper for String#{startsWith, endsWith, includes}\nvar isRegExp = __webpack_require__(\"aae3\");\nvar defined = __webpack_require__(\"be13\");\n\nmodule.exports = function (that, searchString, NAME) {\n  if (isRegExp(searchString)) throw TypeError('String#' + NAME + \" doesn't accept regex!\");\n  return String(defined(that));\n};\n\n\n/***/ }),\n\n/***/ \"d2d5\":\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(\"1654\");\n__webpack_require__(\"549b\");\nmodule.exports = __webpack_require__(\"584a\").Array.from;\n\n\n/***/ }),\n\n/***/ \"d3f4\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n/***/ }),\n\n/***/ \"d864\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// optional / simple context binding\nvar aFunction = __webpack_require__(\"79aa\");\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n\n/***/ }),\n\n/***/ \"d8e8\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n/***/ }),\n\n/***/ \"d9f6\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(\"e4ae\");\nvar IE8_DOM_DEFINE = __webpack_require__(\"794b\");\nvar toPrimitive = __webpack_require__(\"1bc3\");\nvar dP = Object.defineProperty;\n\nexports.f = __webpack_require__(\"8e60\") ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n/***/ }),\n\n/***/ \"dbdb\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar core = __webpack_require__(\"584a\");\nvar global = __webpack_require__(\"e53d\");\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: core.version,\n  mode: __webpack_require__(\"b8e3\") ? 'pure' : 'global',\n  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'\n});\n\n\n/***/ }),\n\n/***/ \"dc62\":\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(\"9427\");\nvar $Object = __webpack_require__(\"584a\").Object;\nmodule.exports = function create(P, D) {\n  return $Object.create(P, D);\n};\n\n\n/***/ }),\n\n/***/ \"e4ae\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"f772\");\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n/***/ }),\n\n/***/ \"e53d\":\n/***/ (function(module, exports) {\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n\n\n/***/ }),\n\n/***/ \"e6f3\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar has = __webpack_require__(\"07e3\");\nvar toIObject = __webpack_require__(\"36c3\");\nvar arrayIndexOf = __webpack_require__(\"5b4e\")(false);\nvar IE_PROTO = __webpack_require__(\"5559\")('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n/***/ }),\n\n/***/ \"f410\":\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(\"1af6\");\nmodule.exports = __webpack_require__(\"584a\").Array.isArray;\n\n\n/***/ }),\n\n/***/ \"f559\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// 21.1.3.18 String.prototype.startsWith(searchString [, position ])\n\nvar $export = __webpack_require__(\"5ca1\");\nvar toLength = __webpack_require__(\"9def\");\nvar context = __webpack_require__(\"d2c8\");\nvar STARTS_WITH = 'startsWith';\nvar $startsWith = ''[STARTS_WITH];\n\n$export($export.P + $export.F * __webpack_require__(\"5147\")(STARTS_WITH), 'String', {\n  startsWith: function startsWith(searchString /* , position = 0 */) {\n    var that = context(this, searchString, STARTS_WITH);\n    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));\n    var search = String(searchString);\n    return $startsWith\n      ? $startsWith.call(that, search, index)\n      : that.slice(index, index + search.length) === search;\n  }\n});\n\n\n/***/ }),\n\n/***/ \"f772\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n/***/ }),\n\n/***/ \"fa5b\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(\"5537\")('native-function-to-string', Function.toString);\n\n\n/***/ }),\n\n/***/ \"fb15\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js\n// This file is imported into lib/wc client bundles.\n\nif (typeof window !== 'undefined') {\n  var setPublicPath_i\n  if ((setPublicPath_i = window.document.currentScript) && (setPublicPath_i = setPublicPath_i.src.match(/(.+\\/)[^/]+\\.js(\\?.*)?$/))) {\n    __webpack_require__.p = setPublicPath_i[1] // eslint-disable-line\n  }\n}\n\n// Indicate to webpack that this file can be concatenated\n/* harmony default export */ var setPublicPath = (null);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/object/assign.js\nvar object_assign = __webpack_require__(\"5176\");\nvar assign_default = /*#__PURE__*/__webpack_require__.n(object_assign);\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.starts-with.js\nvar es6_string_starts_with = __webpack_require__(\"f559\");\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/object/keys.js\nvar keys = __webpack_require__(\"a4bb\");\nvar keys_default = /*#__PURE__*/__webpack_require__.n(keys);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/array/is-array.js\nvar is_array = __webpack_require__(\"a745\");\nvar is_array_default = /*#__PURE__*/__webpack_require__.n(is_array);\n\n// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/arrayWithHoles.js\n\nfunction _arrayWithHoles(arr) {\n  if (is_array_default()(arr)) return arr;\n}\n// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/get-iterator.js\nvar get_iterator = __webpack_require__(\"5d73\");\nvar get_iterator_default = /*#__PURE__*/__webpack_require__.n(get_iterator);\n\n// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/iterableToArrayLimit.js\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = get_iterator_default()(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/nonIterableRest.js\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/slicedToArray.js\n\n\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es7.array.includes.js\nvar es7_array_includes = __webpack_require__(\"6762\");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.includes.js\nvar es6_string_includes = __webpack_require__(\"2fdb\");\n\n// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/arrayWithoutHoles.js\n\nfunction _arrayWithoutHoles(arr) {\n  if (is_array_default()(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/array/from.js\nvar from = __webpack_require__(\"774e\");\nvar from_default = /*#__PURE__*/__webpack_require__.n(from);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/is-iterable.js\nvar is_iterable = __webpack_require__(\"c8bb\");\nvar is_iterable_default = /*#__PURE__*/__webpack_require__.n(is_iterable);\n\n// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/iterableToArray.js\n\n\nfunction _iterableToArray(iter) {\n  if (is_iterable_default()(Object(iter)) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return from_default()(iter);\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/nonIterableSpread.js\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/toConsumableArray.js\n\n\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n// EXTERNAL MODULE: external {\"commonjs\":\"sortablejs\",\"commonjs2\":\"sortablejs\",\"amd\":\"sortablejs\",\"root\":\"Sortable\"}\nvar external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_ = __webpack_require__(\"a352\");\nvar external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_);\n\n// EXTERNAL MODULE: ./src/util/helper.js\nvar helper = __webpack_require__(\"c649\");\n\n// CONCATENATED MODULE: ./src/vuedraggable.js\n\n\n\n\n\n\n\n\n\n\nfunction buildAttribute(object, propName, value) {\n  if (value === undefined) {\n    return object;\n  }\n\n  object = object || {};\n  object[propName] = value;\n  return object;\n}\n\nfunction computeVmIndex(vnodes, element) {\n  return vnodes.map(function (elt) {\n    return elt.elm;\n  }).indexOf(element);\n}\n\nfunction _computeIndexes(slots, children, isTransition, footerOffset) {\n  if (!slots) {\n    return [];\n  }\n\n  var elmFromNodes = slots.map(function (elt) {\n    return elt.elm;\n  });\n  var footerIndex = children.length - footerOffset;\n\n  var rawIndexes = _toConsumableArray(children).map(function (elt, idx) {\n    return idx >= footerIndex ? elmFromNodes.length : elmFromNodes.indexOf(elt);\n  });\n\n  return isTransition ? rawIndexes.filter(function (ind) {\n    return ind !== -1;\n  }) : rawIndexes;\n}\n\nfunction emit(evtName, evtData) {\n  var _this = this;\n\n  this.$nextTick(function () {\n    return _this.$emit(evtName.toLowerCase(), evtData);\n  });\n}\n\nfunction delegateAndEmit(evtName) {\n  var _this2 = this;\n\n  return function (evtData) {\n    if (_this2.realList !== null) {\n      _this2[\"onDrag\" + evtName](evtData);\n    }\n\n    emit.call(_this2, evtName, evtData);\n  };\n}\n\nfunction isTransitionName(name) {\n  return [\"transition-group\", \"TransitionGroup\"].includes(name);\n}\n\nfunction vuedraggable_isTransition(slots) {\n  if (!slots || slots.length !== 1) {\n    return false;\n  }\n\n  var _slots = _slicedToArray(slots, 1),\n      componentOptions = _slots[0].componentOptions;\n\n  if (!componentOptions) {\n    return false;\n  }\n\n  return isTransitionName(componentOptions.tag);\n}\n\nfunction getSlot(slot, scopedSlot, key) {\n  return slot[key] || (scopedSlot[key] ? scopedSlot[key]() : undefined);\n}\n\nfunction computeChildrenAndOffsets(children, slot, scopedSlot) {\n  var headerOffset = 0;\n  var footerOffset = 0;\n  var header = getSlot(slot, scopedSlot, \"header\");\n\n  if (header) {\n    headerOffset = header.length;\n    children = children ? [].concat(_toConsumableArray(header), _toConsumableArray(children)) : _toConsumableArray(header);\n  }\n\n  var footer = getSlot(slot, scopedSlot, \"footer\");\n\n  if (footer) {\n    footerOffset = footer.length;\n    children = children ? [].concat(_toConsumableArray(children), _toConsumableArray(footer)) : _toConsumableArray(footer);\n  }\n\n  return {\n    children: children,\n    headerOffset: headerOffset,\n    footerOffset: footerOffset\n  };\n}\n\nfunction getComponentAttributes($attrs, componentData) {\n  var attributes = null;\n\n  var update = function update(name, value) {\n    attributes = buildAttribute(attributes, name, value);\n  };\n\n  var attrs = keys_default()($attrs).filter(function (key) {\n    return key === \"id\" || key.startsWith(\"data-\");\n  }).reduce(function (res, key) {\n    res[key] = $attrs[key];\n    return res;\n  }, {});\n\n  update(\"attrs\", attrs);\n\n  if (!componentData) {\n    return attributes;\n  }\n\n  var on = componentData.on,\n      props = componentData.props,\n      componentDataAttrs = componentData.attrs;\n  update(\"on\", on);\n  update(\"props\", props);\n\n  assign_default()(attributes.attrs, componentDataAttrs);\n\n  return attributes;\n}\n\nvar eventsListened = [\"Start\", \"Add\", \"Remove\", \"Update\", \"End\"];\nvar eventsToEmit = [\"Choose\", \"Unchoose\", \"Sort\", \"Filter\", \"Clone\"];\nvar readonlyProperties = [\"Move\"].concat(eventsListened, eventsToEmit).map(function (evt) {\n  return \"on\" + evt;\n});\nvar draggingElement = null;\nvar vuedraggable_props = {\n  options: Object,\n  list: {\n    type: Array,\n    required: false,\n    default: null\n  },\n  value: {\n    type: Array,\n    required: false,\n    default: null\n  },\n  noTransitionOnDrag: {\n    type: Boolean,\n    default: false\n  },\n  clone: {\n    type: Function,\n    default: function _default(original) {\n      return original;\n    }\n  },\n  element: {\n    type: String,\n    default: \"div\"\n  },\n  tag: {\n    type: String,\n    default: null\n  },\n  move: {\n    type: Function,\n    default: null\n  },\n  componentData: {\n    type: Object,\n    required: false,\n    default: null\n  }\n};\nvar draggableComponent = {\n  name: \"draggable\",\n  inheritAttrs: false,\n  props: vuedraggable_props,\n  data: function data() {\n    return {\n      transitionMode: false,\n      noneFunctionalComponentMode: false\n    };\n  },\n  render: function render(h) {\n    var slots = this.$slots.default;\n    this.transitionMode = vuedraggable_isTransition(slots);\n\n    var _computeChildrenAndOf = computeChildrenAndOffsets(slots, this.$slots, this.$scopedSlots),\n        children = _computeChildrenAndOf.children,\n        headerOffset = _computeChildrenAndOf.headerOffset,\n        footerOffset = _computeChildrenAndOf.footerOffset;\n\n    this.headerOffset = headerOffset;\n    this.footerOffset = footerOffset;\n    var attributes = getComponentAttributes(this.$attrs, this.componentData);\n    return h(this.getTag(), attributes, children);\n  },\n  created: function created() {\n    if (this.list !== null && this.value !== null) {\n      helper[\"b\" /* console */].error(\"Value and list props are mutually exclusive! Please set one or another.\");\n    }\n\n    if (this.element !== \"div\") {\n      helper[\"b\" /* console */].warn(\"Element props is deprecated please use tag props instead. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#element-props\");\n    }\n\n    if (this.options !== undefined) {\n      helper[\"b\" /* console */].warn(\"Options props is deprecated, add sortable options directly as vue.draggable item, or use v-bind. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#options-props\");\n    }\n  },\n  mounted: function mounted() {\n    var _this3 = this;\n\n    this.noneFunctionalComponentMode = this.getTag().toLowerCase() !== this.$el.nodeName.toLowerCase() && !this.getIsFunctional();\n\n    if (this.noneFunctionalComponentMode && this.transitionMode) {\n      throw new Error(\"Transition-group inside component is not supported. Please alter tag value or remove transition-group. Current tag value: \".concat(this.getTag()));\n    }\n\n    var optionsAdded = {};\n    eventsListened.forEach(function (elt) {\n      optionsAdded[\"on\" + elt] = delegateAndEmit.call(_this3, elt);\n    });\n    eventsToEmit.forEach(function (elt) {\n      optionsAdded[\"on\" + elt] = emit.bind(_this3, elt);\n    });\n\n    var attributes = keys_default()(this.$attrs).reduce(function (res, key) {\n      res[Object(helper[\"a\" /* camelize */])(key)] = _this3.$attrs[key];\n      return res;\n    }, {});\n\n    var options = assign_default()({}, this.options, attributes, optionsAdded, {\n      onMove: function onMove(evt, originalEvent) {\n        return _this3.onDragMove(evt, originalEvent);\n      }\n    });\n\n    !(\"draggable\" in options) && (options.draggable = \">*\");\n    this._sortable = new external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default.a(this.rootContainer, options);\n    this.computeIndexes();\n  },\n  beforeDestroy: function beforeDestroy() {\n    if (this._sortable !== undefined) this._sortable.destroy();\n  },\n  computed: {\n    rootContainer: function rootContainer() {\n      return this.transitionMode ? this.$el.children[0] : this.$el;\n    },\n    realList: function realList() {\n      return this.list ? this.list : this.value;\n    }\n  },\n  watch: {\n    options: {\n      handler: function handler(newOptionValue) {\n        this.updateOptions(newOptionValue);\n      },\n      deep: true\n    },\n    $attrs: {\n      handler: function handler(newOptionValue) {\n        this.updateOptions(newOptionValue);\n      },\n      deep: true\n    },\n    realList: function realList() {\n      this.computeIndexes();\n    }\n  },\n  methods: {\n    getIsFunctional: function getIsFunctional() {\n      var fnOptions = this._vnode.fnOptions;\n      return fnOptions && fnOptions.functional;\n    },\n    getTag: function getTag() {\n      return this.tag || this.element;\n    },\n    updateOptions: function updateOptions(newOptionValue) {\n      for (var property in newOptionValue) {\n        var value = Object(helper[\"a\" /* camelize */])(property);\n\n        if (readonlyProperties.indexOf(value) === -1) {\n          this._sortable.option(value, newOptionValue[property]);\n        }\n      }\n    },\n    getChildrenNodes: function getChildrenNodes() {\n      if (this.noneFunctionalComponentMode) {\n        return this.$children[0].$slots.default;\n      }\n\n      var rawNodes = this.$slots.default;\n      return this.transitionMode ? rawNodes[0].child.$slots.default : rawNodes;\n    },\n    computeIndexes: function computeIndexes() {\n      var _this4 = this;\n\n      this.$nextTick(function () {\n        _this4.visibleIndexes = _computeIndexes(_this4.getChildrenNodes(), _this4.rootContainer.children, _this4.transitionMode, _this4.footerOffset);\n      });\n    },\n    getUnderlyingVm: function getUnderlyingVm(htmlElt) {\n      var index = computeVmIndex(this.getChildrenNodes() || [], htmlElt);\n\n      if (index === -1) {\n        //Edge case during move callback: related element might be\n        //an element different from collection\n        return null;\n      }\n\n      var element = this.realList[index];\n      return {\n        index: index,\n        element: element\n      };\n    },\n    getUnderlyingPotencialDraggableComponent: function getUnderlyingPotencialDraggableComponent(_ref) {\n      var vue = _ref.__vue__;\n\n      if (!vue || !vue.$options || !isTransitionName(vue.$options._componentTag)) {\n        if (!(\"realList\" in vue) && vue.$children.length === 1 && \"realList\" in vue.$children[0]) return vue.$children[0];\n        return vue;\n      }\n\n      return vue.$parent;\n    },\n    emitChanges: function emitChanges(evt) {\n      var _this5 = this;\n\n      this.$nextTick(function () {\n        _this5.$emit(\"change\", evt);\n      });\n    },\n    alterList: function alterList(onList) {\n      if (this.list) {\n        onList(this.list);\n        return;\n      }\n\n      var newList = _toConsumableArray(this.value);\n\n      onList(newList);\n      this.$emit(\"input\", newList);\n    },\n    spliceList: function spliceList() {\n      var _arguments = arguments;\n\n      var spliceList = function spliceList(list) {\n        return list.splice.apply(list, _toConsumableArray(_arguments));\n      };\n\n      this.alterList(spliceList);\n    },\n    updatePosition: function updatePosition(oldIndex, newIndex) {\n      var updatePosition = function updatePosition(list) {\n        return list.splice(newIndex, 0, list.splice(oldIndex, 1)[0]);\n      };\n\n      this.alterList(updatePosition);\n    },\n    getRelatedContextFromMoveEvent: function getRelatedContextFromMoveEvent(_ref2) {\n      var to = _ref2.to,\n          related = _ref2.related;\n      var component = this.getUnderlyingPotencialDraggableComponent(to);\n\n      if (!component) {\n        return {\n          component: component\n        };\n      }\n\n      var list = component.realList;\n      var context = {\n        list: list,\n        component: component\n      };\n\n      if (to !== related && list && component.getUnderlyingVm) {\n        var destination = component.getUnderlyingVm(related);\n\n        if (destination) {\n          return assign_default()(destination, context);\n        }\n      }\n\n      return context;\n    },\n    getVmIndex: function getVmIndex(domIndex) {\n      var indexes = this.visibleIndexes;\n      var numberIndexes = indexes.length;\n      return domIndex > numberIndexes - 1 ? numberIndexes : indexes[domIndex];\n    },\n    getComponent: function getComponent() {\n      return this.$slots.default[0].componentInstance;\n    },\n    resetTransitionData: function resetTransitionData(index) {\n      if (!this.noTransitionOnDrag || !this.transitionMode) {\n        return;\n      }\n\n      var nodes = this.getChildrenNodes();\n      nodes[index].data = null;\n      var transitionContainer = this.getComponent();\n      transitionContainer.children = [];\n      transitionContainer.kept = undefined;\n    },\n    onDragStart: function onDragStart(evt) {\n      this.context = this.getUnderlyingVm(evt.item);\n      evt.item._underlying_vm_ = this.clone(this.context.element);\n      draggingElement = evt.item;\n    },\n    onDragAdd: function onDragAdd(evt) {\n      var element = evt.item._underlying_vm_;\n\n      if (element === undefined) {\n        return;\n      }\n\n      Object(helper[\"d\" /* removeNode */])(evt.item);\n      var newIndex = this.getVmIndex(evt.newIndex);\n      this.spliceList(newIndex, 0, element);\n      this.computeIndexes();\n      var added = {\n        element: element,\n        newIndex: newIndex\n      };\n      this.emitChanges({\n        added: added\n      });\n    },\n    onDragRemove: function onDragRemove(evt) {\n      Object(helper[\"c\" /* insertNodeAt */])(this.rootContainer, evt.item, evt.oldIndex);\n\n      if (evt.pullMode === \"clone\") {\n        Object(helper[\"d\" /* removeNode */])(evt.clone);\n        return;\n      }\n\n      var oldIndex = this.context.index;\n      this.spliceList(oldIndex, 1);\n      var removed = {\n        element: this.context.element,\n        oldIndex: oldIndex\n      };\n      this.resetTransitionData(oldIndex);\n      this.emitChanges({\n        removed: removed\n      });\n    },\n    onDragUpdate: function onDragUpdate(evt) {\n      Object(helper[\"d\" /* removeNode */])(evt.item);\n      Object(helper[\"c\" /* insertNodeAt */])(evt.from, evt.item, evt.oldIndex);\n      var oldIndex = this.context.index;\n      var newIndex = this.getVmIndex(evt.newIndex);\n      this.updatePosition(oldIndex, newIndex);\n      var moved = {\n        element: this.context.element,\n        oldIndex: oldIndex,\n        newIndex: newIndex\n      };\n      this.emitChanges({\n        moved: moved\n      });\n    },\n    updateProperty: function updateProperty(evt, propertyName) {\n      evt.hasOwnProperty(propertyName) && (evt[propertyName] += this.headerOffset);\n    },\n    computeFutureIndex: function computeFutureIndex(relatedContext, evt) {\n      if (!relatedContext.element) {\n        return 0;\n      }\n\n      var domChildren = _toConsumableArray(evt.to.children).filter(function (el) {\n        return el.style[\"display\"] !== \"none\";\n      });\n\n      var currentDOMIndex = domChildren.indexOf(evt.related);\n      var currentIndex = relatedContext.component.getVmIndex(currentDOMIndex);\n      var draggedInList = domChildren.indexOf(draggingElement) !== -1;\n      return draggedInList || !evt.willInsertAfter ? currentIndex : currentIndex + 1;\n    },\n    onDragMove: function onDragMove(evt, originalEvent) {\n      var onMove = this.move;\n\n      if (!onMove || !this.realList) {\n        return true;\n      }\n\n      var relatedContext = this.getRelatedContextFromMoveEvent(evt);\n      var draggedContext = this.context;\n      var futureIndex = this.computeFutureIndex(relatedContext, evt);\n\n      assign_default()(draggedContext, {\n        futureIndex: futureIndex\n      });\n\n      var sendEvt = assign_default()({}, evt, {\n        relatedContext: relatedContext,\n        draggedContext: draggedContext\n      });\n\n      return onMove(sendEvt, originalEvent);\n    },\n    onDragEnd: function onDragEnd() {\n      this.computeIndexes();\n      draggingElement = null;\n    }\n  }\n};\n\nif (typeof window !== \"undefined\" && \"Vue\" in window) {\n  window.Vue.component(\"draggable\", draggableComponent);\n}\n\n/* harmony default export */ var vuedraggable = (draggableComponent);\n// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js\n\n\n/* harmony default export */ var entry_lib = __webpack_exports__[\"default\"] = (vuedraggable);\n\n\n\n/***/ })\n\n/******/ })[\"default\"];\n//# sourceMappingURL=vuedraggable.common.js.map\n\n//# sourceURL=webpack:///./node_modules/vuedraggable/dist/vuedraggable.common.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _moduels__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./moduels */ \"./src/js/moduels.js\");\n/* harmony import */ var _modules_onload__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/onload */ \"./src/js/modules/onload.js\");\n/* harmony import */ var _components_form_Select__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/form/Select */ \"./src/js/components/form/Select.vue\");\n/* harmony import */ var _components_form_MultiSelect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/form/MultiSelect */ \"./src/js/components/form/MultiSelect.vue\");\n/* harmony import */ var _components_form_File__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/form/File */ \"./src/js/components/form/File.vue\");\n/* harmony import */ var _components_LoginForm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/LoginForm */ \"./src/js/components/LoginForm.vue\");\n/* harmony import */ var _components_form_ImageIterator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/form/ImageIterator */ \"./src/js/components/form/ImageIterator.vue\");\n/* harmony import */ var vee_validate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vee-validate */ \"./node_modules/vee-validate/dist/vee-validate.esm.js\");\n/* harmony import */ var vee_validate_dist_locale_ru__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! vee-validate/dist/locale/ru */ \"./node_modules/vee-validate/dist/locale/ru.js\");\n/* harmony import */ var vee_validate_dist_locale_ru__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(vee_validate_dist_locale_ru__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm.js\");\n// Vue main file\n\n\n\n\n\n\n\n\n\n\n\nwindow.onload = function () {\n  Object(_moduels__WEBPACK_IMPORTED_MODULE_0__[\"main\"])();\n  Object(_modules_onload__WEBPACK_IMPORTED_MODULE_1__[\"onload\"])();\n}; // ----------------------use-section-------------------------------------------->\n\n\nvue__WEBPACK_IMPORTED_MODULE_9__[\"default\"].use(vee_validate__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n  classes: true,\n  classNames: {\n    valid: 'is-valid',\n    invalid: 'is-invalid'\n  }\n});\nvee_validate__WEBPACK_IMPORTED_MODULE_7__[\"Validator\"].localize('ru', vee_validate_dist_locale_ru__WEBPACK_IMPORTED_MODULE_8___default.a); // ----------------------------------------------------------------------------->\n// ----------------------component-section-------------------------------------->\n\nvue__WEBPACK_IMPORTED_MODULE_9__[\"default\"].component('select-single', _components_form_Select__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\nvue__WEBPACK_IMPORTED_MODULE_9__[\"default\"].component('select-multi', _components_form_MultiSelect__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\nvue__WEBPACK_IMPORTED_MODULE_9__[\"default\"].component('login-form', _components_LoginForm__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\nvue__WEBPACK_IMPORTED_MODULE_9__[\"default\"].component('form-file', _components_form_File__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\nvue__WEBPACK_IMPORTED_MODULE_9__[\"default\"].component('image-iterator', _components_form_ImageIterator__WEBPACK_IMPORTED_MODULE_6__[\"default\"]); // ----------------------------------------------------------------------------->\n// ---------------------Main-instance-of-Vue------------------------------------>\n\nvar app = new vue__WEBPACK_IMPORTED_MODULE_9__[\"default\"]({\n  el: '#app'\n}); // -------------------------Instances-of-Vue------------------------------------>\n// ----------------------------------------------------------------------------->\n\n//# sourceURL=webpack:///./src/js/app.js?");

/***/ }),

/***/ "./src/js/components/LoginForm.vue":
/*!*****************************************!*\
  !*** ./src/js/components/LoginForm.vue ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _LoginForm_vue_vue_type_template_id_b397ab9e___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LoginForm.vue?vue&type=template&id=b397ab9e& */ \"./src/js/components/LoginForm.vue?vue&type=template&id=b397ab9e&\");\n/* harmony import */ var _LoginForm_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LoginForm.vue?vue&type=script&lang=js& */ \"./src/js/components/LoginForm.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _LoginForm_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _LoginForm_vue_vue_type_template_id_b397ab9e___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _LoginForm_vue_vue_type_template_id_b397ab9e___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"src/js/components/LoginForm.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);\n\n//# sourceURL=webpack:///./src/js/components/LoginForm.vue?");

/***/ }),

/***/ "./src/js/components/LoginForm.vue?vue&type=script&lang=js&":
/*!******************************************************************!*\
  !*** ./src/js/components/LoginForm.vue?vue&type=script&lang=js& ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_LoginForm_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib!../../../node_modules/vue-loader/lib??vue-loader-options!./LoginForm.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js?!./src/js/components/LoginForm.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_LoginForm_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); \n\n//# sourceURL=webpack:///./src/js/components/LoginForm.vue?");

/***/ }),

/***/ "./src/js/components/LoginForm.vue?vue&type=template&id=b397ab9e&":
/*!************************************************************************!*\
  !*** ./src/js/components/LoginForm.vue?vue&type=template&id=b397ab9e& ***!
  \************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_LoginForm_vue_vue_type_template_id_b397ab9e___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib??vue-loader-options!./LoginForm.vue?vue&type=template&id=b397ab9e& */ \"./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/LoginForm.vue?vue&type=template&id=b397ab9e&\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_LoginForm_vue_vue_type_template_id_b397ab9e___WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_LoginForm_vue_vue_type_template_id_b397ab9e___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]; });\n\n\n\n//# sourceURL=webpack:///./src/js/components/LoginForm.vue?");

/***/ }),

/***/ "./src/js/components/form/File.vue":
/*!*****************************************!*\
  !*** ./src/js/components/form/File.vue ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _File_vue_vue_type_template_id_5191c18b___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./File.vue?vue&type=template&id=5191c18b& */ \"./src/js/components/form/File.vue?vue&type=template&id=5191c18b&\");\n/* harmony import */ var _File_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./File.vue?vue&type=script&lang=js& */ \"./src/js/components/form/File.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _File_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _File_vue_vue_type_template_id_5191c18b___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _File_vue_vue_type_template_id_5191c18b___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"src/js/components/form/File.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);\n\n//# sourceURL=webpack:///./src/js/components/form/File.vue?");

/***/ }),

/***/ "./src/js/components/form/File.vue?vue&type=script&lang=js&":
/*!******************************************************************!*\
  !*** ./src/js/components/form/File.vue?vue&type=script&lang=js& ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_File_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib!../../../../node_modules/vue-loader/lib??vue-loader-options!./File.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js?!./src/js/components/form/File.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_File_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); \n\n//# sourceURL=webpack:///./src/js/components/form/File.vue?");

/***/ }),

/***/ "./src/js/components/form/File.vue?vue&type=template&id=5191c18b&":
/*!************************************************************************!*\
  !*** ./src/js/components/form/File.vue?vue&type=template&id=5191c18b& ***!
  \************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_File_vue_vue_type_template_id_5191c18b___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../node_modules/vue-loader/lib??vue-loader-options!./File.vue?vue&type=template&id=5191c18b& */ \"./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/form/File.vue?vue&type=template&id=5191c18b&\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_File_vue_vue_type_template_id_5191c18b___WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_File_vue_vue_type_template_id_5191c18b___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]; });\n\n\n\n//# sourceURL=webpack:///./src/js/components/form/File.vue?");

/***/ }),

/***/ "./src/js/components/form/ImageIterator.vue":
/*!**************************************************!*\
  !*** ./src/js/components/form/ImageIterator.vue ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ImageIterator_vue_vue_type_template_id_9d90412c___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageIterator.vue?vue&type=template&id=9d90412c& */ \"./src/js/components/form/ImageIterator.vue?vue&type=template&id=9d90412c&\");\n/* harmony import */ var _ImageIterator_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageIterator.vue?vue&type=script&lang=js& */ \"./src/js/components/form/ImageIterator.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _ImageIterator_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _ImageIterator_vue_vue_type_template_id_9d90412c___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _ImageIterator_vue_vue_type_template_id_9d90412c___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"src/js/components/form/ImageIterator.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);\n\n//# sourceURL=webpack:///./src/js/components/form/ImageIterator.vue?");

/***/ }),

/***/ "./src/js/components/form/ImageIterator.vue?vue&type=script&lang=js&":
/*!***************************************************************************!*\
  !*** ./src/js/components/form/ImageIterator.vue?vue&type=script&lang=js& ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_ImageIterator_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib!../../../../node_modules/vue-loader/lib??vue-loader-options!./ImageIterator.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js?!./src/js/components/form/ImageIterator.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_ImageIterator_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); \n\n//# sourceURL=webpack:///./src/js/components/form/ImageIterator.vue?");

/***/ }),

/***/ "./src/js/components/form/ImageIterator.vue?vue&type=template&id=9d90412c&":
/*!*********************************************************************************!*\
  !*** ./src/js/components/form/ImageIterator.vue?vue&type=template&id=9d90412c& ***!
  \*********************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_ImageIterator_vue_vue_type_template_id_9d90412c___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../node_modules/vue-loader/lib??vue-loader-options!./ImageIterator.vue?vue&type=template&id=9d90412c& */ \"./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/form/ImageIterator.vue?vue&type=template&id=9d90412c&\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_ImageIterator_vue_vue_type_template_id_9d90412c___WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_ImageIterator_vue_vue_type_template_id_9d90412c___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]; });\n\n\n\n//# sourceURL=webpack:///./src/js/components/form/ImageIterator.vue?");

/***/ }),

/***/ "./src/js/components/form/MultiSelect.vue":
/*!************************************************!*\
  !*** ./src/js/components/form/MultiSelect.vue ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _MultiSelect_vue_vue_type_template_id_a401e754___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MultiSelect.vue?vue&type=template&id=a401e754& */ \"./src/js/components/form/MultiSelect.vue?vue&type=template&id=a401e754&\");\n/* harmony import */ var _MultiSelect_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MultiSelect.vue?vue&type=script&lang=js& */ \"./src/js/components/form/MultiSelect.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _MultiSelect_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _MultiSelect_vue_vue_type_template_id_a401e754___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _MultiSelect_vue_vue_type_template_id_a401e754___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"src/js/components/form/MultiSelect.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);\n\n//# sourceURL=webpack:///./src/js/components/form/MultiSelect.vue?");

/***/ }),

/***/ "./src/js/components/form/MultiSelect.vue?vue&type=script&lang=js&":
/*!*************************************************************************!*\
  !*** ./src/js/components/form/MultiSelect.vue?vue&type=script&lang=js& ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_MultiSelect_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib!../../../../node_modules/vue-loader/lib??vue-loader-options!./MultiSelect.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js?!./src/js/components/form/MultiSelect.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_MultiSelect_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); \n\n//# sourceURL=webpack:///./src/js/components/form/MultiSelect.vue?");

/***/ }),

/***/ "./src/js/components/form/MultiSelect.vue?vue&type=template&id=a401e754&":
/*!*******************************************************************************!*\
  !*** ./src/js/components/form/MultiSelect.vue?vue&type=template&id=a401e754& ***!
  \*******************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_MultiSelect_vue_vue_type_template_id_a401e754___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../node_modules/vue-loader/lib??vue-loader-options!./MultiSelect.vue?vue&type=template&id=a401e754& */ \"./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/form/MultiSelect.vue?vue&type=template&id=a401e754&\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_MultiSelect_vue_vue_type_template_id_a401e754___WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_MultiSelect_vue_vue_type_template_id_a401e754___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]; });\n\n\n\n//# sourceURL=webpack:///./src/js/components/form/MultiSelect.vue?");

/***/ }),

/***/ "./src/js/components/form/Select.vue":
/*!*******************************************!*\
  !*** ./src/js/components/form/Select.vue ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Select_vue_vue_type_template_id_b5f5816a___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Select.vue?vue&type=template&id=b5f5816a& */ \"./src/js/components/form/Select.vue?vue&type=template&id=b5f5816a&\");\n/* harmony import */ var _Select_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Select.vue?vue&type=script&lang=js& */ \"./src/js/components/form/Select.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _Select_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _Select_vue_vue_type_template_id_b5f5816a___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _Select_vue_vue_type_template_id_b5f5816a___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"src/js/components/form/Select.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);\n\n//# sourceURL=webpack:///./src/js/components/form/Select.vue?");

/***/ }),

/***/ "./src/js/components/form/Select.vue?vue&type=script&lang=js&":
/*!********************************************************************!*\
  !*** ./src/js/components/form/Select.vue?vue&type=script&lang=js& ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_Select_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib!../../../../node_modules/vue-loader/lib??vue-loader-options!./Select.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js?!./src/js/components/form/Select.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_Select_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); \n\n//# sourceURL=webpack:///./src/js/components/form/Select.vue?");

/***/ }),

/***/ "./src/js/components/form/Select.vue?vue&type=template&id=b5f5816a&":
/*!**************************************************************************!*\
  !*** ./src/js/components/form/Select.vue?vue&type=template&id=b5f5816a& ***!
  \**************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Select_vue_vue_type_template_id_b5f5816a___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../node_modules/vue-loader/lib??vue-loader-options!./Select.vue?vue&type=template&id=b5f5816a& */ \"./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/js/components/form/Select.vue?vue&type=template&id=b5f5816a&\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Select_vue_vue_type_template_id_b5f5816a___WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Select_vue_vue_type_template_id_b5f5816a___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]; });\n\n\n\n//# sourceURL=webpack:///./src/js/components/form/Select.vue?");

/***/ }),

/***/ "./src/js/moduels.js":
/*!***************************!*\
  !*** ./src/js/moduels.js ***!
  \***************************/
/*! exports provided: main */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"main\", function() { return main; });\n/* harmony import */ var _modules_forms_main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/forms/main */ \"./src/js/modules/forms/main.js\");\n/* harmony import */ var _modules_menu_main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/menu/main */ \"./src/js/modules/menu/main.js\");\n/* harmony import */ var _modules_header_main__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/header/main */ \"./src/js/modules/header/main.js\");\n/* harmony import */ var _modules_filemanager_main__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/filemanager/main */ \"./src/js/modules/filemanager/main.js\");\n// Pure JS main file\n\n\n\n\n\nvar main = function main() {\n  Object(_modules_forms_main__WEBPACK_IMPORTED_MODULE_0__[\"formsModule\"])();\n  Object(_modules_menu_main__WEBPACK_IMPORTED_MODULE_1__[\"menuModule\"])();\n  Object(_modules_header_main__WEBPACK_IMPORTED_MODULE_2__[\"headerModule\"])();\n  Object(_modules_filemanager_main__WEBPACK_IMPORTED_MODULE_3__[\"filemanagerModule\"])();\n};\n\n\n\n//# sourceURL=webpack:///./src/js/moduels.js?");

/***/ }),

/***/ "./src/js/modules/filemanager/events.js":
/*!**********************************************!*\
  !*** ./src/js/modules/filemanager/events.js ***!
  \**********************************************/
/*! exports provided: lfm */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lfm\", function() { return lfm; });\nvar lfm = function lfm(options, cb) {\n  var route_prefix = options && options.prefix ? options.prefix : '/laravel-filemanager';\n  window.open(route_prefix + '?type=' + options.type || 'file', 'FileManager', 'width=1200,height=900');\n  window.SetUrl = cb;\n};\n\n\n\n//# sourceURL=webpack:///./src/js/modules/filemanager/events.js?");

/***/ }),

/***/ "./src/js/modules/filemanager/listeners.js":
/*!*************************************************!*\
  !*** ./src/js/modules/filemanager/listeners.js ***!
  \*************************************************/
/*! exports provided: listeners */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"listeners\", function() { return listeners; });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events */ \"./src/js/modules/filemanager/events.js\");\n\n\nvar listeners = function listeners() {\n  managerOpen();\n};\n\nvar managerOpen = function managerOpen() {\n  var items = document.querySelectorAll('.js-manager-open');\n\n  for (var i = 0; i < items.length; i++) {\n    items[i].addEventListener('click', function () {\n      console.log(this);\n      console.log(this.nextSibling);\n      Object(_events__WEBPACK_IMPORTED_MODULE_0__[\"lfm\"])({\n        type: 'image',\n        prefix: '/laravel-filemanager'\n      }, function (url, path) {\n        console.log(url);\n        console.log(path);\n      });\n      console.log(123);\n    });\n  }\n};\n\n\n\n//# sourceURL=webpack:///./src/js/modules/filemanager/listeners.js?");

/***/ }),

/***/ "./src/js/modules/filemanager/main.js":
/*!********************************************!*\
  !*** ./src/js/modules/filemanager/main.js ***!
  \********************************************/
/*! exports provided: filemanagerModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"filemanagerModule\", function() { return filemanagerModule; });\n/* harmony import */ var _listeners__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./listeners */ \"./src/js/modules/filemanager/listeners.js\");\n\n\nvar filemanagerModule = function filemanagerModule() {\n  Object(_listeners__WEBPACK_IMPORTED_MODULE_0__[\"listeners\"])();\n};\n\n\n\n//# sourceURL=webpack:///./src/js/modules/filemanager/main.js?");

/***/ }),

/***/ "./src/js/modules/forms/events.js":
/*!****************************************!*\
  !*** ./src/js/modules/forms/events.js ***!
  \****************************************/
/*! exports provided: tabChange */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tabChange\", function() { return tabChange; });\nvar tabChange = function tabChange() {\n  var tabTitles = document.querySelectorAll('.content-wrapper__tab');\n\n  for (var i = 0; i < tabTitles.length; i++) {\n    tabTitles[i].classList.remove('tab-active');\n  }\n\n  this.classList.add('tab-active');\n  var tabs = document.querySelectorAll('.content-wrapper__tab-form');\n\n  for (var _i = 0; _i < tabs.length; _i++) {\n    tabs[_i].style.display = 'none';\n  }\n\n  var active = document.querySelectorAll('.content-wrapper__tab-form[data-tab=\"' + this.dataset.tab + '\"]')[0];\n  active.style.display = 'block';\n};\n\n\n\n//# sourceURL=webpack:///./src/js/modules/forms/events.js?");

/***/ }),

/***/ "./src/js/modules/forms/listeners.js":
/*!*******************************************!*\
  !*** ./src/js/modules/forms/listeners.js ***!
  \*******************************************/
/*! exports provided: listeners */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"listeners\", function() { return listeners; });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events */ \"./src/js/modules/forms/events.js\");\n\n\nvar listeners = function listeners() {\n  tabs();\n};\n\nvar tabs = function tabs() {\n  var items = document.querySelectorAll('.js-tab-change');\n\n  for (var i = 0; i < items.length; i++) {\n    items[i].addEventListener('click', _events__WEBPACK_IMPORTED_MODULE_0__[\"tabChange\"]);\n  }\n};\n\n\n\n//# sourceURL=webpack:///./src/js/modules/forms/listeners.js?");

/***/ }),

/***/ "./src/js/modules/forms/main.js":
/*!**************************************!*\
  !*** ./src/js/modules/forms/main.js ***!
  \**************************************/
/*! exports provided: formsModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formsModule\", function() { return formsModule; });\n/* harmony import */ var _listeners__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./listeners */ \"./src/js/modules/forms/listeners.js\");\n\n\nvar formsModule = function formsModule() {\n  Object(_listeners__WEBPACK_IMPORTED_MODULE_0__[\"listeners\"])();\n};\n\n\n\n//# sourceURL=webpack:///./src/js/modules/forms/main.js?");

/***/ }),

/***/ "./src/js/modules/forms/redactor.js":
/*!******************************************!*\
  !*** ./src/js/modules/forms/redactor.js ***!
  \******************************************/
/*! exports provided: CKEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CKEditor\", function() { return CKEditor; });\n// onload\nvar CKEditor = function CKEditor() {\n  window.tinymce.init({\n    selector: '.js-redactor'\n  });\n};\n\n\n\n//# sourceURL=webpack:///./src/js/modules/forms/redactor.js?");

/***/ }),

/***/ "./src/js/modules/header/events.js":
/*!*****************************************!*\
  !*** ./src/js/modules/header/events.js ***!
  \*****************************************/
/*! exports provided: logout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"logout\", function() { return logout; });\nvar logout = function logout() {\n  document.getElementById('logout-form').submit();\n};\n\n\n\n//# sourceURL=webpack:///./src/js/modules/header/events.js?");

/***/ }),

/***/ "./src/js/modules/header/listeners.js":
/*!********************************************!*\
  !*** ./src/js/modules/header/listeners.js ***!
  \********************************************/
/*! exports provided: listeners */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"listeners\", function() { return listeners; });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events */ \"./src/js/modules/header/events.js\");\n\n\nvar listeners = function listeners() {\n  logoutListener();\n};\n\nvar logoutListener = function logoutListener() {\n  var button = document.getElementsByClassName('js-logout')[0];\n  if (button) button.addEventListener('click', _events__WEBPACK_IMPORTED_MODULE_0__[\"logout\"]);\n};\n\n\n\n//# sourceURL=webpack:///./src/js/modules/header/listeners.js?");

/***/ }),

/***/ "./src/js/modules/header/main.js":
/*!***************************************!*\
  !*** ./src/js/modules/header/main.js ***!
  \***************************************/
/*! exports provided: headerModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"headerModule\", function() { return headerModule; });\n/* harmony import */ var _listeners__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./listeners */ \"./src/js/modules/header/listeners.js\");\n\n\nvar headerModule = function headerModule() {\n  Object(_listeners__WEBPACK_IMPORTED_MODULE_0__[\"listeners\"])();\n};\n\n\n\n//# sourceURL=webpack:///./src/js/modules/header/main.js?");

/***/ }),

/***/ "./src/js/modules/menu/events.js":
/*!***************************************!*\
  !*** ./src/js/modules/menu/events.js ***!
  \***************************************/
/*! exports provided: menuToggle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"menuToggle\", function() { return menuToggle; });\nvar menuToggle = function menuToggle() {\n  var id = this.dataset.toggle;\n  var children = document.querySelector('.js-menu-item-toggle[data-toggle=\"' + id + '\"]');\n  children.style.display = children.style.display === 'flex' ? 'none' : 'flex';\n};\n\n\n\n//# sourceURL=webpack:///./src/js/modules/menu/events.js?");

/***/ }),

/***/ "./src/js/modules/menu/listeners.js":
/*!******************************************!*\
  !*** ./src/js/modules/menu/listeners.js ***!
  \******************************************/
/*! exports provided: listeners */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"listeners\", function() { return listeners; });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events */ \"./src/js/modules/menu/events.js\");\n\n\nvar listeners = function listeners() {\n  menuItem();\n};\n\nvar menuItem = function menuItem() {\n  var items = document.querySelectorAll('.js-menu-item');\n\n  for (var i = 0; i < items.length; i++) {\n    items[i].addEventListener('click', _events__WEBPACK_IMPORTED_MODULE_0__[\"menuToggle\"]);\n  }\n};\n\n\n\n//# sourceURL=webpack:///./src/js/modules/menu/listeners.js?");

/***/ }),

/***/ "./src/js/modules/menu/main.js":
/*!*************************************!*\
  !*** ./src/js/modules/menu/main.js ***!
  \*************************************/
/*! exports provided: menuModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"menuModule\", function() { return menuModule; });\n/* harmony import */ var _listeners__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./listeners */ \"./src/js/modules/menu/listeners.js\");\n\n\nvar menuModule = function menuModule() {\n  Object(_listeners__WEBPACK_IMPORTED_MODULE_0__[\"listeners\"])();\n};\n\n\n\n//# sourceURL=webpack:///./src/js/modules/menu/main.js?");

/***/ }),

/***/ "./src/js/modules/onload.js":
/*!**********************************!*\
  !*** ./src/js/modules/onload.js ***!
  \**********************************/
/*! exports provided: onload */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onload\", function() { return onload; });\n/* harmony import */ var _forms_redactor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./forms/redactor */ \"./src/js/modules/forms/redactor.js\");\n\n\nvar onload = function onload() {\n  Object(_forms_redactor__WEBPACK_IMPORTED_MODULE_0__[\"CKEditor\"])();\n};\n\n\n\n//# sourceURL=webpack:///./src/js/modules/onload.js?");

/***/ }),

/***/ 0:
/*!*********************************************************!*\
  !*** multi regenerator-runtime/runtime ./src/js/app.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! regenerator-runtime/runtime */\"./node_modules/regenerator-runtime/runtime.js\");\nmodule.exports = __webpack_require__(/*! ./src/js/app.js */\"./src/js/app.js\");\n\n\n//# sourceURL=webpack:///multi_regenerator-runtime/runtime_./src/js/app.js?");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJhcHAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKHtcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPyEuL3NyYy9qcy9jb21wb25lbnRzL0xvZ2luRm9ybS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9qcy9jb21wb25lbnRzL0xvZ2luRm9ybS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1xcXCJkZWZhdWx0XFxcIl0gPSAoe1xcbiAgbmFtZTogXFxcIkxvZ2luRm9ybVxcXCIsXFxuICBwcm9wczogWydtZXRob2QnLCAncm91dGUnLCAnc2VydmVyRXJyb3JzJywgJ2lucHV0cyddLFxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBlbWFpbDogbnVsbCxcXG4gICAgICBwYXNzd29yZDogbnVsbCxcXG4gICAgICB0b2tlbjogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVxcXCJjc3JmLXRva2VuXFxcIl0nKS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKVxcbiAgICB9O1xcbiAgfSxcXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XFxuICAgIHRoaXMuZW1haWwgPSB0aGlzLmlucHV0c0pzb25QYXJzZS5lbWFpbDtcXG4gICAgdGhpcy4kdmFsaWRhdG9yLnBhdXNlKCk7XFxuICB9LFxcbiAgbWV0aG9kczoge1xcbiAgICBjaGVja0Zvcm06IGZ1bmN0aW9uIGNoZWNrRm9ybShlKSB7XFxuICAgICAgdGhpcy4kdmFsaWRhdG9yLnJlc3VtZSgpO1xcbiAgICAgIHRoaXMuJHZhbGlkYXRvci52YWxpZGF0ZUFsbCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xcbiAgICAgICAgaWYgKHJlc3VsdCkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH0sXFxuICBjb21wdXRlZDoge1xcbiAgICBlcnJvcnNKc29uUGFyc2U6IGZ1bmN0aW9uIGVycm9yc0pzb25QYXJzZSgpIHtcXG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLnNlcnZlckVycm9ycyk7XFxuICAgIH0sXFxuICAgIGlucHV0c0pzb25QYXJzZTogZnVuY3Rpb24gaW5wdXRzSnNvblBhcnNlKCkge1xcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuaW5wdXRzKTtcXG4gICAgfVxcbiAgfVxcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL0xvZ2luRm9ybS52dWU/Li9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPyEuL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vRmlsZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vRmlsZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9ICh7XFxuICBuYW1lOiBcXFwiRmlsZVxcXCIsXFxuICBwcm9wczogWyduYW1lJywgJ2RlZmF1bHQnXSxcXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgZmlsZVVybDogdGhpc1tcXFwiZGVmYXVsdFxcXCJdID8gdGhpc1tcXFwiZGVmYXVsdFxcXCJdIDogJycsXFxuICAgICAgZmlsZU5hbWU6ICcnXFxuICAgIH07XFxuICB9LFxcbiAgbWV0aG9kczoge1xcbiAgICBsZm06IGZ1bmN0aW9uIGxmbShvcHRpb25zLCBjYikge1xcbiAgICAgIHZhciByb3V0ZV9wcmVmaXggPSBvcHRpb25zICYmIG9wdGlvbnMucHJlZml4ID8gb3B0aW9ucy5wcmVmaXggOiAnL2xhcmF2ZWwtZmlsZW1hbmFnZXInO1xcbiAgICAgIHdpbmRvdy5vcGVuKHJvdXRlX3ByZWZpeCArICc/dHlwZT0nICsgb3B0aW9ucy50eXBlIHx8ICdmaWxlJywgJ0ZpbGVNYW5hZ2VyJywgJ3dpZHRoPTEyMDAsaGVpZ2h0PTkwMCcpO1xcbiAgICAgIHdpbmRvdy5TZXRVcmwgPSBjYjtcXG4gICAgfSxcXG4gICAgb3Blbk1hbmFnZXI6IGZ1bmN0aW9uIG9wZW5NYW5hZ2VyKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy5sZm0oe1xcbiAgICAgICAgdHlwZTogJ2ltYWdlJ1xcbiAgICAgIH0sIGZ1bmN0aW9uICh1cmwsIHBhdGgpIHtcXG4gICAgICAgIF90aGlzLmZpbGVVcmwgPSB1cmxbMF0udXJsO1xcbiAgICAgICAgX3RoaXMuZmlsZU5hbWUgPSB1cmxbMF0ubmFtZTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfSxcXG4gIGNvbXB1dGVkOiB7XFxuICAgIHVybDogZnVuY3Rpb24gdXJsKCkge1xcbiAgICAgIHJldHVybiB0aGlzLmZpbGVVcmwgPyB0aGlzLmZpbGVVcmwucmVwbGFjZSgvXi4qXFxcXC9cXFxcL1teXFxcXC9dKy8sICcnKSA6ICcnO1xcbiAgICB9XFxuICB9XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9GaWxlLnZ1ZT8uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnNcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/IS4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9JbWFnZUl0ZXJhdG9yLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9JbWFnZUl0ZXJhdG9yLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyYgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9GaWxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL0ZpbGUgKi8gXFxcIi4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9GaWxlLnZ1ZVxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVkcmFnZ2FibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHZ1ZWRyYWdnYWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdnVlZHJhZ2dhYmxlL2Rpc3QvdnVlZHJhZ2dhYmxlLmNvbW1vbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVkcmFnZ2FibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih2dWVkcmFnZ2FibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG5cXG5cXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9ICh7XFxuICBjb21wb25lbnRzOiB7XFxuICAgIEZpbGU6IF9GaWxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSxcXG4gICAgZHJhZ2dhYmxlOiB2dWVkcmFnZ2FibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0LmFcXG4gIH0sXFxuICBwcm9wczogWydkZWZhdWx0J10sXFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGltYWdlczogSlNPTi5wYXJzZSh0aGlzW1xcXCJkZWZhdWx0XFxcIl0pLFxcbiAgICAgIGN1cnJlbnRJbmRleDogMVxcbiAgICB9O1xcbiAgfSxcXG4gIG1ldGhvZHM6IHtcXG4gICAgYWRkSXRlcmF0ZTogZnVuY3Rpb24gYWRkSXRlcmF0ZSgpIHtcXG4gICAgICB0aGlzLmN1cnJlbnRJbmRleCsrO1xcbiAgICAgIHRoaXMuaW1hZ2VzLnB1c2goe1xcbiAgICAgICAgaWQ6IHRoaXMuY3VycmVudEluZGV4XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIHJlbW92ZUl0ZXJhdGU6IGZ1bmN0aW9uIHJlbW92ZUl0ZXJhdGUoaW5kZXgpIHtcXG4gICAgICB0aGlzLmltYWdlcy5zcGxpY2UoaW5kZXgsIDEpO1xcbiAgICB9XFxuICB9LFxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcXG4gICAgaWYgKHRoaXMuaW1hZ2VzLmxlbmd0aCA+IDApIHRoaXMuY3VycmVudEluZGV4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdGhpcy5pbWFnZXMubWFwKGZ1bmN0aW9uIChvKSB7XFxuICAgICAgcmV0dXJuIG8uaWQ7XFxuICAgIH0pKTtcXG4gIH0sXFxuICBuYW1lOiBcXFwiSW1hZ2VJdGVyYXRvclxcXCJcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL0ltYWdlSXRlcmF0b3IudnVlPy4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9uc1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8hLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL011bHRpU2VsZWN0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vTXVsdGlTZWxlY3QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJiAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9zZWFyY2hfc2VsZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB2dWUtc2VhcmNoLXNlbGVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdnVlLXNlYXJjaC1zZWxlY3QvcHVibGlzaC92dWUtc2VhcmNoLXNlbGVjdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfc2VhcmNoX3NlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHZ1ZV9zZWFyY2hfc2VsZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcblxcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcXFwiZGVmYXVsdFxcXCJdID0gKHtcXG4gIHByb3BzOiBbJ2l0ZW1zJywgJ3ZhbHVlJywgJ3RleHQnLCAnbmFtZScsICdkZWZhdWx0J10sXFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGRhdGE6IEpTT04ucGFyc2UodGhpcy5pdGVtcyksXFxuICAgICAgc2VhcmNoVGV4dDogJycsXFxuICAgICAgc2VsZWN0ZWRJdGVtczogW10sXFxuICAgICAgbGFzdFNlbGVjdEl0ZW06IHt9XFxuICAgIH07XFxuICB9LFxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcXG4gICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgaWYgKHRoaXNbXFxcImRlZmF1bHRcXFwiXSkge1xcbiAgICAgIChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgZGVmID0gSlNPTi5wYXJzZShfdGhpc1tcXFwiZGVmYXVsdFxcXCJdKTtcXG5cXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlZikpIHtcXG4gICAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3Aoa2V5KSB7XFxuICAgICAgICAgICAgY29uc29sZS5sb2coZGVmW2tleV0pO1xcblxcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IF90aGlzLmRhdGEuZmlsdGVyKGZ1bmN0aW9uIChvYmopIHtcXG4gICAgICAgICAgICAgIHJldHVybiBvYmpbX3RoaXMudmFsdWVdID09IGRlZltrZXldO1xcbiAgICAgICAgICAgIH0pWzBdO1xcblxcbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xcbiAgICAgICAgICAgICAgX3RoaXMuc2VsZWN0ZWRJdGVtcy5wdXNoKGZvdW5kKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH07XFxuXFxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBkZWYpIHtcXG4gICAgICAgICAgICBfbG9vcChrZXkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBfdGhpcy5zZWxlY3RlZEl0ZW1zLnB1c2goZGVmKTtcXG4gICAgICAgIH1cXG4gICAgICB9KSgpO1xcbiAgICB9XFxuICB9LFxcbiAgbWV0aG9kczoge1xcbiAgICBvblNlbGVjdDogZnVuY3Rpb24gb25TZWxlY3QoaXRlbXMsIGxhc3RTZWxlY3RJdGVtKSB7XFxuICAgICAgdGhpcy5zZWxlY3RlZEl0ZW1zID0gaXRlbXM7XFxuICAgICAgdGhpcy5sYXN0U2VsZWN0SXRlbSA9IGxhc3RTZWxlY3RJdGVtO1xcbiAgICB9XFxuICB9LFxcbiAgY29tcG9uZW50czoge1xcbiAgICBNdWx0aUxpc3RTZWxlY3Q6IHZ1ZV9zZWFyY2hfc2VsZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIk11bHRpTGlzdFNlbGVjdFxcXCJdXFxuICB9XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9NdWx0aVNlbGVjdC52dWU/Li9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPyEuL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vU2VsZWN0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL1NlbGVjdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9zZWFyY2hfc2VsZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB2dWUtc2VhcmNoLXNlbGVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdnVlLXNlYXJjaC1zZWxlY3QvcHVibGlzaC92dWUtc2VhcmNoLXNlbGVjdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfc2VhcmNoX3NlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHZ1ZV9zZWFyY2hfc2VsZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcbi8vXFxuLy9cXG4vL1xcblxcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcXFwiZGVmYXVsdFxcXCJdID0gKHtcXG4gIHByb3BzOiBbJ2l0ZW1zJywgJ3ZhbHVlJywgJ3RleHQnLCAnbmFtZScsICdkZWZhdWx0J10sXFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGRhdGE6IEpTT04ucGFyc2UodGhpcy5pdGVtcyksXFxuICAgICAgb2JqZWN0SXRlbToge31cXG4gICAgfTtcXG4gIH0sXFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICB0aGlzLm9iamVjdEl0ZW0gPSB0aGlzLmRhdGFbMF07XFxuXFxuICAgIGlmICh0aGlzW1xcXCJkZWZhdWx0XFxcIl0pIHtcXG4gICAgICB0aGlzLm9iamVjdEl0ZW0gPSB0aGlzLmRhdGEuZmlsdGVyKGZ1bmN0aW9uIChvYmopIHtcXG4gICAgICAgIHJldHVybiBvYmpbX3RoaXMudmFsdWVdID09IF90aGlzW1xcXCJkZWZhdWx0XFxcIl07XFxuICAgICAgfSlbMF07XFxuICAgIH1cXG4gIH0sXFxuICBjb21wb25lbnRzOiB7XFxuICAgIE1vZGVsTGlzdFNlbGVjdDogdnVlX3NlYXJjaF9zZWxlY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiTW9kZWxMaXN0U2VsZWN0XFxcIl1cXG4gIH1cXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL1NlbGVjdC52dWU/Li9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcXG5cXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcXG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXFxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cXG5cXG52YXIgY2FjaGVkU2V0VGltZW91dDtcXG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xcblxcbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xcbn1cXG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcXG59XFxuKGZ1bmN0aW9uICgpIHtcXG4gICAgdHJ5IHtcXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcXG4gICAgICAgIH1cXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xcbiAgICAgICAgfVxcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xcbiAgICB9XFxufSAoKSlcXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXFxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xcbiAgICB9XFxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XFxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXFxuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xcbiAgICB9IGNhdGNoKGUpe1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XFxuICAgICAgICB9IGNhdGNoKGUpe1xcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuXFxufVxcbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcXG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XFxuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcXG4gICAgfVxcbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXFxuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XFxuICAgIH0gY2F0Y2ggKGUpe1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XFxuICAgICAgICB9IGNhdGNoIChlKXtcXG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG5cXG5cXG59XFxudmFyIHF1ZXVlID0gW107XFxudmFyIGRyYWluaW5nID0gZmFsc2U7XFxudmFyIGN1cnJlbnRRdWV1ZTtcXG52YXIgcXVldWVJbmRleCA9IC0xO1xcblxcbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcXG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcXG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcXG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XFxuICAgIH1cXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xcbiAgICB9XFxufVxcblxcbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XFxuICAgIGlmIChkcmFpbmluZykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xcbiAgICBkcmFpbmluZyA9IHRydWU7XFxuXFxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XFxuICAgIHdoaWxlKGxlbikge1xcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XFxuICAgICAgICBxdWV1ZSA9IFtdO1xcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcXG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcXG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcXG4gICAgfVxcbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XFxufVxcblxcbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XFxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XFxuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XFxuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xcbiAgICB9XFxufTtcXG5cXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXFxuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XFxuICAgIHRoaXMuZnVuID0gZnVuO1xcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XFxufVxcbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XFxufTtcXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XFxucHJvY2Vzcy5lbnYgPSB7fTtcXG5wcm9jZXNzLmFyZ3YgPSBbXTtcXG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcXG5wcm9jZXNzLnZlcnNpb25zID0ge307XFxuXFxuZnVuY3Rpb24gbm9vcCgpIHt9XFxuXFxucHJvY2Vzcy5vbiA9IG5vb3A7XFxucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XFxucHJvY2Vzcy5vbmNlID0gbm9vcDtcXG5wcm9jZXNzLm9mZiA9IG5vb3A7XFxucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XFxucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XFxucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XFxuXFxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxcblxcbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcXG59O1xcblxcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XFxucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcXG59O1xcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiLyoqXFxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXFxuICpcXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXFxuICovXFxuXFxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XFxuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XFxuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiA/IFN5bWJvbCA6IHt9O1xcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcXFwiQEBpdGVyYXRvclxcXCI7XFxuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcXFwiQEBhc3luY0l0ZXJhdG9yXFxcIjtcXG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXFxcIkBAdG9TdHJpbmdUYWdcXFwiO1xcblxcbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XFxuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XFxuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xcblxcbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xcblxcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xcbiAgfVxcbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcXG5cXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxcbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXFxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xcbiAgICB0cnkge1xcbiAgICAgIHJldHVybiB7IHR5cGU6IFxcXCJub3JtYWxcXFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIHJldHVybiB7IHR5cGU6IFxcXCJ0aHJvd1xcXCIsIGFyZzogZXJyIH07XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXFxcInN1c3BlbmRlZFN0YXJ0XFxcIjtcXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXFxcInN1c3BlbmRlZFlpZWxkXFxcIjtcXG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFxcXCJleGVjdXRpbmdcXFwiO1xcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXFxcImNvbXBsZXRlZFxcXCI7XFxuXFxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXFxuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXFxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xcblxcbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXFxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxcbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cXG5cXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcXG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXFxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcXG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9O1xcblxcbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXFxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXFxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXFxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XFxuICB9XFxuXFxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxcbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XFxuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcXG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XFxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXFxcIkdlbmVyYXRvckZ1bmN0aW9uXFxcIjtcXG5cXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXFxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxcbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xcbiAgICBbXFxcIm5leHRcXFwiLCBcXFwidGhyb3dcXFwiLCBcXFwicmV0dXJuXFxcIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcXG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XFxuICAgICAgfTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcXG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcXG4gICAgcmV0dXJuIGN0b3JcXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXFxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXFxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcXFwiR2VuZXJhdG9yRnVuY3Rpb25cXFwiXFxuICAgICAgOiBmYWxzZTtcXG4gIH07XFxuXFxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcXG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XFxuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFxcXCJHZW5lcmF0b3JGdW5jdGlvblxcXCI7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcXG4gICAgcmV0dXJuIGdlbkZ1bjtcXG4gIH07XFxuXFxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFxcXCJfX2F3YWl0XFxcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcXG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcXG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcXG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XFxuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XFxuICAgICAgICBpZiAodmFsdWUgJiZcXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFxcXCJvYmplY3RcXFwiICYmXFxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFxcXCJfX2F3YWl0XFxcIikpIHtcXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAgICAgICAgaW52b2tlKFxcXCJuZXh0XFxcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XFxuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xcbiAgICAgICAgICAgIGludm9rZShcXFwidGhyb3dcXFwiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcXG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXFxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxcbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XFxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcXG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XFxuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXFxuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcXFwidGhyb3dcXFwiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xcblxcbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XFxuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XFxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XFxuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cXG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcXG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXFxuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XFxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXFxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXFxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xcbiAgICB9XFxuXFxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxcbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xcbiAgfVxcblxcbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcXG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH07XFxuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xcblxcbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXFxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXFxuICAgICk7XFxuXFxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxcbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XFxuICAgICAgICB9KTtcXG4gIH07XFxuXFxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcXG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcXG5cXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1xcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XFxuICAgICAgICBpZiAobWV0aG9kID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICAgIHRocm93IGFyZztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XFxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXFxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcXG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcXG5cXG4gICAgICB3aGlsZSAodHJ1ZSkge1xcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcXG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcXG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XFxuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcXG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXFxcIm5leHRcXFwiKSB7XFxuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxcbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XFxuXFxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XFxuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XFxuXFxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcXFwicmV0dXJuXFxcIikge1xcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcXFwicmV0dXJuXFxcIiwgY29udGV4dC5hcmcpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcXG5cXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcXG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcIm5vcm1hbFxcXCIpIHtcXG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxcbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXFxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXFxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcXG5cXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxcbiAgICAgICAgICB9O1xcblxcbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXFxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXFxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcInRocm93XFxcIjtcXG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcXG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcXG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XFxuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcXG5cXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgIC8vIE5vdGU6IFtcXFwicmV0dXJuXFxcIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1xcXCJyZXR1cm5cXFwiXSkge1xcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXFxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwicmV0dXJuXFxcIjtcXG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XFxuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xcblxcbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxcbiAgICAgICAgICAgIC8vIFxcXCJyZXR1cm5cXFwiIHRvIFxcXCJ0aHJvd1xcXCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXFxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcInRocm93XFxcIjtcXG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcXG4gICAgICAgICAgXFxcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgIH1cXG5cXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcXG5cXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwidGhyb3dcXFwiO1xcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgfVxcblxcbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XFxuXFxuICAgIGlmICghIGluZm8pIHtcXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJ0aHJvd1xcXCI7XFxuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxcXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFxcXCIpO1xcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICB9XFxuXFxuICAgIGlmIChpbmZvLmRvbmUpIHtcXG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXFxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XFxuXFxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxcbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XFxuXFxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFxcXCJ0aHJvd1xcXCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXFxcIm5leHRcXFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cXG4gICAgICAvLyBcXFwiY29uc3VtZWRcXFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXFxuICAgICAgLy8gXFxcInJldHVyblxcXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXFxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxcbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXFxcInJldHVyblxcXCIpIHtcXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcIm5leHRcXFwiO1xcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XFxuICAgICAgfVxcblxcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cXG4gICAgICByZXR1cm4gaW5mbztcXG4gICAgfVxcblxcbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxcbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcXG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICB9XFxuXFxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxcbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcXG5cXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFxcXCJHZW5lcmF0b3JcXFwiO1xcblxcbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXFxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXFxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH07XFxuXFxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gXFxcIltvYmplY3QgR2VuZXJhdG9yXVxcXCI7XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcXG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcXG5cXG4gICAgaWYgKDEgaW4gbG9jcykge1xcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcXG4gICAgfVxcblxcbiAgICBpZiAoMiBpbiBsb2NzKSB7XFxuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XFxuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xcbiAgICB9XFxuXFxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcXG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XFxuICAgIHJlY29yZC50eXBlID0gXFxcIm5vcm1hbFxcXCI7XFxuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxcbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXFxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXFxcInJvb3RcXFwiIH1dO1xcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XFxuICAgIHRoaXMucmVzZXQodHJ1ZSk7XFxuICB9XFxuXFxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcXG4gICAgdmFyIGtleXMgPSBbXTtcXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xcbiAgICAgIGtleXMucHVzaChrZXkpO1xcbiAgICB9XFxuICAgIGtleXMucmV2ZXJzZSgpO1xcblxcbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxcbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcXG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcXG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcXG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XFxuICAgICAgICAgIHJldHVybiBuZXh0O1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxcbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XFxuICAgICAgcmV0dXJuIG5leHQ7XFxuICAgIH07XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XFxuICAgIGlmIChpdGVyYWJsZSkge1xcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcXG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcXG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuICAgICAgICByZXR1cm4gaXRlcmFibGU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XFxuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcXG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XFxuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XFxuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcXG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xcblxcbiAgICAgICAgICByZXR1cm4gbmV4dDtcXG4gICAgICAgIH07XFxuXFxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxcbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XFxuICB9XFxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcXG5cXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XFxuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcXG4gIH1cXG5cXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcXG5cXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcXG4gICAgICB0aGlzLnByZXYgPSAwO1xcbiAgICAgIHRoaXMubmV4dCA9IDA7XFxuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxcbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XFxuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XFxuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XFxuXFxuICAgICAgdGhpcy5tZXRob2QgPSBcXFwibmV4dFxcXCI7XFxuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XFxuXFxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XFxuXFxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XFxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcXG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcXG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcXFwidFxcXCIgJiZcXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXFxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XFxuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XFxuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcXG5cXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XFxuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XFxuICAgIH0sXFxuXFxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcXG4gICAgICBpZiAodGhpcy5kb25lKSB7XFxuICAgICAgICB0aHJvdyBleGNlcHRpb247XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcXG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcXG4gICAgICAgIHJlY29yZC50eXBlID0gXFxcInRocm93XFxcIjtcXG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XFxuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XFxuXFxuICAgICAgICBpZiAoY2F1Z2h0KSB7XFxuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXFxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcIm5leHRcXFwiO1xcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcXG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xcblxcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXFxcInJvb3RcXFwiKSB7XFxuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXFxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xcbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxcbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFxcXCJlbmRcXFwiKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XFxuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcXFwiY2F0Y2hMb2NcXFwiKTtcXG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXFxcImZpbmFsbHlMb2NcXFwiKTtcXG5cXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcXFwiKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XFxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcXFwiZmluYWxseUxvY1xcXCIpICYmXFxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXFxuICAgICAgICAgICh0eXBlID09PSBcXFwiYnJlYWtcXFwiIHx8XFxuICAgICAgICAgICB0eXBlID09PSBcXFwiY29udGludWVcXFwiKSAmJlxcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcXG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcXG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xcblxcbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcXG4gICAgICAgIHRoaXMubWV0aG9kID0gXFxcIm5leHRcXFwiO1xcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XFxuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcXG4gICAgfSxcXG5cXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcImJyZWFrXFxcIiB8fFxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXFxcImNvbnRpbnVlXFxcIikge1xcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcXG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcXFwicmV0dXJuXFxcIikge1xcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcXFwicmV0dXJuXFxcIjtcXG4gICAgICAgIHRoaXMubmV4dCA9IFxcXCJlbmRcXFwiO1xcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJub3JtYWxcXFwiICYmIGFmdGVyTG9jKSB7XFxuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgIH0sXFxuXFxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcXG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XFxuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcXG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICBcXFwiY2F0Y2hcXFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XFxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcXG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XFxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiB0aHJvd247XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxcbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFxcXCIpO1xcbiAgICB9LFxcblxcbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XFxuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXFxuICAgICAgfTtcXG5cXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFxcXCJuZXh0XFxcIikge1xcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcXG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXFxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxcbiAgcmV0dXJuIGV4cG9ydHM7XFxuXFxufShcXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXFxuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cXG4gICB0cnVlID8gbW9kdWxlLmV4cG9ydHMgOiB1bmRlZmluZWRcXG4pKTtcXG5cXG50cnkge1xcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcXG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCB3ZSBjYW4gZXNjYXBlXFxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXFxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxcbiAgRnVuY3Rpb24oXFxcInJcXFwiLCBcXFwicmVnZW5lcmF0b3JSdW50aW1lID0gclxcXCIpKHJ1bnRpbWUpO1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCwgcHJvY2VzcykgeyhmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcXG4gICAgXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXFxuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XFxuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcXG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcXG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xcblxcbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcXG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcXFwiXFxcIiArIGNhbGxiYWNrKTtcXG4gICAgICB9XFxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xcbiAgICAgIH1cXG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XFxuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XFxuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XFxuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcXG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcXG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XFxuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcXG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcXG4gICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSAxOlxcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSAyOlxcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSAzOlxcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcXG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFxcXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cXFwiXFxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxcbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXFxuICAgICAgICAgICAgLy8gXFxcInRvbyBtdWNoIHJlY3Vyc2lvblxcXCIgZXJyb3IuXFxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XFxuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XFxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XFxuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XFxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XFxuICAgICAgICB9O1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXFxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcXG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcXG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcXFwiXFxcIiwgXFxcIipcXFwiKTtcXG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXFxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcXG5cXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXFxcInNldEltbWVkaWF0ZSRcXFwiICsgTWF0aC5yYW5kb20oKSArIFxcXCIkXFxcIjtcXG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXFxcInN0cmluZ1xcXCIgJiZcXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XFxuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuXFxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcXG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcXFwibWVzc2FnZVxcXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXFxcIm9ubWVzc2FnZVxcXCIsIG9uR2xvYmFsTWVzc2FnZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcXFwiKlxcXCIpO1xcbiAgICAgICAgfTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcXG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XFxuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XFxuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XFxuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcXG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XFxuICAgICAgICB9O1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XFxuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XFxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXFxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFxcXCJzY3JpcHRcXFwiKTtcXG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcXG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XFxuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcXG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcXG4gICAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XFxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XFxuICAgICAgICB9O1xcbiAgICB9XFxuXFxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxcbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XFxuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xcblxcbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXFxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXFxcIltvYmplY3QgcHJvY2Vzc11cXFwiKSB7XFxuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XFxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xcblxcbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcXG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XFxuXFxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XFxuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcXG5cXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXFxcIm9ucmVhZHlzdGF0ZWNoYW5nZVxcXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXFxcInNjcmlwdFxcXCIpKSB7XFxuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcXG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcXG5cXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xcbiAgICB9XFxuXFxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcXG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcXG59KHR5cGVvZiBzZWxmID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcXG5cXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi8uLi93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzXFxcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vLi4vcHJvY2Vzcy9icm93c2VyLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcXFwiKSkpXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zb3J0YWJsZWpzL1NvcnRhYmxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc29ydGFibGVqcy9Tb3J0YWJsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiohXFxuICogU29ydGFibGVcXG4gKiBAYXV0aG9yXFx0UnViYVhhICAgPHRyYXNoQHJ1YmF4YS5vcmc+XFxuICogQGF1dGhvclxcdG93ZW5tICAgIDxvd2VuMjMzNTVAZ21haWwuY29tPlxcbiAqIEBsaWNlbnNlIE1JVFxcbiAqL1xcblxcbihmdW5jdGlvbiBzb3J0YWJsZU1vZHVsZShmYWN0b3J5KSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdGlmICh0cnVlKSB7XFxuXFx0XFx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XFxuXFx0XFx0XFx0XFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSkpIDpcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcXG5cXHR9XFxuXFx0ZWxzZSB7fVxcbn0pKGZ1bmN0aW9uIHNvcnRhYmxlRmFjdG9yeSgpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFxcXCJ1bmRlZmluZWRcXFwiIHx8ICF3aW5kb3cuZG9jdW1lbnQpIHtcXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24gc29ydGFibGVFcnJvcigpIHtcXG5cXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoXFxcIlNvcnRhYmxlLmpzIHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFxcXCIpO1xcblxcdFxcdH07XFxuXFx0fVxcblxcblxcdHZhciBkcmFnRWwsXFxuXFx0XFx0cGFyZW50RWwsXFxuXFx0XFx0Z2hvc3RFbCxcXG5cXHRcXHRjbG9uZUVsLFxcblxcdFxcdHJvb3RFbCxcXG5cXHRcXHRuZXh0RWwsXFxuXFx0XFx0bGFzdERvd25FbCxcXG5cXG5cXHRcXHRzY3JvbGxFbCxcXG5cXHRcXHRzY3JvbGxQYXJlbnRFbCxcXG5cXHRcXHRzY3JvbGxDdXN0b21GbixcXG5cXG5cXHRcXHRvbGRJbmRleCxcXG5cXHRcXHRuZXdJbmRleCxcXG5cXHRcXHRvbGREcmFnZ2FibGVJbmRleCxcXG5cXHRcXHRuZXdEcmFnZ2FibGVJbmRleCxcXG5cXG5cXHRcXHRhY3RpdmVHcm91cCxcXG5cXHRcXHRwdXRTb3J0YWJsZSxcXG5cXG5cXHRcXHRhdXRvU2Nyb2xscyA9IFtdLFxcblxcdFxcdHNjcm9sbGluZyA9IGZhbHNlLFxcblxcblxcdFxcdGF3YWl0aW5nRHJhZ1N0YXJ0ZWQgPSBmYWxzZSxcXG5cXHRcXHRpZ25vcmVOZXh0Q2xpY2sgPSBmYWxzZSxcXG5cXHRcXHRzb3J0YWJsZXMgPSBbXSxcXG5cXG5cXHRcXHRwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCxcXG5cXHRcXHRsYXN0UG9pbnRlckVsZW1YLFxcblxcdFxcdGxhc3RQb2ludGVyRWxlbVksXFxuXFxuXFx0XFx0dGFwRXZ0LFxcblxcdFxcdHRvdWNoRXZ0LFxcblxcblxcdFxcdG1vdmVkLFxcblxcblxcblxcdFxcdGxhc3RUYXJnZXQsXFxuXFx0XFx0bGFzdERpcmVjdGlvbixcXG5cXHRcXHRwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggPSBmYWxzZSxcXG5cXHRcXHRpc0NpcmN1bXN0YW50aWFsSW52ZXJ0ID0gZmFsc2UsXFxuXFx0XFx0bGFzdE1vZGUsIC8vICdzd2FwJyBvciAnaW5zZXJ0J1xcblxcblxcdFxcdHRhcmdldE1vdmVEaXN0YW5jZSxcXG5cXG5cXHRcXHQvLyBGb3IgcG9zaXRpb25pbmcgZ2hvc3QgYWJzb2x1dGVseVxcblxcdFxcdGdob3N0UmVsYXRpdmVQYXJlbnQsXFxuXFx0XFx0Z2hvc3RSZWxhdGl2ZVBhcmVudEluaXRpYWxTY3JvbGwgPSBbXSwgLy8gKGxlZnQsIHRvcClcXG5cXG5cXHRcXHRyZWFsRHJhZ0VsUmVjdCwgLy8gZHJhZ0VsIHJlY3QgYWZ0ZXIgY3VycmVudCBhbmltYXRpb25cXG5cXG5cXHRcXHQvKiogQGNvbnN0ICovXFxuXFx0XFx0Ul9TUEFDRSA9IC9cXFxccysvZyxcXG5cXG5cXHRcXHRleHBhbmRvID0gJ1NvcnRhYmxlJyArIChuZXcgRGF0ZSkuZ2V0VGltZSgpLFxcblxcblxcdFxcdHdpbiA9IHdpbmRvdyxcXG5cXHRcXHRkb2N1bWVudCA9IHdpbi5kb2N1bWVudCxcXG5cXHRcXHRwYXJzZUludCA9IHdpbi5wYXJzZUludCxcXG5cXHRcXHRzZXRUaW1lb3V0ID0gd2luLnNldFRpbWVvdXQsXFxuXFxuXFx0XFx0JCA9IHdpbi5qUXVlcnkgfHwgd2luLlplcHRvLFxcblxcdFxcdFBvbHltZXIgPSB3aW4uUG9seW1lcixcXG5cXG5cXHRcXHRjYXB0dXJlTW9kZSA9IHtcXG5cXHRcXHRcXHRjYXB0dXJlOiBmYWxzZSxcXG5cXHRcXHRcXHRwYXNzaXZlOiBmYWxzZVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0SUUxMU9yTGVzcyA9ICEhbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvKD86VHJpZGVudC4qcnZbIDpdPzExXFxcXC58bXNpZXxpZW1vYmlsZSkvaSksXFxuXFx0XFx0RWRnZSA9ICEhbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRWRnZS9pKSxcXG5cXHRcXHRGaXJlRm94ID0gISFuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9maXJlZm94L2kpLFxcblxcdFxcdFNhZmFyaSA9ICEhKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL3NhZmFyaS9pKSAmJiAhbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvY2hyb21lL2kpICYmICFuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9hbmRyb2lkL2kpKSxcXG5cXHRcXHRJT1MgPSAhIShuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9pUChhZHxvZHxob25lKS9pKSksXFxuXFxuXFx0XFx0UG9zaXRpb25HaG9zdEFic29sdXRlbHkgPSBJT1MsXFxuXFxuXFx0XFx0Q1NTRmxvYXRQcm9wZXJ0eSA9IEVkZ2UgfHwgSUUxMU9yTGVzcyA/ICdjc3NGbG9hdCcgOiAnZmxvYXQnLFxcblxcblxcdFxcdC8vIFRoaXMgd2lsbCBub3QgcGFzcyBmb3IgSUU5LCBiZWNhdXNlIElFOSBEbkQgb25seSB3b3JrcyBvbiBhbmNob3JzXFxuXFx0XFx0c3VwcG9ydERyYWdnYWJsZSA9ICgnZHJhZ2dhYmxlJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSksXFxuXFxuXFx0XFx0c3VwcG9ydENzc1BvaW50ZXJFdmVudHMgPSAoZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0Ly8gZmFsc2Ugd2hlbiA8PSBJRTExXFxuXFx0XFx0XFx0aWYgKElFMTFPckxlc3MpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3gnKTtcXG5cXHRcXHRcXHRlbC5zdHlsZS5jc3NUZXh0ID0gJ3BvaW50ZXItZXZlbnRzOmF1dG8nO1xcblxcdFxcdFxcdHJldHVybiBlbC5zdHlsZS5wb2ludGVyRXZlbnRzID09PSAnYXV0byc7XFxuXFx0XFx0fSkoKSxcXG5cXG5cXHRcXHRfc2lsZW50ID0gZmFsc2UsXFxuXFx0XFx0X2FsaWduZWRTaWxlbnQgPSBmYWxzZSxcXG5cXG5cXHRcXHRhYnMgPSBNYXRoLmFicyxcXG5cXHRcXHRtaW4gPSBNYXRoLm1pbixcXG5cXHRcXHRtYXggPSBNYXRoLm1heCxcXG5cXG5cXHRcXHRzYXZlZElucHV0Q2hlY2tlZCA9IFtdLFxcblxcblxcdFxcdF9kZXRlY3REaXJlY3Rpb24gPSBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xcblxcdFxcdFxcdHZhciBlbENTUyA9IF9jc3MoZWwpLFxcblxcdFxcdFxcdFxcdGVsV2lkdGggPSBwYXJzZUludChlbENTUy53aWR0aClcXG5cXHRcXHRcXHRcXHRcXHQtIHBhcnNlSW50KGVsQ1NTLnBhZGRpbmdMZWZ0KVxcblxcdFxcdFxcdFxcdFxcdC0gcGFyc2VJbnQoZWxDU1MucGFkZGluZ1JpZ2h0KVxcblxcdFxcdFxcdFxcdFxcdC0gcGFyc2VJbnQoZWxDU1MuYm9yZGVyTGVmdFdpZHRoKVxcblxcdFxcdFxcdFxcdFxcdC0gcGFyc2VJbnQoZWxDU1MuYm9yZGVyUmlnaHRXaWR0aCksXFxuXFx0XFx0XFx0XFx0Y2hpbGQxID0gX2dldENoaWxkKGVsLCAwLCBvcHRpb25zKSxcXG5cXHRcXHRcXHRcXHRjaGlsZDIgPSBfZ2V0Q2hpbGQoZWwsIDEsIG9wdGlvbnMpLFxcblxcdFxcdFxcdFxcdGZpcnN0Q2hpbGRDU1MgPSBjaGlsZDEgJiYgX2NzcyhjaGlsZDEpLFxcblxcdFxcdFxcdFxcdHNlY29uZENoaWxkQ1NTID0gY2hpbGQyICYmIF9jc3MoY2hpbGQyKSxcXG5cXHRcXHRcXHRcXHRmaXJzdENoaWxkV2lkdGggPSBmaXJzdENoaWxkQ1NTICYmIHBhcnNlSW50KGZpcnN0Q2hpbGRDU1MubWFyZ2luTGVmdCkgKyBwYXJzZUludChmaXJzdENoaWxkQ1NTLm1hcmdpblJpZ2h0KSArIF9nZXRSZWN0KGNoaWxkMSkud2lkdGgsXFxuXFx0XFx0XFx0XFx0c2Vjb25kQ2hpbGRXaWR0aCA9IHNlY29uZENoaWxkQ1NTICYmIHBhcnNlSW50KHNlY29uZENoaWxkQ1NTLm1hcmdpbkxlZnQpICsgcGFyc2VJbnQoc2Vjb25kQ2hpbGRDU1MubWFyZ2luUmlnaHQpICsgX2dldFJlY3QoY2hpbGQyKS53aWR0aDtcXG5cXG5cXHRcXHRcXHRpZiAoZWxDU1MuZGlzcGxheSA9PT0gJ2ZsZXgnKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGVsQ1NTLmZsZXhEaXJlY3Rpb24gPT09ICdjb2x1bW4nIHx8IGVsQ1NTLmZsZXhEaXJlY3Rpb24gPT09ICdjb2x1bW4tcmV2ZXJzZSdcXG5cXHRcXHRcXHRcXHQ/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChlbENTUy5kaXNwbGF5ID09PSAnZ3JpZCcpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZWxDU1MuZ3JpZFRlbXBsYXRlQ29sdW1ucy5zcGxpdCgnICcpLmxlbmd0aCA8PSAxID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGNoaWxkMSAmJiBmaXJzdENoaWxkQ1NTLmZsb2F0ICE9PSAnbm9uZScpIHtcXG5cXHRcXHRcXHRcXHR2YXIgdG91Y2hpbmdTaWRlQ2hpbGQyID0gZmlyc3RDaGlsZENTUy5mbG9hdCA9PT0gJ2xlZnQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gY2hpbGQyICYmIChzZWNvbmRDaGlsZENTUy5jbGVhciA9PT0gJ2JvdGgnIHx8IHNlY29uZENoaWxkQ1NTLmNsZWFyID09PSB0b3VjaGluZ1NpZGVDaGlsZDIpID9cXG5cXHRcXHRcXHRcXHRcXHQndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gKGNoaWxkMSAmJlxcblxcdFxcdFxcdFxcdChcXG5cXHRcXHRcXHRcXHRcXHRmaXJzdENoaWxkQ1NTLmRpc3BsYXkgPT09ICdibG9jaycgfHxcXG5cXHRcXHRcXHRcXHRcXHRmaXJzdENoaWxkQ1NTLmRpc3BsYXkgPT09ICdmbGV4JyB8fFxcblxcdFxcdFxcdFxcdFxcdGZpcnN0Q2hpbGRDU1MuZGlzcGxheSA9PT0gJ3RhYmxlJyB8fFxcblxcdFxcdFxcdFxcdFxcdGZpcnN0Q2hpbGRDU1MuZGlzcGxheSA9PT0gJ2dyaWQnIHx8XFxuXFx0XFx0XFx0XFx0XFx0Zmlyc3RDaGlsZFdpZHRoID49IGVsV2lkdGggJiZcXG5cXHRcXHRcXHRcXHRcXHRlbENTU1tDU1NGbG9hdFByb3BlcnR5XSA9PT0gJ25vbmUnIHx8XFxuXFx0XFx0XFx0XFx0XFx0Y2hpbGQyICYmXFxuXFx0XFx0XFx0XFx0XFx0ZWxDU1NbQ1NTRmxvYXRQcm9wZXJ0eV0gPT09ICdub25lJyAmJlxcblxcdFxcdFxcdFxcdFxcdGZpcnN0Q2hpbGRXaWR0aCArIHNlY29uZENoaWxkV2lkdGggPiBlbFdpZHRoXFxuXFx0XFx0XFx0XFx0KSA/XFxuXFx0XFx0XFx0XFx0J3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJ1xcblxcdFxcdFxcdCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBEZXRlY3RzIGZpcnN0IG5lYXJlc3QgZW1wdHkgc29ydGFibGUgdG8gWCBhbmQgWSBwb3NpdGlvbiB1c2luZyBlbXB0eUluc2VydFRocmVzaG9sZC5cXG5cXHRcXHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHggICAgICBYIHBvc2l0aW9uXFxuXFx0XFx0ICogQHBhcmFtICB7TnVtYmVyfSB5ICAgICAgWSBwb3NpdGlvblxcblxcdFxcdCAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgIEVsZW1lbnQgb2YgdGhlIGZpcnN0IGZvdW5kIG5lYXJlc3QgU29ydGFibGVcXG5cXHRcXHQgKi9cXG5cXHRcXHRfZGV0ZWN0TmVhcmVzdEVtcHR5U29ydGFibGUgPSBmdW5jdGlvbih4LCB5KSB7XFxuXFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0YWJsZXMubGVuZ3RoOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRpZiAoX2xhc3RDaGlsZChzb3J0YWJsZXNbaV0pKSBjb250aW51ZTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcmVjdCA9IF9nZXRSZWN0KHNvcnRhYmxlc1tpXSksXFxuXFx0XFx0XFx0XFx0XFx0dGhyZXNob2xkID0gc29ydGFibGVzW2ldW2V4cGFuZG9dLm9wdGlvbnMuZW1wdHlJbnNlcnRUaHJlc2hvbGQsXFxuXFx0XFx0XFx0XFx0XFx0aW5zaWRlSG9yaXpvbnRhbGx5ID0geCA+PSAocmVjdC5sZWZ0IC0gdGhyZXNob2xkKSAmJiB4IDw9IChyZWN0LnJpZ2h0ICsgdGhyZXNob2xkKSxcXG5cXHRcXHRcXHRcXHRcXHRpbnNpZGVWZXJ0aWNhbGx5ID0geSA+PSAocmVjdC50b3AgLSB0aHJlc2hvbGQpICYmIHkgPD0gKHJlY3QuYm90dG9tICsgdGhyZXNob2xkKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAodGhyZXNob2xkICYmIGluc2lkZUhvcml6b250YWxseSAmJiBpbnNpZGVWZXJ0aWNhbGx5KSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHNvcnRhYmxlc1tpXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2lzQ2xpZW50SW5Sb3dDb2x1bW4gPSBmdW5jdGlvbih4LCB5LCBlbCwgYXhpcywgb3B0aW9ucykge1xcblxcdFxcdFxcdHZhciB0YXJnZXRSZWN0ID0gX2dldFJlY3QoZWwpLFxcblxcdFxcdFxcdFxcdHRhcmdldFMxT3BwID0gYXhpcyA9PT0gJ3ZlcnRpY2FsJyA/IHRhcmdldFJlY3QubGVmdCA6IHRhcmdldFJlY3QudG9wLFxcblxcdFxcdFxcdFxcdHRhcmdldFMyT3BwID0gYXhpcyA9PT0gJ3ZlcnRpY2FsJyA/IHRhcmdldFJlY3QucmlnaHQgOiB0YXJnZXRSZWN0LmJvdHRvbSxcXG5cXHRcXHRcXHRcXHRtb3VzZU9uT3BwQXhpcyA9IGF4aXMgPT09ICd2ZXJ0aWNhbCcgPyB4IDogeTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGFyZ2V0UzFPcHAgPCBtb3VzZU9uT3BwQXhpcyAmJiBtb3VzZU9uT3BwQXhpcyA8IHRhcmdldFMyT3BwO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2lzRWxJblJvd0NvbHVtbiA9IGZ1bmN0aW9uKGVsMSwgZWwyLCBheGlzKSB7XFxuXFx0XFx0XFx0dmFyIGVsMVJlY3QgPSBlbDEgPT09IGRyYWdFbCAmJiByZWFsRHJhZ0VsUmVjdCB8fCBfZ2V0UmVjdChlbDEpLFxcblxcdFxcdFxcdFxcdGVsMlJlY3QgPSBlbDIgPT09IGRyYWdFbCAmJiByZWFsRHJhZ0VsUmVjdCB8fCBfZ2V0UmVjdChlbDIpLFxcblxcdFxcdFxcdFxcdGVsMVMxT3BwID0gYXhpcyA9PT0gJ3ZlcnRpY2FsJyA/IGVsMVJlY3QubGVmdCA6IGVsMVJlY3QudG9wLFxcblxcdFxcdFxcdFxcdGVsMVMyT3BwID0gYXhpcyA9PT0gJ3ZlcnRpY2FsJyA/IGVsMVJlY3QucmlnaHQgOiBlbDFSZWN0LmJvdHRvbSxcXG5cXHRcXHRcXHRcXHRlbDFPcHBMZW5ndGggPSBheGlzID09PSAndmVydGljYWwnID8gZWwxUmVjdC53aWR0aCA6IGVsMVJlY3QuaGVpZ2h0LFxcblxcdFxcdFxcdFxcdGVsMlMxT3BwID0gYXhpcyA9PT0gJ3ZlcnRpY2FsJyA/IGVsMlJlY3QubGVmdCA6IGVsMlJlY3QudG9wLFxcblxcdFxcdFxcdFxcdGVsMlMyT3BwID0gYXhpcyA9PT0gJ3ZlcnRpY2FsJyA/IGVsMlJlY3QucmlnaHQgOiBlbDJSZWN0LmJvdHRvbSxcXG5cXHRcXHRcXHRcXHRlbDJPcHBMZW5ndGggPSBheGlzID09PSAndmVydGljYWwnID8gZWwyUmVjdC53aWR0aCA6IGVsMlJlY3QuaGVpZ2h0O1xcblxcblxcdFxcdFxcdHJldHVybiAoXFxuXFx0XFx0XFx0XFx0ZWwxUzFPcHAgPT09IGVsMlMxT3BwIHx8XFxuXFx0XFx0XFx0XFx0ZWwxUzJPcHAgPT09IGVsMlMyT3BwIHx8XFxuXFx0XFx0XFx0XFx0KGVsMVMxT3BwICsgZWwxT3BwTGVuZ3RoIC8gMikgPT09IChlbDJTMU9wcCArIGVsMk9wcExlbmd0aCAvIDIpXFxuXFx0XFx0XFx0KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9nZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudCA9IGZ1bmN0aW9uKGVsLCBpbmNsdWRlU2VsZikge1xcblxcdFxcdFxcdC8vIHNraXAgdG8gd2luZG93XFxuXFx0XFx0XFx0aWYgKCFlbCB8fCAhZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSByZXR1cm4gX2dldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcXG5cXG5cXHRcXHRcXHR2YXIgZWxlbSA9IGVsO1xcblxcdFxcdFxcdHZhciBnb3RTZWxmID0gZmFsc2U7XFxuXFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdC8vIHdlIGRvbid0IG5lZWQgdG8gZ2V0IGVsZW0gY3NzIGlmIGl0IGlzbid0IGV2ZW4gb3ZlcmZsb3dpbmcgaW4gdGhlIGZpcnN0IHBsYWNlIChwZXJmb3JtYW5jZSlcXG5cXHRcXHRcXHRcXHRpZiAoZWxlbS5jbGllbnRXaWR0aCA8IGVsZW0uc2Nyb2xsV2lkdGggfHwgZWxlbS5jbGllbnRIZWlnaHQgPCBlbGVtLnNjcm9sbEhlaWdodCkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBlbGVtQ1NTID0gX2NzcyhlbGVtKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5jbGllbnRXaWR0aCA8IGVsZW0uc2Nyb2xsV2lkdGggJiYgKGVsZW1DU1Mub3ZlcmZsb3dYID09ICdhdXRvJyB8fCBlbGVtQ1NTLm92ZXJmbG93WCA9PSAnc2Nyb2xsJykgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtLmNsaWVudEhlaWdodCA8IGVsZW0uc2Nyb2xsSGVpZ2h0ICYmIChlbGVtQ1NTLm92ZXJmbG93WSA9PSAnYXV0bycgfHwgZWxlbUNTUy5vdmVyZmxvd1kgPT0gJ3Njcm9sbCcpXFxuXFx0XFx0XFx0XFx0XFx0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCFlbGVtIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCB8fCBlbGVtID09PSBkb2N1bWVudC5ib2R5KSByZXR1cm4gX2dldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZ290U2VsZiB8fCBpbmNsdWRlU2VsZikgcmV0dXJuIGVsZW07XFxuXFx0XFx0XFx0XFx0XFx0XFx0Z290U2VsZiA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvKiBqc2hpbnQgYm9zczp0cnVlICovXFxuXFx0XFx0XFx0fSB3aGlsZSAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIF9nZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGlmIChJRTExT3JMZXNzKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHJldHVybiBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50O1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9zY3JvbGxCeSA9IGZ1bmN0aW9uKGVsLCB4LCB5KSB7XFxuXFx0XFx0XFx0ZWwuc2Nyb2xsTGVmdCArPSB4O1xcblxcdFxcdFxcdGVsLnNjcm9sbFRvcCArPSB5O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2F1dG9TY3JvbGwgPSBfdGhyb3R0bGUoZnVuY3Rpb24gKC8qKkV2ZW50Ki9ldnQsIC8qKk9iamVjdCovb3B0aW9ucywgLyoqSFRNTEVsZW1lbnQqL3Jvb3RFbCwgLyoqQm9vbGVhbiovaXNGYWxsYmFjaykge1xcblxcdFxcdFxcdC8vIEJ1ZzogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTA1NTIxXFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMuc2Nyb2xsKSB7XFxuXFx0XFx0XFx0XFx0dmFyIF90aGlzID0gcm9vdEVsID8gcm9vdEVsW2V4cGFuZG9dIDogd2luZG93LFxcblxcdFxcdFxcdFxcdFxcdHNlbnMgPSBvcHRpb25zLnNjcm9sbFNlbnNpdGl2aXR5LFxcblxcdFxcdFxcdFxcdFxcdHNwZWVkID0gb3B0aW9ucy5zY3JvbGxTcGVlZCxcXG5cXG5cXHRcXHRcXHRcXHRcXHR4ID0gZXZ0LmNsaWVudFgsXFxuXFx0XFx0XFx0XFx0XFx0eSA9IGV2dC5jbGllbnRZLFxcblxcblxcdFxcdFxcdFxcdFxcdHdpblNjcm9sbGVyID0gX2dldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKSxcXG5cXG5cXHRcXHRcXHRcXHRcXHRzY3JvbGxUaGlzSW5zdGFuY2UgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEZXRlY3Qgc2Nyb2xsRWxcXG5cXHRcXHRcXHRcXHRpZiAoc2Nyb2xsUGFyZW50RWwgIT09IHJvb3RFbCkge1xcblxcdFxcdFxcdFxcdFxcdF9jbGVhckF1dG9TY3JvbGxzKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c2Nyb2xsRWwgPSBvcHRpb25zLnNjcm9sbDtcXG5cXHRcXHRcXHRcXHRcXHRzY3JvbGxDdXN0b21GbiA9IG9wdGlvbnMuc2Nyb2xsRm47XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHNjcm9sbEVsID09PSB0cnVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2Nyb2xsRWwgPSBfZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQocm9vdEVsLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzY3JvbGxQYXJlbnRFbCA9IHNjcm9sbEVsO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFxuXFx0XFx0XFx0XFx0dmFyIGxheWVyc091dCA9IDA7XFxuXFx0XFx0XFx0XFx0dmFyIGN1cnJlbnRQYXJlbnQgPSBzY3JvbGxFbDtcXG5cXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyXFx0ZWwgPSBjdXJyZW50UGFyZW50LFxcblxcdFxcdFxcdFxcdFxcdFxcdHJlY3QgPSBfZ2V0UmVjdChlbCksXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dG9wID0gcmVjdC50b3AsXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ym90dG9tID0gcmVjdC5ib3R0b20sXFxuXFx0XFx0XFx0XFx0XFx0XFx0bGVmdCA9IHJlY3QubGVmdCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRyaWdodCA9IHJlY3QucmlnaHQsXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0d2lkdGggPSByZWN0LndpZHRoLFxcblxcdFxcdFxcdFxcdFxcdFxcdGhlaWdodCA9IHJlY3QuaGVpZ2h0LFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHNjcm9sbFdpZHRoLFxcblxcdFxcdFxcdFxcdFxcdFxcdHNjcm9sbEhlaWdodCxcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjc3MsXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dngsXFxuXFx0XFx0XFx0XFx0XFx0XFx0dnksXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FuU2Nyb2xsWCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYW5TY3JvbGxZLFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHNjcm9sbFBvc1gsXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2Nyb2xsUG9zWTtcXG5cXG5cXG5cXHRcXHRcXHRcXHRcXHRzY3JvbGxXaWR0aCA9IGVsLnNjcm9sbFdpZHRoO1xcblxcdFxcdFxcdFxcdFxcdHNjcm9sbEhlaWdodCA9IGVsLnNjcm9sbEhlaWdodDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjc3MgPSBfY3NzKGVsKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzY3JvbGxQb3NYID0gZWwuc2Nyb2xsTGVmdDtcXG5cXHRcXHRcXHRcXHRcXHRzY3JvbGxQb3NZID0gZWwuc2Nyb2xsVG9wO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChlbCA9PT0gd2luU2Nyb2xsZXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYW5TY3JvbGxYID0gd2lkdGggPCBzY3JvbGxXaWR0aCAmJiAoY3NzLm92ZXJmbG93WCA9PT0gJ2F1dG8nIHx8IGNzcy5vdmVyZmxvd1ggPT09ICdzY3JvbGwnIHx8IGNzcy5vdmVyZmxvd1ggPT09ICd2aXNpYmxlJyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FuU2Nyb2xsWSA9IGhlaWdodCA8IHNjcm9sbEhlaWdodCAmJiAoY3NzLm92ZXJmbG93WSA9PT0gJ2F1dG8nIHx8IGNzcy5vdmVyZmxvd1kgPT09ICdzY3JvbGwnIHx8IGNzcy5vdmVyZmxvd1kgPT09ICd2aXNpYmxlJyk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYW5TY3JvbGxYID0gd2lkdGggPCBzY3JvbGxXaWR0aCAmJiAoY3NzLm92ZXJmbG93WCA9PT0gJ2F1dG8nIHx8IGNzcy5vdmVyZmxvd1ggPT09ICdzY3JvbGwnKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYW5TY3JvbGxZID0gaGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0ICYmIChjc3Mub3ZlcmZsb3dZID09PSAnYXV0bycgfHwgY3NzLm92ZXJmbG93WSA9PT0gJ3Njcm9sbCcpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR2eCA9IGNhblNjcm9sbFggJiYgKGFicyhyaWdodCAtIHgpIDw9IHNlbnMgJiYgKHNjcm9sbFBvc1ggKyB3aWR0aCkgPCBzY3JvbGxXaWR0aCkgLSAoYWJzKGxlZnQgLSB4KSA8PSBzZW5zICYmICEhc2Nyb2xsUG9zWCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dnkgPSBjYW5TY3JvbGxZICYmIChhYnMoYm90dG9tIC0geSkgPD0gc2VucyAmJiAoc2Nyb2xsUG9zWSArIGhlaWdodCkgPCBzY3JvbGxIZWlnaHQpIC0gKGFicyh0b3AgLSB5KSA8PSBzZW5zICYmICEhc2Nyb2xsUG9zWSk7XFxuXFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFhdXRvU2Nyb2xsc1tsYXllcnNPdXRdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gbGF5ZXJzT3V0OyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIWF1dG9TY3JvbGxzW2ldKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YXV0b1Njcm9sbHNbaV0gPSB7fTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS52eCAhPSB2eCB8fCBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnZ5ICE9IHZ5IHx8IGF1dG9TY3JvbGxzW2xheWVyc091dF0uZWwgIT09IGVsKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5lbCA9IGVsO1xcblxcdFxcdFxcdFxcdFxcdFxcdGF1dG9TY3JvbGxzW2xheWVyc091dF0udnggPSB2eDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnZ5ID0gdnk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2xlYXJJbnRlcnZhbChhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnBpZCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGVsICYmICh2eCAhPSAwIHx8IHZ5ICE9IDApKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2Nyb2xsVGhpc0luc3RhbmNlID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvKiBqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSAqL1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGF1dG9TY3JvbGxzW2xheWVyc091dF0ucGlkID0gc2V0SW50ZXJ2YWwoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBlbXVsYXRlIGRyYWcgb3ZlciBkdXJpbmcgYXV0b3Njcm9sbCAoZmFsbGJhY2spLCBlbXVsYXRpbmcgbmF0aXZlIERuRCBiZWhhdmlvdXJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoaXNGYWxsYmFjayAmJiB0aGlzLmxheWVyID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0U29ydGFibGUuYWN0aXZlLl9lbXVsYXRlRHJhZ092ZXIodHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0U29ydGFibGUuYWN0aXZlLl9vblRvdWNoTW92ZSh0b3VjaEV2dCwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBzY3JvbGxPZmZzZXRZID0gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnkgPyBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS52eSAqIHNwZWVkIDogMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgc2Nyb2xsT2Zmc2V0WCA9IGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLnZ4ID8gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnggKiBzcGVlZCA6IDA7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZihzY3JvbGxDdXN0b21GbikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoc2Nyb2xsQ3VzdG9tRm4uY2FsbChfdGhpcywgc2Nyb2xsT2Zmc2V0WCwgc2Nyb2xsT2Zmc2V0WSwgZXZ0LCB0b3VjaEV2dCwgYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0uZWwpICE9PSAnY29udGludWUnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0X3Njcm9sbEJ5KGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLmVsLCBzY3JvbGxPZmZzZXRYLCBzY3JvbGxPZmZzZXRZKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9KS5iaW5kKHtsYXllcjogbGF5ZXJzT3V0fSksIDI0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGxheWVyc091dCsrO1xcblxcdFxcdFxcdFxcdH0gd2hpbGUgKG9wdGlvbnMuYnViYmxlU2Nyb2xsICYmIGN1cnJlbnRQYXJlbnQgIT09IHdpblNjcm9sbGVyICYmIChjdXJyZW50UGFyZW50ID0gX2dldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGN1cnJlbnRQYXJlbnQsIGZhbHNlKSkpO1xcblxcdFxcdFxcdFxcdHNjcm9sbGluZyA9IHNjcm9sbFRoaXNJbnN0YW5jZTsgLy8gaW4gY2FzZSBhbm90aGVyIGZ1bmN0aW9uIGNhdGNoZXMgc2Nyb2xsaW5nIGFzIGZhbHNlIGluIGJldHdlZW4gd2hlbiBpdCBpcyBub3RcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSwgMzApLFxcblxcblxcdFxcdF9jbGVhckF1dG9TY3JvbGxzID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdGF1dG9TY3JvbGxzLmZvckVhY2goZnVuY3Rpb24oYXV0b1Njcm9sbCkge1xcblxcdFxcdFxcdFxcdGNsZWFySW50ZXJ2YWwoYXV0b1Njcm9sbC5waWQpO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdGF1dG9TY3JvbGxzID0gW107XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfcHJlcGFyZUdyb3VwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcXG5cXHRcXHRcXHRmdW5jdGlvbiB0b0ZuKHZhbHVlLCBwdWxsKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uKHRvLCBmcm9tLCBkcmFnRWwsIGV2dCkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBzYW1lR3JvdXAgPSB0by5vcHRpb25zLmdyb3VwLm5hbWUgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRmcm9tLm9wdGlvbnMuZ3JvdXAubmFtZSAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRvLm9wdGlvbnMuZ3JvdXAubmFtZSA9PT0gZnJvbS5vcHRpb25zLmdyb3VwLm5hbWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHZhbHVlID09IG51bGwgJiYgKHB1bGwgfHwgc2FtZUdyb3VwKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIERlZmF1bHQgcHVsbCB2YWx1ZVxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIERlZmF1bHQgcHVsbCBhbmQgcHV0IHZhbHVlIGlmIHNhbWUgZ3JvdXBcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAocHVsbCAmJiB2YWx1ZSA9PT0gJ2Nsb25lJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0b0ZuKHZhbHVlKHRvLCBmcm9tLCBkcmFnRWwsIGV2dCksIHB1bGwpKHRvLCBmcm9tLCBkcmFnRWwsIGV2dCk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgb3RoZXJHcm91cCA9IChwdWxsID8gdG8gOiBmcm9tKS5vcHRpb25zLmdyb3VwLm5hbWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuICh2YWx1ZSA9PT0gdHJ1ZSB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdCh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlID09PSBvdGhlckdyb3VwKSB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdCh2YWx1ZS5qb2luICYmIHZhbHVlLmluZGV4T2Yob3RoZXJHcm91cCkgPiAtMSkpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgZ3JvdXAgPSB7fTtcXG5cXHRcXHRcXHR2YXIgb3JpZ2luYWxHcm91cCA9IG9wdGlvbnMuZ3JvdXA7XFxuXFxuXFx0XFx0XFx0aWYgKCFvcmlnaW5hbEdyb3VwIHx8IHR5cGVvZiBvcmlnaW5hbEdyb3VwICE9ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0b3JpZ2luYWxHcm91cCA9IHtuYW1lOiBvcmlnaW5hbEdyb3VwfTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Z3JvdXAubmFtZSA9IG9yaWdpbmFsR3JvdXAubmFtZTtcXG5cXHRcXHRcXHRncm91cC5jaGVja1B1bGwgPSB0b0ZuKG9yaWdpbmFsR3JvdXAucHVsbCwgdHJ1ZSk7XFxuXFx0XFx0XFx0Z3JvdXAuY2hlY2tQdXQgPSB0b0ZuKG9yaWdpbmFsR3JvdXAucHV0KTtcXG5cXHRcXHRcXHRncm91cC5yZXZlcnRDbG9uZSA9IG9yaWdpbmFsR3JvdXAucmV2ZXJ0Q2xvbmU7XFxuXFxuXFx0XFx0XFx0b3B0aW9ucy5ncm91cCA9IGdyb3VwO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2NoZWNrQWxpZ25tZW50ID0gZnVuY3Rpb24oZXZ0KSB7XFxuXFx0XFx0XFx0aWYgKCFkcmFnRWwgfHwgIWRyYWdFbC5wYXJlbnROb2RlKSByZXR1cm47XFxuXFx0XFx0XFx0ZHJhZ0VsLnBhcmVudE5vZGVbZXhwYW5kb10gJiYgZHJhZ0VsLnBhcmVudE5vZGVbZXhwYW5kb10uX2NvbXB1dGVJc0FsaWduZWQoZXZ0KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9oaWRlR2hvc3RGb3JUYXJnZXQgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRpZiAoIXN1cHBvcnRDc3NQb2ludGVyRXZlbnRzICYmIGdob3N0RWwpIHtcXG5cXHRcXHRcXHRcXHRfY3NzKGdob3N0RWwsICdkaXNwbGF5JywgJ25vbmUnKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfdW5oaWRlR2hvc3RGb3JUYXJnZXQgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRpZiAoIXN1cHBvcnRDc3NQb2ludGVyRXZlbnRzICYmIGdob3N0RWwpIHtcXG5cXHRcXHRcXHRcXHRfY3NzKGdob3N0RWwsICdkaXNwbGF5JywgJycpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcblxcblxcdC8vICMxMTg0IGZpeCAtIFByZXZlbnQgY2xpY2sgZXZlbnQgb24gZmFsbGJhY2sgaWYgZHJhZ2dlZCBidXQgaXRlbSBub3QgY2hhbmdlZCBwb3NpdGlvblxcblxcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXZ0KSB7XFxuXFx0XFx0aWYgKGlnbm9yZU5leHRDbGljaykge1xcblxcdFxcdFxcdGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdGV2dC5zdG9wUHJvcGFnYXRpb24gJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xcblxcdFxcdFxcdGV2dC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gJiYgZXZ0LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcblxcdFxcdFxcdGlnbm9yZU5leHRDbGljayA9IGZhbHNlO1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9XFxuXFx0fSwgdHJ1ZSk7XFxuXFxuXFx0dmFyIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50ID0gZnVuY3Rpb24oZXZ0KSB7XFxuXFx0XFx0aWYgKGRyYWdFbCkge1xcblxcdFxcdFxcdGV2dCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQ7XFxuXFx0XFx0XFx0dmFyIG5lYXJlc3QgPSBfZGV0ZWN0TmVhcmVzdEVtcHR5U29ydGFibGUoZXZ0LmNsaWVudFgsIGV2dC5jbGllbnRZKTtcXG5cXG5cXHRcXHRcXHRpZiAobmVhcmVzdCkge1xcblxcdFxcdFxcdFxcdC8vIENyZWF0ZSBpbWl0YXRpb24gZXZlbnRcXG5cXHRcXHRcXHRcXHR2YXIgZXZlbnQgPSB7fTtcXG5cXHRcXHRcXHRcXHRmb3IgKHZhciBpIGluIGV2dCkge1xcblxcdFxcdFxcdFxcdFxcdGV2ZW50W2ldID0gZXZ0W2ldO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRldmVudC50YXJnZXQgPSBldmVudC5yb290RWwgPSBuZWFyZXN0O1xcblxcdFxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0ID0gdm9pZCAwO1xcblxcdFxcdFxcdFxcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IHZvaWQgMDtcXG5cXHRcXHRcXHRcXHRuZWFyZXN0W2V4cGFuZG9dLl9vbkRyYWdPdmVyKGV2ZW50KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGNsYXNzICBTb3J0YWJsZVxcblxcdCAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSAgZWxcXG5cXHQgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgIFtvcHRpb25zXVxcblxcdCAqL1xcblxcdGZ1bmN0aW9uIFNvcnRhYmxlKGVsLCBvcHRpb25zKSB7XFxuXFx0XFx0aWYgKCEoZWwgJiYgZWwubm9kZVR5cGUgJiYgZWwubm9kZVR5cGUgPT09IDEpKSB7XFxuXFx0XFx0XFx0dGhyb3cgJ1NvcnRhYmxlOiBgZWxgIG11c3QgYmUgSFRNTEVsZW1lbnQsIG5vdCAnICsge30udG9TdHJpbmcuY2FsbChlbCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuZWwgPSBlbDsgLy8gcm9vdCBlbGVtZW50XFxuXFx0XFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IF9leHRlbmQoe30sIG9wdGlvbnMpO1xcblxcblxcblxcdFxcdC8vIEV4cG9ydCBpbnN0YW5jZVxcblxcdFxcdGVsW2V4cGFuZG9dID0gdGhpcztcXG5cXG5cXHRcXHQvLyBEZWZhdWx0IG9wdGlvbnNcXG5cXHRcXHR2YXIgZGVmYXVsdHMgPSB7XFxuXFx0XFx0XFx0Z3JvdXA6IG51bGwsXFxuXFx0XFx0XFx0c29ydDogdHJ1ZSxcXG5cXHRcXHRcXHRkaXNhYmxlZDogZmFsc2UsXFxuXFx0XFx0XFx0c3RvcmU6IG51bGwsXFxuXFx0XFx0XFx0aGFuZGxlOiBudWxsLFxcblxcdFxcdFxcdHNjcm9sbDogdHJ1ZSxcXG5cXHRcXHRcXHRzY3JvbGxTZW5zaXRpdml0eTogMzAsXFxuXFx0XFx0XFx0c2Nyb2xsU3BlZWQ6IDEwLFxcblxcdFxcdFxcdGJ1YmJsZVNjcm9sbDogdHJ1ZSxcXG5cXHRcXHRcXHRkcmFnZ2FibGU6IC9bdW9dbC9pLnRlc3QoZWwubm9kZU5hbWUpID8gJz5saScgOiAnPionLFxcblxcdFxcdFxcdHN3YXBUaHJlc2hvbGQ6IDEsIC8vIHBlcmNlbnRhZ2U7IDAgPD0geCA8PSAxXFxuXFx0XFx0XFx0aW52ZXJ0U3dhcDogZmFsc2UsIC8vIGludmVydCBhbHdheXNcXG5cXHRcXHRcXHRpbnZlcnRlZFN3YXBUaHJlc2hvbGQ6IG51bGwsIC8vIHdpbGwgYmUgc2V0IHRvIHNhbWUgYXMgc3dhcFRocmVzaG9sZCBpZiBkZWZhdWx0XFxuXFx0XFx0XFx0cmVtb3ZlQ2xvbmVPbkhpZGU6IHRydWUsXFxuXFx0XFx0XFx0ZGlyZWN0aW9uOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gX2RldGVjdERpcmVjdGlvbihlbCwgdGhpcy5vcHRpb25zKTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGdob3N0Q2xhc3M6ICdzb3J0YWJsZS1naG9zdCcsXFxuXFx0XFx0XFx0Y2hvc2VuQ2xhc3M6ICdzb3J0YWJsZS1jaG9zZW4nLFxcblxcdFxcdFxcdGRyYWdDbGFzczogJ3NvcnRhYmxlLWRyYWcnLFxcblxcdFxcdFxcdGlnbm9yZTogJ2EsIGltZycsXFxuXFx0XFx0XFx0ZmlsdGVyOiBudWxsLFxcblxcdFxcdFxcdHByZXZlbnRPbkZpbHRlcjogdHJ1ZSxcXG5cXHRcXHRcXHRhbmltYXRpb246IDAsXFxuXFx0XFx0XFx0ZWFzaW5nOiBudWxsLFxcblxcdFxcdFxcdHNldERhdGE6IGZ1bmN0aW9uIChkYXRhVHJhbnNmZXIsIGRyYWdFbCkge1xcblxcdFxcdFxcdFxcdGRhdGFUcmFuc2Zlci5zZXREYXRhKCdUZXh0JywgZHJhZ0VsLnRleHRDb250ZW50KTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGRyb3BCdWJibGU6IGZhbHNlLFxcblxcdFxcdFxcdGRyYWdvdmVyQnViYmxlOiBmYWxzZSxcXG5cXHRcXHRcXHRkYXRhSWRBdHRyOiAnZGF0YS1pZCcsXFxuXFx0XFx0XFx0ZGVsYXk6IDAsXFxuXFx0XFx0XFx0ZGVsYXlPblRvdWNoT25seTogZmFsc2UsXFxuXFx0XFx0XFx0dG91Y2hTdGFydFRocmVzaG9sZDogcGFyc2VJbnQod2luZG93LmRldmljZVBpeGVsUmF0aW8sIDEwKSB8fCAxLFxcblxcdFxcdFxcdGZvcmNlRmFsbGJhY2s6IGZhbHNlLFxcblxcdFxcdFxcdGZhbGxiYWNrQ2xhc3M6ICdzb3J0YWJsZS1mYWxsYmFjaycsXFxuXFx0XFx0XFx0ZmFsbGJhY2tPbkJvZHk6IGZhbHNlLFxcblxcdFxcdFxcdGZhbGxiYWNrVG9sZXJhbmNlOiAwLFxcblxcdFxcdFxcdGZhbGxiYWNrT2Zmc2V0OiB7eDogMCwgeTogMH0sXFxuXFx0XFx0XFx0c3VwcG9ydFBvaW50ZXI6IFNvcnRhYmxlLnN1cHBvcnRQb2ludGVyICE9PSBmYWxzZSAmJiAoJ1BvaW50ZXJFdmVudCcgaW4gd2luZG93KSxcXG5cXHRcXHRcXHRlbXB0eUluc2VydFRocmVzaG9sZDogNVxcblxcdFxcdH07XFxuXFxuXFxuXFx0XFx0Ly8gU2V0IGRlZmF1bHQgb3B0aW9uc1xcblxcdFxcdGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdHMpIHtcXG5cXHRcXHRcXHQhKG5hbWUgaW4gb3B0aW9ucykgJiYgKG9wdGlvbnNbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdF9wcmVwYXJlR3JvdXAob3B0aW9ucyk7XFxuXFxuXFx0XFx0Ly8gQmluZCBhbGwgcHJpdmF0ZSBtZXRob2RzXFxuXFx0XFx0Zm9yICh2YXIgZm4gaW4gdGhpcykge1xcblxcdFxcdFxcdGlmIChmbi5jaGFyQXQoMCkgPT09ICdfJyAmJiB0eXBlb2YgdGhpc1tmbl0gPT09ICdmdW5jdGlvbicpIHtcXG5cXHRcXHRcXHRcXHR0aGlzW2ZuXSA9IHRoaXNbZm5dLmJpbmQodGhpcyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTZXR1cCBkcmFnIG1vZGVcXG5cXHRcXHR0aGlzLm5hdGl2ZURyYWdnYWJsZSA9IG9wdGlvbnMuZm9yY2VGYWxsYmFjayA/IGZhbHNlIDogc3VwcG9ydERyYWdnYWJsZTtcXG5cXG5cXHRcXHRpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcXG5cXHRcXHRcXHQvLyBUb3VjaCBzdGFydCB0aHJlc2hvbGQgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiB0aGUgbmF0aXZlIGRyYWdzdGFydCB0aHJlc2hvbGRcXG5cXHRcXHRcXHR0aGlzLm9wdGlvbnMudG91Y2hTdGFydFRocmVzaG9sZCA9IDE7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEJpbmQgZXZlbnRzXFxuXFx0XFx0aWYgKG9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcXG5cXHRcXHRcXHRfb24oZWwsICdwb2ludGVyZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0X29uKGVsLCAnbW91c2Vkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XFxuXFx0XFx0XFx0X29uKGVsLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVGFwU3RhcnQpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcXG5cXHRcXHRcXHRfb24oZWwsICdkcmFnb3ZlcicsIHRoaXMpO1xcblxcdFxcdFxcdF9vbihlbCwgJ2RyYWdlbnRlcicsIHRoaXMpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRzb3J0YWJsZXMucHVzaCh0aGlzLmVsKTtcXG5cXG5cXHRcXHQvLyBSZXN0b3JlIHNvcnRpbmdcXG5cXHRcXHRvcHRpb25zLnN0b3JlICYmIG9wdGlvbnMuc3RvcmUuZ2V0ICYmIHRoaXMuc29ydChvcHRpb25zLnN0b3JlLmdldCh0aGlzKSB8fCBbXSk7XFxuXFx0fVxcblxcblxcdFNvcnRhYmxlLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgU29ydGFibGUucHJvdG90eXBlICovIHtcXG5cXHRcXHRjb25zdHJ1Y3RvcjogU29ydGFibGUsXFxuXFxuXFx0XFx0X2NvbXB1dGVJc0FsaWduZWQ6IGZ1bmN0aW9uKGV2dCkge1xcblxcdFxcdFxcdHZhciB0YXJnZXQ7XFxuXFxuXFx0XFx0XFx0aWYgKGdob3N0RWwgJiYgIXN1cHBvcnRDc3NQb2ludGVyRXZlbnRzKSB7XFxuXFx0XFx0XFx0XFx0X2hpZGVHaG9zdEZvclRhcmdldCgpO1xcblxcdFxcdFxcdFxcdHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZ0LmNsaWVudFgsIGV2dC5jbGllbnRZKTtcXG5cXHRcXHRcXHRcXHRfdW5oaWRlR2hvc3RGb3JUYXJnZXQoKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHRhcmdldCA9IGV2dC50YXJnZXQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRhcmdldCA9IF9jbG9zZXN0KHRhcmdldCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSwgdGhpcy5lbCwgZmFsc2UpO1xcblxcdFxcdFxcdGlmIChfYWxpZ25lZFNpbGVudCkgcmV0dXJuO1xcblxcdFxcdFxcdGlmICghZHJhZ0VsIHx8IGRyYWdFbC5wYXJlbnROb2RlICE9PSB0aGlzLmVsKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0dmFyIGNoaWxkcmVuID0gdGhpcy5lbC5jaGlsZHJlbjtcXG5cXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0Ly8gRG9uJ3QgY2hhbmdlIGZvciB0YXJnZXQgaW4gY2FzZSBpdCBpcyBjaGFuZ2VkIHRvIGFsaWduZWQgYmVmb3JlIG9uRHJhZ092ZXIgaXMgZmlyZWRcXG5cXHRcXHRcXHRcXHRpZiAoX2Nsb3Nlc3QoY2hpbGRyZW5baV0sIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUsIHRoaXMuZWwsIGZhbHNlKSAmJiBjaGlsZHJlbltpXSAhPT0gdGFyZ2V0KSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2hpbGRyZW5baV0uc29ydGFibGVNb3VzZUFsaWduZWQgPSBfaXNDbGllbnRJblJvd0NvbHVtbihldnQuY2xpZW50WCwgZXZ0LmNsaWVudFksIGNoaWxkcmVuW2ldLCB0aGlzLl9nZXREaXJlY3Rpb24oZXZ0LCBudWxsKSwgdGhpcy5vcHRpb25zKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIFVzZWQgZm9yIG51bGxpbmcgbGFzdCB0YXJnZXQgd2hlbiBub3QgaW4gZWxlbWVudCwgbm90aGluZyB0byBkbyB3aXRoIGNoZWNraW5nIGlmIGFsaWduZWRcXG5cXHRcXHRcXHRpZiAoIV9jbG9zZXN0KHRhcmdldCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSwgdGhpcy5lbCwgdHJ1ZSkpIHtcXG5cXHRcXHRcXHRcXHRsYXN0VGFyZ2V0ID0gbnVsbDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0X2FsaWduZWRTaWxlbnQgPSB0cnVlO1xcblxcdFxcdFxcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0X2FsaWduZWRTaWxlbnQgPSBmYWxzZTtcXG5cXHRcXHRcXHR9LCAzMCk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZ2V0RGlyZWN0aW9uOiBmdW5jdGlvbihldnQsIHRhcmdldCkge1xcblxcdFxcdFxcdHJldHVybiAodHlwZW9mIHRoaXMub3B0aW9ucy5kaXJlY3Rpb24gPT09ICdmdW5jdGlvbicpID8gdGhpcy5vcHRpb25zLmRpcmVjdGlvbi5jYWxsKHRoaXMsIGV2dCwgdGFyZ2V0LCBkcmFnRWwpIDogdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9vblRhcFN0YXJ0OiBmdW5jdGlvbiAoLyoqIEV2ZW50fFRvdWNoRXZlbnQgKi9ldnQpIHtcXG5cXHRcXHRcXHRpZiAoIWV2dC5jYW5jZWxhYmxlKSByZXR1cm47XFxuXFx0XFx0XFx0dmFyIF90aGlzID0gdGhpcyxcXG5cXHRcXHRcXHRcXHRlbCA9IHRoaXMuZWwsXFxuXFx0XFx0XFx0XFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcXG5cXHRcXHRcXHRcXHRwcmV2ZW50T25GaWx0ZXIgPSBvcHRpb25zLnByZXZlbnRPbkZpbHRlcixcXG5cXHRcXHRcXHRcXHR0eXBlID0gZXZ0LnR5cGUsXFxuXFx0XFx0XFx0XFx0dG91Y2ggPSBldnQudG91Y2hlcyAmJiBldnQudG91Y2hlc1swXSxcXG5cXHRcXHRcXHRcXHR0YXJnZXQgPSAodG91Y2ggfHwgZXZ0KS50YXJnZXQsXFxuXFx0XFx0XFx0XFx0b3JpZ2luYWxUYXJnZXQgPSBldnQudGFyZ2V0LnNoYWRvd1Jvb3QgJiYgKChldnQucGF0aCAmJiBldnQucGF0aFswXSkgfHwgKGV2dC5jb21wb3NlZFBhdGggJiYgZXZ0LmNvbXBvc2VkUGF0aCgpWzBdKSkgfHwgdGFyZ2V0LFxcblxcdFxcdFxcdFxcdGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyLFxcblxcdFxcdFxcdFxcdHN0YXJ0SW5kZXgsXFxuXFx0XFx0XFx0XFx0c3RhcnREcmFnZ2FibGVJbmRleDtcXG5cXG5cXHRcXHRcXHRfc2F2ZUlucHV0Q2hlY2tlZFN0YXRlKGVsKTtcXG5cXG5cXHRcXHRcXHQvLyBEb24ndCB0cmlnZ2VyIHN0YXJ0IGV2ZW50IHdoZW4gYW4gZWxlbWVudCBpcyBiZWVuIGRyYWdnZWQsIG90aGVyd2lzZSB0aGUgZXZ0Lm9sZGluZGV4IGFsd2F5cyB3cm9uZyB3aGVuIHNldCBvcHRpb24uZ3JvdXAuXFxuXFx0XFx0XFx0aWYgKGRyYWdFbCkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKC9tb3VzZWRvd258cG9pbnRlcmRvd24vLnRlc3QodHlwZSkgJiYgZXZ0LmJ1dHRvbiAhPT0gMCB8fCBvcHRpb25zLmRpc2FibGVkKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuOyAvLyBvbmx5IGxlZnQgYnV0dG9uIGFuZCBlbmFibGVkXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGNhbmNlbCBkbmQgaWYgb3JpZ2luYWwgdGFyZ2V0IGlzIGNvbnRlbnQgZWRpdGFibGVcXG5cXHRcXHRcXHRpZiAob3JpZ2luYWxUYXJnZXQuaXNDb250ZW50RWRpdGFibGUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRhcmdldCA9IF9jbG9zZXN0KHRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUsIGVsLCBmYWxzZSk7XFxuXFxuXFxuXFx0XFx0XFx0aWYgKGxhc3REb3duRWwgPT09IHRhcmdldCkge1xcblxcdFxcdFxcdFxcdC8vIElnbm9yaW5nIGR1cGxpY2F0ZSBgZG93bmBcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGRyYWdnZWQgZWxlbWVudCB3aXRoaW4gaXRzIHBhcmVudFxcblxcdFxcdFxcdHN0YXJ0SW5kZXggPSBfaW5kZXgodGFyZ2V0KTtcXG5cXHRcXHRcXHRzdGFydERyYWdnYWJsZUluZGV4ID0gX2luZGV4KHRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUpO1xcblxcblxcdFxcdFxcdC8vIENoZWNrIGZpbHRlclxcblxcdFxcdFxcdGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGZpbHRlci5jYWxsKHRoaXMsIGV2dCwgdGFyZ2V0LCB0aGlzKSkge1xcblxcdFxcdFxcdFxcdFxcdF9kaXNwYXRjaEV2ZW50KF90aGlzLCBvcmlnaW5hbFRhcmdldCwgJ2ZpbHRlcicsIHRhcmdldCwgZWwsIGVsLCBzdGFydEluZGV4LCB1bmRlZmluZWQsIHN0YXJ0RHJhZ2dhYmxlSW5kZXgpO1xcblxcdFxcdFxcdFxcdFxcdHByZXZlbnRPbkZpbHRlciAmJiBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47IC8vIGNhbmNlbCBkbmRcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGVsc2UgaWYgKGZpbHRlcikge1xcblxcdFxcdFxcdFxcdGZpbHRlciA9IGZpbHRlci5zcGxpdCgnLCcpLnNvbWUoZnVuY3Rpb24gKGNyaXRlcmlhKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y3JpdGVyaWEgPSBfY2xvc2VzdChvcmlnaW5hbFRhcmdldCwgY3JpdGVyaWEudHJpbSgpLCBlbCwgZmFsc2UpO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChjcml0ZXJpYSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdF9kaXNwYXRjaEV2ZW50KF90aGlzLCBjcml0ZXJpYSwgJ2ZpbHRlcicsIHRhcmdldCwgZWwsIGVsLCBzdGFydEluZGV4LCB1bmRlZmluZWQsIHN0YXJ0RHJhZ2dhYmxlSW5kZXgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoZmlsdGVyKSB7XFxuXFx0XFx0XFx0XFx0XFx0cHJldmVudE9uRmlsdGVyICYmIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjsgLy8gY2FuY2VsIGRuZFxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMuaGFuZGxlICYmICFfY2xvc2VzdChvcmlnaW5hbFRhcmdldCwgb3B0aW9ucy5oYW5kbGUsIGVsLCBmYWxzZSkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFByZXBhcmUgYGRyYWdzdGFydGBcXG5cXHRcXHRcXHR0aGlzLl9wcmVwYXJlRHJhZ1N0YXJ0KGV2dCwgdG91Y2gsIHRhcmdldCwgc3RhcnRJbmRleCwgc3RhcnREcmFnZ2FibGVJbmRleCk7XFxuXFx0XFx0fSxcXG5cXG5cXG5cXHRcXHRfaGFuZGxlQXV0b1Njcm9sbDogZnVuY3Rpb24oZXZ0LCBmYWxsYmFjaykge1xcblxcdFxcdFxcdGlmICghZHJhZ0VsIHx8ICF0aGlzLm9wdGlvbnMuc2Nyb2xsKSByZXR1cm47XFxuXFx0XFx0XFx0dmFyIHggPSBldnQuY2xpZW50WCxcXG5cXHRcXHRcXHRcXHR5ID0gZXZ0LmNsaWVudFksXFxuXFxuXFx0XFx0XFx0XFx0ZWxlbSA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSksXFxuXFx0XFx0XFx0XFx0X3RoaXMgPSB0aGlzO1xcblxcblxcdFxcdFxcdC8vIElFIGRvZXMgbm90IHNlZW0gdG8gaGF2ZSBuYXRpdmUgYXV0b3Njcm9sbCxcXG5cXHRcXHRcXHQvLyBFZGdlJ3MgYXV0b3Njcm9sbCBzZWVtcyB0b28gY29uZGl0aW9uYWwsXFxuXFx0XFx0XFx0Ly8gTUFDT1MgU2FmYXJpIGRvZXMgbm90IGhhdmUgYXV0b3Njcm9sbCxcXG5cXHRcXHRcXHQvLyBGaXJlZm94IGFuZCBDaHJvbWUgYXJlIGdvb2RcXG5cXHRcXHRcXHRpZiAoZmFsbGJhY2sgfHwgRWRnZSB8fCBJRTExT3JMZXNzIHx8IFNhZmFyaSkge1xcblxcdFxcdFxcdFxcdF9hdXRvU2Nyb2xsKGV2dCwgX3RoaXMub3B0aW9ucywgZWxlbSwgZmFsbGJhY2spO1xcblxcblxcdFxcdFxcdFxcdC8vIExpc3RlbmVyIGZvciBwb2ludGVyIGVsZW1lbnQgY2hhbmdlXFxuXFx0XFx0XFx0XFx0dmFyIG9nRWxlbVNjcm9sbGVyID0gX2dldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsZW0sIHRydWUpO1xcblxcdFxcdFxcdFxcdGlmIChcXG5cXHRcXHRcXHRcXHRcXHRzY3JvbGxpbmcgJiZcXG5cXHRcXHRcXHRcXHRcXHQoXFxuXFx0XFx0XFx0XFx0XFx0XFx0IXBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0eCAhPT0gbGFzdFBvaW50ZXJFbGVtWCB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdHkgIT09IGxhc3RQb2ludGVyRWxlbVlcXG5cXHRcXHRcXHRcXHRcXHQpXFxuXFx0XFx0XFx0XFx0KSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgJiYgY2xlYXJJbnRlcnZhbChwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCk7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gRGV0ZWN0IGZvciBwb2ludGVyIGVsZW0gY2hhbmdlLCBlbXVsYXRpbmcgbmF0aXZlIERuRCBiZWhhdmlvdXJcXG5cXHRcXHRcXHRcXHRcXHRwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICghZHJhZ0VsKSByZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gY291bGQgYWxzbyBjaGVjayBpZiBzY3JvbGwgZGlyZWN0aW9uIG9uIG5ld0VsZW0gY2hhbmdlcyBkdWUgdG8gcGFyZW50IGF1dG9zY3JvbGxpbmdcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgbmV3RWxlbSA9IF9nZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgsIHkpLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobmV3RWxlbSAhPT0gb2dFbGVtU2Nyb2xsZXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvZ0VsZW1TY3JvbGxlciA9IG5ld0VsZW07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0X2NsZWFyQXV0b1Njcm9sbHMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRfYXV0b1Njcm9sbChldnQsIF90aGlzLm9wdGlvbnMsIG9nRWxlbVNjcm9sbGVyLCBmYWxsYmFjayk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH0sIDEwKTtcXG5cXHRcXHRcXHRcXHRcXHRsYXN0UG9pbnRlckVsZW1YID0geDtcXG5cXHRcXHRcXHRcXHRcXHRsYXN0UG9pbnRlckVsZW1ZID0geTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHQvLyBpZiBEbkQgaXMgZW5hYmxlZCAoYW5kIGJyb3dzZXIgaGFzIGdvb2QgYXV0b3Njcm9sbGluZyksIGZpcnN0IGF1dG9zY3JvbGwgd2lsbCBhbHJlYWR5IHNjcm9sbCwgc28gZ2V0IHBhcmVudCBhdXRvc2Nyb2xsIG9mIGZpcnN0IGF1dG9zY3JvbGxcXG5cXHRcXHRcXHRcXHRpZiAoIV90aGlzLm9wdGlvbnMuYnViYmxlU2Nyb2xsIHx8IF9nZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbGVtLCB0cnVlKSA9PT0gX2dldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKSkge1xcblxcdFxcdFxcdFxcdFxcdF9jbGVhckF1dG9TY3JvbGxzKCk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRfYXV0b1Njcm9sbChldnQsIF90aGlzLm9wdGlvbnMsIF9nZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbGVtLCBmYWxzZSksIGZhbHNlKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfcHJlcGFyZURyYWdTdGFydDogZnVuY3Rpb24gKC8qKiBFdmVudCAqL2V2dCwgLyoqIFRvdWNoICovdG91Y2gsIC8qKiBIVE1MRWxlbWVudCAqL3RhcmdldCwgLyoqIE51bWJlciAqL3N0YXJ0SW5kZXgsIC8qKiBOdW1iZXIgKi9zdGFydERyYWdnYWJsZUluZGV4KSB7XFxuXFx0XFx0XFx0dmFyIF90aGlzID0gdGhpcyxcXG5cXHRcXHRcXHRcXHRlbCA9IF90aGlzLmVsLFxcblxcdFxcdFxcdFxcdG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zLFxcblxcdFxcdFxcdFxcdG93bmVyRG9jdW1lbnQgPSBlbC5vd25lckRvY3VtZW50LFxcblxcdFxcdFxcdFxcdGRyYWdTdGFydEZuO1xcblxcblxcdFxcdFxcdGlmICh0YXJnZXQgJiYgIWRyYWdFbCAmJiAodGFyZ2V0LnBhcmVudE5vZGUgPT09IGVsKSkge1xcblxcdFxcdFxcdFxcdHJvb3RFbCA9IGVsO1xcblxcdFxcdFxcdFxcdGRyYWdFbCA9IHRhcmdldDtcXG5cXHRcXHRcXHRcXHRwYXJlbnRFbCA9IGRyYWdFbC5wYXJlbnROb2RlO1xcblxcdFxcdFxcdFxcdG5leHRFbCA9IGRyYWdFbC5uZXh0U2libGluZztcXG5cXHRcXHRcXHRcXHRsYXN0RG93bkVsID0gdGFyZ2V0O1xcblxcdFxcdFxcdFxcdGFjdGl2ZUdyb3VwID0gb3B0aW9ucy5ncm91cDtcXG5cXHRcXHRcXHRcXHRvbGRJbmRleCA9IHN0YXJ0SW5kZXg7XFxuXFx0XFx0XFx0XFx0b2xkRHJhZ2dhYmxlSW5kZXggPSBzdGFydERyYWdnYWJsZUluZGV4O1xcblxcblxcdFxcdFxcdFxcdHRhcEV2dCA9IHtcXG5cXHRcXHRcXHRcXHRcXHR0YXJnZXQ6IGRyYWdFbCxcXG5cXHRcXHRcXHRcXHRcXHRjbGllbnRYOiAodG91Y2ggfHwgZXZ0KS5jbGllbnRYLFxcblxcdFxcdFxcdFxcdFxcdGNsaWVudFk6ICh0b3VjaCB8fCBldnQpLmNsaWVudFlcXG5cXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX2xhc3RYID0gKHRvdWNoIHx8IGV2dCkuY2xpZW50WDtcXG5cXHRcXHRcXHRcXHR0aGlzLl9sYXN0WSA9ICh0b3VjaCB8fCBldnQpLmNsaWVudFk7XFxuXFxuXFx0XFx0XFx0XFx0ZHJhZ0VsLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJ2FsbCc7XFxuXFx0XFx0XFx0XFx0Ly8gdW5kbyBhbmltYXRpb24gaWYgbmVlZGVkXFxuXFx0XFx0XFx0XFx0ZHJhZ0VsLnN0eWxlLnRyYW5zaXRpb24gPSAnJztcXG5cXHRcXHRcXHRcXHRkcmFnRWwuc3R5bGUudHJhbnNmb3JtID0gJyc7XFxuXFxuXFx0XFx0XFx0XFx0ZHJhZ1N0YXJ0Rm4gPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gRGVsYXllZCBkcmFnIGhhcyBiZWVuIHRyaWdnZXJlZFxcblxcdFxcdFxcdFxcdFxcdC8vIHdlIGNhbiByZS1lbmFibGUgdGhlIGV2ZW50czogdG91Y2htb3ZlL21vdXNlbW92ZVxcblxcdFxcdFxcdFxcdFxcdF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIUZpcmVGb3ggJiYgX3RoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZHJhZ0VsLmRyYWdnYWJsZSA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIEJpbmQgdGhlIGV2ZW50czogZHJhZ3N0YXJ0L2RyYWdlbmRcXG5cXHRcXHRcXHRcXHRcXHRfdGhpcy5fdHJpZ2dlckRyYWdTdGFydChldnQsIHRvdWNoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBEcmFnIHN0YXJ0IGV2ZW50XFxuXFx0XFx0XFx0XFx0XFx0X2Rpc3BhdGNoRXZlbnQoX3RoaXMsIHJvb3RFbCwgJ2Nob29zZScsIGRyYWdFbCwgcm9vdEVsLCByb290RWwsIG9sZEluZGV4LCB1bmRlZmluZWQsIG9sZERyYWdnYWJsZUluZGV4KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBDaG9zZW4gaXRlbVxcblxcdFxcdFxcdFxcdFxcdF90b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuY2hvc2VuQ2xhc3MsIHRydWUpO1xcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRGlzYWJsZSBcXFwiZHJhZ2dhYmxlXFxcIlxcblxcdFxcdFxcdFxcdG9wdGlvbnMuaWdub3JlLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAoY3JpdGVyaWEpIHtcXG5cXHRcXHRcXHRcXHRcXHRfZmluZChkcmFnRWwsIGNyaXRlcmlhLnRyaW0oKSwgX2Rpc2FibGVEcmFnZ2FibGUpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdF9vbihvd25lckRvY3VtZW50LCAnZHJhZ292ZXInLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XFxuXFx0XFx0XFx0XFx0X29uKG93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XFxuXFx0XFx0XFx0XFx0X29uKG93bmVyRG9jdW1lbnQsICd0b3VjaG1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XFxuXFxuXFx0XFx0XFx0XFx0X29uKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgX3RoaXMuX29uRHJvcCk7XFxuXFx0XFx0XFx0XFx0X29uKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9vbkRyb3ApO1xcblxcdFxcdFxcdFxcdF9vbihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCBfdGhpcy5fb25Ecm9wKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBNYWtlIGRyYWdFbCBkcmFnZ2FibGUgKG11c3QgYmUgYmVmb3JlIGRlbGF5IGZvciBGaXJlRm94KVxcblxcdFxcdFxcdFxcdGlmIChGaXJlRm94ICYmIHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5vcHRpb25zLnRvdWNoU3RhcnRUaHJlc2hvbGQgPSA0O1xcblxcdFxcdFxcdFxcdFxcdGRyYWdFbC5kcmFnZ2FibGUgPSB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBEZWxheSBpcyBpbXBvc3NpYmxlIGZvciBuYXRpdmUgRG5EIGluIEVkZ2Ugb3IgSUVcXG5cXHRcXHRcXHRcXHRpZiAob3B0aW9ucy5kZWxheSAmJiAob3B0aW9ucy5kZWxheU9uVG91Y2hPbmx5ID8gdG91Y2ggOiB0cnVlKSAmJiAoIXRoaXMubmF0aXZlRHJhZ2dhYmxlIHx8ICEoRWRnZSB8fCBJRTExT3JMZXNzKSkpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiB0aGUgdXNlciBtb3ZlcyB0aGUgcG9pbnRlciBvciBsZXQgZ28gdGhlIGNsaWNrIG9yIHRvdWNoXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYmVmb3JlIHRoZSBkZWxheSBoYXMgYmVlbiByZWFjaGVkOlxcblxcdFxcdFxcdFxcdFxcdC8vIGRpc2FibGUgdGhlIGRlbGF5ZWQgZHJhZ1xcblxcdFxcdFxcdFxcdFxcdF9vbihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xcblxcdFxcdFxcdFxcdFxcdF9vbihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcXG5cXHRcXHRcXHRcXHRcXHRfb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XFxuXFx0XFx0XFx0XFx0XFx0X29uKG93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBfdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcXG5cXHRcXHRcXHRcXHRcXHRfb24ob3duZXJEb2N1bWVudCwgJ3RvdWNobW92ZScsIF90aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xcblxcdFxcdFxcdFxcdFxcdG9wdGlvbnMuc3VwcG9ydFBvaW50ZXIgJiYgX29uKG93bmVyRG9jdW1lbnQsICdwb2ludGVybW92ZScsIF90aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xcblxcblxcdFxcdFxcdFxcdFxcdF90aGlzLl9kcmFnU3RhcnRUaW1lciA9IHNldFRpbWVvdXQoZHJhZ1N0YXJ0Rm4sIG9wdGlvbnMuZGVsYXkpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0ZHJhZ1N0YXJ0Rm4oKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcjogZnVuY3Rpb24gKC8qKiBUb3VjaEV2ZW50fFBvaW50ZXJFdmVudCAqKi9lKSB7XFxuXFx0XFx0XFx0dmFyIHRvdWNoID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcXG5cXHRcXHRcXHRpZiAobWF4KGFicyh0b3VjaC5jbGllbnRYIC0gdGhpcy5fbGFzdFgpLCBhYnModG91Y2guY2xpZW50WSAtIHRoaXMuX2xhc3RZKSlcXG5cXHRcXHRcXHRcXHRcXHQ+PSBNYXRoLmZsb29yKHRoaXMub3B0aW9ucy50b3VjaFN0YXJ0VGhyZXNob2xkIC8gKHRoaXMubmF0aXZlRHJhZ2dhYmxlICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpKVxcblxcdFxcdFxcdCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZygpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9kaXNhYmxlRGVsYXllZERyYWc6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRkcmFnRWwgJiYgX2Rpc2FibGVEcmFnZ2FibGUoZHJhZ0VsKTtcXG5cXHRcXHRcXHRjbGVhclRpbWVvdXQodGhpcy5fZHJhZ1N0YXJ0VGltZXIpO1xcblxcblxcdFxcdFxcdHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50czogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHZhciBvd25lckRvY3VtZW50ID0gdGhpcy5lbC5vd25lckRvY3VtZW50O1xcblxcdFxcdFxcdF9vZmYob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xcblxcdFxcdFxcdF9vZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcXG5cXHRcXHRcXHRfb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XFxuXFx0XFx0XFx0X29mZihvd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcXG5cXHRcXHRcXHRfb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xcblxcdFxcdFxcdF9vZmYob3duZXJEb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF90cmlnZ2VyRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoLyoqIEV2ZW50ICovZXZ0LCAvKiogVG91Y2ggKi90b3VjaCkge1xcblxcdFxcdFxcdHRvdWNoID0gdG91Y2ggfHwgKGV2dC5wb2ludGVyVHlwZSA9PSAndG91Y2gnID8gZXZ0IDogbnVsbCk7XFxuXFxuXFx0XFx0XFx0aWYgKCF0aGlzLm5hdGl2ZURyYWdnYWJsZSB8fCB0b3VjaCkge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLm9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRfb24oZG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHRvdWNoKSB7XFxuXFx0XFx0XFx0XFx0XFx0X29uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0X29uKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdF9vbihkcmFnRWwsICdkcmFnZW5kJywgdGhpcyk7XFxuXFx0XFx0XFx0XFx0X29uKHJvb3RFbCwgJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gVGltZW91dCBuZWNjZXNzYXJ5IGZvciBJRTlcXG5cXHRcXHRcXHRcXHRcXHRfbmV4dFRpY2soZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGRvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSgpO1xcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0d2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGNhdGNoIChlcnIpIHtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZHJhZ1N0YXJ0ZWQ6IGZ1bmN0aW9uIChmYWxsYmFjaywgZXZ0KSB7XFxuXFx0XFx0XFx0YXdhaXRpbmdEcmFnU3RhcnRlZCA9IGZhbHNlO1xcblxcdFxcdFxcdGlmIChyb290RWwgJiYgZHJhZ0VsKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XFxuXFx0XFx0XFx0XFx0XFx0X29uKGRvY3VtZW50LCAnZHJhZ292ZXInLCB0aGlzLl9oYW5kbGVBdXRvU2Nyb2xsKTtcXG5cXHRcXHRcXHRcXHRcXHRfb24oZG9jdW1lbnQsICdkcmFnb3ZlcicsIF9jaGVja0FsaWdubWVudCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xcblxcblxcdFxcdFxcdFxcdC8vIEFwcGx5IGVmZmVjdFxcblxcdFxcdFxcdFxcdCFmYWxsYmFjayAmJiBfdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmRyYWdDbGFzcywgZmFsc2UpO1xcblxcdFxcdFxcdFxcdF90b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZ2hvc3RDbGFzcywgdHJ1ZSk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSW4gY2FzZSBkcmFnZ2luZyBhbiBhbmltYXRlZCBlbGVtZW50XFxuXFx0XFx0XFx0XFx0X2NzcyhkcmFnRWwsICd0cmFuc2Zvcm0nLCAnJyk7XFxuXFxuXFx0XFx0XFx0XFx0U29ydGFibGUuYWN0aXZlID0gdGhpcztcXG5cXG5cXHRcXHRcXHRcXHRmYWxsYmFjayAmJiB0aGlzLl9hcHBlbmRHaG9zdCgpO1xcblxcblxcdFxcdFxcdFxcdC8vIERyYWcgc3RhcnQgZXZlbnRcXG5cXHRcXHRcXHRcXHRfZGlzcGF0Y2hFdmVudCh0aGlzLCByb290RWwsICdzdGFydCcsIGRyYWdFbCwgcm9vdEVsLCByb290RWwsIG9sZEluZGV4LCB1bmRlZmluZWQsIG9sZERyYWdnYWJsZUluZGV4LCB1bmRlZmluZWQsIGV2dCk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9udWxsaW5nKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2VtdWxhdGVEcmFnT3ZlcjogZnVuY3Rpb24gKGZvckF1dG9TY3JvbGwpIHtcXG5cXHRcXHRcXHRpZiAodG91Y2hFdnQpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fbGFzdFggPT09IHRvdWNoRXZ0LmNsaWVudFggJiYgdGhpcy5fbGFzdFkgPT09IHRvdWNoRXZ0LmNsaWVudFkgJiYgIWZvckF1dG9TY3JvbGwpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRoaXMuX2xhc3RYID0gdG91Y2hFdnQuY2xpZW50WDtcXG5cXHRcXHRcXHRcXHR0aGlzLl9sYXN0WSA9IHRvdWNoRXZ0LmNsaWVudFk7XFxuXFxuXFx0XFx0XFx0XFx0X2hpZGVHaG9zdEZvclRhcmdldCgpO1xcblxcblxcdFxcdFxcdFxcdHZhciB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoRXZ0LmNsaWVudFgsIHRvdWNoRXZ0LmNsaWVudFkpO1xcblxcdFxcdFxcdFxcdHZhciBwYXJlbnQgPSB0YXJnZXQ7XFxuXFxuXFx0XFx0XFx0XFx0d2hpbGUgKHRhcmdldCAmJiB0YXJnZXQuc2hhZG93Um9vdCkge1xcblxcdFxcdFxcdFxcdFxcdHRhcmdldCA9IHRhcmdldC5zaGFkb3dSb290LmVsZW1lbnRGcm9tUG9pbnQodG91Y2hFdnQuY2xpZW50WCwgdG91Y2hFdnQuY2xpZW50WSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRhcmdldCA9PT0gcGFyZW50KSBicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRwYXJlbnQgPSB0YXJnZXQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmIChwYXJlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHBhcmVudFtleHBhbmRvXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBpbnNlcnRlZDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnNlcnRlZCA9IHBhcmVudFtleHBhbmRvXS5fb25EcmFnT3Zlcih7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2xpZW50WDogdG91Y2hFdnQuY2xpZW50WCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjbGllbnRZOiB0b3VjaEV2dC5jbGllbnRZLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRhcmdldDogdGFyZ2V0LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJvb3RFbDogcGFyZW50XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGluc2VydGVkICYmICF0aGlzLm9wdGlvbnMuZHJhZ292ZXJCdWJibGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRhcmdldCA9IHBhcmVudDsgLy8gc3RvcmUgbGFzdCBlbGVtZW50XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdC8qIGpzaGludCBib3NzOnRydWUgKi9cXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAocGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRkcmFnRWwucGFyZW50Tm9kZVtleHBhbmRvXS5fY29tcHV0ZUlzQWxpZ25lZCh0b3VjaEV2dCk7XFxuXFxuXFx0XFx0XFx0XFx0X3VuaGlkZUdob3N0Rm9yVGFyZ2V0KCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFxuXFx0XFx0X29uVG91Y2hNb3ZlOiBmdW5jdGlvbiAoLyoqVG91Y2hFdmVudCovZXZ0LCBmb3JBdXRvU2Nyb2xsKSB7XFxuXFx0XFx0XFx0aWYgKHRhcEV2dCkge1xcblxcdFxcdFxcdFxcdHZhclxcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXFxuXFx0XFx0XFx0XFx0XFx0ZmFsbGJhY2tUb2xlcmFuY2UgPSBvcHRpb25zLmZhbGxiYWNrVG9sZXJhbmNlLFxcblxcdFxcdFxcdFxcdFxcdGZhbGxiYWNrT2Zmc2V0ID0gb3B0aW9ucy5mYWxsYmFja09mZnNldCxcXG5cXHRcXHRcXHRcXHRcXHR0b3VjaCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQsXFxuXFx0XFx0XFx0XFx0XFx0bWF0cml4ID0gZ2hvc3RFbCAmJiBfbWF0cml4KGdob3N0RWwpLFxcblxcdFxcdFxcdFxcdFxcdHNjYWxlWCA9IGdob3N0RWwgJiYgbWF0cml4ICYmIG1hdHJpeC5hLFxcblxcdFxcdFxcdFxcdFxcdHNjYWxlWSA9IGdob3N0RWwgJiYgbWF0cml4ICYmIG1hdHJpeC5kLFxcblxcdFxcdFxcdFxcdFxcdHJlbGF0aXZlU2Nyb2xsT2Zmc2V0ID0gUG9zaXRpb25HaG9zdEFic29sdXRlbHkgJiYgZ2hvc3RSZWxhdGl2ZVBhcmVudCAmJiBfZ2V0UmVsYXRpdmVTY3JvbGxPZmZzZXQoZ2hvc3RSZWxhdGl2ZVBhcmVudCksXFxuXFx0XFx0XFx0XFx0XFx0ZHggPSAoKHRvdWNoLmNsaWVudFggLSB0YXBFdnQuY2xpZW50WClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQrIGZhbGxiYWNrT2Zmc2V0LngpIC8gKHNjYWxlWCB8fCAxKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCsgKHJlbGF0aXZlU2Nyb2xsT2Zmc2V0ID8gKHJlbGF0aXZlU2Nyb2xsT2Zmc2V0WzBdIC0gZ2hvc3RSZWxhdGl2ZVBhcmVudEluaXRpYWxTY3JvbGxbMF0pIDogMCkgLyAoc2NhbGVYIHx8IDEpLFxcblxcdFxcdFxcdFxcdFxcdGR5ID0gKCh0b3VjaC5jbGllbnRZIC0gdGFwRXZ0LmNsaWVudFkpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KyBmYWxsYmFja09mZnNldC55KSAvIChzY2FsZVkgfHwgMSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQrIChyZWxhdGl2ZVNjcm9sbE9mZnNldCA/IChyZWxhdGl2ZVNjcm9sbE9mZnNldFsxXSAtIGdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsWzFdKSA6IDApIC8gKHNjYWxlWSB8fCAxKSxcXG5cXHRcXHRcXHRcXHRcXHR0cmFuc2xhdGUzZCA9IGV2dC50b3VjaGVzID8gJ3RyYW5zbGF0ZTNkKCcgKyBkeCArICdweCwnICsgZHkgKyAncHgsMCknIDogJ3RyYW5zbGF0ZSgnICsgZHggKyAncHgsJyArIGR5ICsgJ3B4KSc7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gb25seSBzZXQgdGhlIHN0YXR1cyB0byBkcmFnZ2luZywgd2hlbiB3ZSBhcmUgYWN0dWFsbHkgZHJhZ2dpbmdcXG5cXHRcXHRcXHRcXHRpZiAoIVNvcnRhYmxlLmFjdGl2ZSAmJiAhYXdhaXRpbmdEcmFnU3RhcnRlZCkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChmYWxsYmFja1RvbGVyYW5jZSAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdG1pbihhYnModG91Y2guY2xpZW50WCAtIHRoaXMuX2xhc3RYKSwgYWJzKHRvdWNoLmNsaWVudFkgLSB0aGlzLl9sYXN0WSkpIDwgZmFsbGJhY2tUb2xlcmFuY2VcXG5cXHRcXHRcXHRcXHRcXHQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX29uRHJhZ1N0YXJ0KGV2dCwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdCFmb3JBdXRvU2Nyb2xsICYmIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwodG91Y2gsIHRydWUpO1xcblxcblxcdFxcdFxcdFxcdG1vdmVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR0b3VjaEV2dCA9IHRvdWNoO1xcblxcblxcdFxcdFxcdFxcdF9jc3MoZ2hvc3RFbCwgJ3dlYmtpdFRyYW5zZm9ybScsIHRyYW5zbGF0ZTNkKTtcXG5cXHRcXHRcXHRcXHRfY3NzKGdob3N0RWwsICdtb3pUcmFuc2Zvcm0nLCB0cmFuc2xhdGUzZCk7XFxuXFx0XFx0XFx0XFx0X2NzcyhnaG9zdEVsLCAnbXNUcmFuc2Zvcm0nLCB0cmFuc2xhdGUzZCk7XFxuXFx0XFx0XFx0XFx0X2NzcyhnaG9zdEVsLCAndHJhbnNmb3JtJywgdHJhbnNsYXRlM2QpO1xcblxcblxcdFxcdFxcdFxcdGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9hcHBlbmRHaG9zdDogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdC8vIEJ1ZyBpZiB1c2luZyBzY2FsZSgpOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNjM3MDU4XFxuXFx0XFx0XFx0Ly8gTm90IGJlaW5nIGFkanVzdGVkIGZvclxcblxcdFxcdFxcdGlmICghZ2hvc3RFbCkge1xcblxcdFxcdFxcdFxcdHZhciBjb250YWluZXIgPSB0aGlzLm9wdGlvbnMuZmFsbGJhY2tPbkJvZHkgPyBkb2N1bWVudC5ib2R5IDogcm9vdEVsLFxcblxcdFxcdFxcdFxcdFxcdHJlY3QgPSBfZ2V0UmVjdChkcmFnRWwsIHRydWUsIGNvbnRhaW5lciwgIVBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5KSxcXG5cXHRcXHRcXHRcXHRcXHRjc3MgPSBfY3NzKGRyYWdFbCksXFxuXFx0XFx0XFx0XFx0XFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucztcXG5cXG5cXHRcXHRcXHRcXHQvLyBQb3NpdGlvbiBhYnNvbHV0ZWx5XFxuXFx0XFx0XFx0XFx0aWYgKFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5KSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gR2V0IHJlbGF0aXZlbHkgcG9zaXRpb25lZCBwYXJlbnRcXG5cXHRcXHRcXHRcXHRcXHRnaG9zdFJlbGF0aXZlUGFyZW50ID0gY29udGFpbmVyO1xcblxcblxcdFxcdFxcdFxcdFxcdHdoaWxlIChcXG5cXHRcXHRcXHRcXHRcXHRcXHRfY3NzKGdob3N0UmVsYXRpdmVQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJyAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdF9jc3MoZ2hvc3RSZWxhdGl2ZVBhcmVudCwgJ3RyYW5zZm9ybScpID09PSAnbm9uZScgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRnaG9zdFJlbGF0aXZlUGFyZW50ICE9PSBkb2N1bWVudFxcblxcdFxcdFxcdFxcdFxcdCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGdob3N0UmVsYXRpdmVQYXJlbnQgPSBnaG9zdFJlbGF0aXZlUGFyZW50LnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlmIChnaG9zdFJlbGF0aXZlUGFyZW50ICE9PSBkb2N1bWVudCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBnaG9zdFJlbGF0aXZlUGFyZW50UmVjdCA9IF9nZXRSZWN0KGdob3N0UmVsYXRpdmVQYXJlbnQsIHRydWUpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHJlY3QudG9wIC09IGdob3N0UmVsYXRpdmVQYXJlbnRSZWN0LnRvcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZWN0LmxlZnQgLT0gZ2hvc3RSZWxhdGl2ZVBhcmVudFJlY3QubGVmdDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGdob3N0UmVsYXRpdmVQYXJlbnQgIT09IGRvY3VtZW50LmJvZHkgJiYgZ2hvc3RSZWxhdGl2ZVBhcmVudCAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGdob3N0UmVsYXRpdmVQYXJlbnQgPT09IGRvY3VtZW50KSBnaG9zdFJlbGF0aXZlUGFyZW50ID0gX2dldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRyZWN0LnRvcCArPSBnaG9zdFJlbGF0aXZlUGFyZW50LnNjcm9sbFRvcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZWN0LmxlZnQgKz0gZ2hvc3RSZWxhdGl2ZVBhcmVudC5zY3JvbGxMZWZ0O1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2hvc3RSZWxhdGl2ZVBhcmVudCA9IF9nZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsID0gX2dldFJlbGF0aXZlU2Nyb2xsT2Zmc2V0KGdob3N0UmVsYXRpdmVQYXJlbnQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXG5cXHRcXHRcXHRcXHRnaG9zdEVsID0gZHJhZ0VsLmNsb25lTm9kZSh0cnVlKTtcXG5cXG5cXHRcXHRcXHRcXHRfdG9nZ2xlQ2xhc3MoZ2hvc3RFbCwgb3B0aW9ucy5naG9zdENsYXNzLCBmYWxzZSk7XFxuXFx0XFx0XFx0XFx0X3RvZ2dsZUNsYXNzKGdob3N0RWwsIG9wdGlvbnMuZmFsbGJhY2tDbGFzcywgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0X3RvZ2dsZUNsYXNzKGdob3N0RWwsIG9wdGlvbnMuZHJhZ0NsYXNzLCB0cnVlKTtcXG5cXG5cXHRcXHRcXHRcXHRfY3NzKGdob3N0RWwsICdib3gtc2l6aW5nJywgJ2JvcmRlci1ib3gnKTtcXG5cXHRcXHRcXHRcXHRfY3NzKGdob3N0RWwsICdtYXJnaW4nLCAwKTtcXG5cXHRcXHRcXHRcXHRfY3NzKGdob3N0RWwsICd0b3AnLCByZWN0LnRvcCk7XFxuXFx0XFx0XFx0XFx0X2NzcyhnaG9zdEVsLCAnbGVmdCcsIHJlY3QubGVmdCk7XFxuXFx0XFx0XFx0XFx0X2NzcyhnaG9zdEVsLCAnd2lkdGgnLCByZWN0LndpZHRoKTtcXG5cXHRcXHRcXHRcXHRfY3NzKGdob3N0RWwsICdoZWlnaHQnLCByZWN0LmhlaWdodCk7XFxuXFx0XFx0XFx0XFx0X2NzcyhnaG9zdEVsLCAnb3BhY2l0eScsICcwLjgnKTtcXG5cXHRcXHRcXHRcXHRfY3NzKGdob3N0RWwsICdwb3NpdGlvbicsIChQb3NpdGlvbkdob3N0QWJzb2x1dGVseSA/ICdhYnNvbHV0ZScgOiAnZml4ZWQnKSk7XFxuXFx0XFx0XFx0XFx0X2NzcyhnaG9zdEVsLCAnekluZGV4JywgJzEwMDAwMCcpO1xcblxcdFxcdFxcdFxcdF9jc3MoZ2hvc3RFbCwgJ3BvaW50ZXJFdmVudHMnLCAnbm9uZScpO1xcblxcblxcdFxcdFxcdFxcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChnaG9zdEVsKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgvKipFdmVudCovZXZ0LCAvKipib29sZWFuKi9mYWxsYmFjaykge1xcblxcdFxcdFxcdHZhciBfdGhpcyA9IHRoaXM7XFxuXFx0XFx0XFx0dmFyIGRhdGFUcmFuc2ZlciA9IGV2dC5kYXRhVHJhbnNmZXI7XFxuXFx0XFx0XFx0dmFyIG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zO1xcblxcblxcdFxcdFxcdC8vIFNldHVwIGNsb25lXFxuXFx0XFx0XFx0Y2xvbmVFbCA9IF9jbG9uZShkcmFnRWwpO1xcblxcblxcdFxcdFxcdGNsb25lRWwuZHJhZ2dhYmxlID0gZmFsc2U7XFxuXFx0XFx0XFx0Y2xvbmVFbC5zdHlsZVsnd2lsbC1jaGFuZ2UnXSA9ICcnO1xcblxcblxcdFxcdFxcdHRoaXMuX2hpZGVDbG9uZSgpO1xcblxcblxcdFxcdFxcdF90b2dnbGVDbGFzcyhjbG9uZUVsLCBfdGhpcy5vcHRpb25zLmNob3NlbkNsYXNzLCBmYWxzZSk7XFxuXFxuXFxuXFx0XFx0XFx0Ly8gIzExNDM6IElGcmFtZSBzdXBwb3J0IHdvcmthcm91bmRcXG5cXHRcXHRcXHRfdGhpcy5fY2xvbmVJZCA9IF9uZXh0VGljayhmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCFfdGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlKSB7XFxuXFx0XFx0XFx0XFx0XFx0cm9vdEVsLmluc2VydEJlZm9yZShjbG9uZUVsLCBkcmFnRWwpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRfZGlzcGF0Y2hFdmVudChfdGhpcywgcm9vdEVsLCAnY2xvbmUnLCBkcmFnRWwpO1xcblxcdFxcdFxcdH0pO1xcblxcblxcblxcdFxcdFxcdCFmYWxsYmFjayAmJiBfdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmRyYWdDbGFzcywgdHJ1ZSk7XFxuXFxuXFx0XFx0XFx0Ly8gU2V0IHByb3BlciBkcm9wIGV2ZW50c1xcblxcdFxcdFxcdGlmIChmYWxsYmFjaykge1xcblxcdFxcdFxcdFxcdGlnbm9yZU5leHRDbGljayA9IHRydWU7XFxuXFx0XFx0XFx0XFx0X3RoaXMuX2xvb3BJZCA9IHNldEludGVydmFsKF90aGlzLl9lbXVsYXRlRHJhZ092ZXIsIDUwKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdC8vIFVuZG8gd2hhdCB3YXMgc2V0IGluIF9wcmVwYXJlRHJhZ1N0YXJ0IGJlZm9yZSBkcmFnIHN0YXJ0ZWRcXG5cXHRcXHRcXHRcXHRfb2ZmKGRvY3VtZW50LCAnbW91c2V1cCcsIF90aGlzLl9vbkRyb3ApO1xcblxcdFxcdFxcdFxcdF9vZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9vbkRyb3ApO1xcblxcdFxcdFxcdFxcdF9vZmYoZG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIF90aGlzLl9vbkRyb3ApO1xcblxcblxcdFxcdFxcdFxcdGlmIChkYXRhVHJhbnNmZXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRkYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9ICdtb3ZlJztcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb25zLnNldERhdGEgJiYgb3B0aW9ucy5zZXREYXRhLmNhbGwoX3RoaXMsIGRhdGFUcmFuc2ZlciwgZHJhZ0VsKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0X29uKGRvY3VtZW50LCAnZHJvcCcsIF90aGlzKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyAjMTI3NiBmaXg6XFxuXFx0XFx0XFx0XFx0X2NzcyhkcmFnRWwsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlWigwKScpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRhd2FpdGluZ0RyYWdTdGFydGVkID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRfdGhpcy5fZHJhZ1N0YXJ0SWQgPSBfbmV4dFRpY2soX3RoaXMuX2RyYWdTdGFydGVkLmJpbmQoX3RoaXMsIGZhbGxiYWNrLCBldnQpKTtcXG5cXHRcXHRcXHRfb24oZG9jdW1lbnQsICdzZWxlY3RzdGFydCcsIF90aGlzKTtcXG5cXHRcXHRcXHRpZiAoU2FmYXJpKSB7XFxuXFx0XFx0XFx0XFx0X2Nzcyhkb2N1bWVudC5ib2R5LCAndXNlci1zZWxlY3QnLCAnbm9uZScpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcblxcdFxcdC8vIFJldHVybnMgdHJ1ZSAtIGlmIG5vIGZ1cnRoZXIgYWN0aW9uIGlzIG5lZWRlZCAoZWl0aGVyIGluc2VydGVkIG9yIGFub3RoZXIgY29uZGl0aW9uKVxcblxcdFxcdF9vbkRyYWdPdmVyOiBmdW5jdGlvbiAoLyoqRXZlbnQqL2V2dCkge1xcblxcdFxcdFxcdHZhciBlbCA9IHRoaXMuZWwsXFxuXFx0XFx0XFx0XFx0dGFyZ2V0ID0gZXZ0LnRhcmdldCxcXG5cXHRcXHRcXHRcXHRkcmFnUmVjdCxcXG5cXHRcXHRcXHRcXHR0YXJnZXRSZWN0LFxcblxcdFxcdFxcdFxcdHJldmVydCxcXG5cXHRcXHRcXHRcXHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxcblxcdFxcdFxcdFxcdGdyb3VwID0gb3B0aW9ucy5ncm91cCxcXG5cXHRcXHRcXHRcXHRhY3RpdmVTb3J0YWJsZSA9IFNvcnRhYmxlLmFjdGl2ZSxcXG5cXHRcXHRcXHRcXHRpc093bmVyID0gKGFjdGl2ZUdyb3VwID09PSBncm91cCksXFxuXFx0XFx0XFx0XFx0Y2FuU29ydCA9IG9wdGlvbnMuc29ydCxcXG5cXHRcXHRcXHRcXHRfdGhpcyA9IHRoaXM7XFxuXFxuXFx0XFx0XFx0aWYgKF9zaWxlbnQpIHJldHVybjtcXG5cXG5cXHRcXHRcXHQvLyBSZXR1cm4gaW52b2NhdGlvbiB3aGVuIGRyYWdFbCBpcyBpbnNlcnRlZCAob3IgY29tcGxldGVkKVxcblxcdFxcdFxcdGZ1bmN0aW9uIGNvbXBsZXRlZChpbnNlcnRpb24pIHtcXG5cXHRcXHRcXHRcXHRpZiAoaW5zZXJ0aW9uKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGlzT3duZXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhY3RpdmVTb3J0YWJsZS5faGlkZUNsb25lKCk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhY3RpdmVTb3J0YWJsZS5fc2hvd0Nsb25lKF90aGlzKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGFjdGl2ZVNvcnRhYmxlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gU2V0IGdob3N0IGNsYXNzIHRvIG5ldyBzb3J0YWJsZSdzIGdob3N0IGNsYXNzXFxuXFx0XFx0XFx0XFx0XFx0XFx0X3RvZ2dsZUNsYXNzKGRyYWdFbCwgcHV0U29ydGFibGUgPyBwdXRTb3J0YWJsZS5vcHRpb25zLmdob3N0Q2xhc3MgOiBhY3RpdmVTb3J0YWJsZS5vcHRpb25zLmdob3N0Q2xhc3MsIGZhbHNlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRfdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmdob3N0Q2xhc3MsIHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAocHV0U29ydGFibGUgIT09IF90aGlzICYmIF90aGlzICE9PSBTb3J0YWJsZS5hY3RpdmUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwdXRTb3J0YWJsZSA9IF90aGlzO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoX3RoaXMgPT09IFNvcnRhYmxlLmFjdGl2ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHB1dFNvcnRhYmxlID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQW5pbWF0aW9uXFxuXFx0XFx0XFx0XFx0XFx0ZHJhZ1JlY3QgJiYgX3RoaXMuX2FuaW1hdGUoZHJhZ1JlY3QsIGRyYWdFbCk7XFxuXFx0XFx0XFx0XFx0XFx0dGFyZ2V0ICYmIHRhcmdldFJlY3QgJiYgX3RoaXMuX2FuaW1hdGUodGFyZ2V0UmVjdCwgdGFyZ2V0KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFxuXFx0XFx0XFx0XFx0Ly8gTnVsbCBsYXN0VGFyZ2V0IGlmIGl0IGlzIG5vdCBpbnNpZGUgYSBwcmV2aW91c2x5IHN3YXBwZWQgZWxlbWVudFxcblxcdFxcdFxcdFxcdGlmICgodGFyZ2V0ID09PSBkcmFnRWwgJiYgIWRyYWdFbC5hbmltYXRlZCkgfHwgKHRhcmdldCA9PT0gZWwgJiYgIXRhcmdldC5hbmltYXRlZCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRsYXN0VGFyZ2V0ID0gbnVsbDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbm8gYnViYmxpbmcgYW5kIG5vdCBmYWxsYmFja1xcblxcdFxcdFxcdFxcdGlmICghb3B0aW9ucy5kcmFnb3ZlckJ1YmJsZSAmJiAhZXZ0LnJvb3RFbCAmJiB0YXJnZXQgIT09IGRvY3VtZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0X3RoaXMuX2hhbmRsZUF1dG9TY3JvbGwoZXZ0KTtcXG5cXHRcXHRcXHRcXHRcXHRkcmFnRWwucGFyZW50Tm9kZVtleHBhbmRvXS5fY29tcHV0ZUlzQWxpZ25lZChldnQpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIERvIG5vdCBkZXRlY3QgZm9yIGVtcHR5IGluc2VydCBpZiBhbHJlYWR5IGluc2VydGVkXFxuXFx0XFx0XFx0XFx0XFx0IWluc2VydGlvbiAmJiBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudChldnQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQhb3B0aW9ucy5kcmFnb3ZlckJ1YmJsZSAmJiBldnQuc3RvcFByb3BhZ2F0aW9uICYmIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ2FsbCB3aGVuIGRyYWdFbCBoYXMgYmVlbiBpbnNlcnRlZFxcblxcdFxcdFxcdGZ1bmN0aW9uIGNoYW5nZWQoKSB7XFxuXFx0XFx0XFx0XFx0X2Rpc3BhdGNoRXZlbnQoX3RoaXMsIHJvb3RFbCwgJ2NoYW5nZScsIHRhcmdldCwgZWwsIHJvb3RFbCwgb2xkSW5kZXgsIF9pbmRleChkcmFnRWwpLCBvbGREcmFnZ2FibGVJbmRleCwgX2luZGV4KGRyYWdFbCwgb3B0aW9ucy5kcmFnZ2FibGUpLCBldnQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXG5cXHRcXHRcXHRpZiAoZXZ0LnByZXZlbnREZWZhdWx0ICE9PSB2b2lkIDApIHtcXG5cXHRcXHRcXHRcXHRldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFxuXFx0XFx0XFx0bW92ZWQgPSB0cnVlO1xcblxcblxcdFxcdFxcdHRhcmdldCA9IF9jbG9zZXN0KHRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUsIGVsLCB0cnVlKTtcXG5cXG5cXHRcXHRcXHQvLyB0YXJnZXQgaXMgZHJhZ0VsIG9yIHRhcmdldCBpcyBhbmltYXRlZFxcblxcdFxcdFxcdGlmIChkcmFnRWwuY29udGFpbnMoZXZ0LnRhcmdldCkgfHwgdGFyZ2V0LmFuaW1hdGVkKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICh0YXJnZXQgIT09IGRyYWdFbCkge1xcblxcdFxcdFxcdFxcdGlnbm9yZU5leHRDbGljayA9IGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoYWN0aXZlU29ydGFibGUgJiYgIW9wdGlvbnMuZGlzYWJsZWQgJiZcXG5cXHRcXHRcXHRcXHQoaXNPd25lclxcblxcdFxcdFxcdFxcdFxcdD8gY2FuU29ydCB8fCAocmV2ZXJ0ID0gIXJvb3RFbC5jb250YWlucyhkcmFnRWwpKSAvLyBSZXZlcnRpbmcgaXRlbSBpbnRvIHRoZSBvcmlnaW5hbCBsaXN0XFxuXFx0XFx0XFx0XFx0XFx0OiAoXFxuXFx0XFx0XFx0XFx0XFx0XFx0cHV0U29ydGFibGUgPT09IHRoaXMgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHQoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KHRoaXMubGFzdFB1dE1vZGUgPSBhY3RpdmVHcm91cC5jaGVja1B1bGwodGhpcywgYWN0aXZlU29ydGFibGUsIGRyYWdFbCwgZXZ0KSkgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRncm91cC5jaGVja1B1dCh0aGlzLCBhY3RpdmVTb3J0YWJsZSwgZHJhZ0VsLCBldnQpXFxuXFx0XFx0XFx0XFx0XFx0XFx0KVxcblxcdFxcdFxcdFxcdFxcdClcXG5cXHRcXHRcXHRcXHQpXFxuXFx0XFx0XFx0KSB7XFxuXFx0XFx0XFx0XFx0dmFyIGF4aXMgPSB0aGlzLl9nZXREaXJlY3Rpb24oZXZ0LCB0YXJnZXQpO1xcblxcblxcdFxcdFxcdFxcdGRyYWdSZWN0ID0gX2dldFJlY3QoZHJhZ0VsKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAocmV2ZXJ0KSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5faGlkZUNsb25lKCk7XFxuXFx0XFx0XFx0XFx0XFx0cGFyZW50RWwgPSByb290RWw7IC8vIGFjdHVhbGl6YXRpb25cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAobmV4dEVsKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cm9vdEVsLmluc2VydEJlZm9yZShkcmFnRWwsIG5leHRFbCk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyb290RWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGNvbXBsZXRlZCh0cnVlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGVsTGFzdENoaWxkID0gX2xhc3RDaGlsZChlbCk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCFlbExhc3RDaGlsZCB8fCBfZ2hvc3RJc0xhc3QoZXZ0LCBheGlzLCBlbCkgJiYgIWVsTGFzdENoaWxkLmFuaW1hdGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gYXNzaWduIHRhcmdldCBvbmx5IGlmIGNvbmRpdGlvbiBpcyB0cnVlXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGVsTGFzdENoaWxkICYmIGVsID09PSBldnQudGFyZ2V0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGFyZ2V0ID0gZWxMYXN0Q2hpbGQ7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlmICh0YXJnZXQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0YXJnZXRSZWN0ID0gX2dldFJlY3QodGFyZ2V0KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGlzT3duZXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhY3RpdmVTb3J0YWJsZS5faGlkZUNsb25lKCk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhY3RpdmVTb3J0YWJsZS5fc2hvd0Nsb25lKHRoaXMpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoX29uTW92ZShyb290RWwsIGVsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXQsIHRhcmdldFJlY3QsIGV2dCwgISF0YXJnZXQpICE9PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cGFyZW50RWwgPSBlbDsgLy8gYWN0dWFsaXphdGlvblxcblxcdFxcdFxcdFxcdFxcdFxcdHJlYWxEcmFnRWxSZWN0ID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjaGFuZ2VkKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGNvbXBsZXRlZCh0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGVsc2UgaWYgKHRhcmdldCAmJiB0YXJnZXQgIT09IGRyYWdFbCAmJiB0YXJnZXQucGFyZW50Tm9kZSA9PT0gZWwpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZGlyZWN0aW9uID0gMCxcXG5cXHRcXHRcXHRcXHRcXHRcXHR0YXJnZXRCZWZvcmVGaXJzdFN3YXAsXFxuXFx0XFx0XFx0XFx0XFx0XFx0YWxpZ25lZCA9IHRhcmdldC5zb3J0YWJsZU1vdXNlQWxpZ25lZCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRkaWZmZXJlbnRMZXZlbCA9IGRyYWdFbC5wYXJlbnROb2RlICE9PSBlbCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRzaWRlMSA9IGF4aXMgPT09ICd2ZXJ0aWNhbCcgPyAndG9wJyA6ICdsZWZ0JyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRzY3JvbGxlZFBhc3RUb3AgPSBfaXNTY3JvbGxlZFBhc3QodGFyZ2V0LCAndG9wJykgfHwgX2lzU2Nyb2xsZWRQYXN0KGRyYWdFbCwgJ3RvcCcpLFxcblxcdFxcdFxcdFxcdFxcdFxcdHNjcm9sbEJlZm9yZSA9IHNjcm9sbGVkUGFzdFRvcCA/IHNjcm9sbGVkUGFzdFRvcC5zY3JvbGxUb3AgOiB2b2lkIDA7XFxuXFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGxhc3RUYXJnZXQgIT09IHRhcmdldCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGxhc3RNb2RlID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0YXJnZXRCZWZvcmVGaXJzdFN3YXAgPSBfZ2V0UmVjdCh0YXJnZXQpW3NpZGUxXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUmVmZXJlbmNlOiBodHRwczovL3d3dy5sdWNpZGNoYXJ0LmNvbS9kb2N1bWVudHMvdmlldy8xMGZhMGU5My1lMzYyLTQxMjYtYWNhMi1iNzA5ZWU1NmJkOGIvMFxcblxcdFxcdFxcdFxcdFxcdGlmIChcXG5cXHRcXHRcXHRcXHRcXHRcXHRfaXNFbEluUm93Q29sdW1uKGRyYWdFbCwgdGFyZ2V0LCBheGlzKSAmJiBhbGlnbmVkIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGlmZmVyZW50TGV2ZWwgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRzY3JvbGxlZFBhc3RUb3AgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRvcHRpb25zLmludmVydFN3YXAgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRsYXN0TW9kZSA9PT0gJ2luc2VydCcgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBOZWVkZWQsIGluIHRoZSBjYXNlIHRoYXQgd2UgYXJlIGluc2lkZSB0YXJnZXQgYW5kIGluc2VydGVkIGJlY2F1c2Ugbm90IGFsaWduZWQuLi4gYWxpZ25lZCB3aWxsIHN0YXkgZmFsc2Ugd2hpbGUgaW5zaWRlXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gYW5kIGxhc3RNb2RlIHdpbGwgY2hhbmdlIHRvICdpbnNlcnQnLCBidXQgd2UgbXVzdCBzd2FwXFxuXFx0XFx0XFx0XFx0XFx0XFx0bGFzdE1vZGUgPT09ICdzd2FwJ1xcblxcdFxcdFxcdFxcdFxcdCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIE5ldyB0YXJnZXQgdGhhdCB3ZSB3aWxsIGJlIGluc2lkZVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChsYXN0TW9kZSAhPT0gJ3N3YXAnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aXNDaXJjdW1zdGFudGlhbEludmVydCA9IG9wdGlvbnMuaW52ZXJ0U3dhcCB8fCBkaWZmZXJlbnRMZXZlbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGlyZWN0aW9uID0gX2dldFN3YXBEaXJlY3Rpb24oZXZ0LCB0YXJnZXQsIGF4aXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0b3B0aW9ucy5zd2FwVGhyZXNob2xkLCBvcHRpb25zLmludmVydGVkU3dhcFRocmVzaG9sZCA9PSBudWxsID8gb3B0aW9ucy5zd2FwVGhyZXNob2xkIDogb3B0aW9ucy5pbnZlcnRlZFN3YXBUaHJlc2hvbGQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aXNDaXJjdW1zdGFudGlhbEludmVydCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRsYXN0VGFyZ2V0ID09PSB0YXJnZXQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGxhc3RNb2RlID0gJ3N3YXAnO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gSW5zZXJ0IGF0IHBvc2l0aW9uXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGlyZWN0aW9uID0gX2dldEluc2VydERpcmVjdGlvbih0YXJnZXQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGxhc3RNb2RlID0gJ2luc2VydCc7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChkaXJlY3Rpb24gPT09IDApIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xcblxcblxcdFxcdFxcdFxcdFxcdHJlYWxEcmFnRWxSZWN0ID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRsYXN0VGFyZ2V0ID0gdGFyZ2V0O1xcblxcblxcdFxcdFxcdFxcdFxcdGxhc3REaXJlY3Rpb24gPSBkaXJlY3Rpb247XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGFyZ2V0UmVjdCA9IF9nZXRSZWN0KHRhcmdldCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIG5leHRTaWJsaW5nID0gdGFyZ2V0Lm5leHRFbGVtZW50U2libGluZyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRhZnRlciA9IGZhbHNlO1xcblxcblxcdFxcdFxcdFxcdFxcdGFmdGVyID0gZGlyZWN0aW9uID09PSAxO1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBtb3ZlVmVjdG9yID0gX29uTW92ZShyb290RWwsIGVsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXQsIHRhcmdldFJlY3QsIGV2dCwgYWZ0ZXIpO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChtb3ZlVmVjdG9yICE9PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChtb3ZlVmVjdG9yID09PSAxIHx8IG1vdmVWZWN0b3IgPT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YWZ0ZXIgPSAobW92ZVZlY3RvciA9PT0gMSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdF9zaWxlbnQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdHNldFRpbWVvdXQoX3Vuc2lsZW50LCAzMCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGlzT3duZXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRhY3RpdmVTb3J0YWJsZS5faGlkZUNsb25lKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRhY3RpdmVTb3J0YWJsZS5fc2hvd0Nsb25lKHRoaXMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoYWZ0ZXIgJiYgIW5leHRTaWJsaW5nKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRhcmdldC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkcmFnRWwsIGFmdGVyID8gbmV4dFNpYmxpbmcgOiB0YXJnZXQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBVbmRvIGNocm9tZSdzIHNjcm9sbCBhZGp1c3RtZW50XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHNjcm9sbGVkUGFzdFRvcCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdF9zY3JvbGxCeShzY3JvbGxlZFBhc3RUb3AsIDAsIHNjcm9sbEJlZm9yZSAtIHNjcm9sbGVkUGFzdFRvcC5zY3JvbGxUb3ApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRwYXJlbnRFbCA9IGRyYWdFbC5wYXJlbnROb2RlOyAvLyBhY3R1YWxpemF0aW9uXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gbXVzdCBiZSBkb25lIGJlZm9yZSBhbmltYXRpb25cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodGFyZ2V0QmVmb3JlRmlyc3RTd2FwICE9PSB1bmRlZmluZWQgJiYgIWlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0YXJnZXRNb3ZlRGlzdGFuY2UgPSBhYnModGFyZ2V0QmVmb3JlRmlyc3RTd2FwIC0gX2dldFJlY3QodGFyZ2V0KVtzaWRlMV0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRjaGFuZ2VkKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGNvbXBsZXRlZCh0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmIChlbC5jb250YWlucyhkcmFnRWwpKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfYW5pbWF0ZTogZnVuY3Rpb24gKHByZXZSZWN0LCB0YXJnZXQpIHtcXG5cXHRcXHRcXHR2YXIgbXMgPSB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uO1xcblxcblxcdFxcdFxcdGlmIChtcykge1xcblxcdFxcdFxcdFxcdHZhciBjdXJyZW50UmVjdCA9IF9nZXRSZWN0KHRhcmdldCk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHRhcmdldCA9PT0gZHJhZ0VsKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmVhbERyYWdFbFJlY3QgPSBjdXJyZW50UmVjdDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHByZXZSZWN0Lm5vZGVUeXBlID09PSAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0cHJldlJlY3QgPSBfZ2V0UmVjdChwcmV2UmVjdCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIENoZWNrIGlmIGFjdHVhbGx5IG1vdmluZyBwb3NpdGlvblxcblxcdFxcdFxcdFxcdGlmICgocHJldlJlY3QubGVmdCArIHByZXZSZWN0LndpZHRoIC8gMikgIT09IChjdXJyZW50UmVjdC5sZWZ0ICsgY3VycmVudFJlY3Qud2lkdGggLyAyKVxcblxcdFxcdFxcdFxcdFxcdHx8IChwcmV2UmVjdC50b3AgKyBwcmV2UmVjdC5oZWlnaHQgLyAyKSAhPT0gKGN1cnJlbnRSZWN0LnRvcCArIGN1cnJlbnRSZWN0LmhlaWdodCAvIDIpXFxuXFx0XFx0XFx0XFx0KSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1hdHJpeCA9IF9tYXRyaXgodGhpcy5lbCksXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2NhbGVYID0gbWF0cml4ICYmIG1hdHJpeC5hLFxcblxcdFxcdFxcdFxcdFxcdFxcdHNjYWxlWSA9IG1hdHJpeCAmJiBtYXRyaXguZDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRfY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAnbm9uZScpO1xcblxcdFxcdFxcdFxcdFxcdF9jc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZTNkKCdcXG5cXHRcXHRcXHRcXHRcXHRcXHQrIChwcmV2UmVjdC5sZWZ0IC0gY3VycmVudFJlY3QubGVmdCkgLyAoc2NhbGVYID8gc2NhbGVYIDogMSkgKyAncHgsJ1xcblxcdFxcdFxcdFxcdFxcdFxcdCsgKHByZXZSZWN0LnRvcCAtIGN1cnJlbnRSZWN0LnRvcCkgLyAoc2NhbGVZID8gc2NhbGVZIDogMSkgKyAncHgsMCknXFxuXFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9yZXBhaW50KHRhcmdldCk7XFxuXFx0XFx0XFx0XFx0XFx0X2Nzcyh0YXJnZXQsICd0cmFuc2l0aW9uJywgJ3RyYW5zZm9ybSAnICsgbXMgKyAnbXMnICsgKHRoaXMub3B0aW9ucy5lYXNpbmcgPyAnICcgKyB0aGlzLm9wdGlvbnMuZWFzaW5nIDogJycpKTtcXG5cXHRcXHRcXHRcXHRcXHRfY3NzKHRhcmdldCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUzZCgwLDAsMCknKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0KHR5cGVvZiB0YXJnZXQuYW5pbWF0ZWQgPT09ICdudW1iZXInKSAmJiBjbGVhclRpbWVvdXQodGFyZ2V0LmFuaW1hdGVkKTtcXG5cXHRcXHRcXHRcXHR0YXJnZXQuYW5pbWF0ZWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRfY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAnJyk7XFxuXFx0XFx0XFx0XFx0XFx0X2Nzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAnJyk7XFxuXFx0XFx0XFx0XFx0XFx0dGFyZ2V0LmFuaW1hdGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fSwgbXMpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9yZXBhaW50OiBmdW5jdGlvbih0YXJnZXQpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGFyZ2V0Lm9mZnNldFdpZHRoO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X29mZk1vdmVFdmVudHM6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdF9vZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XFxuXFx0XFx0XFx0X29mZihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xcblxcdFxcdFxcdF9vZmYoZG9jdW1lbnQsICdkcmFnb3ZlcicsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcXG5cXHRcXHRcXHRfb2ZmKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xcblxcdFxcdFxcdF9vZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfb2ZmVXBFdmVudHM6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHR2YXIgb3duZXJEb2N1bWVudCA9IHRoaXMuZWwub3duZXJEb2N1bWVudDtcXG5cXG5cXHRcXHRcXHRfb2ZmKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fb25Ecm9wKTtcXG5cXHRcXHRcXHRfb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uRHJvcCk7XFxuXFx0XFx0XFx0X29mZihvd25lckRvY3VtZW50LCAncG9pbnRlcnVwJywgdGhpcy5fb25Ecm9wKTtcXG5cXHRcXHRcXHRfb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIHRoaXMuX29uRHJvcCk7XFxuXFx0XFx0XFx0X29mZihkb2N1bWVudCwgJ3NlbGVjdHN0YXJ0JywgdGhpcyk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfb25Ecm9wOiBmdW5jdGlvbiAoLyoqRXZlbnQqL2V2dCkge1xcblxcdFxcdFxcdHZhciBlbCA9IHRoaXMuZWwsXFxuXFx0XFx0XFx0XFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucztcXG5cXHRcXHRcXHRhd2FpdGluZ0RyYWdTdGFydGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0c2Nyb2xsaW5nID0gZmFsc2U7XFxuXFx0XFx0XFx0aXNDaXJjdW1zdGFudGlhbEludmVydCA9IGZhbHNlO1xcblxcdFxcdFxcdHBhc3RGaXJzdEludmVydFRocmVzaCA9IGZhbHNlO1xcblxcblxcdFxcdFxcdGNsZWFySW50ZXJ2YWwodGhpcy5fbG9vcElkKTtcXG5cXG5cXHRcXHRcXHRjbGVhckludGVydmFsKHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKTtcXG5cXHRcXHRcXHRfY2xlYXJBdXRvU2Nyb2xscygpO1xcblxcdFxcdFxcdF9jYW5jZWxUaHJvdHRsZSgpO1xcblxcblxcdFxcdFxcdGNsZWFyVGltZW91dCh0aGlzLl9kcmFnU3RhcnRUaW1lcik7XFxuXFxuXFx0XFx0XFx0X2NhbmNlbE5leHRUaWNrKHRoaXMuX2Nsb25lSWQpO1xcblxcdFxcdFxcdF9jYW5jZWxOZXh0VGljayh0aGlzLl9kcmFnU3RhcnRJZCk7XFxuXFxuXFx0XFx0XFx0Ly8gVW5iaW5kIGV2ZW50c1xcblxcdFxcdFxcdF9vZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XFxuXFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XFxuXFx0XFx0XFx0XFx0X29mZihkb2N1bWVudCwgJ2Ryb3AnLCB0aGlzKTtcXG5cXHRcXHRcXHRcXHRfb2ZmKGVsLCAnZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xcblxcdFxcdFxcdFxcdF9vZmYoZG9jdW1lbnQsICdkcmFnb3ZlcicsIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwpO1xcblxcdFxcdFxcdFxcdF9vZmYoZG9jdW1lbnQsICdkcmFnb3ZlcicsIF9jaGVja0FsaWdubWVudCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChTYWZhcmkpIHtcXG5cXHRcXHRcXHRcXHRfY3NzKGRvY3VtZW50LmJvZHksICd1c2VyLXNlbGVjdCcsICcnKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fb2ZmTW92ZUV2ZW50cygpO1xcblxcdFxcdFxcdHRoaXMuX29mZlVwRXZlbnRzKCk7XFxuXFxuXFx0XFx0XFx0aWYgKGV2dCkge1xcblxcdFxcdFxcdFxcdGlmIChtb3ZlZCkge1xcblxcdFxcdFxcdFxcdFxcdGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdCFvcHRpb25zLmRyb3BCdWJibGUgJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRnaG9zdEVsICYmIGdob3N0RWwucGFyZW50Tm9kZSAmJiBnaG9zdEVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZ2hvc3RFbCk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHJvb3RFbCA9PT0gcGFyZW50RWwgfHwgKHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlICE9PSAnY2xvbmUnKSkge1xcblxcdFxcdFxcdFxcdFxcdC8vIFJlbW92ZSBjbG9uZVxcblxcdFxcdFxcdFxcdFxcdGNsb25lRWwgJiYgY2xvbmVFbC5wYXJlbnROb2RlICYmIGNsb25lRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZUVsKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKGRyYWdFbCkge1xcblxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdF9vZmYoZHJhZ0VsLCAnZHJhZ2VuZCcsIHRoaXMpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRfZGlzYWJsZURyYWdnYWJsZShkcmFnRWwpO1xcblxcdFxcdFxcdFxcdFxcdGRyYWdFbC5zdHlsZVsnd2lsbC1jaGFuZ2UnXSA9ICcnO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFJlbW92ZSBjbGFzcydzXFxuXFx0XFx0XFx0XFx0XFx0X3RvZ2dsZUNsYXNzKGRyYWdFbCwgcHV0U29ydGFibGUgPyBwdXRTb3J0YWJsZS5vcHRpb25zLmdob3N0Q2xhc3MgOiB0aGlzLm9wdGlvbnMuZ2hvc3RDbGFzcywgZmFsc2UpO1xcblxcdFxcdFxcdFxcdFxcdF90b2dnbGVDbGFzcyhkcmFnRWwsIHRoaXMub3B0aW9ucy5jaG9zZW5DbGFzcywgZmFsc2UpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIERyYWcgc3RvcCBldmVudFxcblxcdFxcdFxcdFxcdFxcdF9kaXNwYXRjaEV2ZW50KHRoaXMsIHJvb3RFbCwgJ3VuY2hvb3NlJywgZHJhZ0VsLCBwYXJlbnRFbCwgcm9vdEVsLCBvbGRJbmRleCwgbnVsbCwgb2xkRHJhZ2dhYmxlSW5kZXgsIG51bGwsIGV2dCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHJvb3RFbCAhPT0gcGFyZW50RWwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRuZXdJbmRleCA9IF9pbmRleChkcmFnRWwpO1xcblxcdFxcdFxcdFxcdFxcdFxcdG5ld0RyYWdnYWJsZUluZGV4ID0gX2luZGV4KGRyYWdFbCwgb3B0aW9ucy5kcmFnZ2FibGUpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChuZXdJbmRleCA+PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gQWRkIGV2ZW50XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0X2Rpc3BhdGNoRXZlbnQobnVsbCwgcGFyZW50RWwsICdhZGQnLCBkcmFnRWwsIHBhcmVudEVsLCByb290RWwsIG9sZEluZGV4LCBuZXdJbmRleCwgb2xkRHJhZ2dhYmxlSW5kZXgsIG5ld0RyYWdnYWJsZUluZGV4LCBldnQpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFJlbW92ZSBldmVudFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdF9kaXNwYXRjaEV2ZW50KHRoaXMsIHJvb3RFbCwgJ3JlbW92ZScsIGRyYWdFbCwgcGFyZW50RWwsIHJvb3RFbCwgb2xkSW5kZXgsIG5ld0luZGV4LCBvbGREcmFnZ2FibGVJbmRleCwgbmV3RHJhZ2dhYmxlSW5kZXgsIGV2dCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZHJhZyBmcm9tIG9uZSBsaXN0IGFuZCBkcm9wIGludG8gYW5vdGhlclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdF9kaXNwYXRjaEV2ZW50KG51bGwsIHBhcmVudEVsLCAnc29ydCcsIGRyYWdFbCwgcGFyZW50RWwsIHJvb3RFbCwgb2xkSW5kZXgsIG5ld0luZGV4LCBvbGREcmFnZ2FibGVJbmRleCwgbmV3RHJhZ2dhYmxlSW5kZXgsIGV2dCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0X2Rpc3BhdGNoRXZlbnQodGhpcywgcm9vdEVsLCAnc29ydCcsIGRyYWdFbCwgcGFyZW50RWwsIHJvb3RFbCwgb2xkSW5kZXgsIG5ld0luZGV4LCBvbGREcmFnZ2FibGVJbmRleCwgbmV3RHJhZ2dhYmxlSW5kZXgsIGV2dCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLnNhdmUoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0ZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGRyYWdFbC5uZXh0U2libGluZyAhPT0gbmV4dEVsKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bmV3SW5kZXggPSBfaW5kZXgoZHJhZ0VsKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRuZXdEcmFnZ2FibGVJbmRleCA9IF9pbmRleChkcmFnRWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAobmV3SW5kZXggPj0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGRyYWcgJiBkcm9wIHdpdGhpbiB0aGUgc2FtZSBsaXN0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0X2Rpc3BhdGNoRXZlbnQodGhpcywgcm9vdEVsLCAndXBkYXRlJywgZHJhZ0VsLCBwYXJlbnRFbCwgcm9vdEVsLCBvbGRJbmRleCwgbmV3SW5kZXgsIG9sZERyYWdnYWJsZUluZGV4LCBuZXdEcmFnZ2FibGVJbmRleCwgZXZ0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRfZGlzcGF0Y2hFdmVudCh0aGlzLCByb290RWwsICdzb3J0JywgZHJhZ0VsLCBwYXJlbnRFbCwgcm9vdEVsLCBvbGRJbmRleCwgbmV3SW5kZXgsIG9sZERyYWdnYWJsZUluZGV4LCBuZXdEcmFnZ2FibGVJbmRleCwgZXZ0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoU29ydGFibGUuYWN0aXZlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0LyoganNoaW50IGVxbnVsbDp0cnVlICovXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG5ld0luZGV4ID09IG51bGwgfHwgbmV3SW5kZXggPT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bmV3SW5kZXggPSBvbGRJbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRuZXdEcmFnZ2FibGVJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRfZGlzcGF0Y2hFdmVudCh0aGlzLCByb290RWwsICdlbmQnLCBkcmFnRWwsIHBhcmVudEVsLCByb290RWwsIG9sZEluZGV4LCBuZXdJbmRleCwgb2xkRHJhZ2dhYmxlSW5kZXgsIG5ld0RyYWdnYWJsZUluZGV4LCBldnQpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFNhdmUgc29ydGluZ1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc2F2ZSgpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMuX251bGxpbmcoKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9udWxsaW5nOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyb290RWwgPVxcblxcdFxcdFxcdGRyYWdFbCA9XFxuXFx0XFx0XFx0cGFyZW50RWwgPVxcblxcdFxcdFxcdGdob3N0RWwgPVxcblxcdFxcdFxcdG5leHRFbCA9XFxuXFx0XFx0XFx0Y2xvbmVFbCA9XFxuXFx0XFx0XFx0bGFzdERvd25FbCA9XFxuXFxuXFx0XFx0XFx0c2Nyb2xsRWwgPVxcblxcdFxcdFxcdHNjcm9sbFBhcmVudEVsID1cXG5cXHRcXHRcXHRhdXRvU2Nyb2xscy5sZW5ndGggPVxcblxcblxcdFxcdFxcdHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsID1cXG5cXHRcXHRcXHRsYXN0UG9pbnRlckVsZW1YID1cXG5cXHRcXHRcXHRsYXN0UG9pbnRlckVsZW1ZID1cXG5cXG5cXHRcXHRcXHR0YXBFdnQgPVxcblxcdFxcdFxcdHRvdWNoRXZ0ID1cXG5cXG5cXHRcXHRcXHRtb3ZlZCA9XFxuXFx0XFx0XFx0bmV3SW5kZXggPVxcblxcdFxcdFxcdG9sZEluZGV4ID1cXG5cXG5cXHRcXHRcXHRsYXN0VGFyZ2V0ID1cXG5cXHRcXHRcXHRsYXN0RGlyZWN0aW9uID1cXG5cXG5cXHRcXHRcXHRyZWFsRHJhZ0VsUmVjdCA9XFxuXFxuXFx0XFx0XFx0cHV0U29ydGFibGUgPVxcblxcdFxcdFxcdGFjdGl2ZUdyb3VwID1cXG5cXHRcXHRcXHRTb3J0YWJsZS5hY3RpdmUgPSBudWxsO1xcblxcblxcdFxcdFxcdHNhdmVkSW5wdXRDaGVja2VkLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XFxuXFx0XFx0XFx0XFx0ZWwuY2hlY2tlZCA9IHRydWU7XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0c2F2ZWRJbnB1dENoZWNrZWQubGVuZ3RoID0gMDtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGhhbmRsZUV2ZW50OiBmdW5jdGlvbiAoLyoqRXZlbnQqL2V2dCkge1xcblxcdFxcdFxcdHN3aXRjaCAoZXZ0LnR5cGUpIHtcXG5cXHRcXHRcXHRcXHRjYXNlICdkcm9wJzpcXG5cXHRcXHRcXHRcXHRjYXNlICdkcmFnZW5kJzpcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9vbkRyb3AoZXZ0KTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRjYXNlICdkcmFnZW50ZXInOlxcblxcdFxcdFxcdFxcdGNhc2UgJ2RyYWdvdmVyJzpcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZHJhZ0VsKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fb25EcmFnT3ZlcihldnQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdF9nbG9iYWxEcmFnT3ZlcihldnQpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRjYXNlICdzZWxlY3RzdGFydCc6XFxuXFx0XFx0XFx0XFx0XFx0ZXZ0LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogU2VyaWFsaXplcyB0aGUgaXRlbSBpbnRvIGFuIGFycmF5IG9mIHN0cmluZy5cXG5cXHRcXHQgKiBAcmV0dXJucyB7U3RyaW5nW119XFxuXFx0XFx0ICovXFxuXFx0XFx0dG9BcnJheTogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHZhciBvcmRlciA9IFtdLFxcblxcdFxcdFxcdFxcdGVsLFxcblxcdFxcdFxcdFxcdGNoaWxkcmVuID0gdGhpcy5lbC5jaGlsZHJlbixcXG5cXHRcXHRcXHRcXHRpID0gMCxcXG5cXHRcXHRcXHRcXHRuID0gY2hpbGRyZW4ubGVuZ3RoLFxcblxcdFxcdFxcdFxcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XFxuXFxuXFx0XFx0XFx0Zm9yICg7IGkgPCBuOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRlbCA9IGNoaWxkcmVuW2ldO1xcblxcdFxcdFxcdFxcdGlmIChfY2xvc2VzdChlbCwgb3B0aW9ucy5kcmFnZ2FibGUsIHRoaXMuZWwsIGZhbHNlKSkge1xcblxcdFxcdFxcdFxcdFxcdG9yZGVyLnB1c2goZWwuZ2V0QXR0cmlidXRlKG9wdGlvbnMuZGF0YUlkQXR0cikgfHwgX2dlbmVyYXRlSWQoZWwpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBvcmRlcjtcXG5cXHRcXHR9LFxcblxcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFNvcnRzIHRoZSBlbGVtZW50cyBhY2NvcmRpbmcgdG8gdGhlIGFycmF5LlxcblxcdFxcdCAqIEBwYXJhbSAge1N0cmluZ1tdfSAgb3JkZXIgIG9yZGVyIG9mIHRoZSBpdGVtc1xcblxcdFxcdCAqL1xcblxcdFxcdHNvcnQ6IGZ1bmN0aW9uIChvcmRlcikge1xcblxcdFxcdFxcdHZhciBpdGVtcyA9IHt9LCByb290RWwgPSB0aGlzLmVsO1xcblxcblxcdFxcdFxcdHRoaXMudG9BcnJheSgpLmZvckVhY2goZnVuY3Rpb24gKGlkLCBpKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGVsID0gcm9vdEVsLmNoaWxkcmVuW2ldO1xcblxcblxcdFxcdFxcdFxcdGlmIChfY2xvc2VzdChlbCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSwgcm9vdEVsLCBmYWxzZSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRpdGVtc1tpZF0gPSBlbDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyk7XFxuXFxuXFx0XFx0XFx0b3JkZXIuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcXG5cXHRcXHRcXHRcXHRpZiAoaXRlbXNbaWRdKSB7XFxuXFx0XFx0XFx0XFx0XFx0cm9vdEVsLnJlbW92ZUNoaWxkKGl0ZW1zW2lkXSk7XFxuXFx0XFx0XFx0XFx0XFx0cm9vdEVsLmFwcGVuZENoaWxkKGl0ZW1zW2lkXSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogU2F2ZSB0aGUgY3VycmVudCBzb3J0aW5nXFxuXFx0XFx0ICovXFxuXFx0XFx0c2F2ZTogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHZhciBzdG9yZSA9IHRoaXMub3B0aW9ucy5zdG9yZTtcXG5cXHRcXHRcXHRzdG9yZSAmJiBzdG9yZS5zZXQgJiYgc3RvcmUuc2V0KHRoaXMpO1xcblxcdFxcdH0sXFxuXFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogRm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LCBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3RvciBieSB0ZXN0aW5nIHRoZSBlbGVtZW50IGl0c2VsZiBhbmQgdHJhdmVyc2luZyB1cCB0aHJvdWdoIGl0cyBhbmNlc3RvcnMgaW4gdGhlIERPTSB0cmVlLlxcblxcdFxcdCAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gIGVsXFxuXFx0XFx0ICogQHBhcmFtICAge1N0cmluZ30gICAgICAgW3NlbGVjdG9yXSAgZGVmYXVsdDogYG9wdGlvbnMuZHJhZ2dhYmxlYFxcblxcdFxcdCAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHxudWxsfVxcblxcdFxcdCAqL1xcblxcdFxcdGNsb3Nlc3Q6IGZ1bmN0aW9uIChlbCwgc2VsZWN0b3IpIHtcXG5cXHRcXHRcXHRyZXR1cm4gX2Nsb3Nlc3QoZWwsIHNlbGVjdG9yIHx8IHRoaXMub3B0aW9ucy5kcmFnZ2FibGUsIHRoaXMuZWwsIGZhbHNlKTtcXG5cXHRcXHR9LFxcblxcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFNldC9nZXQgb3B0aW9uXFxuXFx0XFx0ICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxcblxcdFxcdCAqIEBwYXJhbSAgIHsqfSAgICAgIFt2YWx1ZV1cXG5cXHRcXHQgKiBAcmV0dXJucyB7Kn1cXG5cXHRcXHQgKi9cXG5cXHRcXHRvcHRpb246IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xcblxcdFxcdFxcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xcblxcblxcdFxcdFxcdGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIG9wdGlvbnNbbmFtZV07XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRvcHRpb25zW25hbWVdID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKG5hbWUgPT09ICdncm91cCcpIHtcXG5cXHRcXHRcXHRcXHRcXHRfcHJlcGFyZUdyb3VwKG9wdGlvbnMpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBEZXN0cm95XFxuXFx0XFx0ICovXFxuXFx0XFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHZhciBlbCA9IHRoaXMuZWw7XFxuXFxuXFx0XFx0XFx0ZWxbZXhwYW5kb10gPSBudWxsO1xcblxcblxcdFxcdFxcdF9vZmYoZWwsICdtb3VzZWRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcXG5cXHRcXHRcXHRfb2ZmKGVsLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVGFwU3RhcnQpO1xcblxcdFxcdFxcdF9vZmYoZWwsICdwb2ludGVyZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xcblxcblxcdFxcdFxcdGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xcblxcdFxcdFxcdFxcdF9vZmYoZWwsICdkcmFnb3ZlcicsIHRoaXMpO1xcblxcdFxcdFxcdFxcdF9vZmYoZWwsICdkcmFnZW50ZXInLCB0aGlzKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gUmVtb3ZlIGRyYWdnYWJsZSBhdHRyaWJ1dGVzXFxuXFx0XFx0XFx0QXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChlbC5xdWVyeVNlbGVjdG9yQWxsKCdbZHJhZ2dhYmxlXScpLCBmdW5jdGlvbiAoZWwpIHtcXG5cXHRcXHRcXHRcXHRlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RyYWdnYWJsZScpO1xcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdHRoaXMuX29uRHJvcCgpO1xcblxcblxcdFxcdFxcdHNvcnRhYmxlcy5zcGxpY2Uoc29ydGFibGVzLmluZGV4T2YodGhpcy5lbCksIDEpO1xcblxcblxcdFxcdFxcdHRoaXMuZWwgPSBlbCA9IG51bGw7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfaGlkZUNsb25lOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRpZiAoIWNsb25lRWwuY2xvbmVIaWRkZW4pIHtcXG5cXHRcXHRcXHRcXHRfY3NzKGNsb25lRWwsICdkaXNwbGF5JywgJ25vbmUnKTtcXG5cXHRcXHRcXHRcXHRjbG9uZUVsLmNsb25lSGlkZGVuID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRpZiAoY2xvbmVFbC5wYXJlbnROb2RlICYmIHRoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSkge1xcblxcdFxcdFxcdFxcdFxcdGNsb25lRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZUVsKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3Nob3dDbG9uZTogZnVuY3Rpb24ocHV0U29ydGFibGUpIHtcXG5cXHRcXHRcXHRpZiAocHV0U29ydGFibGUubGFzdFB1dE1vZGUgIT09ICdjbG9uZScpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9oaWRlQ2xvbmUoKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChjbG9uZUVsLmNsb25lSGlkZGVuKSB7XFxuXFx0XFx0XFx0XFx0Ly8gc2hvdyBjbG9uZSBhdCBkcmFnRWwgb3Igb3JpZ2luYWwgcG9zaXRpb25cXG5cXHRcXHRcXHRcXHRpZiAocm9vdEVsLmNvbnRhaW5zKGRyYWdFbCkgJiYgIXRoaXMub3B0aW9ucy5ncm91cC5yZXZlcnRDbG9uZSkge1xcblxcdFxcdFxcdFxcdFxcdHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmVFbCwgZHJhZ0VsKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKG5leHRFbCkge1xcblxcdFxcdFxcdFxcdFxcdHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmVFbCwgbmV4dEVsKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHJvb3RFbC5hcHBlbmRDaGlsZChjbG9uZUVsKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMub3B0aW9ucy5ncm91cC5yZXZlcnRDbG9uZSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2FuaW1hdGUoZHJhZ0VsLCBjbG9uZUVsKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0X2NzcyhjbG9uZUVsLCAnZGlzcGxheScsICcnKTtcXG5cXHRcXHRcXHRcXHRjbG9uZUVsLmNsb25lSGlkZGVuID0gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIF9jbG9zZXN0KC8qKkhUTUxFbGVtZW50Ki9lbCwgLyoqU3RyaW5nKi9zZWxlY3RvciwgLyoqSFRNTEVsZW1lbnQqL2N0eCwgaW5jbHVkZUNUWCkge1xcblxcdFxcdGlmIChlbCkge1xcblxcdFxcdFxcdGN0eCA9IGN0eCB8fCBkb2N1bWVudDtcXG5cXG5cXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0aWYgKFxcblxcdFxcdFxcdFxcdFxcdHNlbGVjdG9yICE9IG51bGwgJiZcXG5cXHRcXHRcXHRcXHRcXHQoXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2VsZWN0b3JbMF0gPT09ICc+JyA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWwucGFyZW50Tm9kZSA9PT0gY3R4ICYmIF9tYXRjaGVzKGVsLCBzZWxlY3RvcikgOlxcblxcdFxcdFxcdFxcdFxcdFxcdF9tYXRjaGVzKGVsLCBzZWxlY3RvcilcXG5cXHRcXHRcXHRcXHRcXHQpIHx8XFxuXFx0XFx0XFx0XFx0XFx0aW5jbHVkZUNUWCAmJiBlbCA9PT0gY3R4XFxuXFx0XFx0XFx0XFx0KSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGVsO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoZWwgPT09IGN0eCkgYnJlYWs7XFxuXFx0XFx0XFx0XFx0LyoganNoaW50IGJvc3M6dHJ1ZSAqL1xcblxcdFxcdFxcdH0gd2hpbGUgKGVsID0gX2dldFBhcmVudE9ySG9zdChlbCkpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gbnVsbDtcXG5cXHR9XFxuXFxuXFxuXFx0ZnVuY3Rpb24gX2dldFBhcmVudE9ySG9zdChlbCkge1xcblxcdFxcdHJldHVybiAoZWwuaG9zdCAmJiBlbCAhPT0gZG9jdW1lbnQgJiYgZWwuaG9zdC5ub2RlVHlwZSlcXG5cXHRcXHRcXHQ/IGVsLmhvc3RcXG5cXHRcXHRcXHQ6IGVsLnBhcmVudE5vZGU7XFxuXFx0fVxcblxcblxcblxcdGZ1bmN0aW9uIF9nbG9iYWxEcmFnT3ZlcigvKipFdmVudCovZXZ0KSB7XFxuXFx0XFx0aWYgKGV2dC5kYXRhVHJhbnNmZXIpIHtcXG5cXHRcXHRcXHRldnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnbW92ZSc7XFxuXFx0XFx0fVxcblxcdFxcdGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdH1cXG5cXG5cXG5cXHRmdW5jdGlvbiBfb24oZWwsIGV2ZW50LCBmbikge1xcblxcdFxcdGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCBJRTExT3JMZXNzID8gZmFsc2UgOiBjYXB0dXJlTW9kZSk7XFxuXFx0fVxcblxcblxcblxcdGZ1bmN0aW9uIF9vZmYoZWwsIGV2ZW50LCBmbikge1xcblxcdFxcdGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCBJRTExT3JMZXNzID8gZmFsc2UgOiBjYXB0dXJlTW9kZSk7XFxuXFx0fVxcblxcblxcblxcdGZ1bmN0aW9uIF90b2dnbGVDbGFzcyhlbCwgbmFtZSwgc3RhdGUpIHtcXG5cXHRcXHRpZiAoZWwgJiYgbmFtZSkge1xcblxcdFxcdFxcdGlmIChlbC5jbGFzc0xpc3QpIHtcXG5cXHRcXHRcXHRcXHRlbC5jbGFzc0xpc3Rbc3RhdGUgPyAnYWRkJyA6ICdyZW1vdmUnXShuYW1lKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZWxzZSB7XFxuXFx0XFx0XFx0XFx0dmFyIGNsYXNzTmFtZSA9ICgnICcgKyBlbC5jbGFzc05hbWUgKyAnICcpLnJlcGxhY2UoUl9TUEFDRSwgJyAnKS5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJyk7XFxuXFx0XFx0XFx0XFx0ZWwuY2xhc3NOYW1lID0gKGNsYXNzTmFtZSArIChzdGF0ZSA/ICcgJyArIG5hbWUgOiAnJykpLnJlcGxhY2UoUl9TUEFDRSwgJyAnKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXG5cXHRmdW5jdGlvbiBfY3NzKGVsLCBwcm9wLCB2YWwpIHtcXG5cXHRcXHR2YXIgc3R5bGUgPSBlbCAmJiBlbC5zdHlsZTtcXG5cXG5cXHRcXHRpZiAoc3R5bGUpIHtcXG5cXHRcXHRcXHRpZiAodmFsID09PSB2b2lkIDApIHtcXG5cXHRcXHRcXHRcXHRpZiAoZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkge1xcblxcdFxcdFxcdFxcdFxcdHZhbCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsICcnKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0ZWxzZSBpZiAoZWwuY3VycmVudFN0eWxlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFsID0gZWwuY3VycmVudFN0eWxlO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gcHJvcCA9PT0gdm9pZCAwID8gdmFsIDogdmFsW3Byb3BdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRlbHNlIHtcXG5cXHRcXHRcXHRcXHRpZiAoIShwcm9wIGluIHN0eWxlKSAmJiBwcm9wLmluZGV4T2YoJ3dlYmtpdCcpID09PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdHByb3AgPSAnLXdlYmtpdC0nICsgcHJvcDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0c3R5bGVbcHJvcF0gPSB2YWwgKyAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyAnJyA6ICdweCcpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIF9tYXRyaXgoZWwpIHtcXG5cXHRcXHR2YXIgYXBwbGllZFRyYW5zZm9ybXMgPSAnJztcXG5cXHRcXHRkbyB7XFxuXFx0XFx0XFx0dmFyIHRyYW5zZm9ybSA9IF9jc3MoZWwsICd0cmFuc2Zvcm0nKTtcXG5cXG5cXHRcXHRcXHRpZiAodHJhbnNmb3JtICYmIHRyYW5zZm9ybSAhPT0gJ25vbmUnKSB7XFxuXFx0XFx0XFx0XFx0YXBwbGllZFRyYW5zZm9ybXMgPSB0cmFuc2Zvcm0gKyAnICcgKyBhcHBsaWVkVHJhbnNmb3JtcztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0LyoganNoaW50IGJvc3M6dHJ1ZSAqL1xcblxcdFxcdH0gd2hpbGUgKGVsID0gZWwucGFyZW50Tm9kZSk7XFxuXFxuXFx0XFx0aWYgKHdpbmRvdy5ET01NYXRyaXgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gbmV3IERPTU1hdHJpeChhcHBsaWVkVHJhbnNmb3Jtcyk7XFxuXFx0XFx0fSBlbHNlIGlmICh3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KSB7XFxuXFx0XFx0XFx0cmV0dXJuIG5ldyBXZWJLaXRDU1NNYXRyaXgoYXBwbGllZFRyYW5zZm9ybXMpO1xcblxcdFxcdH0gZWxzZSBpZiAod2luZG93LkNTU01hdHJpeCkge1xcblxcdFxcdFxcdHJldHVybiBuZXcgQ1NTTWF0cml4KGFwcGxpZWRUcmFuc2Zvcm1zKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcblxcdGZ1bmN0aW9uIF9maW5kKGN0eCwgdGFnTmFtZSwgaXRlcmF0b3IpIHtcXG5cXHRcXHRpZiAoY3R4KSB7XFxuXFx0XFx0XFx0dmFyIGxpc3QgPSBjdHguZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSksIGkgPSAwLCBuID0gbGlzdC5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0aWYgKGl0ZXJhdG9yKSB7XFxuXFx0XFx0XFx0XFx0Zm9yICg7IGkgPCBuOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRpdGVyYXRvcihsaXN0W2ldLCBpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBsaXN0O1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gW107XFxuXFx0fVxcblxcblxcblxcblxcdGZ1bmN0aW9uIF9kaXNwYXRjaEV2ZW50KFxcblxcdFxcdHNvcnRhYmxlLCByb290RWwsIG5hbWUsXFxuXFx0XFx0dGFyZ2V0RWwsIHRvRWwsIGZyb21FbCxcXG5cXHRcXHRzdGFydEluZGV4LCBuZXdJbmRleCxcXG5cXHRcXHRzdGFydERyYWdnYWJsZUluZGV4LCBuZXdEcmFnZ2FibGVJbmRleCxcXG5cXHRcXHRvcmlnaW5hbEV2dFxcblxcdCkge1xcblxcdFxcdHNvcnRhYmxlID0gKHNvcnRhYmxlIHx8IHJvb3RFbFtleHBhbmRvXSk7XFxuXFx0XFx0dmFyIGV2dCxcXG5cXHRcXHRcXHRvcHRpb25zID0gc29ydGFibGUub3B0aW9ucyxcXG5cXHRcXHRcXHRvbk5hbWUgPSAnb24nICsgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpO1xcblxcdFxcdC8vIFN1cHBvcnQgZm9yIG5ldyBDdXN0b21FdmVudCBmZWF0dXJlXFxuXFx0XFx0aWYgKHdpbmRvdy5DdXN0b21FdmVudCAmJiAhSUUxMU9yTGVzcyAmJiAhRWRnZSkge1xcblxcdFxcdFxcdGV2dCA9IG5ldyBDdXN0b21FdmVudChuYW1lLCB7XFxuXFx0XFx0XFx0XFx0YnViYmxlczogdHJ1ZSxcXG5cXHRcXHRcXHRcXHRjYW5jZWxhYmxlOiB0cnVlXFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcXG5cXHRcXHRcXHRldnQuaW5pdEV2ZW50KG5hbWUsIHRydWUsIHRydWUpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRldnQudG8gPSB0b0VsIHx8IHJvb3RFbDtcXG5cXHRcXHRldnQuZnJvbSA9IGZyb21FbCB8fCByb290RWw7XFxuXFx0XFx0ZXZ0Lml0ZW0gPSB0YXJnZXRFbCB8fCByb290RWw7XFxuXFx0XFx0ZXZ0LmNsb25lID0gY2xvbmVFbDtcXG5cXG5cXHRcXHRldnQub2xkSW5kZXggPSBzdGFydEluZGV4O1xcblxcdFxcdGV2dC5uZXdJbmRleCA9IG5ld0luZGV4O1xcblxcblxcdFxcdGV2dC5vbGREcmFnZ2FibGVJbmRleCA9IHN0YXJ0RHJhZ2dhYmxlSW5kZXg7XFxuXFx0XFx0ZXZ0Lm5ld0RyYWdnYWJsZUluZGV4ID0gbmV3RHJhZ2dhYmxlSW5kZXg7XFxuXFxuXFx0XFx0ZXZ0Lm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2dDtcXG5cXHRcXHRldnQucHVsbE1vZGUgPSBwdXRTb3J0YWJsZSA/IHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlIDogdW5kZWZpbmVkO1xcblxcblxcdFxcdGlmIChyb290RWwpIHtcXG5cXHRcXHRcXHRyb290RWwuZGlzcGF0Y2hFdmVudChldnQpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAob3B0aW9uc1tvbk5hbWVdKSB7XFxuXFx0XFx0XFx0b3B0aW9uc1tvbk5hbWVdLmNhbGwoc29ydGFibGUsIGV2dCk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXG5cXHRmdW5jdGlvbiBfb25Nb3ZlKGZyb21FbCwgdG9FbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0RWwsIHRhcmdldFJlY3QsIG9yaWdpbmFsRXZ0LCB3aWxsSW5zZXJ0QWZ0ZXIpIHtcXG5cXHRcXHR2YXIgZXZ0LFxcblxcdFxcdFxcdHNvcnRhYmxlID0gZnJvbUVsW2V4cGFuZG9dLFxcblxcdFxcdFxcdG9uTW92ZUZuID0gc29ydGFibGUub3B0aW9ucy5vbk1vdmUsXFxuXFx0XFx0XFx0cmV0VmFsO1xcblxcdFxcdC8vIFN1cHBvcnQgZm9yIG5ldyBDdXN0b21FdmVudCBmZWF0dXJlXFxuXFx0XFx0aWYgKHdpbmRvdy5DdXN0b21FdmVudCAmJiAhSUUxMU9yTGVzcyAmJiAhRWRnZSkge1xcblxcdFxcdFxcdGV2dCA9IG5ldyBDdXN0b21FdmVudCgnbW92ZScsIHtcXG5cXHRcXHRcXHRcXHRidWJibGVzOiB0cnVlLFxcblxcdFxcdFxcdFxcdGNhbmNlbGFibGU6IHRydWVcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xcblxcdFxcdFxcdGV2dC5pbml0RXZlbnQoJ21vdmUnLCB0cnVlLCB0cnVlKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZXZ0LnRvID0gdG9FbDtcXG5cXHRcXHRldnQuZnJvbSA9IGZyb21FbDtcXG5cXHRcXHRldnQuZHJhZ2dlZCA9IGRyYWdFbDtcXG5cXHRcXHRldnQuZHJhZ2dlZFJlY3QgPSBkcmFnUmVjdDtcXG5cXHRcXHRldnQucmVsYXRlZCA9IHRhcmdldEVsIHx8IHRvRWw7XFxuXFx0XFx0ZXZ0LnJlbGF0ZWRSZWN0ID0gdGFyZ2V0UmVjdCB8fCBfZ2V0UmVjdCh0b0VsKTtcXG5cXHRcXHRldnQud2lsbEluc2VydEFmdGVyID0gd2lsbEluc2VydEFmdGVyO1xcblxcblxcdFxcdGV2dC5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdnQ7XFxuXFxuXFx0XFx0ZnJvbUVsLmRpc3BhdGNoRXZlbnQoZXZ0KTtcXG5cXG5cXHRcXHRpZiAob25Nb3ZlRm4pIHtcXG5cXHRcXHRcXHRyZXRWYWwgPSBvbk1vdmVGbi5jYWxsKHNvcnRhYmxlLCBldnQsIG9yaWdpbmFsRXZ0KTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHJldFZhbDtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gX2Rpc2FibGVEcmFnZ2FibGUoZWwpIHtcXG5cXHRcXHRlbC5kcmFnZ2FibGUgPSBmYWxzZTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gX3Vuc2lsZW50KCkge1xcblxcdFxcdF9zaWxlbnQgPSBmYWxzZTtcXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0cyBudGggY2hpbGQgb2YgZWwsIGlnbm9yaW5nIGhpZGRlbiBjaGlsZHJlbiwgc29ydGFibGUncyBlbGVtZW50cyAoZG9lcyBub3QgaWdub3JlIGNsb25lIGlmIGl0J3MgdmlzaWJsZSlcXG5cXHQgKiBhbmQgbm9uLWRyYWdnYWJsZSBlbGVtZW50c1xcblxcdCAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICAgICBUaGUgcGFyZW50IGVsZW1lbnRcXG5cXHQgKiBAcGFyYW0gIHtOdW1iZXJ9IGNoaWxkTnVtICAgICAgVGhlIGluZGV4IG9mIHRoZSBjaGlsZFxcblxcdCAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAgICAgICBQYXJlbnQgU29ydGFibGUncyBvcHRpb25zXFxuXFx0ICogQHJldHVybiB7SFRNTEVsZW1lbnR9ICAgICAgICAgIFRoZSBjaGlsZCBhdCBpbmRleCBjaGlsZE51bSwgb3IgbnVsbCBpZiBub3QgZm91bmRcXG5cXHQgKi9cXG5cXHRmdW5jdGlvbiBfZ2V0Q2hpbGQoZWwsIGNoaWxkTnVtLCBvcHRpb25zKSB7XFxuXFx0XFx0dmFyIGN1cnJlbnRDaGlsZCA9IDAsXFxuXFx0XFx0XFx0aSA9IDAsXFxuXFx0XFx0XFx0Y2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcXG5cXG5cXHRcXHR3aGlsZSAoaSA8IGNoaWxkcmVuLmxlbmd0aCkge1xcblxcdFxcdFxcdGlmIChcXG5cXHRcXHRcXHRcXHRjaGlsZHJlbltpXS5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScgJiZcXG5cXHRcXHRcXHRcXHRjaGlsZHJlbltpXSAhPT0gZ2hvc3RFbCAmJlxcblxcdFxcdFxcdFxcdGNoaWxkcmVuW2ldICE9PSBkcmFnRWwgJiZcXG5cXHRcXHRcXHRcXHRfY2xvc2VzdChjaGlsZHJlbltpXSwgb3B0aW9ucy5kcmFnZ2FibGUsIGVsLCBmYWxzZSlcXG5cXHRcXHRcXHQpIHtcXG5cXHRcXHRcXHRcXHRpZiAoY3VycmVudENoaWxkID09PSBjaGlsZE51bSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBjaGlsZHJlbltpXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Y3VycmVudENoaWxkKys7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGkrKztcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIG51bGw7XFxuXFx0fVxcblxcblxcdC8qKlxcblxcdCAqIEdldHMgdGhlIGxhc3QgY2hpbGQgaW4gdGhlIGVsLCBpZ25vcmluZyBnaG9zdEVsIG9yIGludmlzaWJsZSBlbGVtZW50cyAoY2xvbmVzKVxcblxcdCAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICAgICBQYXJlbnQgZWxlbWVudFxcblxcdCAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgICAgICAgICBUaGUgbGFzdCBjaGlsZCwgaWdub3JpbmcgZ2hvc3RFbFxcblxcdCAqL1xcblxcdGZ1bmN0aW9uIF9sYXN0Q2hpbGQoZWwpIHtcXG5cXHRcXHR2YXIgbGFzdCA9IGVsLmxhc3RFbGVtZW50Q2hpbGQ7XFxuXFxuXFx0XFx0d2hpbGUgKGxhc3QgJiYgKGxhc3QgPT09IGdob3N0RWwgfHwgX2NzcyhsYXN0LCAnZGlzcGxheScpID09PSAnbm9uZScpKSB7XFxuXFx0XFx0XFx0bGFzdCA9IGxhc3QucHJldmlvdXNFbGVtZW50U2libGluZztcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGxhc3QgfHwgbnVsbDtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gX2dob3N0SXNMYXN0KGV2dCwgYXhpcywgZWwpIHtcXG5cXHRcXHR2YXIgZWxSZWN0ID0gX2dldFJlY3QoX2xhc3RDaGlsZChlbCkpLFxcblxcdFxcdFxcdG1vdXNlT25BeGlzID0gYXhpcyA9PT0gJ3ZlcnRpY2FsJyA/IGV2dC5jbGllbnRZIDogZXZ0LmNsaWVudFgsXFxuXFx0XFx0XFx0bW91c2VPbk9wcEF4aXMgPSBheGlzID09PSAndmVydGljYWwnID8gZXZ0LmNsaWVudFggOiBldnQuY2xpZW50WSxcXG5cXHRcXHRcXHR0YXJnZXRTMiA9IGF4aXMgPT09ICd2ZXJ0aWNhbCcgPyBlbFJlY3QuYm90dG9tIDogZWxSZWN0LnJpZ2h0LFxcblxcdFxcdFxcdHRhcmdldFMxT3BwID0gYXhpcyA9PT0gJ3ZlcnRpY2FsJyA/IGVsUmVjdC5sZWZ0IDogZWxSZWN0LnRvcCxcXG5cXHRcXHRcXHR0YXJnZXRTMk9wcCA9IGF4aXMgPT09ICd2ZXJ0aWNhbCcgPyBlbFJlY3QucmlnaHQgOiBlbFJlY3QuYm90dG9tLFxcblxcdFxcdFxcdHNwYWNlciA9IDEwO1xcblxcblxcdFxcdHJldHVybiAoXFxuXFx0XFx0XFx0YXhpcyA9PT0gJ3ZlcnRpY2FsJyA/XFxuXFx0XFx0XFx0XFx0KG1vdXNlT25PcHBBeGlzID4gdGFyZ2V0UzJPcHAgKyBzcGFjZXIgfHwgbW91c2VPbk9wcEF4aXMgPD0gdGFyZ2V0UzJPcHAgJiYgbW91c2VPbkF4aXMgPiB0YXJnZXRTMiAmJiBtb3VzZU9uT3BwQXhpcyA+PSB0YXJnZXRTMU9wcCkgOlxcblxcdFxcdFxcdFxcdChtb3VzZU9uQXhpcyA+IHRhcmdldFMyICYmIG1vdXNlT25PcHBBeGlzID4gdGFyZ2V0UzFPcHAgfHwgbW91c2VPbkF4aXMgPD0gdGFyZ2V0UzIgJiYgbW91c2VPbk9wcEF4aXMgPiB0YXJnZXRTMk9wcCArIHNwYWNlcilcXG5cXHRcXHQpO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBfZ2V0U3dhcERpcmVjdGlvbihldnQsIHRhcmdldCwgYXhpcywgc3dhcFRocmVzaG9sZCwgaW52ZXJ0ZWRTd2FwVGhyZXNob2xkLCBpbnZlcnRTd2FwLCBpc0xhc3RUYXJnZXQpIHtcXG5cXHRcXHR2YXIgdGFyZ2V0UmVjdCA9IF9nZXRSZWN0KHRhcmdldCksXFxuXFx0XFx0XFx0bW91c2VPbkF4aXMgPSBheGlzID09PSAndmVydGljYWwnID8gZXZ0LmNsaWVudFkgOiBldnQuY2xpZW50WCxcXG5cXHRcXHRcXHR0YXJnZXRMZW5ndGggPSBheGlzID09PSAndmVydGljYWwnID8gdGFyZ2V0UmVjdC5oZWlnaHQgOiB0YXJnZXRSZWN0LndpZHRoLFxcblxcdFxcdFxcdHRhcmdldFMxID0gYXhpcyA9PT0gJ3ZlcnRpY2FsJyA/IHRhcmdldFJlY3QudG9wIDogdGFyZ2V0UmVjdC5sZWZ0LFxcblxcdFxcdFxcdHRhcmdldFMyID0gYXhpcyA9PT0gJ3ZlcnRpY2FsJyA/IHRhcmdldFJlY3QuYm90dG9tIDogdGFyZ2V0UmVjdC5yaWdodCxcXG5cXHRcXHRcXHRkcmFnUmVjdCA9IF9nZXRSZWN0KGRyYWdFbCksXFxuXFx0XFx0XFx0aW52ZXJ0ID0gZmFsc2U7XFxuXFxuXFxuXFx0XFx0aWYgKCFpbnZlcnRTd2FwKSB7XFxuXFx0XFx0XFx0Ly8gTmV2ZXIgaW52ZXJ0IG9yIGNyZWF0ZSBkcmFnRWwgc2hhZG93IHdoZW4gdGFyZ2V0IG1vdmVtZW5ldCBjYXVzZXMgbW91c2UgdG8gbW92ZSBwYXN0IHRoZSBlbmQgb2YgcmVndWxhciBzd2FwVGhyZXNob2xkXFxuXFx0XFx0XFx0aWYgKGlzTGFzdFRhcmdldCAmJiB0YXJnZXRNb3ZlRGlzdGFuY2UgPCB0YXJnZXRMZW5ndGggKiBzd2FwVGhyZXNob2xkKSB7IC8vIG11bHRpcGxpZWQgb25seSBieSBzd2FwVGhyZXNob2xkIGJlY2F1c2UgbW91c2Ugd2lsbCBhbHJlYWR5IGJlIGluc2lkZSB0YXJnZXQgYnkgKDEgLSB0aHJlc2hvbGQpICogdGFyZ2V0TGVuZ3RoIC8gMlxcblxcdFxcdFxcdFxcdC8vIGNoZWNrIGlmIHBhc3QgZmlyc3QgaW52ZXJ0IHRocmVzaG9sZCBvbiBzaWRlIG9wcG9zaXRlIG9mIGxhc3REaXJlY3Rpb25cXG5cXHRcXHRcXHRcXHRpZiAoIXBhc3RGaXJzdEludmVydFRocmVzaCAmJlxcblxcdFxcdFxcdFxcdFxcdChsYXN0RGlyZWN0aW9uID09PSAxID9cXG5cXHRcXHRcXHRcXHRcXHRcXHQoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bW91c2VPbkF4aXMgPiB0YXJnZXRTMSArIHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDJcXG5cXHRcXHRcXHRcXHRcXHRcXHQpIDpcXG5cXHRcXHRcXHRcXHRcXHRcXHQoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bW91c2VPbkF4aXMgPCB0YXJnZXRTMiAtIHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDJcXG5cXHRcXHRcXHRcXHRcXHRcXHQpXFxuXFx0XFx0XFx0XFx0XFx0KVxcblxcdFxcdFxcdFxcdClcXG5cXHRcXHRcXHRcXHR7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gcGFzdCBmaXJzdCBpbnZlcnQgdGhyZXNob2xkLCBkbyBub3QgcmVzdHJpY3QgaW52ZXJ0ZWQgdGhyZXNob2xkIHRvIGRyYWdFbCBzaGFkb3dcXG5cXHRcXHRcXHRcXHRcXHRwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggPSB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIXBhc3RGaXJzdEludmVydFRocmVzaCkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBkcmFnUzEgPSBheGlzID09PSAndmVydGljYWwnID8gZHJhZ1JlY3QudG9wIDogZHJhZ1JlY3QubGVmdCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRkcmFnUzIgPSBheGlzID09PSAndmVydGljYWwnID8gZHJhZ1JlY3QuYm90dG9tIDogZHJhZ1JlY3QucmlnaHQ7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gZHJhZ0VsIHNoYWRvdyAodGFyZ2V0IG1vdmUgZGlzdGFuY2Ugc2hhZG93KVxcblxcdFxcdFxcdFxcdFxcdGlmIChcXG5cXHRcXHRcXHRcXHRcXHRcXHRsYXN0RGlyZWN0aW9uID09PSAxID9cXG5cXHRcXHRcXHRcXHRcXHRcXHQoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bW91c2VPbkF4aXMgPCB0YXJnZXRTMSArIHRhcmdldE1vdmVEaXN0YW5jZSAvLyBvdmVyIGRyYWdFbCBzaGFkb3dcXG5cXHRcXHRcXHRcXHRcXHRcXHQpIDpcXG5cXHRcXHRcXHRcXHRcXHRcXHQoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bW91c2VPbkF4aXMgPiB0YXJnZXRTMiAtIHRhcmdldE1vdmVEaXN0YW5jZVxcblxcdFxcdFxcdFxcdFxcdFxcdClcXG5cXHRcXHRcXHRcXHRcXHQpXFxuXFx0XFx0XFx0XFx0XFx0e1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBsYXN0RGlyZWN0aW9uICogLTE7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0aW52ZXJ0ID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHQvLyBSZWd1bGFyXFxuXFx0XFx0XFx0XFx0aWYgKFxcblxcdFxcdFxcdFxcdFxcdG1vdXNlT25BeGlzID4gdGFyZ2V0UzEgKyAodGFyZ2V0TGVuZ3RoICogKDEgLSBzd2FwVGhyZXNob2xkKSAvIDIpICYmXFxuXFx0XFx0XFx0XFx0XFx0bW91c2VPbkF4aXMgPCB0YXJnZXRTMiAtICh0YXJnZXRMZW5ndGggKiAoMSAtIHN3YXBUaHJlc2hvbGQpIC8gMilcXG5cXHRcXHRcXHRcXHQpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gX2dldEluc2VydERpcmVjdGlvbih0YXJnZXQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdGludmVydCA9IGludmVydCB8fCBpbnZlcnRTd2FwO1xcblxcblxcdFxcdGlmIChpbnZlcnQpIHtcXG5cXHRcXHRcXHQvLyBJbnZlcnQgb2YgcmVndWxhclxcblxcdFxcdFxcdGlmIChcXG5cXHRcXHRcXHRcXHRtb3VzZU9uQXhpcyA8IHRhcmdldFMxICsgKHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDIpIHx8XFxuXFx0XFx0XFx0XFx0bW91c2VPbkF4aXMgPiB0YXJnZXRTMiAtICh0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyKVxcblxcdFxcdFxcdClcXG5cXHRcXHRcXHR7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICgobW91c2VPbkF4aXMgPiB0YXJnZXRTMSArIHRhcmdldExlbmd0aCAvIDIpID8gMSA6IC0xKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiAwO1xcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBHZXRzIHRoZSBkaXJlY3Rpb24gZHJhZ0VsIG11c3QgYmUgc3dhcHBlZCByZWxhdGl2ZSB0byB0YXJnZXQgaW4gb3JkZXIgdG8gbWFrZSBpdFxcblxcdCAqIHNlZW0gdGhhdCBkcmFnRWwgaGFzIGJlZW4gXFxcImluc2VydGVkXFxcIiBpbnRvIHRoYXQgZWxlbWVudCdzIHBvc2l0aW9uXFxuXFx0ICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IHRhcmdldCAgICAgICBUaGUgdGFyZ2V0IHdob3NlIHBvc2l0aW9uIGRyYWdFbCBpcyBiZWluZyBpbnNlcnRlZCBhdFxcblxcdCAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgRGlyZWN0aW9uIGRyYWdFbCBtdXN0IGJlIHN3YXBwZWRcXG5cXHQgKi9cXG5cXHRmdW5jdGlvbiBfZ2V0SW5zZXJ0RGlyZWN0aW9uKHRhcmdldCkge1xcblxcdFxcdHZhciBkcmFnRWxJbmRleCA9IF9pbmRleChkcmFnRWwpLFxcblxcdFxcdFxcdHRhcmdldEluZGV4ID0gX2luZGV4KHRhcmdldCk7XFxuXFxuXFx0XFx0aWYgKGRyYWdFbEluZGV4IDwgdGFyZ2V0SW5kZXgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gMTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHJldHVybiAtMTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcblxcdC8qKlxcblxcdCAqIEdlbmVyYXRlIGlkXFxuXFx0ICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBlbFxcblxcdCAqIEByZXR1cm5zIHtTdHJpbmd9XFxuXFx0ICogQHByaXZhdGVcXG5cXHQgKi9cXG5cXHRmdW5jdGlvbiBfZ2VuZXJhdGVJZChlbCkge1xcblxcdFxcdHZhciBzdHIgPSBlbC50YWdOYW1lICsgZWwuY2xhc3NOYW1lICsgZWwuc3JjICsgZWwuaHJlZiArIGVsLnRleHRDb250ZW50LFxcblxcdFxcdFxcdGkgPSBzdHIubGVuZ3RoLFxcblxcdFxcdFxcdHN1bSA9IDA7XFxuXFxuXFx0XFx0d2hpbGUgKGktLSkge1xcblxcdFxcdFxcdHN1bSArPSBzdHIuY2hhckNvZGVBdChpKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHN1bS50b1N0cmluZygzNik7XFxuXFx0fVxcblxcblxcdC8qKlxcblxcdCAqIFJldHVybnMgdGhlIGluZGV4IG9mIGFuIGVsZW1lbnQgd2l0aGluIGl0cyBwYXJlbnQgZm9yIGEgc2VsZWN0ZWQgc2V0IG9mXFxuXFx0ICogZWxlbWVudHNcXG5cXHQgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWxcXG5cXHQgKiBAcGFyYW0gIHtzZWxlY3Rvcn0gc2VsZWN0b3JcXG5cXHQgKiBAcmV0dXJuIHtudW1iZXJ9XFxuXFx0ICovXFxuXFx0ZnVuY3Rpb24gX2luZGV4KGVsLCBzZWxlY3Rvcikge1xcblxcdFxcdHZhciBpbmRleCA9IDA7XFxuXFxuXFx0XFx0aWYgKCFlbCB8fCAhZWwucGFyZW50Tm9kZSkge1xcblxcdFxcdFxcdHJldHVybiAtMTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0d2hpbGUgKGVsICYmIChlbCA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpKSB7XFxuXFx0XFx0XFx0aWYgKChlbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnVEVNUExBVEUnKSAmJiBlbCAhPT0gY2xvbmVFbCAmJiAoIXNlbGVjdG9yIHx8IF9tYXRjaGVzKGVsLCBzZWxlY3RvcikpKSB7XFxuXFx0XFx0XFx0XFx0aW5kZXgrKztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBpbmRleDtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gX21hdGNoZXMoLyoqSFRNTEVsZW1lbnQqL2VsLCAvKipTdHJpbmcqL3NlbGVjdG9yKSB7XFxuXFx0XFx0aWYgKCFzZWxlY3RvcikgcmV0dXJuO1xcblxcblxcdFxcdHNlbGVjdG9yWzBdID09PSAnPicgJiYgKHNlbGVjdG9yID0gc2VsZWN0b3Iuc3Vic3RyaW5nKDEpKTtcXG5cXG5cXHRcXHRpZiAoZWwpIHtcXG5cXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdGlmIChlbC5tYXRjaGVzKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGVsLm1hdGNoZXMoc2VsZWN0b3IpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoZWwubXNNYXRjaGVzU2VsZWN0b3IpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZWwubXNNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gY2F0Y2goXykge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHR9XFxuXFxuXFx0dmFyIF90aHJvdHRsZVRpbWVvdXQ7XFxuXFx0ZnVuY3Rpb24gX3Rocm90dGxlKGNhbGxiYWNrLCBtcykge1xcblxcdFxcdHJldHVybiBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0aWYgKCFfdGhyb3R0bGVUaW1lb3V0KSB7XFxuXFx0XFx0XFx0XFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXFxuXFx0XFx0XFx0XFx0XFx0X3RoaXMgPSB0aGlzO1xcblxcblxcdFxcdFxcdFxcdF90aHJvdHRsZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYWxsYmFjay5jYWxsKF90aGlzLCBhcmdzWzBdKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmFwcGx5KF90aGlzLCBhcmdzKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0X3Rocm90dGxlVGltZW91dCA9IHZvaWQgMDtcXG5cXHRcXHRcXHRcXHR9LCBtcyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIF9jYW5jZWxUaHJvdHRsZSgpIHtcXG5cXHRcXHRjbGVhclRpbWVvdXQoX3Rocm90dGxlVGltZW91dCk7XFxuXFx0XFx0X3Rocm90dGxlVGltZW91dCA9IHZvaWQgMDtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gX2V4dGVuZChkc3QsIHNyYykge1xcblxcdFxcdGlmIChkc3QgJiYgc3JjKSB7XFxuXFx0XFx0XFx0Zm9yICh2YXIga2V5IGluIHNyYykge1xcblxcdFxcdFxcdFxcdGlmIChzcmMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcblxcdFxcdFxcdFxcdFxcdGRzdFtrZXldID0gc3JjW2tleV07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGRzdDtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gX2Nsb25lKGVsKSB7XFxuXFx0XFx0aWYgKFBvbHltZXIgJiYgUG9seW1lci5kb20pIHtcXG5cXHRcXHRcXHRyZXR1cm4gUG9seW1lci5kb20oZWwpLmNsb25lTm9kZSh0cnVlKTtcXG5cXHRcXHR9XFxuXFx0XFx0ZWxzZSBpZiAoJCkge1xcblxcdFxcdFxcdHJldHVybiAkKGVsKS5jbG9uZSh0cnVlKVswXTtcXG5cXHRcXHR9XFxuXFx0XFx0ZWxzZSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVsLmNsb25lTm9kZSh0cnVlKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIF9zYXZlSW5wdXRDaGVja2VkU3RhdGUocm9vdCkge1xcblxcdFxcdHNhdmVkSW5wdXRDaGVja2VkLmxlbmd0aCA9IDA7XFxuXFxuXFx0XFx0dmFyIGlucHV0cyA9IHJvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0Jyk7XFxuXFx0XFx0dmFyIGlkeCA9IGlucHV0cy5sZW5ndGg7XFxuXFxuXFx0XFx0d2hpbGUgKGlkeC0tKSB7XFxuXFx0XFx0XFx0dmFyIGVsID0gaW5wdXRzW2lkeF07XFxuXFx0XFx0XFx0ZWwuY2hlY2tlZCAmJiBzYXZlZElucHV0Q2hlY2tlZC5wdXNoKGVsKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIF9uZXh0VGljayhmbikge1xcblxcdFxcdHJldHVybiBzZXRUaW1lb3V0KGZuLCAwKTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gX2NhbmNlbE5leHRUaWNrKGlkKSB7XFxuXFx0XFx0cmV0dXJuIGNsZWFyVGltZW91dChpZCk7XFxuXFx0fVxcblxcblxcblxcdC8qKlxcblxcdCAqIFJldHVybnMgdGhlIFxcXCJib3VuZGluZyBjbGllbnQgcmVjdFxcXCIgb2YgZ2l2ZW4gZWxlbWVudFxcblxcdCAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICAgICAgICAgICAgICBUaGUgZWxlbWVudCB3aG9zZSBib3VuZGluZ0NsaWVudFJlY3QgaXMgd2FudGVkXFxuXFx0ICogQHBhcmFtICB7W0hUTUxFbGVtZW50XX0gY29udGFpbmVyICAgICAgIHRoZSBwYXJlbnQgdGhlIGVsZW1lbnQgd2lsbCBiZSBwbGFjZWQgaW5cXG5cXHQgKiBAcGFyYW0gIHtbQm9vbGVhbl19IGFkanVzdEZvclRyYW5zZm9ybSAgV2hldGhlciB0aGUgcmVjdCBzaG91bGQgY29tcGVuc2F0ZSBmb3IgcGFyZW50J3MgdHJhbnNmb3JtXFxuXFx0ICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBib3VuZGluZ0NsaWVudFJlY3Qgb2YgZWxcXG5cXHQgKi9cXG5cXHRmdW5jdGlvbiBfZ2V0UmVjdChlbCwgYWRqdXN0Rm9yVHJhbnNmb3JtLCBjb250YWluZXIsIGFkanVzdEZvckZpeGVkKSB7XFxuXFx0XFx0aWYgKCFlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgZWwgIT09IHdpbikgcmV0dXJuO1xcblxcblxcdFxcdHZhciBlbFJlY3QsXFxuXFx0XFx0XFx0dG9wLFxcblxcdFxcdFxcdGxlZnQsXFxuXFx0XFx0XFx0Ym90dG9tLFxcblxcdFxcdFxcdHJpZ2h0LFxcblxcdFxcdFxcdGhlaWdodCxcXG5cXHRcXHRcXHR3aWR0aDtcXG5cXG5cXHRcXHRpZiAoZWwgIT09IHdpbiAmJiBlbCAhPT0gX2dldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKSkge1xcblxcdFxcdFxcdGVsUmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcblxcdFxcdFxcdHRvcCA9IGVsUmVjdC50b3A7XFxuXFx0XFx0XFx0bGVmdCA9IGVsUmVjdC5sZWZ0O1xcblxcdFxcdFxcdGJvdHRvbSA9IGVsUmVjdC5ib3R0b207XFxuXFx0XFx0XFx0cmlnaHQgPSBlbFJlY3QucmlnaHQ7XFxuXFx0XFx0XFx0aGVpZ2h0ID0gZWxSZWN0LmhlaWdodDtcXG5cXHRcXHRcXHR3aWR0aCA9IGVsUmVjdC53aWR0aDtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHRvcCA9IDA7XFxuXFx0XFx0XFx0bGVmdCA9IDA7XFxuXFx0XFx0XFx0Ym90dG9tID0gd2luZG93LmlubmVySGVpZ2h0O1xcblxcdFxcdFxcdHJpZ2h0ID0gd2luZG93LmlubmVyV2lkdGg7XFxuXFx0XFx0XFx0aGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xcblxcdFxcdFxcdHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmIChhZGp1c3RGb3JGaXhlZCAmJiBlbCAhPT0gd2luKSB7XFxuXFx0XFx0XFx0Ly8gQWRqdXN0IGZvciB0cmFuc2xhdGUoKVxcblxcdFxcdFxcdGNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBlbC5wYXJlbnROb2RlO1xcblxcblxcdFxcdFxcdC8vIHNvbHZlcyAjMTEyMyAoc2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzc5NTM4MDYvNjA4ODMxMilcXG5cXHRcXHRcXHQvLyBOb3QgbmVlZGVkIG9uIDw9IElFMTFcXG5cXHRcXHRcXHRpZiAoIUlFMTFPckxlc3MpIHtcXG5cXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIF9jc3MoY29udGFpbmVyLCAndHJhbnNmb3JtJykgIT09ICdub25lJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBjb250YWluZXJSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFNldCByZWxhdGl2ZSB0byBlZGdlcyBvZiBwYWRkaW5nIGJveCBvZiBjb250YWluZXJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0b3AgLT0gY29udGFpbmVyUmVjdC50b3AgKyBwYXJzZUludChfY3NzKGNvbnRhaW5lciwgJ2JvcmRlci10b3Atd2lkdGgnKSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bGVmdCAtPSBjb250YWluZXJSZWN0LmxlZnQgKyBwYXJzZUludChfY3NzKGNvbnRhaW5lciwgJ2JvcmRlci1sZWZ0LXdpZHRoJykpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJvdHRvbSA9IHRvcCArIGVsUmVjdC5oZWlnaHQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmlnaHQgPSBsZWZ0ICsgZWxSZWN0LndpZHRoO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHQvKiBqc2hpbnQgYm9zczp0cnVlICovXFxuXFx0XFx0XFx0XFx0fSB3aGlsZSAoY29udGFpbmVyID0gY29udGFpbmVyLnBhcmVudE5vZGUpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKGFkanVzdEZvclRyYW5zZm9ybSAmJiBlbCAhPT0gd2luKSB7XFxuXFx0XFx0XFx0Ly8gQWRqdXN0IGZvciBzY2FsZSgpXFxuXFx0XFx0XFx0dmFyIG1hdHJpeCA9IF9tYXRyaXgoY29udGFpbmVyIHx8IGVsKSxcXG5cXHRcXHRcXHRcXHRzY2FsZVggPSBtYXRyaXggJiYgbWF0cml4LmEsXFxuXFx0XFx0XFx0XFx0c2NhbGVZID0gbWF0cml4ICYmIG1hdHJpeC5kO1xcblxcblxcdFxcdFxcdGlmIChtYXRyaXgpIHtcXG5cXHRcXHRcXHRcXHR0b3AgLz0gc2NhbGVZO1xcblxcdFxcdFxcdFxcdGxlZnQgLz0gc2NhbGVYO1xcblxcblxcdFxcdFxcdFxcdHdpZHRoIC89IHNjYWxlWDtcXG5cXHRcXHRcXHRcXHRoZWlnaHQgLz0gc2NhbGVZO1xcblxcblxcdFxcdFxcdFxcdGJvdHRvbSA9IHRvcCArIGhlaWdodDtcXG5cXHRcXHRcXHRcXHRyaWdodCA9IGxlZnQgKyB3aWR0aDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0dG9wOiB0b3AsXFxuXFx0XFx0XFx0bGVmdDogbGVmdCxcXG5cXHRcXHRcXHRib3R0b206IGJvdHRvbSxcXG5cXHRcXHRcXHRyaWdodDogcmlnaHQsXFxuXFx0XFx0XFx0d2lkdGg6IHdpZHRoLFxcblxcdFxcdFxcdGhlaWdodDogaGVpZ2h0XFxuXFx0XFx0fTtcXG5cXHR9XFxuXFxuXFxuXFx0LyoqXFxuXFx0ICogQ2hlY2tzIGlmIGEgc2lkZSBvZiBhbiBlbGVtZW50IGlzIHNjcm9sbGVkIHBhc3QgYSBzaWRlIG9mIGl0J3MgcGFyZW50c1xcblxcdCAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSAgZWwgICAgICAgVGhlIGVsZW1lbnQgd2hvJ3Mgc2lkZSBiZWluZyBzY3JvbGxlZCBvdXQgb2YgdmlldyBpcyBpbiBxdWVzdGlvblxcblxcdCAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgc2lkZSAgICAgU2lkZSBvZiB0aGUgZWxlbWVudCBpbiBxdWVzdGlvbiAoJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdHRvbScpXFxuXFx0ICogQHJldHVybiB7SFRNTEVsZW1lbnR9ICAgICAgICAgICBUaGUgcGFyZW50IHNjcm9sbCBlbGVtZW50IHRoYXQgdGhlIGVsJ3Mgc2lkZSBpcyBzY3JvbGxlZCBwYXN0LCBvciBudWxsIGlmIHRoZXJlIGlzIG5vIHN1Y2ggZWxlbWVudFxcblxcdCAqL1xcblxcdGZ1bmN0aW9uIF9pc1Njcm9sbGVkUGFzdChlbCwgc2lkZSkge1xcblxcdFxcdHZhciBwYXJlbnQgPSBfZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWwsIHRydWUpLFxcblxcdFxcdFxcdGVsU2lkZSA9IF9nZXRSZWN0KGVsKVtzaWRlXTtcXG5cXG5cXHRcXHQvKiBqc2hpbnQgYm9zczp0cnVlICovXFxuXFx0XFx0d2hpbGUgKHBhcmVudCkge1xcblxcdFxcdFxcdHZhciBwYXJlbnRTaWRlID0gX2dldFJlY3QocGFyZW50KVtzaWRlXSxcXG5cXHRcXHRcXHRcXHR2aXNpYmxlO1xcblxcblxcdFxcdFxcdGlmIChzaWRlID09PSAndG9wJyB8fCBzaWRlID09PSAnbGVmdCcpIHtcXG5cXHRcXHRcXHRcXHR2aXNpYmxlID0gZWxTaWRlID49IHBhcmVudFNpZGU7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR2aXNpYmxlID0gZWxTaWRlIDw9IHBhcmVudFNpZGU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICghdmlzaWJsZSkgcmV0dXJuIHBhcmVudDtcXG5cXG5cXHRcXHRcXHRpZiAocGFyZW50ID09PSBfZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpKSBicmVhaztcXG5cXG5cXHRcXHRcXHRwYXJlbnQgPSBfZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQocGFyZW50LCBmYWxzZSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogUmV0dXJucyB0aGUgc2Nyb2xsIG9mZnNldCBvZiB0aGUgZ2l2ZW4gZWxlbWVudCwgYWRkZWQgd2l0aCBhbGwgdGhlIHNjcm9sbCBvZmZzZXRzIG9mIHBhcmVudCBlbGVtZW50cy5cXG5cXHQgKiBUaGUgdmFsdWUgaXMgcmV0dXJuZWQgaW4gcmVhbCBwaXhlbHMuXFxuXFx0ICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsXFxuXFx0ICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgIE9mZnNldHMgaW4gdGhlIGZvcm1hdCBvZiBbbGVmdCwgdG9wXVxcblxcdCAqL1xcblxcdGZ1bmN0aW9uIF9nZXRSZWxhdGl2ZVNjcm9sbE9mZnNldChlbCkge1xcblxcdFxcdHZhciBvZmZzZXRMZWZ0ID0gMCxcXG5cXHRcXHRcXHRvZmZzZXRUb3AgPSAwLFxcblxcdFxcdFxcdHdpblNjcm9sbGVyID0gX2dldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcXG5cXG5cXHRcXHRpZiAoZWwpIHtcXG5cXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0dmFyIG1hdHJpeCA9IF9tYXRyaXgoZWwpLFxcblxcdFxcdFxcdFxcdFxcdHNjYWxlWCA9IG1hdHJpeC5hLFxcblxcdFxcdFxcdFxcdFxcdHNjYWxlWSA9IG1hdHJpeC5kO1xcblxcblxcdFxcdFxcdFxcdG9mZnNldExlZnQgKz0gZWwuc2Nyb2xsTGVmdCAqIHNjYWxlWDtcXG5cXHRcXHRcXHRcXHRvZmZzZXRUb3AgKz0gZWwuc2Nyb2xsVG9wICogc2NhbGVZO1xcblxcdFxcdFxcdH0gd2hpbGUgKGVsICE9PSB3aW5TY3JvbGxlciAmJiAoZWwgPSBlbC5wYXJlbnROb2RlKSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBbb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wXTtcXG5cXHR9XFxuXFxuXFx0Ly8gRml4ZWQgIzk3MzpcXG5cXHRfb24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBmdW5jdGlvbihldnQpIHtcXG5cXHRcXHRpZiAoKFNvcnRhYmxlLmFjdGl2ZSB8fCBhd2FpdGluZ0RyYWdTdGFydGVkKSAmJiBldnQuY2FuY2VsYWJsZSkge1xcblxcdFxcdFxcdGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdH1cXG5cXHR9KTtcXG5cXG5cXG5cXHQvLyBFeHBvcnQgdXRpbHNcXG5cXHRTb3J0YWJsZS51dGlscyA9IHtcXG5cXHRcXHRvbjogX29uLFxcblxcdFxcdG9mZjogX29mZixcXG5cXHRcXHRjc3M6IF9jc3MsXFxuXFx0XFx0ZmluZDogX2ZpbmQsXFxuXFx0XFx0aXM6IGZ1bmN0aW9uIChlbCwgc2VsZWN0b3IpIHtcXG5cXHRcXHRcXHRyZXR1cm4gISFfY2xvc2VzdChlbCwgc2VsZWN0b3IsIGVsLCBmYWxzZSk7XFxuXFx0XFx0fSxcXG5cXHRcXHRleHRlbmQ6IF9leHRlbmQsXFxuXFx0XFx0dGhyb3R0bGU6IF90aHJvdHRsZSxcXG5cXHRcXHRjbG9zZXN0OiBfY2xvc2VzdCxcXG5cXHRcXHR0b2dnbGVDbGFzczogX3RvZ2dsZUNsYXNzLFxcblxcdFxcdGNsb25lOiBfY2xvbmUsXFxuXFx0XFx0aW5kZXg6IF9pbmRleCxcXG5cXHRcXHRuZXh0VGljazogX25leHRUaWNrLFxcblxcdFxcdGNhbmNlbE5leHRUaWNrOiBfY2FuY2VsTmV4dFRpY2ssXFxuXFx0XFx0ZGV0ZWN0RGlyZWN0aW9uOiBfZGV0ZWN0RGlyZWN0aW9uLFxcblxcdFxcdGdldENoaWxkOiBfZ2V0Q2hpbGRcXG5cXHR9O1xcblxcblxcblxcdC8qKlxcblxcdCAqIENyZWF0ZSBzb3J0YWJsZSBpbnN0YW5jZVxcblxcdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICBlbFxcblxcdCAqIEBwYXJhbSB7T2JqZWN0fSAgICAgIFtvcHRpb25zXVxcblxcdCAqL1xcblxcdFNvcnRhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xcblxcdFxcdHJldHVybiBuZXcgU29ydGFibGUoZWwsIG9wdGlvbnMpO1xcblxcdH07XFxuXFxuXFxuXFx0Ly8gRXhwb3J0XFxuXFx0U29ydGFibGUudmVyc2lvbiA9ICcxLjkuMCc7XFxuXFx0cmV0dXJuIFNvcnRhYmxlO1xcbn0pO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb3J0YWJsZWpzL1NvcnRhYmxlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge3ZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBnbG9iYWwpIHx8XFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBzZWxmKSB8fFxcbiAgICAgICAgICAgIHdpbmRvdztcXG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XFxuXFxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcXG5cXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcXG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xcbn07XFxuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcXG59O1xcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cXG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XFxuICBpZiAodGltZW91dCkge1xcbiAgICB0aW1lb3V0LmNsb3NlKCk7XFxuICB9XFxufTtcXG5cXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XFxuICB0aGlzLl9pZCA9IGlkO1xcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XFxufVxcblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcXG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XFxufTtcXG5cXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XFxuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XFxuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xcbn07XFxuXFxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcXG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcXG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XFxufTtcXG5cXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xcblxcbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XFxuICBpZiAobXNlY3MgPj0gMCkge1xcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XFxuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xcbiAgICB9LCBtc2Vjcyk7XFxuICB9XFxufTtcXG5cXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XFxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgc2V0aW1tZWRpYXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzXFxcIik7XFxuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXFxuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxcbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcXG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xcblxcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLy4uL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanNcXFwiKSkpXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy92ZWUtdmFsaWRhdGUvZGlzdC9sb2NhbGUvcnUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3ZlZS12YWxpZGF0ZS9kaXN0L2xvY2FsZS9ydS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIiFmdW5jdGlvbihuLGUpeyB0cnVlP21vZHVsZS5leHBvcnRzPWUoKTp1bmRlZmluZWR9KHRoaXMsZnVuY3Rpb24oKXtcXFwidXNlIHN0cmljdFxcXCI7dmFyIG4sZT17bmFtZTpcXFwicnVcXFwiLG1lc3NhZ2VzOntfZGVmYXVsdDpmdW5jdGlvbihuKXtyZXR1cm5cXFwi0JfQvdCw0YfQtdC90LjQtSDQv9C+0LvRjyBcXFwiK24rXFxcIiDQvdC10LTQvtC/0YPRgdGC0LjQvNC+LlxcXCJ9LGFmdGVyOmZ1bmN0aW9uKG4sZSl7dmFyIHQ9ZVswXTtyZXR1cm5cXFwi0JIg0L/QvtC70LUgXFxcIituK1xcXCIg0LTQvtC70LbQvdCwINCx0YvRgtGMINC00LDRgtCwINC/0L7RgdC70LUgXFxcIisoZVsxXT9cXFwi0LjQu9C4INGA0LDQstC90LDRjyBcXFwiOlxcXCJcXFwiKSt0K1xcXCIuXFxcIn0sYWxwaGE6ZnVuY3Rpb24obil7cmV0dXJuXFxcItCf0L7Qu9C1IFxcXCIrbitcXFwiINC80L7QttC10YIg0YHQvtC00LXRgNC20LDRgtGMINGC0L7Qu9GM0LrQviDQsdGD0LrQstGLLlxcXCJ9LGFscGhhX2Rhc2g6ZnVuY3Rpb24obil7cmV0dXJuXFxcItCf0L7Qu9C1IFxcXCIrbitcXFwiINC80L7QttC10YIg0YHQvtC00LXRgNC20LDRgtGMINGC0L7Qu9GM0LrQviDQsdGD0LrQstGLLCDRhtC40YTRgNGLINC4INC00LXRhNC40YEuXFxcIn0sYWxwaGFfbnVtOmZ1bmN0aW9uKG4pe3JldHVyblxcXCLQn9C+0LvQtSBcXFwiK24rXFxcIiDQvNC+0LbQtdGCINGB0L7QtNC10YDQttCw0YLRjCDRgtC+0LvRjNC60L4g0LHRg9C60LLRiyDQuCDRhtC40YTRgNGLLlxcXCJ9LGFscGhhX3NwYWNlczpmdW5jdGlvbihuKXtyZXR1cm5cXFwi0J/QvtC70LUgXFxcIituK1xcXCIg0LzQvtC20LXRgiDRgdC+0LTQtdGA0LbQsNGC0Ywg0YLQvtC70YzQutC+INCx0YPQutCy0Ysg0Lgg0L/RgNC+0LHQtdC70YsuXFxcIn0sYmVmb3JlOmZ1bmN0aW9uKG4sZSl7dmFyIHQ9ZVswXTtyZXR1cm5cXFwi0JIg0L/QvtC70LUgXFxcIituK1xcXCIg0LTQvtC70LbQvdCwINCx0YvRgtGMINC00LDRgtCwINC00L4gXFxcIisoZVsxXT9cXFwi0LjQu9C4INGA0LDQstC90LDRjyBcXFwiOlxcXCJcXFwiKSt0K1xcXCIuXFxcIn0sYmV0d2VlbjpmdW5jdGlvbihuLGUpe3JldHVyblxcXCLQn9C+0LvQtSBcXFwiK24rXFxcIiDQtNC+0LvQttC90L4g0LHRi9GC0Ywg0LzQtdC20LTRgyBcXFwiK2VbMF0rXFxcIiDQuCBcXFwiK2VbMV0rXFxcIi5cXFwifSxjb25maXJtZWQ6ZnVuY3Rpb24obixlKXtyZXR1cm5cXFwi0J/QvtC70LUgXFxcIituK1xcXCIg0L3QtSDRgdC+0LLQv9Cw0LTQsNC10YIg0YEg0L/QvtC70LXQvCBcXFwiK2VbMF0rXFxcIi5cXFwifSxjcmVkaXRfY2FyZDpmdW5jdGlvbihuKXtyZXR1cm5cXFwi0J/QvtC70LUgXFxcIituK1xcXCIg0LTQvtC70LbQvdC+INCx0YvRgtGMINC00LXQudGB0YLQstC40YLQtdC70YzQvdGL0Lwg0L3QvtC80LXRgNC+0Lwg0LrQsNGA0YLRi1xcXCJ9LGRhdGVfYmV0d2VlbjpmdW5jdGlvbihuLGUpe3JldHVyblxcXCLQn9C+0LvQtSBcXFwiK24rXFxcIiDQtNC+0LvQttC90L4g0LHRi9GC0Ywg0LzQtdC20LTRgyBcXFwiK2VbMF0rXFxcIiDQuCBcXFwiK2VbMV0rXFxcIi5cXFwifSxkYXRlX2Zvcm1hdDpmdW5jdGlvbihuLGUpe3JldHVyblxcXCLQn9C+0LvQtSBcXFwiK24rXFxcIiDQtNC+0LvQttC90L4g0LHRi9GC0Ywg0LIg0YTQvtGA0LzQsNGC0LUgXFxcIitlWzBdK1xcXCIuXFxcIn0sZGVjaW1hbDpmdW5jdGlvbihuLGUpe3ZvaWQgMD09PWUmJihlPVtdKTt2YXIgdD1lWzBdO3JldHVybiB2b2lkIDA9PT10JiYodD1cXFwiKlxcXCIpLFxcXCLQn9C+0LvQtSBcXFwiK24rXFxcIiDQtNC+0LvQttC90L4g0LHRi9GC0Ywg0YfQuNGB0LvQvtCy0YvQvCDQuCDQvNC+0LbQtdGCINGB0L7QtNC10YDQttCw0YLRjFxcXCIrKFxcXCIqXFxcIj09PXQ/XFxcIiDQtNC10YHRj9GC0LjRh9C90YvQtSDRh9C40YHQu9CwXFxcIjpcXFwiIFxcXCIrdCtcXFwiINC00LXRgdGP0YLQuNGH0L3Ri9GFINGH0LjRgdC10LtcXFwiKStcXFwiLlxcXCJ9LGRpZ2l0czpmdW5jdGlvbihuLGUpe3JldHVyblxcXCLQn9C+0LvQtSBcXFwiK24rXFxcIiDQtNC+0LvQttC90L4g0LHRi9GC0Ywg0YfQuNGB0LvQvtCy0YvQvCDQuCDRgtC+0YfQvdC+INGB0L7QtNC10YDQttCw0YLRjCBcXFwiK2VbMF0rXFxcIiDRhtC40YTRgNGLLlxcXCJ9LGRpbWVuc2lvbnM6ZnVuY3Rpb24obixlKXtyZXR1cm5cXFwi0J/QvtC70LUgXFxcIituK1xcXCIg0LTQvtC70LbQvdC+INCx0YvRgtGMIFxcXCIrZVswXStcXFwiINC/0LjQutGB0LXQu9C10Lkg0L3QsCBcXFwiK2VbMV0rXFxcIiDQv9C40LrRgdC10LvQtdC5LlxcXCJ9LGVtYWlsOmZ1bmN0aW9uKG4pe3JldHVyblxcXCLQn9C+0LvQtSBcXFwiK24rXFxcIiDQtNC+0LvQttC90L4g0LHRi9GC0Ywg0LTQtdC50YHRgtCy0LjRgtC10LvRjNC90YvQvCDRjdC70LXQutGC0YDQvtC90L3Ri9C8INCw0LTRgNC10YHQvtC8LlxcXCJ9LGV4Y2x1ZGVkOmZ1bmN0aW9uKG4pe3JldHVyblxcXCLQn9C+0LvQtSBcXFwiK24rXFxcIiDQtNC+0LvQttC90L4g0LHRi9GC0Ywg0LTQvtC/0YPRgdGC0LjQvNGL0Lwg0LfQvdCw0YfQtdC90LjQtdC8LlxcXCJ9LGV4dDpmdW5jdGlvbihuLGUpe3JldHVyblxcXCLQn9C+0LvQtSBcXFwiK24rXFxcIiDQtNC+0LvQttC90L4g0LHRi9GC0Ywg0LTQtdC50YHRgtCy0LjRgtC10LvRjNC90YvQvCDRhNCw0LnQu9C+0LwuIChcXFwiK2Uuc2xpY2UoMCkrXFxcIilcXFwifSxpbWFnZTpmdW5jdGlvbihuKXtyZXR1cm5cXFwi0J/QvtC70LUgXFxcIituK1xcXCIg0LTQvtC70LbQvdC+INCx0YvRgtGMINC40LfQvtCx0YDQsNC20LXQvdC40LXQvC5cXFwifSxpbmNsdWRlZDpmdW5jdGlvbihuKXtyZXR1cm5cXFwi0J/QvtC70LUgXFxcIituK1xcXCIg0LTQvtC70LbQvdC+INCx0YvRgtGMINC00L7Qv9GD0YHRgtC40LzRi9C8INC30L3QsNGH0LXQvdC40LXQvC5cXFwifSxpbnRlZ2VyOmZ1bmN0aW9uKG4pe3JldHVyblxcXCLQn9C+0LvQtSBcXFwiK24rXFxcIiDQtNC+0LvQttC90L4g0LHRi9GC0Ywg0YbQtdC70YvQvCDRh9C40YHQu9C+0LwuXFxcIn0saXA6ZnVuY3Rpb24obil7cmV0dXJuXFxcItCf0L7Qu9C1IFxcXCIrbitcXFwiINC00L7Qu9C20L3QviDQsdGL0YLRjCDQtNC10LnRgdGC0LLQuNGC0LXQu9GM0L3Ri9C8IElQLdCw0LTRgNC10YHQvtC8LlxcXCJ9LGxlbmd0aDpmdW5jdGlvbihuLGUpe3ZhciB0PWVbMF0scj1lWzFdO3JldHVybiByP1xcXCLQlNC70LjQvdCwINC/0L7Qu9GPIFxcXCIrbitcXFwiINC00L7Qu9C20L3QsCDQsdGL0YLRjCDQvNC10LbQtNGDIFxcXCIrdCtcXFwiINC4IFxcXCIrcitcXFwiLlxcXCI6XFxcItCU0LvQuNC90LAg0L/QvtC70Y8gXFxcIituK1xcXCIg0LTQvtC70LbQvdCwINCx0YvRgtGMIFxcXCIrdCtcXFwiLlxcXCJ9LG1heDpmdW5jdGlvbihuLGUpe3JldHVyblxcXCLQn9C+0LvQtSBcXFwiK24rXFxcIiDQvdC1INC80L7QttC10YIg0LHRi9GC0Ywg0LHQvtC70LXQtSBcXFwiK2VbMF0rXFxcIiDRgdC40LzQstC+0LvQvtCyLlxcXCJ9LG1heF92YWx1ZTpmdW5jdGlvbihuLGUpe3JldHVyblxcXCLQn9C+0LvQtSBcXFwiK24rXFxcIiDQtNC+0LvQttC90L4g0LHRi9GC0YwgXFxcIitlWzBdK1xcXCIg0LjQu9C4INC80LXQvdC10LUuXFxcIn0sbWltZXM6ZnVuY3Rpb24obixlKXtyZXR1cm5cXFwi0J/QvtC70LUgXFxcIituK1xcXCIg0LTQvtC70LbQvdC+INC40LzQtdGC0Ywg0LTQvtC/0YPRgdGC0LjQvNGL0Lkg0YLQuNC/INGE0LDQudC70LAuIChcXFwiK2Uuc2xpY2UoMCkrXFxcIilcXFwifSxtaW46ZnVuY3Rpb24obixlKXtyZXR1cm5cXFwi0J/QvtC70LUgXFxcIituK1xcXCIg0LTQvtC70LbQvdC+INCx0YvRgtGMINC90LUg0LzQtdC90LXQtSBcXFwiK2VbMF0rXFxcIiDRgdC40LzQstC+0LvQvtCyLlxcXCJ9LG1pbl92YWx1ZTpmdW5jdGlvbihuLGUpe3JldHVyblxcXCLQn9C+0LvQtSBcXFwiK24rXFxcIiDQtNC+0LvQttC90L4g0LHRi9GC0YwgXFxcIitlWzBdK1xcXCIg0LjQu9C4INCx0L7Qu9GM0YjQtS5cXFwifSxudW1lcmljOmZ1bmN0aW9uKG4pe3JldHVyblxcXCLQn9C+0LvQtSBcXFwiK24rXFxcIiDQtNC+0LvQttC90L4g0LHRi9GC0Ywg0YfQuNGB0LvQvtC8LlxcXCJ9LHJlZ2V4OmZ1bmN0aW9uKG4pe3JldHVyblxcXCLQn9C+0LvQtSBcXFwiK24rXFxcIiDQuNC80LXQtdGCINC+0YjQuNCx0L7Rh9C90YvQuSDRhNC+0YDQvNCw0YIuXFxcIn0scmVxdWlyZWQ6ZnVuY3Rpb24obil7cmV0dXJuXFxcItCf0L7Qu9C1IFxcXCIrbitcXFwiINC+0LHRj9C30LDRgtC10LvRjNC90L4g0LTQu9GPINC30LDQv9C+0LvQvdC10L3QuNGPLlxcXCJ9LHNpemU6ZnVuY3Rpb24obixlKXtyZXR1cm5cXFwi0J/QvtC70LUgXFxcIituK1xcXCIg0LTQvtC70LbQvdC+INCx0YvRgtGMINC80LXQvdGM0YjQtSwg0YfQtdC8IFxcXCIrZnVuY3Rpb24obil7dmFyIGU9MTAyNCx0PTA9PT0obj1OdW1iZXIobikqZSk/MDpNYXRoLmZsb29yKE1hdGgubG9nKG4pL01hdGgubG9nKGUpKTtyZXR1cm4gMSoobi9NYXRoLnBvdyhlLHQpKS50b0ZpeGVkKDIpK1xcXCIgXFxcIitbXFxcIkJ5dGVcXFwiLFxcXCJLQlxcXCIsXFxcIk1CXFxcIixcXFwiR0JcXFwiLFxcXCJUQlxcXCIsXFxcIlBCXFxcIixcXFwiRUJcXFwiLFxcXCJaQlxcXCIsXFxcIllCXFxcIl1bdF19KGVbMF0pK1xcXCIuXFxcIn0sdXJsOmZ1bmN0aW9uKG4pe3JldHVyblxcXCLQn9C+0LvQtSBcXFwiK24rXFxcIiDQuNC80LXQtdGCINC+0YjQuNCx0L7Rh9C90YvQuSDRhNC+0YDQvNCw0YIgVVJMLlxcXCJ9fSxhdHRyaWJ1dGVzOnt9fTtyZXR1cm5cXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIFZlZVZhbGlkYXRlJiZWZWVWYWxpZGF0ZS5WYWxpZGF0b3IubG9jYWxpemUoKChuPXt9KVtlLm5hbWVdPWUsbikpLGV9KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmVlLXZhbGlkYXRlL2Rpc3QvbG9jYWxlL3J1LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvdmVlLXZhbGlkYXRlL2Rpc3QvdmVlLXZhbGlkYXRlLmVzbS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3ZlZS12YWxpZGF0ZS9kaXN0L3ZlZS12YWxpZGF0ZS5lc20uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0LCBFcnJvckJhZywgUnVsZXMsIFZhbGlkYXRpb25PYnNlcnZlciwgVmFsaWRhdGlvblByb3ZpZGVyLCBWYWxpZGF0b3IsIGRpcmVjdGl2ZSwgaW5zdGFsbCwgbWFwRmllbGRzLCBtaXhpbiwgdmVyc2lvbiwgd2l0aFZhbGlkYXRpb24gKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkVycm9yQmFnXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFcnJvckJhZzsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiUnVsZXNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFJ1bGVzOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJWYWxpZGF0aW9uT2JzZXJ2ZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFZhbGlkYXRpb25PYnNlcnZlcjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiVmFsaWRhdGlvblByb3ZpZGVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBWYWxpZGF0aW9uUHJvdmlkZXI7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlZhbGlkYXRvclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVmFsaWRhdG9yOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkaXJlY3RpdmVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRpcmVjdGl2ZTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiaW5zdGFsbFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaW5zdGFsbDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwibWFwRmllbGRzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtYXBGaWVsZHM7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIm1peGluXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtaXhpbjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwidmVyc2lvblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdmVyc2lvbjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwid2l0aFZhbGlkYXRpb25cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHdpdGhWYWxpZGF0aW9uOyB9KTtcXG4vKipcXG4gICogdmVlLXZhbGlkYXRlIHYyLjIuMTJcXG4gICogKGMpIDIwMTkgQWJkZWxyYWhtYW4gQXdhZFxcbiAgKiBAbGljZW5zZSBNSVRcXG4gICovXFxuLy8gXFxuXFxudmFyIGlzVGV4dElucHV0ID0gZnVuY3Rpb24gKGVsKSB7XFxuICByZXR1cm4gaW5jbHVkZXMoWyd0ZXh0JywgJ3Bhc3N3b3JkJywgJ3NlYXJjaCcsICdlbWFpbCcsICd0ZWwnLCAndXJsJywgJ3RleHRhcmVhJywgJ251bWJlciddLCBlbC50eXBlKTtcXG59O1xcblxcbnZhciBpc0NoZWNrYm94T3JSYWRpb0lucHV0ID0gZnVuY3Rpb24gKGVsKSB7XFxuICByZXR1cm4gaW5jbHVkZXMoWydyYWRpbycsICdjaGVja2JveCddLCBlbC50eXBlKTtcXG59O1xcblxcbnZhciBpc0RhdGVJbnB1dCA9IGZ1bmN0aW9uIChlbCkge1xcbiAgcmV0dXJuIGluY2x1ZGVzKFsnZGF0ZScsICd3ZWVrJywgJ21vbnRoJywgJ2RhdGV0aW1lLWxvY2FsJywgJ3RpbWUnXSwgZWwudHlwZSk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXRzIHRoZSBkYXRhIGF0dHJpYnV0ZS4gdGhlIG5hbWUgbXVzdCBiZSBrZWJhYi1jYXNlLlxcbiAqL1xcbnZhciBnZXREYXRhQXR0cmlidXRlID0gZnVuY3Rpb24gKGVsLCBuYW1lKSB7IHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoKFxcXCJkYXRhLXZ2LVxcXCIgKyBuYW1lKSk7IH07XFxuXFxudmFyIGlzTmFOJDEgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG4gIGlmICgnaXNOYU4nIGluIE51bWJlcikge1xcbiAgICByZXR1cm4gTnVtYmVyLmlzTmFOKHZhbHVlKTtcXG4gIH1cXG5cXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxcbiAgcmV0dXJuIHR5cGVvZih2YWx1ZSkgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSB2YWx1ZTtcXG59O1xcblxcbi8qKlxcbiAqIENoZWNrcyBpZiB0aGUgdmFsdWVzIGFyZSBlaXRoZXIgbnVsbCBvciB1bmRlZmluZWQuXFxuICovXFxudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHZhbHVlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xcbiAgd2hpbGUgKCBsZW4tLSApIHZhbHVlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xcblxcbiAgcmV0dXJuIHZhbHVlcy5ldmVyeShmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XFxuICB9KTtcXG59O1xcblxcbi8qKlxcbiAqIENyZWF0ZXMgdGhlIGRlZmF1bHQgZmxhZ3Mgb2JqZWN0LlxcbiAqL1xcbnZhciBjcmVhdGVGbGFncyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XFxuICB1bnRvdWNoZWQ6IHRydWUsXFxuICB0b3VjaGVkOiBmYWxzZSxcXG4gIGRpcnR5OiBmYWxzZSxcXG4gIHByaXN0aW5lOiB0cnVlLFxcbiAgdmFsaWQ6IG51bGwsXFxuICBpbnZhbGlkOiBudWxsLFxcbiAgdmFsaWRhdGVkOiBmYWxzZSxcXG4gIHBlbmRpbmc6IGZhbHNlLFxcbiAgcmVxdWlyZWQ6IGZhbHNlLFxcbiAgY2hhbmdlZDogZmFsc2VcXG59KTsgfTtcXG5cXG4vKipcXG4gKiBTaGFsbG93IG9iamVjdCBjb21wYXJpc29uLlxcbiAqL1xcbnZhciBpc0VxdWFsID0gZnVuY3Rpb24gKGxocywgcmhzKSB7XFxuICBpZiAobGhzIGluc3RhbmNlb2YgUmVnRXhwICYmIHJocyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xcbiAgICByZXR1cm4gaXNFcXVhbChsaHMuc291cmNlLCByaHMuc291cmNlKSAmJiBpc0VxdWFsKGxocy5mbGFncywgcmhzLmZsYWdzKTtcXG4gIH1cXG5cXG4gIGlmIChBcnJheS5pc0FycmF5KGxocykgJiYgQXJyYXkuaXNBcnJheShyaHMpKSB7XFxuICAgIGlmIChsaHMubGVuZ3RoICE9PSByaHMubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxcblxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxocy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGlmICghaXNFcXVhbChsaHNbaV0sIHJoc1tpXSkpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuXFxuICAvLyBpZiBib3RoIGFyZSBvYmplY3RzLCBjb21wYXJlIGVhY2gga2V5IHJlY3Vyc2l2ZWx5LlxcbiAgaWYgKGlzT2JqZWN0KGxocykgJiYgaXNPYmplY3QocmhzKSkge1xcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobGhzKS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgcmV0dXJuIGlzRXF1YWwobGhzW2tleV0sIHJoc1trZXldKTtcXG4gICAgfSkgJiYgT2JqZWN0LmtleXMocmhzKS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgcmV0dXJuIGlzRXF1YWwobGhzW2tleV0sIHJoc1trZXldKTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBpZiAoaXNOYU4kMShsaHMpICYmIGlzTmFOJDEocmhzKSkge1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH1cXG5cXG4gIHJldHVybiBsaHMgPT09IHJocztcXG59O1xcblxcbi8qKlxcbiAqIERldGVybWluZXMgdGhlIGlucHV0IGZpZWxkIHNjb3BlLlxcbiAqL1xcbnZhciBnZXRTY29wZSA9IGZ1bmN0aW9uIChlbCkge1xcbiAgdmFyIHNjb3BlID0gZ2V0RGF0YUF0dHJpYnV0ZShlbCwgJ3Njb3BlJyk7XFxuICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoc2NvcGUpKSB7XFxuICAgIHZhciBmb3JtID0gZ2V0Rm9ybShlbCk7XFxuXFxuICAgIGlmIChmb3JtKSB7XFxuICAgICAgc2NvcGUgPSBnZXREYXRhQXR0cmlidXRlKGZvcm0sICdzY29wZScpO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gIWlzTnVsbE9yVW5kZWZpbmVkKHNjb3BlKSA/IHNjb3BlIDogbnVsbDtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgY2xvc2VzdCBmb3JtIGVsZW1lbnQuXFxuICovXFxudmFyIGdldEZvcm0gPSBmdW5jdGlvbiAoZWwpIHtcXG4gIGlmIChpc051bGxPclVuZGVmaW5lZChlbCkpIHsgcmV0dXJuIG51bGw7IH1cXG5cXG4gIGlmIChlbC50YWdOYW1lID09PSAnRk9STScpIHsgcmV0dXJuIGVsOyB9XFxuXFxuICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGVsLmZvcm0pKSB7IHJldHVybiBlbC5mb3JtOyB9XFxuXFxuICByZXR1cm4gIWlzTnVsbE9yVW5kZWZpbmVkKGVsLnBhcmVudE5vZGUpID8gZ2V0Rm9ybShlbC5wYXJlbnROb2RlKSA6IG51bGw7XFxufTtcXG5cXG4vKipcXG4gKiBHZXRzIHRoZSB2YWx1ZSBpbiBhbiBvYmplY3Qgc2FmZWx5LlxcbiAqL1xcbnZhciBnZXRQYXRoID0gZnVuY3Rpb24gKHBhdGgsIHRhcmdldCwgZGVmKSB7XFxuICBpZiAoIGRlZiA9PT0gdm9pZCAwICkgZGVmID0gdW5kZWZpbmVkO1xcblxcbiAgaWYgKCFwYXRoIHx8ICF0YXJnZXQpIHsgcmV0dXJuIGRlZjsgfVxcblxcbiAgdmFyIHZhbHVlID0gdGFyZ2V0O1xcbiAgcGF0aC5zcGxpdCgnLicpLmV2ZXJ5KGZ1bmN0aW9uIChwcm9wKSB7XFxuICAgIGlmIChwcm9wIGluIHZhbHVlKSB7XFxuICAgICAgdmFsdWUgPSB2YWx1ZVtwcm9wXTtcXG5cXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICB2YWx1ZSA9IGRlZjtcXG5cXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfSk7XFxuXFxuICByZXR1cm4gdmFsdWU7XFxufTtcXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgcGF0aCBleGlzdHMgd2l0aGluIGFuIG9iamVjdC5cXG4gKi9cXG52YXIgaGFzUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCB0YXJnZXQpIHtcXG4gIHZhciBvYmogPSB0YXJnZXQ7XFxuICB2YXIgcHJldmlvdXNQYXRoID0gbnVsbDtcXG4gIHZhciBpc051bGxPck5vbk9iamVjdCA9IGZhbHNlO1xcbiAgdmFyIGlzVmFsaWRQYXRoID0gcGF0aC5zcGxpdCgnLicpLnJlZHVjZShmdW5jdGlvbiAocmVkdWNlciwgcHJvcCkge1xcbiAgICBpZiAob2JqID09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcXG4gICAgICBpc051bGxPck5vbk9iamVjdCA9IHRydWU7XFxuICAgICAgcmV0dXJuIHJlZHVjZXIgJiYgZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgaWYgKHByb3AgaW4gb2JqKSB7XFxuICAgICAgb2JqID0gb2JqW3Byb3BdO1xcbiAgICAgIHByZXZpb3VzUGF0aCA9IHByZXZpb3VzUGF0aCA9PT0gbnVsbCA/IHByb3AgOiBwcmV2aW91c1BhdGggKyAnLicgKyBwcm9wO1xcblxcbiAgICAgIHJldHVybiByZWR1Y2VyICYmIHRydWU7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHJlZHVjZXIgJiYgZmFsc2U7XFxuICB9LCB0cnVlKTtcXG5cXG4gIGlmICh0cnVlKSB7XFxuICAgIGlmIChpc051bGxPck5vbk9iamVjdCkge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcmV2aW91c1BhdGggKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIGlzVmFsaWRQYXRoO1xcbn07XFxuXFxuLyoqXFxuICogUGFyc2VzIGEgcnVsZSBzdHJpbmcgZXhwcmVzc2lvbi5cXG4gKi9cXG52YXIgcGFyc2VSdWxlID0gZnVuY3Rpb24gKHJ1bGUpIHtcXG4gIHZhciBwYXJhbXMgPSBbXTtcXG4gIHZhciBuYW1lID0gcnVsZS5zcGxpdCgnOicpWzBdO1xcblxcbiAgaWYgKGluY2x1ZGVzKHJ1bGUsICc6JykpIHtcXG4gICAgcGFyYW1zID0gcnVsZS5zcGxpdCgnOicpLnNsaWNlKDEpLmpvaW4oJzonKS5zcGxpdCgnLCcpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHsgbmFtZTogbmFtZSwgcGFyYW1zOiBwYXJhbXMgfTtcXG59O1xcblxcbi8qKlxcbiAqIERlYm91bmNlcyBhIGZ1bmN0aW9uLlxcbiAqL1xcbnZhciBkZWJvdW5jZSA9IGZ1bmN0aW9uIChmbiwgd2FpdCwgdG9rZW4pIHtcXG4gIGlmICggd2FpdCA9PT0gdm9pZCAwICkgd2FpdCA9IDA7XFxuICBpZiAoIHRva2VuID09PSB2b2lkIDAgKSB0b2tlbiA9IHsgY2FuY2VsbGVkOiBmYWxzZSB9O1xcblxcbiAgaWYgKHdhaXQgPT09IDApIHtcXG4gICAgcmV0dXJuIGZuO1xcbiAgfVxcblxcbiAgdmFyIHRpbWVvdXQ7XFxuXFxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xcblxcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgdGltZW91dCA9IG51bGw7XFxuXFxuICAgICAgLy8gY2hlY2sgaWYgdGhlIGZuIGNhbGwgd2FzIGNhbmNlbGxlZC5cXG4gICAgICBpZiAoIXRva2VuLmNhbmNlbGxlZCkgeyBmbi5hcHBseSh2b2lkIDAsIGFyZ3MpOyB9XFxuICAgIH07XFxuXFxuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcXG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xcbiAgICBpZiAoIXRpbWVvdXQpIHsgZm4uYXBwbHkodm9pZCAwLCBhcmdzKTsgfVxcbiAgfTtcXG59O1xcblxcbi8qKlxcbiAqIEFwcGVuZHMgYSBydWxlIGRlZmluaXRpb24gdG8gYSBsaXN0IG9mIHJ1bGVzLlxcbiAqL1xcbnZhciBhcHBlbmRSdWxlID0gZnVuY3Rpb24gKHJ1bGUsIHJ1bGVzKSB7XFxuICBpZiAoIXJ1bGVzKSB7XFxuICAgIHJldHVybiBub3JtYWxpemVSdWxlcyhydWxlKTtcXG4gIH1cXG5cXG4gIGlmICghcnVsZSkge1xcbiAgICByZXR1cm4gbm9ybWFsaXplUnVsZXMocnVsZXMpO1xcbiAgfVxcblxcbiAgaWYgKHR5cGVvZiBydWxlcyA9PT0gJ3N0cmluZycpIHtcXG4gICAgcnVsZXMgPSBub3JtYWxpemVSdWxlcyhydWxlcyk7XFxuICB9XFxuXFxuICByZXR1cm4gYXNzaWduKHt9LCBydWxlcywgbm9ybWFsaXplUnVsZXMocnVsZSkpO1xcbn07XFxuXFxuLyoqXFxuICogTm9ybWFsaXplcyB0aGUgZ2l2ZW4gcnVsZXMgZXhwcmVzc2lvbi5cXG4gKi9cXG52YXIgbm9ybWFsaXplUnVsZXMgPSBmdW5jdGlvbiAocnVsZXMpIHtcXG4gIC8vIGlmIGZhbHN5IHZhbHVlIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXFxuICBpZiAoIXJ1bGVzKSB7XFxuICAgIHJldHVybiB7fTtcXG4gIH1cXG5cXG4gIGlmIChpc09iamVjdChydWxlcykpIHtcXG4gICAgLy8gJEZsb3dGaXhNZVxcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocnVsZXMpLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xcbiAgICAgIHZhciBwYXJhbXMgPSBbXTtcXG4gICAgICAvLyAkRmxvd0ZpeE1lXFxuICAgICAgaWYgKHJ1bGVzW2N1cnJdID09PSB0cnVlKSB7XFxuICAgICAgICBwYXJhbXMgPSBbXTtcXG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocnVsZXNbY3Vycl0pKSB7XFxuICAgICAgICBwYXJhbXMgPSBydWxlc1tjdXJyXTtcXG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHJ1bGVzW2N1cnJdKSkge1xcbiAgICAgICAgcGFyYW1zID0gcnVsZXNbY3Vycl07XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHBhcmFtcyA9IFtydWxlc1tjdXJyXV07XFxuICAgICAgfVxcblxcbiAgICAgIC8vICRGbG93Rml4TWVcXG4gICAgICBpZiAocnVsZXNbY3Vycl0gIT09IGZhbHNlKSB7XFxuICAgICAgICBwcmV2W2N1cnJdID0gcGFyYW1zO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gcHJldjtcXG4gICAgfSwge30pO1xcbiAgfVxcblxcbiAgaWYgKHR5cGVvZiBydWxlcyAhPT0gJ3N0cmluZycpIHtcXG4gICAgd2FybigncnVsZXMgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gb2JqZWN0LicpO1xcbiAgICByZXR1cm4ge307XFxuICB9XFxuXFxuICByZXR1cm4gcnVsZXMuc3BsaXQoJ3wnKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIHJ1bGUpIHtcXG4gICAgdmFyIHBhcnNlZFJ1bGUgPSBwYXJzZVJ1bGUocnVsZSk7XFxuICAgIGlmICghcGFyc2VkUnVsZS5uYW1lKSB7XFxuICAgICAgcmV0dXJuIHByZXY7XFxuICAgIH1cXG5cXG4gICAgcHJldltwYXJzZWRSdWxlLm5hbWVdID0gcGFyc2VkUnVsZS5wYXJhbXM7XFxuICAgIHJldHVybiBwcmV2O1xcbiAgfSwge30pO1xcbn07XFxuXFxuLyoqXFxuICogRW1pdHMgYSB3YXJuaW5nIHRvIHRoZSBjb25zb2xlLlxcbiAqL1xcbnZhciB3YXJuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcXG4gIGNvbnNvbGUud2FybigoXFxcIlt2ZWUtdmFsaWRhdGVdIFxcXCIgKyBtZXNzYWdlKSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcXG59O1xcblxcbi8qKlxcbiAqIENyZWF0ZXMgYSBicmFuZGVkIGVycm9yIG9iamVjdC5cXG4gKi9cXG52YXIgY3JlYXRlRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkgeyByZXR1cm4gbmV3IEVycm9yKChcXFwiW3ZlZS12YWxpZGF0ZV0gXFxcIiArIG1lc3NhZ2UpKTsgfTtcXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdC5cXG4gKi9cXG52YXIgaXNPYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogIT09IG51bGwgJiYgb2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICEgQXJyYXkuaXNBcnJheShvYmopOyB9O1xcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBhIGZ1bmN0aW9uIGlzIGNhbGxhYmxlLlxcbiAqL1xcbnZhciBpc0NhbGxhYmxlID0gZnVuY3Rpb24gKGZ1bmMpIHsgcmV0dXJuIHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nOyB9O1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIGVsZW1lbnQgaGFzIHRoZSBjc3MgY2xhc3Mgb24gaXQuXFxuICovXFxudmFyIGhhc0NsYXNzID0gZnVuY3Rpb24gKGVsLCBjbGFzc05hbWUpIHtcXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcXG4gICAgcmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xcbiAgfVxcblxcbiAgcmV0dXJuICEhZWwuY2xhc3NOYW1lLm1hdGNoKG5ldyBSZWdFeHAoKFxcXCIoXFxcXFxcXFxzfF4pXFxcIiArIGNsYXNzTmFtZSArIFxcXCIoXFxcXFxcXFxzfCQpXFxcIikpKTtcXG59O1xcblxcbi8qKlxcbiAqIEFkZHMgdGhlIHByb3ZpZGVkIGNzcyBjbGFzc05hbWUgdG8gdGhlIGVsZW1lbnQuXFxuICovXFxudmFyIGFkZENsYXNzID0gZnVuY3Rpb24gKGVsLCBjbGFzc05hbWUpIHtcXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcXG4gICAgZWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICBpZiAoIWhhc0NsYXNzKGVsLCBjbGFzc05hbWUpKSB7XFxuICAgIGVsLmNsYXNzTmFtZSArPSBcXFwiIFxcXCIgKyBjbGFzc05hbWU7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBSZW1vdmUgdGhlIHByb3ZpZGVkIGNzcyBjbGFzc05hbWUgZnJvbSB0aGUgZWxlbWVudC5cXG4gKi9cXG52YXIgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoZWwsIGNsYXNzTmFtZSkge1xcbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGlmIChoYXNDbGFzcyhlbCwgY2xhc3NOYW1lKSkge1xcbiAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cCgoXFxcIihcXFxcXFxcXHN8XilcXFwiICsgY2xhc3NOYW1lICsgXFxcIihcXFxcXFxcXHN8JClcXFwiKSk7XFxuICAgIGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKHJlZywgJyAnKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIEFkZHMgb3IgcmVtb3ZlcyBhIGNsYXNzIG5hbWUgb24gdGhlIGlucHV0IGRlcGVuZGluZyBvbiB0aGUgc3RhdHVzIGZsYWcuXFxuICovXFxudmFyIHRvZ2dsZUNsYXNzID0gZnVuY3Rpb24gKGVsLCBjbGFzc05hbWUsIHN0YXR1cykge1xcbiAgaWYgKCFlbCB8fCAhY2xhc3NOYW1lKSB7IHJldHVybjsgfVxcblxcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2xhc3NOYW1lKSkge1xcbiAgICBjbGFzc05hbWUuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gdG9nZ2xlQ2xhc3MoZWwsIGl0ZW0sIHN0YXR1cyk7IH0pO1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICBpZiAoc3RhdHVzKSB7XFxuICAgIHJldHVybiBhZGRDbGFzcyhlbCwgY2xhc3NOYW1lKTtcXG4gIH1cXG5cXG4gIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpO1xcbn07XFxuXFxuLyoqXFxuICogQ29udmVydHMgYW4gYXJyYXktbGlrZSBvYmplY3QgdG8gYXJyYXksIHByb3ZpZGVzIGEgc2ltcGxlIHBvbHlmaWxsIGZvciBBcnJheS5mcm9tXFxuICovXFxudmFyIHRvQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXlMaWtlKSB7XFxuICBpZiAoaXNDYWxsYWJsZShBcnJheS5mcm9tKSkge1xcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnJheUxpa2UpO1xcbiAgfVxcblxcbiAgdmFyIGFycmF5ID0gW107XFxuICB2YXIgbGVuZ3RoID0gYXJyYXlMaWtlLmxlbmd0aDtcXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuICAgIGFycmF5LnB1c2goYXJyYXlMaWtlW2ldKTtcXG4gIH1cXG5cXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXFxuICByZXR1cm4gYXJyYXk7XFxufTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0cyBhbiBhcnJheS1saWtlIG9iamVjdCB0byBhcnJheSBhbmQgcGxhY2Ugb3RoZXIgZWxlbWVudHMgaW4gYW4gYXJyYXlcXG4gKi9cXG52YXIgZW5zdXJlQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXlMaWtlKSB7XFxuICBpZiAoQXJyYXkuaXNBcnJheShhcnJheUxpa2UpKSB7XFxuICAgIHJldHVybiBbXS5jb25jYXQoIGFycmF5TGlrZSApO1xcbiAgfVxcbiAgdmFyIGFycmF5ID0gdG9BcnJheShhcnJheUxpa2UpO1xcbiAgcmV0dXJuIGlzRW1wdHlBcnJheShhcnJheSkgPyBbYXJyYXlMaWtlXSA6IGFycmF5O1xcbn07XFxuXFxuLyoqXFxuICogQXNzaWduIHBvbHlmaWxsIGZyb20gdGhlIG1kbi5cXG4gKi9cXG52YXIgYXNzaWduID0gZnVuY3Rpb24gKHRhcmdldCkge1xcbiAgdmFyIG90aGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcXG4gIHdoaWxlICggbGVuLS0gPiAwICkgb3RoZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xcblxcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cXG4gIGlmIChpc0NhbGxhYmxlKE9iamVjdC5hc3NpZ24pKSB7XFxuICAgIHJldHVybiBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgWyB0YXJnZXQgXS5jb25jYXQoIG90aGVycyApKTtcXG4gIH1cXG5cXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXFxuICBpZiAodGFyZ2V0ID09IG51bGwpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XFxuICB9XFxuXFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xcbiAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xcbiAgb3RoZXJzLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xcbiAgICAvLyBTa2lwIG92ZXIgaWYgdW5kZWZpbmVkIG9yIG51bGxcXG4gICAgaWYgKGFyZyAhPSBudWxsKSB7XFxuICAgICAgT2JqZWN0LmtleXMoYXJnKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgICAgIHRvW2tleV0gPSBhcmdba2V5XTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfSk7XFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xcbiAgcmV0dXJuIHRvO1xcbn07XFxuXFxudmFyIGlkID0gMDtcXG52YXIgaWRUZW1wbGF0ZSA9ICd7aWR9JztcXG5cXG4vKipcXG4gKiBHZW5lcmF0ZXMgYSB1bmlxdWUgaWQuXFxuICovXFxudmFyIHVuaXFJZCA9IGZ1bmN0aW9uICgpIHtcXG4gIC8vIGhhbmRsZSB0b28gbWFueSB1c2VzIG9mIHVuaXFJZCwgYWx0aG91Z2ggdW5saWtlbHkuXFxuICBpZiAoaWQgPj0gOTk5OSkge1xcbiAgICBpZCA9IDA7XFxuICAgIC8vIHNoaWZ0IHRoZSB0ZW1wbGF0ZS5cXG4gICAgaWRUZW1wbGF0ZSA9IGlkVGVtcGxhdGUucmVwbGFjZSgne2lkfScsICdfe2lkfScpO1xcbiAgfVxcblxcbiAgaWQrKztcXG4gIHZhciBuZXdJZCA9IGlkVGVtcGxhdGUucmVwbGFjZSgne2lkfScsIFN0cmluZyhpZCkpO1xcblxcbiAgcmV0dXJuIG5ld0lkO1xcbn07XFxuXFxudmFyIGZpbmRJbmRleCA9IGZ1bmN0aW9uIChhcnJheUxpa2UsIHByZWRpY2F0ZSkge1xcbiAgdmFyIGFycmF5ID0gQXJyYXkuaXNBcnJheShhcnJheUxpa2UpID8gYXJyYXlMaWtlIDogdG9BcnJheShhcnJheUxpa2UpO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2ldKSkge1xcbiAgICAgIHJldHVybiBpO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gLTE7XFxufTtcXG5cXG4vKipcXG4gKiBmaW5kcyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IHNhdGlzZmllcyB0aGUgcHJlZGljYXRlIGNhbGxiYWNrLCBwb2x5ZmlsbHMgYXJyYXkuZmluZFxcbiAqL1xcbnZhciBmaW5kID0gZnVuY3Rpb24gKGFycmF5TGlrZSwgcHJlZGljYXRlKSB7XFxuICB2YXIgYXJyYXkgPSBBcnJheS5pc0FycmF5KGFycmF5TGlrZSkgPyBhcnJheUxpa2UgOiB0b0FycmF5KGFycmF5TGlrZSk7XFxuICB2YXIgaWR4ID0gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUpO1xcblxcbiAgcmV0dXJuIGlkeCA9PT0gLTEgPyB1bmRlZmluZWQgOiBhcnJheVtpZHhdO1xcbn07XFxuXFxudmFyIGlzQnVpbHRJbkNvbXBvbmVudCA9IGZ1bmN0aW9uICh2bm9kZSkge1xcbiAgaWYgKCF2bm9kZSkge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICB2YXIgdGFnID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucy50YWc7XFxuXFxuICByZXR1cm4gL14oa2VlcC1hbGl2ZXx0cmFuc2l0aW9ufHRyYW5zaXRpb24tZ3JvdXApJC8udGVzdCh0YWcpO1xcbn07XFxuXFxudmFyIG1ha2VEZWxheU9iamVjdCA9IGZ1bmN0aW9uIChldmVudHMsIGRlbGF5LCBkZWxheUNvbmZpZykge1xcbiAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicpIHtcXG4gICAgcmV0dXJuIGV2ZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGUpIHtcXG4gICAgICBwcmV2W2VdID0gZGVsYXk7XFxuICAgICAgcmV0dXJuIHByZXY7XFxuICAgIH0sIHt9KTtcXG4gIH1cXG5cXG4gIHJldHVybiBldmVudHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBlKSB7XFxuICAgIGlmICh0eXBlb2YgZGVsYXkgPT09ICdvYmplY3QnICYmIGUgaW4gZGVsYXkpIHtcXG4gICAgICBwcmV2W2VdID0gZGVsYXlbZV07XFxuICAgICAgcmV0dXJuIHByZXY7XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBkZWxheUNvbmZpZyA9PT0gJ251bWJlcicpIHtcXG4gICAgICBwcmV2W2VdID0gZGVsYXlDb25maWc7XFxuICAgICAgcmV0dXJuIHByZXY7XFxuICAgIH1cXG5cXG4gICAgcHJldltlXSA9IChkZWxheUNvbmZpZyAmJiBkZWxheUNvbmZpZ1tlXSkgfHwgMDtcXG5cXG4gICAgcmV0dXJuIHByZXY7XFxuICB9LCB7fSk7XFxufTtcXG5cXG52YXIgZGVlcFBhcnNlSW50ID0gZnVuY3Rpb24gKGlucHV0KSB7XFxuICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykgeyByZXR1cm4gaW5wdXQ7IH1cXG5cXG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7IHJldHVybiBwYXJzZUludChpbnB1dCk7IH1cXG5cXG4gIHZhciBtYXAgPSB7fTtcXG4gIGZvciAodmFyIGVsZW1lbnQgaW4gaW5wdXQpIHtcXG4gICAgbWFwW2VsZW1lbnRdID0gcGFyc2VJbnQoaW5wdXRbZWxlbWVudF0pO1xcbiAgfVxcblxcbiAgcmV0dXJuIG1hcDtcXG59O1xcblxcbnZhciBtZXJnZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xcbiAgaWYgKCEgKGlzT2JqZWN0KHRhcmdldCkgJiYgaXNPYmplY3Qoc291cmNlKSkpIHtcXG4gICAgcmV0dXJuIHRhcmdldDtcXG4gIH1cXG5cXG4gIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XFxuICAgIHZhciBvYmosIG9iaiQxO1xcblxcbiAgICBpZiAoaXNPYmplY3Qoc291cmNlW2tleV0pKSB7XFxuICAgICAgaWYgKCEgdGFyZ2V0W2tleV0pIHtcXG4gICAgICAgIGFzc2lnbih0YXJnZXQsICggb2JqID0ge30sIG9ialtrZXldID0ge30sIG9iaiApKTtcXG4gICAgICB9XFxuXFxuICAgICAgbWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgYXNzaWduKHRhcmdldCwgKCBvYmokMSA9IHt9LCBvYmokMVtrZXldID0gc291cmNlW2tleV0sIG9iaiQxICkpO1xcbiAgfSk7XFxuXFxuICByZXR1cm4gdGFyZ2V0O1xcbn07XFxuXFxudmFyIGZpbGxSdWxlc0Zyb21FbGVtZW50ID0gZnVuY3Rpb24gKGVsLCBydWxlcykge1xcbiAgaWYgKGVsLnJlcXVpcmVkKSB7XFxuICAgIHJ1bGVzID0gYXBwZW5kUnVsZSgncmVxdWlyZWQnLCBydWxlcyk7XFxuICB9XFxuXFxuICBpZiAoaXNUZXh0SW5wdXQoZWwpKSB7XFxuICAgIGlmIChlbC50eXBlID09PSAnZW1haWwnKSB7XFxuICAgICAgcnVsZXMgPSBhcHBlbmRSdWxlKChcXFwiZW1haWxcXFwiICsgKGVsLm11bHRpcGxlID8gJzptdWx0aXBsZScgOiAnJykpLCBydWxlcyk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGVsLnBhdHRlcm4pIHtcXG4gICAgICBydWxlcyA9IGFwcGVuZFJ1bGUoeyByZWdleDogZWwucGF0dGVybiB9LCBydWxlcyk7XFxuICAgIH1cXG5cXG4gICAgLy8gNTI0Mjg4IGlzIHRoZSBtYXggb24gc29tZSBicm93c2VycyBhbmQgdGVzdCBlbnZpcm9ubWVudHMuXFxuICAgIGlmIChlbC5tYXhMZW5ndGggPj0gMCAmJiBlbC5tYXhMZW5ndGggPCA1MjQyODgpIHtcXG4gICAgICBydWxlcyA9IGFwcGVuZFJ1bGUoKFxcXCJtYXg6XFxcIiArIChlbC5tYXhMZW5ndGgpKSwgcnVsZXMpO1xcbiAgICB9XFxuXFxuICAgIGlmIChlbC5taW5MZW5ndGggPiAwKSB7XFxuICAgICAgcnVsZXMgPSBhcHBlbmRSdWxlKChcXFwibWluOlxcXCIgKyAoZWwubWluTGVuZ3RoKSksIHJ1bGVzKTtcXG4gICAgfVxcblxcbiAgICBpZiAoZWwudHlwZSA9PT0gJ251bWJlcicpIHtcXG4gICAgICBydWxlcyA9IGFwcGVuZFJ1bGUoJ2RlY2ltYWwnLCBydWxlcyk7XFxuICAgICAgaWYgKGVsLm1pbiAhPT0gJycpIHtcXG4gICAgICAgIHJ1bGVzID0gYXBwZW5kUnVsZSgoXFxcIm1pbl92YWx1ZTpcXFwiICsgKGVsLm1pbikpLCBydWxlcyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChlbC5tYXggIT09ICcnKSB7XFxuICAgICAgICBydWxlcyA9IGFwcGVuZFJ1bGUoKFxcXCJtYXhfdmFsdWU6XFxcIiArIChlbC5tYXgpKSwgcnVsZXMpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gcnVsZXM7XFxuICB9XFxuXFxuICBpZiAoaXNEYXRlSW5wdXQoZWwpKSB7XFxuICAgIHZhciB0aW1lRm9ybWF0ID0gZWwuc3RlcCAmJiBOdW1iZXIoZWwuc3RlcCkgPCA2MCA/ICdISDptbTpzcycgOiAnSEg6bW0nO1xcblxcbiAgICBpZiAoZWwudHlwZSA9PT0gJ2RhdGUnKSB7XFxuICAgICAgcmV0dXJuIGFwcGVuZFJ1bGUoJ2RhdGVfZm9ybWF0Onl5eXktTU0tZGQnLCBydWxlcyk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGVsLnR5cGUgPT09ICdkYXRldGltZS1sb2NhbCcpIHtcXG4gICAgICByZXR1cm4gYXBwZW5kUnVsZSgoXFxcImRhdGVfZm9ybWF0Onl5eXktTU0tZGRUXFxcIiArIHRpbWVGb3JtYXQpLCBydWxlcyk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGVsLnR5cGUgPT09ICdtb250aCcpIHtcXG4gICAgICByZXR1cm4gYXBwZW5kUnVsZSgnZGF0ZV9mb3JtYXQ6eXl5eS1NTScsIHJ1bGVzKTtcXG4gICAgfVxcblxcbiAgICBpZiAoZWwudHlwZSA9PT0gJ3dlZWsnKSB7XFxuICAgICAgcmV0dXJuIGFwcGVuZFJ1bGUoJ2RhdGVfZm9ybWF0Onl5eXktW1ddV1cnLCBydWxlcyk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGVsLnR5cGUgPT09ICd0aW1lJykge1xcbiAgICAgIHJldHVybiBhcHBlbmRSdWxlKChcXFwiZGF0ZV9mb3JtYXQ6XFxcIiArIHRpbWVGb3JtYXQpLCBydWxlcyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBydWxlcztcXG59O1xcblxcbnZhciB2YWx1ZXMgPSBmdW5jdGlvbiAob2JqKSB7XFxuICBpZiAoaXNDYWxsYWJsZShPYmplY3QudmFsdWVzKSkge1xcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhvYmopO1xcbiAgfVxcblxcbiAgLy8gZmFsbGJhY2sgdG8ga2V5cygpXFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBvYmpba107IH0pO1xcbn07XFxuXFxudmFyIHBhcnNlU2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcXG4gIHZhciBydWxlID0gbnVsbDtcXG4gIGlmIChpbmNsdWRlcyhzZWxlY3RvciwgJzonKSkge1xcbiAgICBydWxlID0gc2VsZWN0b3Iuc3BsaXQoJzonKS5wb3AoKTtcXG4gICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKChcXFwiOlxcXCIgKyBydWxlKSwgJycpO1xcbiAgfVxcblxcbiAgaWYgKHNlbGVjdG9yWzBdID09PSAnIycpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBpZDogc2VsZWN0b3Iuc2xpY2UoMSksXFxuICAgICAgcnVsZTogcnVsZSxcXG4gICAgICBuYW1lOiBudWxsLFxcbiAgICAgIHNjb3BlOiBudWxsXFxuICAgIH07XFxuICB9XFxuXFxuICB2YXIgc2NvcGUgPSBudWxsO1xcbiAgdmFyIG5hbWUgPSBzZWxlY3RvcjtcXG4gIGlmIChpbmNsdWRlcyhzZWxlY3RvciwgJy4nKSkge1xcbiAgICB2YXIgcGFydHMgPSBzZWxlY3Rvci5zcGxpdCgnLicpO1xcbiAgICBzY29wZSA9IHBhcnRzWzBdO1xcbiAgICBuYW1lID0gcGFydHMuc2xpY2UoMSkuam9pbignLicpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHtcXG4gICAgaWQ6IG51bGwsXFxuICAgIHNjb3BlOiBzY29wZSxcXG4gICAgbmFtZTogbmFtZSxcXG4gICAgcnVsZTogcnVsZVxcbiAgfTtcXG59O1xcblxcbnZhciBpbmNsdWRlcyA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBpdGVtKSB7XFxuICByZXR1cm4gY29sbGVjdGlvbi5pbmRleE9mKGl0ZW0pICE9PSAtMTtcXG59O1xcblxcbnZhciBpc0VtcHR5QXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7XFxuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpICYmIGFyci5sZW5ndGggPT09IDA7XFxufTtcXG5cXG52YXIgZGVmaW5lTm9uUmVhY3RpdmUgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWx1ZSkge1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxcbiAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgdmFsdWU6IHZhbHVlXFxuICB9KTtcXG59O1xcblxcbi8vIFxcblxcbnZhciBMT0NBTEUgPSAnZW4nO1xcblxcbnZhciBEaWN0aW9uYXJ5ID0gZnVuY3Rpb24gRGljdGlvbmFyeSAoZGljdGlvbmFyeSkge1xcbiAgaWYgKCBkaWN0aW9uYXJ5ID09PSB2b2lkIDAgKSBkaWN0aW9uYXJ5ID0ge307XFxuXFxuICB0aGlzLmNvbnRhaW5lciA9IHt9O1xcbiAgdGhpcy5tZXJnZShkaWN0aW9uYXJ5KTtcXG59O1xcblxcbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGxvY2FsZTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xcblxcbnByb3RvdHlwZUFjY2Vzc29ycy5sb2NhbGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIExPQ0FMRTtcXG59O1xcblxcbnByb3RvdHlwZUFjY2Vzc29ycy5sb2NhbGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICBMT0NBTEUgPSB2YWx1ZSB8fCAnZW4nO1xcbn07XFxuXFxuRGljdGlvbmFyeS5wcm90b3R5cGUuaGFzTG9jYWxlID0gZnVuY3Rpb24gaGFzTG9jYWxlIChsb2NhbGUpIHtcXG4gIHJldHVybiAhIXRoaXMuY29udGFpbmVyW2xvY2FsZV07XFxufTtcXG5cXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5zZXREYXRlRm9ybWF0ID0gZnVuY3Rpb24gc2V0RGF0ZUZvcm1hdCAobG9jYWxlLCBmb3JtYXQpIHtcXG4gIGlmICghdGhpcy5jb250YWluZXJbbG9jYWxlXSkge1xcbiAgICB0aGlzLmNvbnRhaW5lcltsb2NhbGVdID0ge307XFxuICB9XFxuXFxuICB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLmRhdGVGb3JtYXQgPSBmb3JtYXQ7XFxufTtcXG5cXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXREYXRlRm9ybWF0ID0gZnVuY3Rpb24gZ2V0RGF0ZUZvcm1hdCAobG9jYWxlKSB7XFxuICBpZiAoIXRoaXMuY29udGFpbmVyW2xvY2FsZV0gfHwgIXRoaXMuY29udGFpbmVyW2xvY2FsZV0uZGF0ZUZvcm1hdCkge1xcbiAgICByZXR1cm4gbnVsbDtcXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLmRhdGVGb3JtYXQ7XFxufTtcXG5cXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRNZXNzYWdlID0gZnVuY3Rpb24gZ2V0TWVzc2FnZSAobG9jYWxlLCBrZXksIGRhdGEpIHtcXG4gIHZhciBtZXNzYWdlID0gbnVsbDtcXG4gIGlmICghdGhpcy5oYXNNZXNzYWdlKGxvY2FsZSwga2V5KSkge1xcbiAgICBtZXNzYWdlID0gdGhpcy5fZ2V0RGVmYXVsdE1lc3NhZ2UobG9jYWxlKTtcXG4gIH0gZWxzZSB7XFxuICAgIG1lc3NhZ2UgPSB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLm1lc3NhZ2VzW2tleV07XFxuICB9XFxuXFxuICByZXR1cm4gaXNDYWxsYWJsZShtZXNzYWdlKSA/IG1lc3NhZ2UuYXBwbHkodm9pZCAwLCBkYXRhKSA6IG1lc3NhZ2U7XFxufTtcXG5cXG4vKipcXG4gKiBHZXRzIGEgc3BlY2lmaWMgbWVzc2FnZSBmb3IgZmllbGQuIGZhbGxzIGJhY2sgdG8gdGhlIHJ1bGUgbWVzc2FnZS5cXG4gKi9cXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRGaWVsZE1lc3NhZ2UgPSBmdW5jdGlvbiBnZXRGaWVsZE1lc3NhZ2UgKGxvY2FsZSwgZmllbGQsIGtleSwgZGF0YSkge1xcbiAgaWYgKCF0aGlzLmhhc0xvY2FsZShsb2NhbGUpKSB7XFxuICAgIHJldHVybiB0aGlzLmdldE1lc3NhZ2UobG9jYWxlLCBrZXksIGRhdGEpO1xcbiAgfVxcblxcbiAgdmFyIGRpY3QgPSB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLmN1c3RvbSAmJiB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLmN1c3RvbVtmaWVsZF07XFxuICBpZiAoIWRpY3QgfHwgIWRpY3Rba2V5XSkge1xcbiAgICByZXR1cm4gdGhpcy5nZXRNZXNzYWdlKGxvY2FsZSwga2V5LCBkYXRhKTtcXG4gIH1cXG5cXG4gIHZhciBtZXNzYWdlID0gZGljdFtrZXldO1xcbiAgcmV0dXJuIGlzQ2FsbGFibGUobWVzc2FnZSkgPyBtZXNzYWdlLmFwcGx5KHZvaWQgMCwgZGF0YSkgOiBtZXNzYWdlO1xcbn07XFxuXFxuRGljdGlvbmFyeS5wcm90b3R5cGUuX2dldERlZmF1bHRNZXNzYWdlID0gZnVuY3Rpb24gX2dldERlZmF1bHRNZXNzYWdlIChsb2NhbGUpIHtcXG4gIGlmICh0aGlzLmhhc01lc3NhZ2UobG9jYWxlLCAnX2RlZmF1bHQnKSkge1xcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXJbbG9jYWxlXS5tZXNzYWdlcy5fZGVmYXVsdDtcXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzLmNvbnRhaW5lci5lbi5tZXNzYWdlcy5fZGVmYXVsdDtcXG59O1xcblxcbkRpY3Rpb25hcnkucHJvdG90eXBlLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZSAobG9jYWxlLCBrZXksIGZhbGxiYWNrKSB7XFxuICAgIGlmICggZmFsbGJhY2sgPT09IHZvaWQgMCApIGZhbGxiYWNrID0gJyc7XFxuXFxuICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKGxvY2FsZSwga2V5KSkge1xcbiAgICByZXR1cm4gZmFsbGJhY2s7XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcy5jb250YWluZXJbbG9jYWxlXS5hdHRyaWJ1dGVzW2tleV07XFxufTtcXG5cXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5oYXNNZXNzYWdlID0gZnVuY3Rpb24gaGFzTWVzc2FnZSAobG9jYWxlLCBrZXkpIHtcXG4gIHJldHVybiAhISAoXFxuICAgIHRoaXMuaGFzTG9jYWxlKGxvY2FsZSkgJiZcXG4gICAgICAgICAgdGhpcy5jb250YWluZXJbbG9jYWxlXS5tZXNzYWdlcyAmJlxcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLm1lc3NhZ2VzW2tleV1cXG4gICk7XFxufTtcXG5cXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5oYXNBdHRyaWJ1dGUgPSBmdW5jdGlvbiBoYXNBdHRyaWJ1dGUgKGxvY2FsZSwga2V5KSB7XFxuICByZXR1cm4gISEgKFxcbiAgICB0aGlzLmhhc0xvY2FsZShsb2NhbGUpICYmXFxuICAgICAgICAgIHRoaXMuY29udGFpbmVyW2xvY2FsZV0uYXR0cmlidXRlcyAmJlxcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLmF0dHJpYnV0ZXNba2V5XVxcbiAgKTtcXG59O1xcblxcbkRpY3Rpb25hcnkucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gbWVyZ2UkMSAoZGljdGlvbmFyeSkge1xcbiAgbWVyZ2UodGhpcy5jb250YWluZXIsIGRpY3Rpb25hcnkpO1xcbn07XFxuXFxuRGljdGlvbmFyeS5wcm90b3R5cGUuc2V0TWVzc2FnZSA9IGZ1bmN0aW9uIHNldE1lc3NhZ2UgKGxvY2FsZSwga2V5LCBtZXNzYWdlKSB7XFxuICBpZiAoISB0aGlzLmhhc0xvY2FsZShsb2NhbGUpKSB7XFxuICAgIHRoaXMuY29udGFpbmVyW2xvY2FsZV0gPSB7XFxuICAgICAgbWVzc2FnZXM6IHt9LFxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9XFxuICAgIH07XFxuICB9XFxuICAgIFxcbiAgaWYgKCF0aGlzLmNvbnRhaW5lcltsb2NhbGVdLm1lc3NhZ2VzKSB7XFxuICAgIHRoaXMuY29udGFpbmVyW2xvY2FsZV0ubWVzc2FnZXMgPSB7fTtcXG4gIH1cXG5cXG4gIHRoaXMuY29udGFpbmVyW2xvY2FsZV0ubWVzc2FnZXNba2V5XSA9IG1lc3NhZ2U7XFxufTtcXG5cXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKGxvY2FsZSwga2V5LCBhdHRyaWJ1dGUpIHtcXG4gIGlmICghIHRoaXMuaGFzTG9jYWxlKGxvY2FsZSkpIHtcXG4gICAgdGhpcy5jb250YWluZXJbbG9jYWxlXSA9IHtcXG4gICAgICBtZXNzYWdlczoge30sXFxuICAgICAgYXR0cmlidXRlczoge31cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHRoaXMuY29udGFpbmVyW2xvY2FsZV0uYXR0cmlidXRlc1trZXldID0gYXR0cmlidXRlO1xcbn07XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIERpY3Rpb25hcnkucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcXG5cXG52YXIgZHJpdmVycyA9IHtcXG4gIGRlZmF1bHQ6IG5ldyBEaWN0aW9uYXJ5KHtcXG4gICAgZW46IHtcXG4gICAgICBtZXNzYWdlczoge30sXFxuICAgICAgYXR0cmlidXRlczoge30sXFxuICAgICAgY3VzdG9tOiB7fVxcbiAgICB9XFxuICB9KVxcbn07XFxuXFxudmFyIGN1cnJlbnREcml2ZXIgPSAnZGVmYXVsdCc7XFxuXFxudmFyIERpY3Rpb25hcnlSZXNvbHZlciA9IGZ1bmN0aW9uIERpY3Rpb25hcnlSZXNvbHZlciAoKSB7fTtcXG5cXG5EaWN0aW9uYXJ5UmVzb2x2ZXIuX2NoZWNrRHJpdmVyTmFtZSA9IGZ1bmN0aW9uIF9jaGVja0RyaXZlck5hbWUgKGRyaXZlcikge1xcbiAgaWYgKCFkcml2ZXIpIHtcXG4gICAgdGhyb3cgY3JlYXRlRXJyb3IoJ3lvdSBtdXN0IHByb3ZpZGUgYSBuYW1lIHRvIHRoZSBkaWN0aW9uYXJ5IGRyaXZlcicpO1xcbiAgfVxcbn07XFxuXFxuRGljdGlvbmFyeVJlc29sdmVyLnNldERyaXZlciA9IGZ1bmN0aW9uIHNldERyaXZlciAoZHJpdmVyLCBpbXBsZW1lbnRhdGlvbikge1xcbiAgICBpZiAoIGltcGxlbWVudGF0aW9uID09PSB2b2lkIDAgKSBpbXBsZW1lbnRhdGlvbiA9IG51bGw7XFxuXFxuICB0aGlzLl9jaGVja0RyaXZlck5hbWUoZHJpdmVyKTtcXG4gIGlmIChpbXBsZW1lbnRhdGlvbikge1xcbiAgICBkcml2ZXJzW2RyaXZlcl0gPSBpbXBsZW1lbnRhdGlvbjtcXG4gIH1cXG5cXG4gIGN1cnJlbnREcml2ZXIgPSBkcml2ZXI7XFxufTtcXG5cXG5EaWN0aW9uYXJ5UmVzb2x2ZXIuZ2V0RHJpdmVyID0gZnVuY3Rpb24gZ2V0RHJpdmVyICgpIHtcXG4gIHJldHVybiBkcml2ZXJzW2N1cnJlbnREcml2ZXJdO1xcbn07XFxuXFxuLy8gXFxuXFxudmFyIEVycm9yQmFnID0gZnVuY3Rpb24gRXJyb3JCYWcgKGVycm9yQmFnLCBpZCkge1xcbiAgaWYgKCBlcnJvckJhZyA9PT0gdm9pZCAwICkgZXJyb3JCYWcgPSBudWxsO1xcbiAgaWYgKCBpZCA9PT0gdm9pZCAwICkgaWQgPSBudWxsO1xcblxcbiAgdGhpcy52bUlkID0gaWQgfHwgbnVsbDtcXG4gIC8vIG1ha2UgdGhpcyBiYWcgYSBtaXJyb3Igb2YgdGhlIHByb3ZpZGVkIG9uZSwgc2hhcmluZyB0aGUgc2FtZSBpdGVtcyByZWZlcmVuY2UuXFxuICBpZiAoZXJyb3JCYWcgJiYgZXJyb3JCYWcgaW5zdGFuY2VvZiBFcnJvckJhZykge1xcbiAgICB0aGlzLml0ZW1zID0gZXJyb3JCYWcuaXRlbXM7XFxuICB9IGVsc2Uge1xcbiAgICB0aGlzLml0ZW1zID0gW107XFxuICB9XFxufTtcXG5cXG5FcnJvckJhZy5wcm90b3R5cGVbdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyA/IFN5bWJvbC5pdGVyYXRvciA6ICdAQGl0ZXJhdG9yJ10gPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgdmFyIGluZGV4ID0gMDtcXG4gIHJldHVybiB7XFxuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4geyB2YWx1ZTogdGhpcyQxLml0ZW1zW2luZGV4KytdLCBkb25lOiBpbmRleCA+IHRoaXMkMS5pdGVtcy5sZW5ndGggfTtcXG4gICAgfVxcbiAgfTtcXG59O1xcblxcbi8qKlxcbiAqIEFkZHMgYW4gZXJyb3IgdG8gdGhlIGludGVybmFsIGFycmF5LlxcbiAqL1xcbkVycm9yQmFnLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGVycm9yKSB7XFxuICAgIHZhciByZWY7XFxuXFxuICAocmVmID0gdGhpcy5pdGVtcykucHVzaC5hcHBseShcXG4gICAgcmVmLCB0aGlzLl9ub3JtYWxpemVFcnJvcihlcnJvcilcXG4gICk7XFxufTtcXG5cXG4vKipcXG4gKiBOb3JtYWxpemVzIHBhc3NlZCBlcnJvcnMgdG8gYW4gZXJyb3IgYXJyYXkuXFxuICovXFxuRXJyb3JCYWcucHJvdG90eXBlLl9ub3JtYWxpemVFcnJvciA9IGZ1bmN0aW9uIF9ub3JtYWxpemVFcnJvciAoZXJyb3IpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICBpZiAoQXJyYXkuaXNBcnJheShlcnJvcikpIHtcXG4gICAgcmV0dXJuIGVycm9yLm1hcChmdW5jdGlvbiAoZSkge1xcbiAgICAgIGUuc2NvcGUgPSAhaXNOdWxsT3JVbmRlZmluZWQoZS5zY29wZSkgPyBlLnNjb3BlIDogbnVsbDtcXG4gICAgICBlLnZtSWQgPSAhaXNOdWxsT3JVbmRlZmluZWQoZS52bUlkKSA/IGUudm1JZCA6ICh0aGlzJDEudm1JZCB8fCBudWxsKTtcXG5cXG4gICAgICByZXR1cm4gZTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBlcnJvci5zY29wZSA9ICFpc051bGxPclVuZGVmaW5lZChlcnJvci5zY29wZSkgPyBlcnJvci5zY29wZSA6IG51bGw7XFxuICBlcnJvci52bUlkID0gIWlzTnVsbE9yVW5kZWZpbmVkKGVycm9yLnZtSWQpID8gZXJyb3Iudm1JZCA6ICh0aGlzLnZtSWQgfHwgbnVsbCk7XFxuXFxuICByZXR1cm4gW2Vycm9yXTtcXG59O1xcblxcbi8qKlxcbiAqIFJlZ2VucmF0ZXMgZXJyb3IgbWVzc2FnZXMgaWYgdGhleSBoYXZlIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxcbiAqL1xcbkVycm9yQmFnLnByb3RvdHlwZS5yZWdlbmVyYXRlID0gZnVuY3Rpb24gcmVnZW5lcmF0ZSAoKSB7XFxuICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcXG4gICAgaS5tc2cgPSBpc0NhbGxhYmxlKGkucmVnZW5lcmF0ZSkgPyBpLnJlZ2VuZXJhdGUoKSA6IGkubXNnO1xcbiAgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBVcGRhdGVzIGEgZmllbGQgZXJyb3Igd2l0aCB0aGUgbmV3IGZpZWxkIHNjb3BlLlxcbiAqL1xcbkVycm9yQmFnLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKGlkLCBlcnJvcikge1xcbiAgdmFyIGl0ZW0gPSBmaW5kKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLmlkID09PSBpZDsgfSk7XFxuICBpZiAoIWl0ZW0pIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgdmFyIGlkeCA9IHRoaXMuaXRlbXMuaW5kZXhPZihpdGVtKTtcXG4gIHRoaXMuaXRlbXMuc3BsaWNlKGlkeCwgMSk7XFxuICBpdGVtLnNjb3BlID0gZXJyb3Iuc2NvcGU7XFxuICB0aGlzLml0ZW1zLnB1c2goaXRlbSk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXRzIGFsbCBlcnJvciBtZXNzYWdlcyBmcm9tIHRoZSBpbnRlcm5hbCBhcnJheS5cXG4gKi9cXG5FcnJvckJhZy5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gYWxsIChzY29wZSkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIHZhciBmaWx0ZXJGbiA9IGZ1bmN0aW9uIChpdGVtKSB7XFxuICAgIHZhciBtYXRjaGVzU2NvcGUgPSB0cnVlO1xcbiAgICB2YXIgbWF0Y2hlc1ZNID0gdHJ1ZTtcXG4gICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChzY29wZSkpIHtcXG4gICAgICBtYXRjaGVzU2NvcGUgPSBpdGVtLnNjb3BlID09PSBzY29wZTtcXG4gICAgfVxcblxcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHRoaXMkMS52bUlkKSkge1xcbiAgICAgIG1hdGNoZXNWTSA9IGl0ZW0udm1JZCA9PT0gdGhpcyQxLnZtSWQ7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG1hdGNoZXNWTSAmJiBtYXRjaGVzU2NvcGU7XFxuICB9O1xcblxcbiAgcmV0dXJuIHRoaXMuaXRlbXMuZmlsdGVyKGZpbHRlckZuKS5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUubXNnOyB9KTtcXG59O1xcblxcbi8qKlxcbiAqIENoZWNrcyBpZiB0aGVyZSBhcmUgYW55IGVycm9ycyBpbiB0aGUgaW50ZXJuYWwgYXJyYXkuXFxuICovXFxuRXJyb3JCYWcucHJvdG90eXBlLmFueSA9IGZ1bmN0aW9uIGFueSAoc2NvcGUpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB2YXIgZmlsdGVyRm4gPSBmdW5jdGlvbiAoaXRlbSkge1xcbiAgICB2YXIgbWF0Y2hlc1Njb3BlID0gdHJ1ZTtcXG4gICAgdmFyIG1hdGNoZXNWTSA9IHRydWU7XFxuICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoc2NvcGUpKSB7XFxuICAgICAgbWF0Y2hlc1Njb3BlID0gaXRlbS5zY29wZSA9PT0gc2NvcGU7XFxuICAgIH1cXG5cXG4gICAgaWYgKCFpc051bGxPclVuZGVmaW5lZCh0aGlzJDEudm1JZCkpIHtcXG4gICAgICBtYXRjaGVzVk0gPSBpdGVtLnZtSWQgPT09IHRoaXMkMS52bUlkO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBtYXRjaGVzVk0gJiYgbWF0Y2hlc1Njb3BlO1xcbiAgfTtcXG5cXG4gIHJldHVybiAhIXRoaXMuaXRlbXMuZmlsdGVyKGZpbHRlckZuKS5sZW5ndGg7XFxufTtcXG5cXG4vKipcXG4gKiBSZW1vdmVzIGFsbCBpdGVtcyBmcm9tIHRoZSBpbnRlcm5hbCBhcnJheS5cXG4gKi9cXG5FcnJvckJhZy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoc2NvcGUpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB2YXIgbWF0Y2hlc1ZNID0gaXNOdWxsT3JVbmRlZmluZWQodGhpcy52bUlkKSA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0gOiBmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS52bUlkID09PSB0aGlzJDEudm1JZDsgfTtcXG4gIGlmIChpc051bGxPclVuZGVmaW5lZChzY29wZSkpIHtcXG4gICAgc2NvcGUgPSBudWxsO1xcbiAgfVxcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgKytpKSB7XFxuICAgIGlmIChtYXRjaGVzVk0odGhpcy5pdGVtc1tpXSkgJiYgdGhpcy5pdGVtc1tpXS5zY29wZSA9PT0gc2NvcGUpIHtcXG4gICAgICB0aGlzLml0ZW1zLnNwbGljZShpLCAxKTtcXG4gICAgICAtLWk7XFxuICAgIH1cXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIENvbGxlY3RzIGVycm9ycyBpbnRvIGdyb3VwcyBvciBmb3IgYSBzcGVjaWZpYyBmaWVsZC5cXG4gKi9cXG5FcnJvckJhZy5wcm90b3R5cGUuY29sbGVjdCA9IGZ1bmN0aW9uIGNvbGxlY3QgKGZpZWxkLCBzY29wZSwgbWFwKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcbiAgICBpZiAoIG1hcCA9PT0gdm9pZCAwICkgbWFwID0gdHJ1ZTtcXG5cXG4gIHZhciBpc1NpbmdsZUZpZWxkID0gIWlzTnVsbE9yVW5kZWZpbmVkKGZpZWxkKSAmJiAhZmllbGQuaW5jbHVkZXMoJyonKTtcXG4gIHZhciBncm91cEVycm9ycyA9IGZ1bmN0aW9uIChpdGVtcykge1xcbiAgICB2YXIgZXJyb3JzID0gaXRlbXMucmVkdWNlKGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBlcnJvcikge1xcbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQodGhpcyQxLnZtSWQpICYmIGVycm9yLnZtSWQgIT09IHRoaXMkMS52bUlkKSB7XFxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFjb2xsZWN0aW9uW2Vycm9yLmZpZWxkXSkge1xcbiAgICAgICAgY29sbGVjdGlvbltlcnJvci5maWVsZF0gPSBbXTtcXG4gICAgICB9XFxuXFxuICAgICAgY29sbGVjdGlvbltlcnJvci5maWVsZF0ucHVzaChtYXAgPyBlcnJvci5tc2cgOiBlcnJvcik7XFxuXFxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XFxuICAgIH0sIHt9KTtcXG5cXG4gICAgLy8gcmVkdWNlIHRoZSBjb2xsZWN0aW9uIHRvIGJlIGEgc2luZ2xlIGFycmF5LlxcbiAgICBpZiAoaXNTaW5nbGVGaWVsZCkge1xcbiAgICAgIHJldHVybiB2YWx1ZXMoZXJyb3JzKVswXSB8fCBbXTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gZXJyb3JzO1xcbiAgfTtcXG5cXG4gIGlmIChpc051bGxPclVuZGVmaW5lZChmaWVsZCkpIHtcXG4gICAgcmV0dXJuIGdyb3VwRXJyb3JzKHRoaXMuaXRlbXMpO1xcbiAgfVxcblxcbiAgdmFyIHNlbGVjdG9yID0gaXNOdWxsT3JVbmRlZmluZWQoc2NvcGUpID8gU3RyaW5nKGZpZWxkKSA6IChzY29wZSArIFxcXCIuXFxcIiArIGZpZWxkKTtcXG4gIHZhciByZWYgPSB0aGlzLl9tYWtlQ2FuZGlkYXRlRmlsdGVycyhzZWxlY3Rvcik7XFxuICAgIHZhciBpc1ByaW1hcnkgPSByZWYuaXNQcmltYXJ5O1xcbiAgICB2YXIgaXNBbHQgPSByZWYuaXNBbHQ7XFxuXFxuICB2YXIgY29sbGVjdGVkID0gdGhpcy5pdGVtcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcXG4gICAgaWYgKGlzUHJpbWFyeShjdXJyKSkge1xcbiAgICAgIHByZXYucHJpbWFyeS5wdXNoKGN1cnIpO1xcbiAgICB9XFxuXFxuICAgIGlmIChpc0FsdChjdXJyKSkge1xcbiAgICAgIHByZXYuYWx0LnB1c2goY3Vycik7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHByZXY7XFxuICB9LCB7IHByaW1hcnk6IFtdLCBhbHQ6IFtdIH0pO1xcblxcbiAgY29sbGVjdGVkID0gY29sbGVjdGVkLnByaW1hcnkubGVuZ3RoID8gY29sbGVjdGVkLnByaW1hcnkgOiBjb2xsZWN0ZWQuYWx0O1xcblxcbiAgcmV0dXJuIGdyb3VwRXJyb3JzKGNvbGxlY3RlZCk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXRzIHRoZSBpbnRlcm5hbCBhcnJheSBsZW5ndGguXFxuICovXFxuRXJyb3JCYWcucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gY291bnQgKCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIGlmICh0aGlzLnZtSWQpIHtcXG4gICAgcmV0dXJuIHRoaXMuaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnZtSWQgPT09IHRoaXMkMS52bUlkOyB9KS5sZW5ndGg7XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcy5pdGVtcy5sZW5ndGg7XFxufTtcXG5cXG4vKipcXG4gKiBGaW5kcyBhbmQgZmV0Y2hlcyB0aGUgZmlyc3QgZXJyb3IgbWVzc2FnZSBmb3IgdGhlIHNwZWNpZmllZCBmaWVsZCBpZC5cXG4gKi9cXG5FcnJvckJhZy5wcm90b3R5cGUuZmlyc3RCeUlkID0gZnVuY3Rpb24gZmlyc3RCeUlkIChpZCkge1xcbiAgdmFyIGVycm9yID0gZmluZCh0aGlzLml0ZW1zLCBmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS5pZCA9PT0gaWQ7IH0pO1xcblxcbiAgcmV0dXJuIGVycm9yID8gZXJyb3IubXNnIDogdW5kZWZpbmVkO1xcbn07XFxuXFxuLyoqXFxuICogR2V0cyB0aGUgZmlyc3QgZXJyb3IgbWVzc2FnZSBmb3IgYSBzcGVjaWZpYyBmaWVsZC5cXG4gKi9cXG5FcnJvckJhZy5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbiBmaXJzdCAoZmllbGQsIHNjb3BlKSB7XFxuICAgIGlmICggc2NvcGUgPT09IHZvaWQgMCApIHNjb3BlID0gbnVsbDtcXG5cXG4gIHZhciBzZWxlY3RvciA9IGlzTnVsbE9yVW5kZWZpbmVkKHNjb3BlKSA/IGZpZWxkIDogKHNjb3BlICsgXFxcIi5cXFwiICsgZmllbGQpO1xcbiAgdmFyIG1hdGNoID0gdGhpcy5fbWF0Y2goc2VsZWN0b3IpO1xcblxcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoLm1zZztcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybnMgdGhlIGZpcnN0IGVycm9yIHJ1bGUgZm9yIHRoZSBzcGVjaWZpZWQgZmllbGRcXG4gKi9cXG5FcnJvckJhZy5wcm90b3R5cGUuZmlyc3RSdWxlID0gZnVuY3Rpb24gZmlyc3RSdWxlIChmaWVsZCwgc2NvcGUpIHtcXG4gIHZhciBlcnJvcnMgPSB0aGlzLmNvbGxlY3QoZmllbGQsIHNjb3BlLCBmYWxzZSk7XFxuXFxuICByZXR1cm4gKGVycm9ycy5sZW5ndGggJiYgZXJyb3JzWzBdLnJ1bGUpIHx8IHVuZGVmaW5lZDtcXG59O1xcblxcbi8qKlxcbiAqIENoZWNrcyBpZiB0aGUgaW50ZXJuYWwgYXJyYXkgaGFzIGF0IGxlYXN0IG9uZSBlcnJvciBmb3IgdGhlIHNwZWNpZmllZCBmaWVsZC5cXG4gKi9cXG5FcnJvckJhZy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChmaWVsZCwgc2NvcGUpIHtcXG4gICAgaWYgKCBzY29wZSA9PT0gdm9pZCAwICkgc2NvcGUgPSBudWxsO1xcblxcbiAgcmV0dXJuICEhdGhpcy5maXJzdChmaWVsZCwgc2NvcGUpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0cyB0aGUgZmlyc3QgZXJyb3IgbWVzc2FnZSBmb3IgYSBzcGVjaWZpYyBmaWVsZCBhbmQgYSBydWxlLlxcbiAqL1xcbkVycm9yQmFnLnByb3RvdHlwZS5maXJzdEJ5UnVsZSA9IGZ1bmN0aW9uIGZpcnN0QnlSdWxlIChuYW1lLCBydWxlLCBzY29wZSkge1xcbiAgICBpZiAoIHNjb3BlID09PSB2b2lkIDAgKSBzY29wZSA9IG51bGw7XFxuXFxuICB2YXIgZXJyb3IgPSB0aGlzLmNvbGxlY3QobmFtZSwgc2NvcGUsIGZhbHNlKS5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUucnVsZSA9PT0gcnVsZTsgfSlbMF07XFxuXFxuICByZXR1cm4gKGVycm9yICYmIGVycm9yLm1zZykgfHwgdW5kZWZpbmVkO1xcbn07XFxuXFxuLyoqXFxuICogR2V0cyB0aGUgZmlyc3QgZXJyb3IgbWVzc2FnZSBmb3IgYSBzcGVjaWZpYyBmaWVsZCB0aGF0IG5vdCBtYXRjaCB0aGUgcnVsZS5cXG4gKi9cXG5FcnJvckJhZy5wcm90b3R5cGUuZmlyc3ROb3QgPSBmdW5jdGlvbiBmaXJzdE5vdCAobmFtZSwgcnVsZSwgc2NvcGUpIHtcXG4gICAgaWYgKCBydWxlID09PSB2b2lkIDAgKSBydWxlID0gJ3JlcXVpcmVkJztcXG4gICAgaWYgKCBzY29wZSA9PT0gdm9pZCAwICkgc2NvcGUgPSBudWxsO1xcblxcbiAgdmFyIGVycm9yID0gdGhpcy5jb2xsZWN0KG5hbWUsIHNjb3BlLCBmYWxzZSkuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnJ1bGUgIT09IHJ1bGU7IH0pWzBdO1xcblxcbiAgcmV0dXJuIChlcnJvciAmJiBlcnJvci5tc2cpIHx8IHVuZGVmaW5lZDtcXG59O1xcblxcbi8qKlxcbiAqIFJlbW92ZXMgZXJyb3JzIGJ5IG1hdGNoaW5nIGFnYWluc3QgdGhlIGlkIG9yIGlkcy5cXG4gKi9cXG5FcnJvckJhZy5wcm90b3R5cGUucmVtb3ZlQnlJZCA9IGZ1bmN0aW9uIHJlbW92ZUJ5SWQgKGlkKSB7XFxuICB2YXIgY29uZGl0aW9uID0gZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uaWQgPT09IGlkOyB9O1xcbiAgaWYgKEFycmF5LmlzQXJyYXkoaWQpKSB7XFxuICAgIGNvbmRpdGlvbiA9IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpZC5pbmRleE9mKGl0ZW0uaWQpICE9PSAtMTsgfTtcXG4gIH1cXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7ICsraSkge1xcbiAgICBpZiAoY29uZGl0aW9uKHRoaXMuaXRlbXNbaV0pKSB7XFxuICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaSwgMSk7XFxuICAgICAgLS1pO1xcbiAgICB9XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBSZW1vdmVzIGFsbCBlcnJvciBtZXNzYWdlcyBhc3NvY2lhdGVkIHdpdGggYSBzcGVjaWZpYyBmaWVsZC5cXG4gKi9cXG5FcnJvckJhZy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChmaWVsZCwgc2NvcGUsIHZtSWQpIHtcXG4gIGlmIChpc051bGxPclVuZGVmaW5lZChmaWVsZCkpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgdmFyIHNlbGVjdG9yID0gaXNOdWxsT3JVbmRlZmluZWQoc2NvcGUpID8gU3RyaW5nKGZpZWxkKSA6IChzY29wZSArIFxcXCIuXFxcIiArIGZpZWxkKTtcXG4gIHZhciByZWYgPSB0aGlzLl9tYWtlQ2FuZGlkYXRlRmlsdGVycyhzZWxlY3Rvcik7XFxuICAgIHZhciBpc1ByaW1hcnkgPSByZWYuaXNQcmltYXJ5O1xcbiAgICB2YXIgaXNBbHQgPSByZWYuaXNBbHQ7XFxuICB2YXIgbWF0Y2hlcyA9IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpc1ByaW1hcnkoaXRlbSkgfHwgaXNBbHQoaXRlbSk7IH07XFxuICB2YXIgc2hvdWxkUmVtb3ZlID0gZnVuY3Rpb24gKGl0ZW0pIHtcXG4gICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHZtSWQpKSB7IHJldHVybiBtYXRjaGVzKGl0ZW0pOyB9XFxuXFxuICAgIHJldHVybiBtYXRjaGVzKGl0ZW0pICYmIGl0ZW0udm1JZCA9PT0gdm1JZDtcXG4gIH07XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyArK2kpIHtcXG4gICAgaWYgKHNob3VsZFJlbW92ZSh0aGlzLml0ZW1zW2ldKSkge1xcbiAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGksIDEpO1xcbiAgICAgIC0taTtcXG4gICAgfVxcbiAgfVxcbn07XFxuXFxuRXJyb3JCYWcucHJvdG90eXBlLl9tYWtlQ2FuZGlkYXRlRmlsdGVycyA9IGZ1bmN0aW9uIF9tYWtlQ2FuZGlkYXRlRmlsdGVycyAoc2VsZWN0b3IpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB2YXIgbWF0Y2hlc1J1bGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xcbiAgdmFyIG1hdGNoZXNTY29wZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XFxuICB2YXIgbWF0Y2hlc05hbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xcbiAgdmFyIG1hdGNoZXNWTSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XFxuXFxuICB2YXIgcmVmID0gcGFyc2VTZWxlY3RvcihzZWxlY3Rvcik7XFxuICAgIHZhciBpZCA9IHJlZi5pZDtcXG4gICAgdmFyIHJ1bGUgPSByZWYucnVsZTtcXG4gICAgdmFyIHNjb3BlID0gcmVmLnNjb3BlO1xcbiAgICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xcblxcbiAgaWYgKHJ1bGUpIHtcXG4gICAgbWF0Y2hlc1J1bGUgPSBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5ydWxlID09PSBydWxlOyB9O1xcbiAgfVxcblxcbiAgLy8gbWF0Y2ggYnkgaWQsIGNhbiBiZSBjb21iaW5lZCB3aXRoIHJ1bGUgc2VsZWN0aW9uLlxcbiAgaWYgKGlkKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgaXNQcmltYXJ5OiBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gbWF0Y2hlc1J1bGUoaXRlbSkgJiYgKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpZCA9PT0gaXRlbS5pZDsgfSk7IH0sXFxuICAgICAgaXNBbHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9XFxuICAgIH07XFxuICB9XFxuXFxuICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoc2NvcGUpKSB7XFxuICAgIC8vIGlmIG5vIHNjb3BlIHNwZWNpZmllZCwgbWFrZSBzdXJlIHRoZSBmb3VuZCBlcnJvciBoYXMgbm8gc2NvcGUuXFxuICAgIG1hdGNoZXNTY29wZSA9IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpc051bGxPclVuZGVmaW5lZChpdGVtLnNjb3BlKTsgfTtcXG4gIH0gZWxzZSB7XFxuICAgIG1hdGNoZXNTY29wZSA9IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLnNjb3BlID09PSBzY29wZTsgfTtcXG4gIH1cXG5cXG4gIGlmICghaXNOdWxsT3JVbmRlZmluZWQobmFtZSkgJiYgbmFtZSAhPT0gJyonKSB7XFxuICAgIG1hdGNoZXNOYW1lID0gZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uZmllbGQgPT09IG5hbWU7IH07XFxuICB9XFxuXFxuICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHRoaXMudm1JZCkpIHtcXG4gICAgbWF0Y2hlc1ZNID0gZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0udm1JZCA9PT0gdGhpcyQxLnZtSWQ7IH07XFxuICB9XFxuXFxuICAvLyBtYXRjaGVzIHRoZSBmaXJzdCBjYW5kaWRhdGUuXFxuICB2YXIgaXNQcmltYXJ5ID0gZnVuY3Rpb24gKGl0ZW0pIHtcXG4gICAgcmV0dXJuIG1hdGNoZXNWTShpdGVtKSAmJiBtYXRjaGVzTmFtZShpdGVtKSAmJiBtYXRjaGVzUnVsZShpdGVtKSAmJiBtYXRjaGVzU2NvcGUoaXRlbSk7XFxuICB9O1xcblxcbiAgLy8gbWF0Y2hlcyBhIHNlY29uZCBjYW5kaWRhdGUsIHdoaWNoIGlzIGEgZmllbGQgd2l0aCBhIG5hbWUgY29udGFpbmluZyB0aGUgJy4nIGNoYXJhY3Rlci5cXG4gIHZhciBpc0FsdCA9IGZ1bmN0aW9uIChpdGVtKSB7XFxuICAgIHJldHVybiBtYXRjaGVzVk0oaXRlbSkgJiYgbWF0Y2hlc1J1bGUoaXRlbSkgJiYgaXRlbS5maWVsZCA9PT0gKHNjb3BlICsgXFxcIi5cXFwiICsgbmFtZSk7XFxuICB9O1xcblxcbiAgcmV0dXJuIHtcXG4gICAgaXNQcmltYXJ5OiBpc1ByaW1hcnksXFxuICAgIGlzQWx0OiBpc0FsdFxcbiAgfTtcXG59O1xcblxcbkVycm9yQmFnLnByb3RvdHlwZS5fbWF0Y2ggPSBmdW5jdGlvbiBfbWF0Y2ggKHNlbGVjdG9yKSB7XFxuICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoc2VsZWN0b3IpKSB7XFxuICAgIHJldHVybiB1bmRlZmluZWQ7XFxuICB9XFxuXFxuICB2YXIgcmVmID0gdGhpcy5fbWFrZUNhbmRpZGF0ZUZpbHRlcnMoc2VsZWN0b3IpO1xcbiAgICB2YXIgaXNQcmltYXJ5ID0gcmVmLmlzUHJpbWFyeTtcXG4gICAgdmFyIGlzQWx0ID0gcmVmLmlzQWx0O1xcblxcbiAgcmV0dXJuIHRoaXMuaXRlbXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBpdGVtLCBpZHgsIGFycikge1xcbiAgICB2YXIgaXNMYXN0ID0gaWR4ID09PSBhcnIubGVuZ3RoIC0gMTtcXG4gICAgaWYgKHByZXYucHJpbWFyeSkge1xcbiAgICAgIHJldHVybiBpc0xhc3QgPyBwcmV2LnByaW1hcnkgOiBwcmV2O1xcbiAgICB9XFxuXFxuICAgIGlmIChpc1ByaW1hcnkoaXRlbSkpIHtcXG4gICAgICBwcmV2LnByaW1hcnkgPSBpdGVtO1xcbiAgICB9XFxuXFxuICAgIGlmIChpc0FsdChpdGVtKSkge1xcbiAgICAgIHByZXYuYWx0ID0gaXRlbTtcXG4gICAgfVxcblxcbiAgICAvLyBrZWVwIGdvaW5nLlxcbiAgICBpZiAoIWlzTGFzdCkge1xcbiAgICAgIHJldHVybiBwcmV2O1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBwcmV2LnByaW1hcnkgfHwgcHJldi5hbHQ7XFxuICB9LCB7fSk7XFxufTtcXG5cXG52YXIgREVGQVVMVF9DT05GSUcgPSB7XFxuICBsb2NhbGU6ICdlbicsXFxuICBkZWxheTogMCxcXG4gIGVycm9yQmFnTmFtZTogJ2Vycm9ycycsXFxuICBkaWN0aW9uYXJ5OiBudWxsLFxcbiAgZmllbGRzQmFnTmFtZTogJ2ZpZWxkcycsXFxuICBjbGFzc2VzOiBmYWxzZSxcXG4gIGNsYXNzTmFtZXM6IG51bGwsXFxuICBldmVudHM6ICdpbnB1dCcsXFxuICBpbmplY3Q6IHRydWUsXFxuICBmYXN0RXhpdDogdHJ1ZSxcXG4gIGFyaWE6IHRydWUsXFxuICB2YWxpZGl0eTogZmFsc2UsXFxuICBtb2RlOiAnYWdncmVzc2l2ZScsXFxuICB1c2VDb25zdHJhaW50QXR0cnM6IHRydWUsXFxuICBpMThuOiBudWxsLFxcbiAgaTE4blJvb3RLZXk6ICd2YWxpZGF0aW9uJ1xcbn07XFxuXFxudmFyIGN1cnJlbnRDb25maWcgPSBhc3NpZ24oe30sIERFRkFVTFRfQ09ORklHKTtcXG5cXG52YXIgcmVzb2x2ZUNvbmZpZyA9IGZ1bmN0aW9uIChjdHgpIHtcXG4gIHZhciBzZWxmQ29uZmlnID0gZ2V0UGF0aCgnJG9wdGlvbnMuJF92ZWVWYWxpZGF0ZScsIGN0eCwge30pO1xcblxcbiAgcmV0dXJuIGFzc2lnbih7fSwgY3VycmVudENvbmZpZywgc2VsZkNvbmZpZyk7XFxufTtcXG5cXG52YXIgZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY3VycmVudENvbmZpZzsgfTtcXG5cXG52YXIgc2V0Q29uZmlnID0gZnVuY3Rpb24gKG5ld0NvbmYpIHtcXG4gIGN1cnJlbnRDb25maWcgPSBhc3NpZ24oe30sIGN1cnJlbnRDb25maWcsIG5ld0NvbmYpO1xcbn07XFxuXFxuLy8gVk5vZGUgVXRpbHNcXG5cXG4vLyBHZXRzIHRoZSBtb2RlbCBvYmplY3Qgb24gdGhlIHZub2RlLlxcbmZ1bmN0aW9uIGZpbmRNb2RlbCAodm5vZGUpIHtcXG4gIGlmICghdm5vZGUuZGF0YSkge1xcbiAgICByZXR1cm4gbnVsbDtcXG4gIH1cXG5cXG4gIC8vIENvbXBvbmVudCBNb2RlbFxcbiAgaWYgKHZub2RlLmRhdGEubW9kZWwpIHtcXG4gICAgcmV0dXJuIHZub2RlLmRhdGEubW9kZWw7XFxuICB9XFxuXFxuICByZXR1cm4gISEodm5vZGUuZGF0YS5kaXJlY3RpdmVzKSAmJiBmaW5kKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gJ21vZGVsJzsgfSk7XFxufVxcblxcbmZ1bmN0aW9uIGV4dHJhY3RDaGlsZHJlbiAodm5vZGUpIHtcXG4gIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xcbiAgICByZXR1cm4gdm5vZGU7XFxuICB9XFxuXFxuICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZS5jaGlsZHJlbikpIHtcXG4gICAgcmV0dXJuIHZub2RlLmNoaWxkcmVuO1xcbiAgfVxcblxcbiAgaWYgKHZub2RlLmNvbXBvbmVudE9wdGlvbnMgJiYgQXJyYXkuaXNBcnJheSh2bm9kZS5jb21wb25lbnRPcHRpb25zLmNoaWxkcmVuKSkge1xcbiAgICByZXR1cm4gdm5vZGUuY29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcXG4gIH1cXG5cXG4gIHJldHVybiBbXTtcXG59XFxuXFxuZnVuY3Rpb24gZXh0cmFjdFZOb2RlcyAodm5vZGUpIHtcXG4gIGlmIChmaW5kTW9kZWwodm5vZGUpKSB7XFxuICAgIHJldHVybiBbdm5vZGVdO1xcbiAgfVxcblxcbiAgdmFyIGNoaWxkcmVuID0gZXh0cmFjdENoaWxkcmVuKHZub2RlKTtcXG5cXG4gIHJldHVybiBjaGlsZHJlbi5yZWR1Y2UoZnVuY3Rpb24gKG5vZGVzLCBub2RlKSB7XFxuICAgIHZhciBjYW5kaWRhdGVzID0gZXh0cmFjdFZOb2Rlcyhub2RlKTtcXG4gICAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoKSB7XFxuICAgICAgbm9kZXMucHVzaC5hcHBseShub2RlcywgY2FuZGlkYXRlcyk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG5vZGVzO1xcbiAgfSwgW10pO1xcbn1cXG5cXG4vLyBSZXNvbHZlcyB2LW1vZGVsIGNvbmZpZyBpZiBleGlzdHMuXFxuZnVuY3Rpb24gZmluZE1vZGVsQ29uZmlnICh2bm9kZSkge1xcbiAgaWYgKCF2bm9kZS5jb21wb25lbnRPcHRpb25zKSB7IHJldHVybiBudWxsOyB9XFxuXFxuICByZXR1cm4gdm5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yLm9wdGlvbnMubW9kZWw7XFxufVxcbi8vIEFkZHMgYSBsaXN0ZW5lciB0byB2bm9kZSBsaXN0ZW5lciBvYmplY3QuXFxuZnVuY3Rpb24gbWVyZ2VWTm9kZUxpc3RlbmVycyAob2JqLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcXG4gIC8vIEhhcyBhIHNpbmdsZSBsaXN0ZW5lci5cXG4gIGlmIChpc0NhbGxhYmxlKG9ialtldmVudE5hbWVdKSkge1xcbiAgICB2YXIgcHJldkhhbmRsZXIgPSBvYmpbZXZlbnROYW1lXTtcXG4gICAgb2JqW2V2ZW50TmFtZV0gPSBbcHJldkhhbmRsZXJdO1xcbiAgfVxcblxcbiAgLy8gaGFzIG90aGVyIGxpc3RlbmVycy5cXG4gIGlmIChBcnJheS5pc0FycmF5KG9ialtldmVudE5hbWVdKSkge1xcbiAgICBvYmpbZXZlbnROYW1lXS5wdXNoKGhhbmRsZXIpO1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICAvLyBubyBsaXN0ZW5lciBhdCBhbGwuXFxuICBpZiAoaXNOdWxsT3JVbmRlZmluZWQob2JqW2V2ZW50TmFtZV0pKSB7XFxuICAgIG9ialtldmVudE5hbWVdID0gW2hhbmRsZXJdO1xcbiAgfVxcbn1cXG5cXG4vLyBBZGRzIGEgbGlzdGVuZXIgdG8gYSBuYXRpdmUgSFRNTCB2bm9kZS5cXG5mdW5jdGlvbiBhZGROYXRpdmVOb2RlTGlzdGVuZXIgKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xcbiAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKG5vZGUuZGF0YS5vbikpIHtcXG4gICAgbm9kZS5kYXRhLm9uID0ge307XFxuICB9XFxuXFxuICBtZXJnZVZOb2RlTGlzdGVuZXJzKG5vZGUuZGF0YS5vbiwgZXZlbnROYW1lLCBoYW5kbGVyKTtcXG59XFxuXFxuLy8gQWRkcyBhIGxpc3RlbmVyIHRvIGEgVnVlIGNvbXBvbmVudCB2bm9kZS5cXG5mdW5jdGlvbiBhZGRDb21wb25lbnROb2RlTGlzdGVuZXIgKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cXG4gIGlmICghbm9kZS5jb21wb25lbnRPcHRpb25zLmxpc3RlbmVycykge1xcbiAgICBub2RlLmNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzID0ge307XFxuICB9XFxuXFxuICBtZXJnZVZOb2RlTGlzdGVuZXJzKG5vZGUuY29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnMsIGV2ZW50TmFtZSwgaGFuZGxlcik7XFxufVxcbmZ1bmN0aW9uIGFkZFZOb2RlTGlzdGVuZXIgKHZub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcXG4gIGlmICh2bm9kZS5jb21wb25lbnRPcHRpb25zKSB7XFxuICAgIGFkZENvbXBvbmVudE5vZGVMaXN0ZW5lcih2bm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgYWRkTmF0aXZlTm9kZUxpc3RlbmVyKHZub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xcbn1cXG4vLyBEZXRlcm1pbmVzIGlmIGBjaGFuZ2VgIHNob3VsZCBiZSB1c2VkIG92ZXIgYGlucHV0YCBmb3IgbGlzdGVuZXJzLlxcbmZ1bmN0aW9uIGdldElucHV0RXZlbnROYW1lICh2bm9kZSwgbW9kZWwpIHtcXG4gIC8vIElzIGEgY29tcG9uZW50LlxcbiAgaWYgKHZub2RlLmNvbXBvbmVudE9wdGlvbnMpIHtcXG4gICAgdmFyIHJlZiA9IGZpbmRNb2RlbENvbmZpZyh2bm9kZSkgfHwgeyBldmVudDogJ2lucHV0JyB9O1xcbiAgICB2YXIgZXZlbnQgPSByZWYuZXZlbnQ7XFxuXFxuICAgIHJldHVybiBldmVudDtcXG4gIH1cXG5cXG4gIC8vIExhenkgTW9kZWxzIGFuZCBzZWxlY3QgdGFnIHR5cGljYWxseSB1c2UgY2hhbmdlIGV2ZW50XFxuICBpZiAoKG1vZGVsICYmIG1vZGVsLm1vZGlmaWVycyAmJiBtb2RlbC5tb2RpZmllcnMubGF6eSkgfHwgdm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xcbiAgICByZXR1cm4gJ2NoYW5nZSc7XFxuICB9XFxuXFxuICAvLyBpcyBhIHRleHR1YWwtdHlwZSBpbnB1dC5cXG4gIGlmICh2bm9kZS5kYXRhLmF0dHJzICYmIGlzVGV4dElucHV0KHsgdHlwZTogdm5vZGUuZGF0YS5hdHRycy50eXBlIHx8ICd0ZXh0JyB9KSkge1xcbiAgICByZXR1cm4gJ2lucHV0JztcXG4gIH1cXG5cXG4gIHJldHVybiAnY2hhbmdlJztcXG59XFxuXFxuZnVuY3Rpb24gbm9ybWFsaXplU2xvdHMgKHNsb3RzLCBjdHgpIHtcXG4gIHJldHVybiBPYmplY3Qua2V5cyhzbG90cykucmVkdWNlKGZ1bmN0aW9uIChhcnIsIGtleSkge1xcbiAgICBzbG90c1trZXldLmZvckVhY2goZnVuY3Rpb24gKHZub2RlKSB7XFxuICAgICAgaWYgKCF2bm9kZS5jb250ZXh0KSB7XFxuICAgICAgICBzbG90c1trZXldLmNvbnRleHQgPSBjdHg7XFxuICAgICAgICBpZiAoIXZub2RlLmRhdGEpIHtcXG4gICAgICAgICAgdm5vZGUuZGF0YSA9IHt9O1xcbiAgICAgICAgfVxcbiAgICAgICAgdm5vZGUuZGF0YS5zbG90ID0ga2V5O1xcbiAgICAgIH1cXG4gICAgfSk7XFxuXFxuICAgIHJldHVybiBhcnIuY29uY2F0KHNsb3RzW2tleV0pO1xcbiAgfSwgW10pO1xcbn1cXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJsZXNzIChoLCBjaGlsZHJlbikge1xcbiAgLy8gT25seSByZW5kZXIgdGhlIGZpcnN0IGl0ZW0gb2YgdGhlIG5vZGUuXFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiYgY2hpbGRyZW5bMF0pIHtcXG4gICAgcmV0dXJuIGNoaWxkcmVuWzBdO1xcbiAgfVxcblxcbiAgLy8gYSBzaW5nbGUgbm9kZS5cXG4gIGlmIChjaGlsZHJlbikge1xcbiAgICByZXR1cm4gY2hpbGRyZW47XFxuICB9XFxuXFxuICAvLyBObyBzbG90cywgcmVuZGVyIG5vdGhpbmcuXFxuICByZXR1cm4gaCgpO1xcbn1cXG5cXG4vKipcXG4gKiBHZW5lcmF0ZXMgdGhlIG9wdGlvbnMgcmVxdWlyZWQgdG8gY29uc3RydWN0IGEgZmllbGQuXFxuICovXFxudmFyIFJlc29sdmVyID0gZnVuY3Rpb24gUmVzb2x2ZXIgKCkge307XFxuXFxuUmVzb2x2ZXIuZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZSAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XFxuICB2YXIgbW9kZWwgPSBSZXNvbHZlci5yZXNvbHZlTW9kZWwoYmluZGluZywgdm5vZGUpO1xcbiAgdmFyIG9wdGlvbnMgPSByZXNvbHZlQ29uZmlnKHZub2RlLmNvbnRleHQpO1xcblxcbiAgcmV0dXJuIHtcXG4gICAgbmFtZTogUmVzb2x2ZXIucmVzb2x2ZU5hbWUoZWwsIHZub2RlKSxcXG4gICAgZWw6IGVsLFxcbiAgICBsaXN0ZW46ICFiaW5kaW5nLm1vZGlmaWVycy5kaXNhYmxlLFxcbiAgICBiYWlsczogYmluZGluZy5tb2RpZmllcnMuYmFpbHMgPyB0cnVlIDogKGJpbmRpbmcubW9kaWZpZXJzLmNvbnRpbnVlcyA9PT0gdHJ1ZSA/IGZhbHNlIDogdW5kZWZpbmVkKSxcXG4gICAgc2NvcGU6IFJlc29sdmVyLnJlc29sdmVTY29wZShlbCwgYmluZGluZywgdm5vZGUpLFxcbiAgICB2bTogdm5vZGUuY29udGV4dCxcXG4gICAgZXhwcmVzc2lvbjogYmluZGluZy52YWx1ZSxcXG4gICAgY29tcG9uZW50OiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSxcXG4gICAgY2xhc3Nlczogb3B0aW9ucy5jbGFzc2VzLFxcbiAgICBjbGFzc05hbWVzOiBvcHRpb25zLmNsYXNzTmFtZXMsXFxuICAgIGdldHRlcjogUmVzb2x2ZXIucmVzb2x2ZUdldHRlcihlbCwgdm5vZGUsIG1vZGVsKSxcXG4gICAgZXZlbnRzOiBSZXNvbHZlci5yZXNvbHZlRXZlbnRzKGVsLCB2bm9kZSkgfHwgb3B0aW9ucy5ldmVudHMsXFxuICAgIG1vZGVsOiBtb2RlbCxcXG4gICAgZGVsYXk6IFJlc29sdmVyLnJlc29sdmVEZWxheShlbCwgdm5vZGUsIG9wdGlvbnMpLFxcbiAgICBydWxlczogUmVzb2x2ZXIucmVzb2x2ZVJ1bGVzKGVsLCBiaW5kaW5nLCB2bm9kZSksXFxuICAgIGltbWVkaWF0ZTogISFiaW5kaW5nLm1vZGlmaWVycy5pbml0aWFsIHx8ICEhYmluZGluZy5tb2RpZmllcnMuaW1tZWRpYXRlLFxcbiAgICBwZXJzaXN0OiAhIWJpbmRpbmcubW9kaWZpZXJzLnBlcnNpc3QsXFxuICAgIHZhbGlkaXR5OiBvcHRpb25zLnZhbGlkaXR5ICYmICF2bm9kZS5jb21wb25lbnRJbnN0YW5jZSxcXG4gICAgYXJpYTogb3B0aW9ucy5hcmlhICYmICF2bm9kZS5jb21wb25lbnRJbnN0YW5jZSxcXG4gICAgaW5pdGlhbFZhbHVlOiBSZXNvbHZlci5yZXNvbHZlSW5pdGlhbFZhbHVlKHZub2RlKVxcbiAgfTtcXG59O1xcblxcblJlc29sdmVyLmdldEN0b3JDb25maWcgPSBmdW5jdGlvbiBnZXRDdG9yQ29uZmlnICh2bm9kZSkge1xcbiAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgeyByZXR1cm4gbnVsbDsgfVxcblxcbiAgdmFyIGNvbmZpZyA9IGdldFBhdGgoJ2NvbXBvbmVudEluc3RhbmNlLiRvcHRpb25zLiRfdmVlVmFsaWRhdGUnLCB2bm9kZSk7XFxuXFxuICByZXR1cm4gY29uZmlnO1xcbn07XFxuXFxuLyoqXFxuICogUmVzb2x2ZXMgdGhlIHJ1bGVzIGRlZmluZWQgb24gYW4gZWxlbWVudC5cXG4gKi9cXG5SZXNvbHZlci5yZXNvbHZlUnVsZXMgPSBmdW5jdGlvbiByZXNvbHZlUnVsZXMgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xcbiAgdmFyIHJ1bGVzID0gJyc7XFxuICBpZiAoIWJpbmRpbmcudmFsdWUgJiYgKCFiaW5kaW5nIHx8ICFiaW5kaW5nLmV4cHJlc3Npb24pKSB7XFxuICAgIHJ1bGVzID0gZ2V0RGF0YUF0dHJpYnV0ZShlbCwgJ3J1bGVzJyk7XFxuICB9XFxuXFxuICBpZiAoYmluZGluZy52YWx1ZSAmJiBpbmNsdWRlcyhbJ3N0cmluZycsICdvYmplY3QnXSwgdHlwZW9mIGJpbmRpbmcudmFsdWUucnVsZXMpKSB7XFxuICAgIHJ1bGVzID0gYmluZGluZy52YWx1ZS5ydWxlcztcXG4gIH0gZWxzZSBpZiAoYmluZGluZy52YWx1ZSkge1xcbiAgICBydWxlcyA9IGJpbmRpbmcudmFsdWU7XFxuICB9XFxuXFxuICBpZiAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcXG4gICAgcmV0dXJuIHJ1bGVzO1xcbiAgfVxcblxcbiAgLy8gSWYgdmFsaWRpdHkgaXMgZGlzYWJsZWQsIGlnbm9yZSBmaWVsZCBydWxlcy5cXG4gIHZhciBub3JtYWxpemVkID0gbm9ybWFsaXplUnVsZXMocnVsZXMpO1xcbiAgaWYgKCFnZXRDb25maWcoKS51c2VDb25zdHJhaW50QXR0cnMpIHtcXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XFxuICB9XFxuXFxuICByZXR1cm4gYXNzaWduKHt9LCBmaWxsUnVsZXNGcm9tRWxlbWVudChlbCwge30pLCBub3JtYWxpemVkKTtcXG59O1xcblxcbi8qKlxcbiAqIEBwYXJhbSB7Kn0gdm5vZGVcXG4gKi9cXG5SZXNvbHZlci5yZXNvbHZlSW5pdGlhbFZhbHVlID0gZnVuY3Rpb24gcmVzb2x2ZUluaXRpYWxWYWx1ZSAodm5vZGUpIHtcXG4gIHZhciBtb2RlbCA9IHZub2RlLmRhdGEubW9kZWwgfHwgZmluZCh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdtb2RlbCc7IH0pO1xcblxcbiAgcmV0dXJuIG1vZGVsICYmIG1vZGVsLnZhbHVlO1xcbn07XFxuXFxuLyoqXFxuICogUmVzb2x2ZXMgdGhlIGRlbGF5IHZhbHVlLlxcbiAqIEBwYXJhbSB7Kn0gZWxcXG4gKiBAcGFyYW0geyp9IHZub2RlXFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcXG4gKi9cXG5SZXNvbHZlci5yZXNvbHZlRGVsYXkgPSBmdW5jdGlvbiByZXNvbHZlRGVsYXkgKGVsLCB2bm9kZSwgb3B0aW9ucykge1xcbiAgdmFyIGRlbGF5ID0gZ2V0RGF0YUF0dHJpYnV0ZShlbCwgJ2RlbGF5Jyk7XFxuICB2YXIgZ2xvYmFsRGVsYXkgPSAob3B0aW9ucyAmJiAnZGVsYXknIGluIG9wdGlvbnMpID8gb3B0aW9ucy5kZWxheSA6IDA7XFxuXFxuICBpZiAoIWRlbGF5ICYmIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRhdHRycykge1xcbiAgICBkZWxheSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRhdHRyc1snZGF0YS12di1kZWxheSddO1xcbiAgfVxcblxcbiAgaWYgKCFpc09iamVjdChnbG9iYWxEZWxheSkpIHtcXG4gICAgcmV0dXJuIGRlZXBQYXJzZUludChkZWxheSB8fCBnbG9iYWxEZWxheSk7XFxuICB9XFxuXFxuICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGRlbGF5KSkge1xcbiAgICBnbG9iYWxEZWxheS5pbnB1dCA9IGRlbGF5O1xcbiAgfVxcblxcbiAgcmV0dXJuIGRlZXBQYXJzZUludChnbG9iYWxEZWxheSk7XFxufTtcXG5cXG4vKipcXG4gKiBSZXNvbHZlcyB0aGUgZXZlbnRzIHRvIHZhbGlkYXRlIGluIHJlc3BvbnNlIHRvLlxcbiAqIEBwYXJhbSB7Kn0gZWxcXG4gKiBAcGFyYW0geyp9IHZub2RlXFxuICovXFxuUmVzb2x2ZXIucmVzb2x2ZUV2ZW50cyA9IGZ1bmN0aW9uIHJlc29sdmVFdmVudHMgKGVsLCB2bm9kZSkge1xcbiAgLy8gcmVzb2x2ZSBpdCBmcm9tIHRoZSByb290IGVsZW1lbnQuXFxuICB2YXIgZXZlbnRzID0gZ2V0RGF0YUF0dHJpYnV0ZShlbCwgJ3ZhbGlkYXRlLW9uJyk7XFxuXFxuICAvLyByZXNvbHZlIGZyb20gZGF0YS12di12YWxpZGF0ZS1vbiBpZiBpdHMgYSB2dWUgY29tcG9uZW50LlxcbiAgaWYgKCFldmVudHMgJiYgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGF0dHJzKSB7XFxuICAgIGV2ZW50cyA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRhdHRyc1snZGF0YS12di12YWxpZGF0ZS1vbiddO1xcbiAgfVxcblxcbiAgLy8gcmVzb2x2ZSBpdCBmcm9tICRfdmVlVmFsaWRhdGUgb3B0aW9ucy5cXG4gIGlmICghZXZlbnRzICYmIHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XFxuICAgIHZhciBjb25maWcgPSBSZXNvbHZlci5nZXRDdG9yQ29uZmlnKHZub2RlKTtcXG4gICAgZXZlbnRzID0gY29uZmlnICYmIGNvbmZpZy5ldmVudHM7XFxuICB9XFxuXFxuICBpZiAoIWV2ZW50cyAmJiBnZXRDb25maWcoKS5ldmVudHMpIHtcXG4gICAgZXZlbnRzID0gZ2V0Q29uZmlnKCkuZXZlbnRzO1xcbiAgfVxcblxcbiAgLy8gcmVzb2x2ZSB0aGUgbW9kZWwgZXZlbnQgaWYgaXRzIGNvbmZpZ3VyZWQgZm9yIGN1c3RvbSBjb21wb25lbnRzLlxcbiAgaWYgKGV2ZW50cyAmJiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiBpbmNsdWRlcyhldmVudHMsICdpbnB1dCcpKSB7XFxuICAgIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kb3B0aW9ucy5tb2RlbCB8fCB7IGV2ZW50OiAnaW5wdXQnIH07XFxuICAgICAgdmFyIGV2ZW50ID0gcmVmLmV2ZW50O1xcbiAgICAvLyBpZiB0aGUgcHJvcCB3YXMgY29uZmlndXJlZCBidXQgbm90IHRoZSBtb2RlbC5cXG4gICAgaWYgKCFldmVudCkge1xcbiAgICAgIHJldHVybiBldmVudHM7XFxuICAgIH1cXG5cXG4gICAgZXZlbnRzID0gZXZlbnRzLnJlcGxhY2UoJ2lucHV0JywgZXZlbnQpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGV2ZW50cztcXG59O1xcblxcbi8qKlxcbiAqIFJlc29sdmVzIHRoZSBzY29wZSBmb3IgdGhlIGZpZWxkLlxcbiAqIEBwYXJhbSB7Kn0gZWxcXG4gKiBAcGFyYW0geyp9IGJpbmRpbmdcXG4gKi9cXG5SZXNvbHZlci5yZXNvbHZlU2NvcGUgPSBmdW5jdGlvbiByZXNvbHZlU2NvcGUgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xcbiAgICBpZiAoIHZub2RlID09PSB2b2lkIDAgKSB2bm9kZSA9IHt9O1xcblxcbiAgdmFyIHNjb3BlID0gbnVsbDtcXG4gIGlmICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiBpc051bGxPclVuZGVmaW5lZChzY29wZSkpIHtcXG4gICAgc2NvcGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kYXR0cnMgJiYgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGF0dHJzWydkYXRhLXZ2LXNjb3BlJ107XFxuICB9XFxuXFxuICByZXR1cm4gIWlzTnVsbE9yVW5kZWZpbmVkKHNjb3BlKSA/IHNjb3BlIDogZ2V0U2NvcGUoZWwpO1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIHRoZSBub2RlIGRpcmVjdGl2ZXMgY29udGFpbnMgYSB2LW1vZGVsIG9yIGEgc3BlY2lmaWVkIGFyZy5cXG4gKiBBcmdzIHRha2UgcHJpb3JpdHkgb3ZlciBtb2RlbHMuXFxuICpcXG4gKiBAcmV0dXJuIHtPYmplY3R9XFxuICovXFxuUmVzb2x2ZXIucmVzb2x2ZU1vZGVsID0gZnVuY3Rpb24gcmVzb2x2ZU1vZGVsIChiaW5kaW5nLCB2bm9kZSkge1xcbiAgaWYgKGJpbmRpbmcuYXJnKSB7XFxuICAgIHJldHVybiB7IGV4cHJlc3Npb246IGJpbmRpbmcuYXJnIH07XFxuICB9XFxuXFxuICB2YXIgbW9kZWwgPSBmaW5kTW9kZWwodm5vZGUpO1xcbiAgaWYgKCFtb2RlbCkge1xcbiAgICByZXR1cm4gbnVsbDtcXG4gIH1cXG5cXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvYmxvYi9kZXYvc3JjL2NvcmUvdXRpbC9sYW5nLmpzI0wyNlxcbiAgdmFyIHdhdGNoYWJsZSA9ICEvW15cXFxcdy4kXS8udGVzdChtb2RlbC5leHByZXNzaW9uKSAmJiBoYXNQYXRoKG1vZGVsLmV4cHJlc3Npb24sIHZub2RlLmNvbnRleHQpO1xcbiAgdmFyIGxhenkgPSAhIShtb2RlbC5tb2RpZmllcnMgJiYgbW9kZWwubW9kaWZpZXJzLmxhenkpO1xcblxcbiAgaWYgKCF3YXRjaGFibGUpIHtcXG4gICAgcmV0dXJuIHsgZXhwcmVzc2lvbjogbnVsbCwgbGF6eTogbGF6eSB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIHsgZXhwcmVzc2lvbjogbW9kZWwuZXhwcmVzc2lvbiwgbGF6eTogbGF6eSB9O1xcbn07XFxuXFxuLyoqXFxuICogUmVzb2x2ZXMgdGhlIGZpZWxkIG5hbWUgdG8gdHJpZ2dlciB2YWxpZGF0aW9ucy5cXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBmaWVsZCBuYW1lLlxcbiAqL1xcblJlc29sdmVyLnJlc29sdmVOYW1lID0gZnVuY3Rpb24gcmVzb2x2ZU5hbWUgKGVsLCB2bm9kZSkge1xcbiAgdmFyIG5hbWUgPSBnZXREYXRhQXR0cmlidXRlKGVsLCAnbmFtZScpO1xcblxcbiAgaWYgKCFuYW1lICYmICF2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xcbiAgICByZXR1cm4gZWwubmFtZTtcXG4gIH1cXG5cXG4gIGlmICghbmFtZSAmJiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kYXR0cnMpIHtcXG4gICAgbmFtZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRhdHRyc1snZGF0YS12di1uYW1lJ10gfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGF0dHJzWyduYW1lJ107XFxuICB9XFxuXFxuICBpZiAoIW5hbWUgJiYgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcXG4gICAgdmFyIGNvbmZpZyA9IFJlc29sdmVyLmdldEN0b3JDb25maWcodm5vZGUpO1xcbiAgICBpZiAoY29uZmlnICYmIGlzQ2FsbGFibGUoY29uZmlnLm5hbWUpKSB7XFxuICAgICAgdmFyIGJvdW5kR2V0dGVyID0gY29uZmlnLm5hbWUuYmluZCh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSk7XFxuXFxuICAgICAgcmV0dXJuIGJvdW5kR2V0dGVyKCk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLm5hbWU7XFxuICB9XFxuXFxuICByZXR1cm4gbmFtZTtcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybnMgYSB2YWx1ZSBnZXR0ZXIgaW5wdXQgdHlwZS5cXG4gKi9cXG5SZXNvbHZlci5yZXNvbHZlR2V0dGVyID0gZnVuY3Rpb24gcmVzb2x2ZUdldHRlciAoZWwsIHZub2RlLCBtb2RlbCkge1xcbiAgaWYgKG1vZGVsICYmIG1vZGVsLmV4cHJlc3Npb24pIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gZ2V0UGF0aChtb2RlbC5leHByZXNzaW9uLCB2bm9kZS5jb250ZXh0KTtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIGlmICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xcbiAgICB2YXIgcGF0aCA9IGdldERhdGFBdHRyaWJ1dGUoZWwsICd2YWx1ZS1wYXRoJykgfHwgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRhdHRycyAmJiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kYXR0cnNbJ2RhdGEtdnYtdmFsdWUtcGF0aCddKTtcXG4gICAgaWYgKHBhdGgpIHtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIGdldFBhdGgocGF0aCwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpO1xcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgdmFyIGNvbmZpZyA9IFJlc29sdmVyLmdldEN0b3JDb25maWcodm5vZGUpO1xcbiAgICBpZiAoY29uZmlnICYmIGlzQ2FsbGFibGUoY29uZmlnLnZhbHVlKSkge1xcbiAgICAgIHZhciBib3VuZEdldHRlciA9IGNvbmZpZy52YWx1ZS5iaW5kKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIGJvdW5kR2V0dGVyKCk7XFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJG9wdGlvbnMubW9kZWwgfHwgeyBwcm9wOiAndmFsdWUnIH07XFxuICAgICAgdmFyIHByb3AgPSByZWYucHJvcDtcXG5cXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2VbcHJvcF07XFxuICAgIH07XFxuICB9XFxuXFxuICBzd2l0Y2ggKGVsLnR5cGUpIHtcXG4gIGNhc2UgJ2NoZWNrYm94JzogcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGVscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoKFxcXCJpbnB1dFtuYW1lPVxcXFxcXFwiXFxcIiArIChlbC5uYW1lKSArIFxcXCJcXFxcXFxcIl1cXFwiKSk7XFxuXFxuICAgIGVscyA9IHRvQXJyYXkoZWxzKS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5jaGVja2VkOyB9KTtcXG4gICAgaWYgKCFlbHMubGVuZ3RoKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cXG5cXG4gICAgcmV0dXJuIGVscy5tYXAoZnVuY3Rpb24gKGNoZWNrYm94KSB7IHJldHVybiBjaGVja2JveC52YWx1ZTsgfSk7XFxuICB9O1xcbiAgY2FzZSAncmFkaW8nOiByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgZWxzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgoXFxcImlucHV0W25hbWU9XFxcXFxcXCJcXFwiICsgKGVsLm5hbWUpICsgXFxcIlxcXFxcXFwiXVxcXCIpKTtcXG4gICAgdmFyIGVsbSA9IGZpbmQoZWxzLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmNoZWNrZWQ7IH0pO1xcblxcbiAgICByZXR1cm4gZWxtICYmIGVsbS52YWx1ZTtcXG4gIH07XFxuICBjYXNlICdmaWxlJzogcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XFxuICAgIHJldHVybiB0b0FycmF5KGVsLmZpbGVzKTtcXG4gIH07XFxuICBjYXNlICdzZWxlY3QtbXVsdGlwbGUnOiByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gdG9BcnJheShlbC5vcHRpb25zKS5maWx0ZXIoZnVuY3Rpb24gKG9wdCkgeyByZXR1cm4gb3B0LnNlbGVjdGVkOyB9KS5tYXAoZnVuY3Rpb24gKG9wdCkgeyByZXR1cm4gb3B0LnZhbHVlOyB9KTtcXG4gIH07XFxuICBkZWZhdWx0OiByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gZWwgJiYgZWwudmFsdWU7XFxuICB9O1xcbiAgfVxcbn07XFxuXFxudmFyIFJVTEVTID0ge307XFxuXFxudmFyIFJ1bGVDb250YWluZXIgPSBmdW5jdGlvbiBSdWxlQ29udGFpbmVyICgpIHt9O1xcblxcbnZhciBzdGF0aWNBY2Nlc3NvcnMgPSB7IHJ1bGVzOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XFxuXFxuUnVsZUNvbnRhaW5lci5hZGQgPSBmdW5jdGlvbiBhZGQgKG5hbWUsIHJlZikge1xcbiAgICB2YXIgdmFsaWRhdGUgPSByZWYudmFsaWRhdGU7XFxuICAgIHZhciBvcHRpb25zID0gcmVmLm9wdGlvbnM7XFxuICAgIHZhciBwYXJhbU5hbWVzID0gcmVmLnBhcmFtTmFtZXM7XFxuXFxuICBSVUxFU1tuYW1lXSA9IHtcXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlLFxcbiAgICBvcHRpb25zOiBvcHRpb25zLFxcbiAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzXFxuICB9O1xcbn07XFxuXFxuc3RhdGljQWNjZXNzb3JzLnJ1bGVzLmdldCA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiBSVUxFUztcXG59O1xcblxcblJ1bGVDb250YWluZXIuaGFzID0gZnVuY3Rpb24gaGFzIChuYW1lKSB7XFxuICByZXR1cm4gISFSVUxFU1tuYW1lXTtcXG59O1xcblxcblJ1bGVDb250YWluZXIuaXNJbW1lZGlhdGUgPSBmdW5jdGlvbiBpc0ltbWVkaWF0ZSAobmFtZSkge1xcbiAgcmV0dXJuICEhKFJVTEVTW25hbWVdICYmIFJVTEVTW25hbWVdLm9wdGlvbnMuaW1tZWRpYXRlKTtcXG59O1xcblxcblJ1bGVDb250YWluZXIuaXNSZXF1aXJlUnVsZSA9IGZ1bmN0aW9uIGlzUmVxdWlyZVJ1bGUgKG5hbWUpIHtcXG4gIHJldHVybiAhIShSVUxFU1tuYW1lXSAmJiBSVUxFU1tuYW1lXS5vcHRpb25zLmNvbXB1dGVzUmVxdWlyZWQpO1xcbn07XFxuXFxuUnVsZUNvbnRhaW5lci5pc1RhcmdldFJ1bGUgPSBmdW5jdGlvbiBpc1RhcmdldFJ1bGUgKG5hbWUpIHtcXG4gIHJldHVybiAhIShSVUxFU1tuYW1lXSAmJiBSVUxFU1tuYW1lXS5vcHRpb25zLmhhc1RhcmdldCk7XFxufTtcXG5cXG5SdWxlQ29udGFpbmVyLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAocnVsZU5hbWUpIHtcXG4gIGRlbGV0ZSBSVUxFU1tydWxlTmFtZV07XFxufTtcXG5cXG5SdWxlQ29udGFpbmVyLmdldFBhcmFtTmFtZXMgPSBmdW5jdGlvbiBnZXRQYXJhbU5hbWVzIChydWxlTmFtZSkge1xcbiAgcmV0dXJuIFJVTEVTW3J1bGVOYW1lXSAmJiBSVUxFU1tydWxlTmFtZV0ucGFyYW1OYW1lcztcXG59O1xcblxcblJ1bGVDb250YWluZXIuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uIGdldE9wdGlvbnMgKHJ1bGVOYW1lKSB7XFxuICByZXR1cm4gUlVMRVNbcnVsZU5hbWVdICYmIFJVTEVTW3J1bGVOYW1lXS5vcHRpb25zO1xcbn07XFxuXFxuUnVsZUNvbnRhaW5lci5nZXRWYWxpZGF0b3JNZXRob2QgPSBmdW5jdGlvbiBnZXRWYWxpZGF0b3JNZXRob2QgKHJ1bGVOYW1lKSB7XFxuICByZXR1cm4gUlVMRVNbcnVsZU5hbWVdID8gUlVMRVNbcnVsZU5hbWVdLnZhbGlkYXRlIDogbnVsbDtcXG59O1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBSdWxlQ29udGFpbmVyLCBzdGF0aWNBY2Nlc3NvcnMgKTtcXG5cXG4vLyBcXG5cXG52YXIgaXNFdmVudCA9IGZ1bmN0aW9uIChldnQpIHtcXG4gIHJldHVybiAodHlwZW9mIEV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpc0NhbGxhYmxlKEV2ZW50KSAmJiBldnQgaW5zdGFuY2VvZiBFdmVudCkgfHwgKGV2dCAmJiBldnQuc3JjRWxlbWVudCk7XFxufTtcXG5cXG52YXIgbm9ybWFsaXplRXZlbnRzID0gZnVuY3Rpb24gKGV2dHMpIHtcXG4gIGlmICghZXZ0cykgeyByZXR1cm4gW107IH1cXG5cXG4gIHJldHVybiAodHlwZW9mIGV2dHMgPT09ICdzdHJpbmcnID8gZXZ0cy5zcGxpdCgnfCcpIDogZXZ0cyk7XFxufTtcXG5cXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcXG5cXG52YXIgZGV0ZWN0UGFzc2l2ZVN1cHBvcnQgPSBmdW5jdGlvbiAoKSB7XFxuICB0cnkge1xcbiAgICB2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xcbiAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmUnLCBudWxsLCBvcHRzKTtcXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlJywgbnVsbCwgb3B0cyk7XFxuICB9IGNhdGNoIChlKSB7XFxuICAgIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xcbiAgfVxcbiAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZTtcXG59O1xcblxcbnZhciBhZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsLCBldmVudE5hbWUsIGNiKSB7XFxuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2IsIHN1cHBvcnRzUGFzc2l2ZSA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogZmFsc2UpO1xcbn07XFxuXFxuLy8gXFxuXFxudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcXG4gIHRhcmdldE9mOiBudWxsLFxcbiAgaW1tZWRpYXRlOiBmYWxzZSxcXG4gIHBlcnNpc3Q6IGZhbHNlLFxcbiAgc2NvcGU6IG51bGwsXFxuICBsaXN0ZW46IHRydWUsXFxuICBuYW1lOiBudWxsLFxcbiAgcnVsZXM6IHt9LFxcbiAgdm06IG51bGwsXFxuICBjbGFzc2VzOiBmYWxzZSxcXG4gIHZhbGlkaXR5OiB0cnVlLFxcbiAgYXJpYTogdHJ1ZSxcXG4gIGV2ZW50czogJ2lucHV0fGJsdXInLFxcbiAgZGVsYXk6IDAsXFxuICBjbGFzc05hbWVzOiB7XFxuICAgIHRvdWNoZWQ6ICd0b3VjaGVkJywgLy8gdGhlIGNvbnRyb2wgaGFzIGJlZW4gYmx1cnJlZFxcbiAgICB1bnRvdWNoZWQ6ICd1bnRvdWNoZWQnLCAvLyB0aGUgY29udHJvbCBoYXNuJ3QgYmVlbiBibHVycmVkXFxuICAgIHZhbGlkOiAndmFsaWQnLCAvLyBtb2RlbCBpcyB2YWxpZFxcbiAgICBpbnZhbGlkOiAnaW52YWxpZCcsIC8vIG1vZGVsIGlzIGludmFsaWRcXG4gICAgcHJpc3RpbmU6ICdwcmlzdGluZScsIC8vIGNvbnRyb2wgaGFzIG5vdCBiZWVuIGludGVyYWN0ZWQgd2l0aFxcbiAgICBkaXJ0eTogJ2RpcnR5JyAvLyBjb250cm9sIGhhcyBiZWVuIGludGVyYWN0ZWQgd2l0aFxcbiAgfVxcbn07XFxuXFxudmFyIEZpZWxkID0gZnVuY3Rpb24gRmllbGQgKG9wdGlvbnMpIHtcXG4gIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xcblxcbiAgdGhpcy5pZCA9IHVuaXFJZCgpO1xcbiAgdGhpcy5lbCA9IG9wdGlvbnMuZWw7XFxuICB0aGlzLnVwZGF0ZWQgPSBmYWxzZTtcXG4gIHRoaXMudm1JZCA9IG9wdGlvbnMudm1JZDtcXG4gIGRlZmluZU5vblJlYWN0aXZlKHRoaXMsICdkZXBlbmRlbmNpZXMnLCBbXSk7XFxuICBkZWZpbmVOb25SZWFjdGl2ZSh0aGlzLCAnd2F0Y2hlcnMnLCBbXSk7XFxuICBkZWZpbmVOb25SZWFjdGl2ZSh0aGlzLCAnZXZlbnRzJywgW10pO1xcbiAgdGhpcy5kZWxheSA9IDA7XFxuICB0aGlzLnJ1bGVzID0ge307XFxuICB0aGlzLmZvcmNlUmVxdWlyZWQgPSBmYWxzZTtcXG4gIHRoaXMuX2NhY2hlSWQob3B0aW9ucyk7XFxuICB0aGlzLmNsYXNzTmFtZXMgPSBhc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUy5jbGFzc05hbWVzKTtcXG4gIG9wdGlvbnMgPSBhc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XFxuICB0aGlzLl9kZWxheSA9ICFpc051bGxPclVuZGVmaW5lZChvcHRpb25zLmRlbGF5KSA/IG9wdGlvbnMuZGVsYXkgOiAwOyAvLyBjYWNoZSBpbml0aWFsIGRlbGF5XFxuICB0aGlzLnZhbGlkaXR5ID0gb3B0aW9ucy52YWxpZGl0eTtcXG4gIHRoaXMuYXJpYSA9IG9wdGlvbnMuYXJpYTtcXG4gIHRoaXMuZmxhZ3MgPSBvcHRpb25zLmZsYWdzIHx8IGNyZWF0ZUZsYWdzKCk7XFxuICBkZWZpbmVOb25SZWFjdGl2ZSh0aGlzLCAndm0nLCBvcHRpb25zLnZtKTtcXG4gIGRlZmluZU5vblJlYWN0aXZlKHRoaXMsICdjb21wb25lbnRJbnN0YW5jZScsIG9wdGlvbnMuY29tcG9uZW50KTtcXG4gIHRoaXMuY3RvckNvbmZpZyA9IHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPyBnZXRQYXRoKCckb3B0aW9ucy4kX3ZlZVZhbGlkYXRlJywgdGhpcy5jb21wb25lbnRJbnN0YW5jZSkgOiB1bmRlZmluZWQ7XFxuICB0aGlzLnVwZGF0ZShvcHRpb25zKTtcXG4gIC8vIHNldCBpbml0aWFsIHZhbHVlLlxcbiAgdGhpcy5pbml0aWFsVmFsdWUgPSB0aGlzLnZhbHVlO1xcbiAgdGhpcy51cGRhdGVkID0gZmFsc2U7XFxufTtcXG5cXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzJDEgPSB7IHZhbGlkYXRvcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpc1JlcXVpcmVkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGlzRGlzYWJsZWQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxpYXM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sdmFsdWU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYmFpbHM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0scmVqZWN0c0ZhbHNlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XFxuXFxucHJvdG90eXBlQWNjZXNzb3JzJDEudmFsaWRhdG9yLmdldCA9IGZ1bmN0aW9uICgpIHtcXG4gIGlmICghdGhpcy52bSB8fCAhdGhpcy52bS4kdmFsaWRhdG9yKSB7XFxuICAgIHJldHVybiB7IHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7IH0gfTtcXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzLnZtLiR2YWxpZGF0b3I7XFxufTtcXG5cXG5wcm90b3R5cGVBY2Nlc3NvcnMkMS5pc1JlcXVpcmVkLmdldCA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiAhIXRoaXMucnVsZXMucmVxdWlyZWQgfHwgdGhpcy5mb3JjZVJlcXVpcmVkO1xcbn07XFxuXFxucHJvdG90eXBlQWNjZXNzb3JzJDEuaXNEaXNhYmxlZC5nZXQgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gISEodGhpcy5lbCAmJiB0aGlzLmVsLmRpc2FibGVkKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldHMgdGhlIGRpc3BsYXkgbmFtZSAodXNlci1mcmllbmRseSBuYW1lKS5cXG4gKi9cXG5wcm90b3R5cGVBY2Nlc3NvcnMkMS5hbGlhcy5nZXQgPSBmdW5jdGlvbiAoKSB7XFxuICBpZiAodGhpcy5fYWxpYXMpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2FsaWFzO1xcbiAgfVxcblxcbiAgdmFyIGFsaWFzID0gbnVsbDtcXG4gIGlmICh0aGlzLmN0b3JDb25maWcgJiYgdGhpcy5jdG9yQ29uZmlnLmFsaWFzKSB7XFxuICAgIGFsaWFzID0gaXNDYWxsYWJsZSh0aGlzLmN0b3JDb25maWcuYWxpYXMpID8gdGhpcy5jdG9yQ29uZmlnLmFsaWFzLmNhbGwodGhpcy5jb21wb25lbnRJbnN0YW5jZSkgOiB0aGlzLmN0b3JDb25maWcuYWxpYXM7XFxuICB9XFxuXFxuICBpZiAoIWFsaWFzICYmIHRoaXMuZWwpIHtcXG4gICAgYWxpYXMgPSBnZXREYXRhQXR0cmlidXRlKHRoaXMuZWwsICdhcycpO1xcbiAgfVxcblxcbiAgaWYgKCFhbGlhcyAmJiB0aGlzLmNvbXBvbmVudEluc3RhbmNlKSB7XFxuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlLiRhdHRycyAmJiB0aGlzLmNvbXBvbmVudEluc3RhbmNlLiRhdHRyc1snZGF0YS12di1hcyddO1xcbiAgfVxcblxcbiAgcmV0dXJuIGFsaWFzO1xcbn07XFxuXFxuLyoqXFxuICogR2V0cyB0aGUgaW5wdXQgdmFsdWUuXFxuICovXFxuXFxucHJvdG90eXBlQWNjZXNzb3JzJDEudmFsdWUuZ2V0ID0gZnVuY3Rpb24gKCkge1xcbiAgaWYgKCFpc0NhbGxhYmxlKHRoaXMuZ2V0dGVyKSkge1xcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXMuZ2V0dGVyKCk7XFxufTtcXG5cXG5wcm90b3R5cGVBY2Nlc3NvcnMkMS5iYWlscy5nZXQgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gdGhpcy5fYmFpbHM7XFxufTtcXG5cXG4vKipcXG4gKiBJZiB0aGUgZmllbGQgcmVqZWN0cyBmYWxzZSBhcyBhIHZhbGlkIHZhbHVlIGZvciB0aGUgcmVxdWlyZWQgcnVsZS5cXG4gKi9cXG5cXG5wcm90b3R5cGVBY2Nlc3NvcnMkMS5yZWplY3RzRmFsc2UuZ2V0ID0gZnVuY3Rpb24gKCkge1xcbiAgaWYgKHRoaXMuY29tcG9uZW50SW5zdGFuY2UgJiYgdGhpcy5jdG9yQ29uZmlnKSB7XFxuICAgIHJldHVybiAhIXRoaXMuY3RvckNvbmZpZy5yZWplY3RzRmFsc2U7XFxuICB9XFxuXFxuICBpZiAoIXRoaXMuZWwpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXMuZWwudHlwZSA9PT0gJ2NoZWNrYm94JztcXG59O1xcblxcbi8qKlxcbiAqIERldGVybWluZXMgaWYgdGhlIGluc3RhbmNlIG1hdGNoZXMgdGhlIG9wdGlvbnMgcHJvdmlkZWQuXFxuICovXFxuRmllbGQucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiBtYXRjaGVzIChvcHRpb25zKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgaWYgKCFvcHRpb25zKSB7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcblxcbiAgaWYgKG9wdGlvbnMuaWQpIHtcXG4gICAgcmV0dXJuIHRoaXMuaWQgPT09IG9wdGlvbnMuaWQ7XFxuICB9XFxuXFxuICB2YXIgbWF0Y2hlc0NvbXBvbmVudElkID0gaXNOdWxsT3JVbmRlZmluZWQob3B0aW9ucy52bUlkKSA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0gOiBmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGlkID09PSB0aGlzJDEudm1JZDsgfTtcXG4gIGlmICghbWF0Y2hlc0NvbXBvbmVudElkKG9wdGlvbnMudm1JZCkpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgaWYgKG9wdGlvbnMubmFtZSA9PT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuc2NvcGUgPT09IHVuZGVmaW5lZCkge1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH1cXG5cXG4gIGlmIChvcHRpb25zLnNjb3BlID09PSB1bmRlZmluZWQpIHtcXG4gICAgcmV0dXJuIHRoaXMubmFtZSA9PT0gb3B0aW9ucy5uYW1lO1xcbiAgfVxcblxcbiAgaWYgKG9wdGlvbnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIHJldHVybiB0aGlzLnNjb3BlID09PSBvcHRpb25zLnNjb3BlO1xcbiAgfVxcblxcbiAgcmV0dXJuIG9wdGlvbnMubmFtZSA9PT0gdGhpcy5uYW1lICYmIG9wdGlvbnMuc2NvcGUgPT09IHRoaXMuc2NvcGU7XFxufTtcXG5cXG4vKipcXG4gKiBDYWNoZXMgdGhlIGZpZWxkIGlkLlxcbiAqL1xcbkZpZWxkLnByb3RvdHlwZS5fY2FjaGVJZCA9IGZ1bmN0aW9uIF9jYWNoZUlkIChvcHRpb25zKSB7XFxuICBpZiAodGhpcy5lbCAmJiAhb3B0aW9ucy50YXJnZXRPZikge1xcbiAgICB0aGlzLmVsLl92ZWVWYWxpZGF0ZUlkID0gdGhpcy5pZDtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIEtlZXBzIGEgcmVmZXJlbmNlIG9mIHRoZSBtb3N0IGN1cnJlbnQgdmFsaWRhdGlvbiBydW4uXFxuICovXFxuRmllbGQucHJvdG90eXBlLndhaXRGb3IgPSBmdW5jdGlvbiB3YWl0Rm9yIChwZW5kaW5nUHJvbWlzZSkge1xcbiAgdGhpcy5fd2FpdGluZ0ZvciA9IHBlbmRpbmdQcm9taXNlO1xcbn07XFxuXFxuRmllbGQucHJvdG90eXBlLmlzV2FpdGluZ0ZvciA9IGZ1bmN0aW9uIGlzV2FpdGluZ0ZvciAocHJvbWlzZSkge1xcbiAgcmV0dXJuIHRoaXMuX3dhaXRpbmdGb3IgPT09IHByb21pc2U7XFxufTtcXG5cXG4vKipcXG4gKiBVcGRhdGVzIHRoZSBmaWVsZCB3aXRoIGNoYW5nZWQgZGF0YS5cXG4gKi9cXG5GaWVsZC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvcHRpb25zKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgdGhpcy50YXJnZXRPZiA9IG9wdGlvbnMudGFyZ2V0T2YgfHwgbnVsbDtcXG4gIHRoaXMuaW1tZWRpYXRlID0gb3B0aW9ucy5pbW1lZGlhdGUgfHwgdGhpcy5pbW1lZGlhdGUgfHwgZmFsc2U7XFxuICB0aGlzLnBlcnNpc3QgPSBvcHRpb25zLnBlcnNpc3QgfHwgdGhpcy5wZXJzaXN0IHx8IGZhbHNlO1xcblxcbiAgLy8gdXBkYXRlIGVycm9ycyBzY29wZSBpZiB0aGUgZmllbGQgc2NvcGUgd2FzIGNoYW5nZWQuXFxuICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG9wdGlvbnMuc2NvcGUpICYmIG9wdGlvbnMuc2NvcGUgIT09IHRoaXMuc2NvcGUgJiYgaXNDYWxsYWJsZSh0aGlzLnZhbGlkYXRvci51cGRhdGUpKSB7XFxuICAgIHRoaXMudmFsaWRhdG9yLnVwZGF0ZSh0aGlzLmlkLCB7IHNjb3BlOiBvcHRpb25zLnNjb3BlIH0pO1xcbiAgfVxcbiAgdGhpcy5zY29wZSA9ICFpc051bGxPclVuZGVmaW5lZChvcHRpb25zLnNjb3BlKSA/IG9wdGlvbnMuc2NvcGVcXG4gICAgOiAhaXNOdWxsT3JVbmRlZmluZWQodGhpcy5zY29wZSkgPyB0aGlzLnNjb3BlIDogbnVsbDtcXG4gIHRoaXMubmFtZSA9ICghaXNOdWxsT3JVbmRlZmluZWQob3B0aW9ucy5uYW1lKSA/IFN0cmluZyhvcHRpb25zLm5hbWUpIDogb3B0aW9ucy5uYW1lKSB8fCB0aGlzLm5hbWUgfHwgbnVsbDtcXG4gIHRoaXMucnVsZXMgPSBvcHRpb25zLnJ1bGVzICE9PSB1bmRlZmluZWQgPyBub3JtYWxpemVSdWxlcyhvcHRpb25zLnJ1bGVzKSA6IHRoaXMucnVsZXM7XFxuICB0aGlzLl9iYWlscyA9IG9wdGlvbnMuYmFpbHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmFpbHMgOiB0aGlzLl9iYWlscztcXG4gIHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsIHx8IHRoaXMubW9kZWw7XFxuICB0aGlzLmxpc3RlbiA9IG9wdGlvbnMubGlzdGVuICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmxpc3RlbiA6IHRoaXMubGlzdGVuO1xcbiAgdGhpcy5jbGFzc2VzID0gKG9wdGlvbnMuY2xhc3NlcyB8fCB0aGlzLmNsYXNzZXMgfHwgZmFsc2UpICYmICF0aGlzLmNvbXBvbmVudEluc3RhbmNlO1xcbiAgdGhpcy5jbGFzc05hbWVzID0gaXNPYmplY3Qob3B0aW9ucy5jbGFzc05hbWVzKSA/IG1lcmdlKHRoaXMuY2xhc3NOYW1lcywgb3B0aW9ucy5jbGFzc05hbWVzKSA6IHRoaXMuY2xhc3NOYW1lcztcXG4gIHRoaXMuZ2V0dGVyID0gaXNDYWxsYWJsZShvcHRpb25zLmdldHRlcikgPyBvcHRpb25zLmdldHRlciA6IHRoaXMuZ2V0dGVyO1xcbiAgdGhpcy5fYWxpYXMgPSBvcHRpb25zLmFsaWFzIHx8IHRoaXMuX2FsaWFzO1xcbiAgdGhpcy5ldmVudHMgPSAob3B0aW9ucy5ldmVudHMpID8gbm9ybWFsaXplRXZlbnRzKG9wdGlvbnMuZXZlbnRzKSA6IHRoaXMuZXZlbnRzO1xcbiAgdGhpcy5kZWxheSA9IG1ha2VEZWxheU9iamVjdCh0aGlzLmV2ZW50cywgb3B0aW9ucy5kZWxheSB8fCB0aGlzLmRlbGF5LCB0aGlzLl9kZWxheSk7XFxuICB0aGlzLnVwZGF0ZURlcGVuZGVuY2llcygpO1xcbiAgdGhpcy5hZGRBY3Rpb25MaXN0ZW5lcnMoKTtcXG5cXG4gIGlmICggdHJ1ZSAmJiAhdGhpcy5uYW1lICYmICF0aGlzLnRhcmdldE9mKSB7XFxuICAgIHdhcm4oJ0EgZmllbGQgaXMgbWlzc2luZyBhIFxcXCJuYW1lXFxcIiBvciBcXFwiZGF0YS12di1uYW1lXFxcIiBhdHRyaWJ1dGUnKTtcXG4gIH1cXG5cXG4gIC8vIHVwZGF0ZSByZXF1aXJlZCBmbGFnIGZsYWdzXFxuICBpZiAob3B0aW9ucy5ydWxlcyAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIHRoaXMuZmxhZ3MucmVxdWlyZWQgPSB0aGlzLmlzUmVxdWlyZWQ7XFxuICB9XFxuXFxuICBpZiAoT2JqZWN0LmtleXMob3B0aW9ucy5ydWxlcyB8fCB7fSkubGVuZ3RoID09PSAwICYmIHRoaXMudXBkYXRlZCkge1xcbiAgICB2YXIgcmVzZXRGbGFnID0gdGhpcy5mbGFncy52YWxpZGF0ZWQ7XFxuICAgIHRoaXMudmFsaWRhdG9yLnZhbGlkYXRlKChcXFwiI1xcXCIgKyAodGhpcy5pZCkpKS50aGVuKGZ1bmN0aW9uICgpIHtcXG4gICAgICB0aGlzJDEuZmxhZ3MudmFsaWRhdGVkID0gcmVzZXRGbGFnO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIC8vIHZhbGlkYXRlIGlmIGl0IHdhcyB2YWxpZGF0ZWQgYmVmb3JlIGFuZCBmaWVsZCB3YXMgdXBkYXRlZCBhbmQgdGhlcmUgd2FzIGEgcnVsZXMgbXV0YXRpb24uXFxuICBpZiAodGhpcy5mbGFncy52YWxpZGF0ZWQgJiYgb3B0aW9ucy5ydWxlcyAhPT0gdW5kZWZpbmVkICYmIHRoaXMudXBkYXRlZCkge1xcbiAgICB0aGlzLnZhbGlkYXRvci52YWxpZGF0ZSgoXFxcIiNcXFwiICsgKHRoaXMuaWQpKSk7XFxuICB9XFxuXFxuICB0aGlzLnVwZGF0ZWQgPSB0cnVlO1xcbiAgdGhpcy5hZGRWYWx1ZUxpc3RlbmVycygpO1xcblxcbiAgLy8gbm8gbmVlZCB0byBjb250aW51ZS5cXG4gIGlmICghdGhpcy5lbCkge1xcbiAgICByZXR1cm47XFxuICB9XFxuICB0aGlzLnVwZGF0ZUNsYXNzZXMoKTtcXG4gIHRoaXMudXBkYXRlQXJpYUF0dHJzKCk7XFxufTtcXG5cXG4vKipcXG4gKiBSZXNldHMgZmllbGQgZmxhZ3MgYW5kIGVycm9ycy5cXG4gKi9cXG5GaWVsZC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCAoKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgaWYgKHRoaXMuX2NhbmNlbGxhdGlvblRva2VuKSB7XFxuICAgIHRoaXMuX2NhbmNlbGxhdGlvblRva2VuLmNhbmNlbGxlZCA9IHRydWU7XFxuICAgIGRlbGV0ZSB0aGlzLl9jYW5jZWxsYXRpb25Ub2tlbjtcXG4gIH1cXG5cXG4gIHZhciBkZWZhdWx0cyA9IGNyZWF0ZUZsYWdzKCk7XFxuICBPYmplY3Qua2V5cyh0aGlzLmZsYWdzKS5maWx0ZXIoZnVuY3Rpb24gKGZsYWcpIHsgcmV0dXJuIGZsYWcgIT09ICdyZXF1aXJlZCc7IH0pLmZvckVhY2goZnVuY3Rpb24gKGZsYWcpIHtcXG4gICAgdGhpcyQxLmZsYWdzW2ZsYWddID0gZGVmYXVsdHNbZmxhZ107XFxuICB9KTtcXG5cXG4gIC8vIHVwZGF0ZSBpbml0aWFsIHZhbHVlXFxuICB0aGlzLmluaXRpYWxWYWx1ZSA9IHRoaXMudmFsdWU7XFxuICB0aGlzLmZsYWdzLmNoYW5nZWQgPSBmYWxzZTtcXG5cXG4gIHRoaXMuYWRkVmFsdWVMaXN0ZW5lcnMoKTtcXG4gIHRoaXMuYWRkQWN0aW9uTGlzdGVuZXJzKCk7XFxuICB0aGlzLnVwZGF0ZUNsYXNzZXModHJ1ZSk7XFxuICB0aGlzLnVwZGF0ZUFyaWFBdHRycygpO1xcbiAgdGhpcy51cGRhdGVDdXN0b21WYWxpZGl0eSgpO1xcbn07XFxuXFxuLyoqXFxuICogU2V0cyB0aGUgZmxhZ3MgYW5kIHRoZWlyIG5lZ2F0ZWQgY291bnRlcnBhcnRzLCBhbmQgdXBkYXRlcyB0aGUgY2xhc3NlcyBhbmQgcmUtYWRkcyBhY3Rpb24gbGlzdGVuZXJzLlxcbiAqL1xcbkZpZWxkLnByb3RvdHlwZS5zZXRGbGFncyA9IGZ1bmN0aW9uIHNldEZsYWdzIChmbGFncykge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIHZhciBuZWdhdGVkID0ge1xcbiAgICBwcmlzdGluZTogJ2RpcnR5JyxcXG4gICAgZGlydHk6ICdwcmlzdGluZScsXFxuICAgIHZhbGlkOiAnaW52YWxpZCcsXFxuICAgIGludmFsaWQ6ICd2YWxpZCcsXFxuICAgIHRvdWNoZWQ6ICd1bnRvdWNoZWQnLFxcbiAgICB1bnRvdWNoZWQ6ICd0b3VjaGVkJ1xcbiAgfTtcXG5cXG4gIE9iamVjdC5rZXlzKGZsYWdzKS5mb3JFYWNoKGZ1bmN0aW9uIChmbGFnKSB7XFxuICAgIHRoaXMkMS5mbGFnc1tmbGFnXSA9IGZsYWdzW2ZsYWddO1xcbiAgICAvLyBpZiBpdCBoYXMgYSBuZWdhdGlvbiBhbmQgd2FzIG5vdCBzcGVjaWZpZWQsIHNldCBpdCBhcyB3ZWxsLlxcbiAgICBpZiAobmVnYXRlZFtmbGFnXSAmJiBmbGFnc1tuZWdhdGVkW2ZsYWddXSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgdGhpcyQxLmZsYWdzW25lZ2F0ZWRbZmxhZ11dID0gIWZsYWdzW2ZsYWddO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIGlmIChcXG4gICAgZmxhZ3MudW50b3VjaGVkICE9PSB1bmRlZmluZWQgfHxcXG4gICAgZmxhZ3MudG91Y2hlZCAhPT0gdW5kZWZpbmVkIHx8XFxuICAgIGZsYWdzLmRpcnR5ICE9PSB1bmRlZmluZWQgfHxcXG4gICAgZmxhZ3MucHJpc3RpbmUgIT09IHVuZGVmaW5lZFxcbiAgKSB7XFxuICAgIHRoaXMuYWRkQWN0aW9uTGlzdGVuZXJzKCk7XFxuICB9XFxuICB0aGlzLnVwZGF0ZUNsYXNzZXMoKTtcXG4gIHRoaXMudXBkYXRlQXJpYUF0dHJzKCk7XFxuICB0aGlzLnVwZGF0ZUN1c3RvbVZhbGlkaXR5KCk7XFxufTtcXG5cXG4vKipcXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBmaWVsZCByZXF1aXJlcyByZWZlcmVuY2VzIHRvIHRhcmdldCBmaWVsZHMuXFxuKi9cXG5GaWVsZC5wcm90b3R5cGUudXBkYXRlRGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gdXBkYXRlRGVwZW5kZW5jaWVzICgpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAvLyByZXNldCBkZXBlbmRlbmNpZXMuXFxuICB0aGlzLmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmZpZWxkLmRlc3Ryb3koKTsgfSk7XFxuICB0aGlzLmRlcGVuZGVuY2llcyA9IFtdO1xcblxcbiAgLy8gd2UgZ2V0IHRoZSBzZWxlY3RvcnMgZm9yIGVhY2ggZmllbGQuXFxuICB2YXIgZmllbGRzID0gT2JqZWN0LmtleXModGhpcy5ydWxlcykucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCByKSB7XFxuICAgIGlmIChSdWxlQ29udGFpbmVyLmlzVGFyZ2V0UnVsZShyKSkge1xcbiAgICAgIHByZXYucHVzaCh7IHNlbGVjdG9yOiB0aGlzJDEucnVsZXNbcl1bMF0sIG5hbWU6IHIgfSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHByZXY7XFxuICB9LCBbXSk7XFxuXFxuICBpZiAoIWZpZWxkcy5sZW5ndGggfHwgIXRoaXMudm0gfHwgIXRoaXMudm0uJGVsKSB7IHJldHVybjsgfVxcblxcbiAgLy8gbXVzdCBiZSBjb250YWluZWQgd2l0aGluIHRoZSBzYW1lIGNvbXBvbmVudCwgc28gd2UgdXNlIHRoZSB2bSByb290IGVsZW1lbnQgY29uc3RyYWluIG91ciBkb20gc2VhcmNoLlxcbiAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKHJlZiQxKSB7XFxuICAgICAgdmFyIHNlbGVjdG9yID0gcmVmJDEuc2VsZWN0b3I7XFxuICAgICAgdmFyIG5hbWUgPSByZWYkMS5uYW1lO1xcblxcbiAgICB2YXIgcmVmID0gdGhpcyQxLnZtLiRyZWZzW3NlbGVjdG9yXTtcXG4gICAgdmFyIGVsID0gQXJyYXkuaXNBcnJheShyZWYpID8gcmVmWzBdIDogcmVmO1xcbiAgICBpZiAoIWVsKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHZhciBvcHRpb25zID0ge1xcbiAgICAgIHZtOiB0aGlzJDEudm0sXFxuICAgICAgY2xhc3NlczogdGhpcyQxLmNsYXNzZXMsXFxuICAgICAgY2xhc3NOYW1lczogdGhpcyQxLmNsYXNzTmFtZXMsXFxuICAgICAgZGVsYXk6IHRoaXMkMS5kZWxheSxcXG4gICAgICBzY29wZTogdGhpcyQxLnNjb3BlLFxcbiAgICAgIGV2ZW50czogdGhpcyQxLmV2ZW50cy5qb2luKCd8JyksXFxuICAgICAgaW1tZWRpYXRlOiB0aGlzJDEuaW1tZWRpYXRlLFxcbiAgICAgIHRhcmdldE9mOiB0aGlzJDEuaWRcXG4gICAgfTtcXG5cXG4gICAgLy8gcHJvYmFibHkgYSBjb21wb25lbnQuXFxuICAgIGlmIChpc0NhbGxhYmxlKGVsLiR3YXRjaCkpIHtcXG4gICAgICBvcHRpb25zLmNvbXBvbmVudCA9IGVsO1xcbiAgICAgIG9wdGlvbnMuZWwgPSBlbC4kZWw7XFxuICAgICAgb3B0aW9ucy5nZXR0ZXIgPSBSZXNvbHZlci5yZXNvbHZlR2V0dGVyKGVsLiRlbCwgZWwuJHZub2RlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBvcHRpb25zLmVsID0gZWw7XFxuICAgICAgb3B0aW9ucy5nZXR0ZXIgPSBSZXNvbHZlci5yZXNvbHZlR2V0dGVyKGVsLCB7fSk7XFxuICAgIH1cXG5cXG4gICAgdGhpcyQxLmRlcGVuZGVuY2llcy5wdXNoKHsgbmFtZTogbmFtZSwgZmllbGQ6IG5ldyBGaWVsZChvcHRpb25zKSB9KTtcXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogUmVtb3ZlcyBsaXN0ZW5lcnMuXFxuICovXFxuRmllbGQucHJvdG90eXBlLnVud2F0Y2ggPSBmdW5jdGlvbiB1bndhdGNoICh0YWcpIHtcXG4gICAgaWYgKCB0YWcgPT09IHZvaWQgMCApIHRhZyA9IG51bGw7XFxuXFxuICBpZiAoIXRhZykge1xcbiAgICB0aGlzLndhdGNoZXJzLmZvckVhY2goZnVuY3Rpb24gKHcpIHsgcmV0dXJuIHcudW53YXRjaCgpOyB9KTtcXG4gICAgdGhpcy53YXRjaGVycyA9IFtdO1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICB0aGlzLndhdGNoZXJzLmZpbHRlcihmdW5jdGlvbiAodykgeyByZXR1cm4gdGFnLnRlc3Qody50YWcpOyB9KS5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHJldHVybiB3LnVud2F0Y2goKTsgfSk7XFxuICB0aGlzLndhdGNoZXJzID0gdGhpcy53YXRjaGVycy5maWx0ZXIoZnVuY3Rpb24gKHcpIHsgcmV0dXJuICF0YWcudGVzdCh3LnRhZyk7IH0pO1xcbn07XFxuXFxuLyoqXFxuICogVXBkYXRlcyB0aGUgZWxlbWVudCBjbGFzc2VzIGRlcGVuZGluZyBvbiBlYWNoIGZpZWxkIGZsYWcgc3RhdHVzLlxcbiAqL1xcbkZpZWxkLnByb3RvdHlwZS51cGRhdGVDbGFzc2VzID0gZnVuY3Rpb24gdXBkYXRlQ2xhc3NlcyAoaXNSZXNldCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG4gICAgaWYgKCBpc1Jlc2V0ID09PSB2b2lkIDAgKSBpc1Jlc2V0ID0gZmFsc2U7XFxuXFxuICBpZiAoIXRoaXMuY2xhc3NlcyB8fCB0aGlzLmlzRGlzYWJsZWQpIHsgcmV0dXJuOyB9XFxuICB2YXIgYXBwbHlDbGFzc2VzID0gZnVuY3Rpb24gKGVsKSB7XFxuICAgIHRvZ2dsZUNsYXNzKGVsLCB0aGlzJDEuY2xhc3NOYW1lcy5kaXJ0eSwgdGhpcyQxLmZsYWdzLmRpcnR5KTtcXG4gICAgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMkMS5jbGFzc05hbWVzLnByaXN0aW5lLCB0aGlzJDEuZmxhZ3MucHJpc3RpbmUpO1xcbiAgICB0b2dnbGVDbGFzcyhlbCwgdGhpcyQxLmNsYXNzTmFtZXMudG91Y2hlZCwgdGhpcyQxLmZsYWdzLnRvdWNoZWQpO1xcbiAgICB0b2dnbGVDbGFzcyhlbCwgdGhpcyQxLmNsYXNzTmFtZXMudW50b3VjaGVkLCB0aGlzJDEuZmxhZ3MudW50b3VjaGVkKTtcXG5cXG4gICAgLy8gcmVtb3ZlIHZhbGlkL2ludmFsaWQgY2xhc3NlcyBvbiByZXNldC5cXG4gICAgaWYgKGlzUmVzZXQpIHtcXG4gICAgICB0b2dnbGVDbGFzcyhlbCwgdGhpcyQxLmNsYXNzTmFtZXMudmFsaWQsIGZhbHNlKTtcXG4gICAgICB0b2dnbGVDbGFzcyhlbCwgdGhpcyQxLmNsYXNzTmFtZXMuaW52YWxpZCwgZmFsc2UpO1xcbiAgICB9XFxuXFxuICAgIC8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBzZXQgYW55IGNsYXNzZXMgaWYgdGhlIHN0YXRlIGlzIHVuZGV0ZXJtaW5lZC5cXG4gICAgaWYgKCFpc051bGxPclVuZGVmaW5lZCh0aGlzJDEuZmxhZ3MudmFsaWQpICYmIHRoaXMkMS5mbGFncy52YWxpZGF0ZWQpIHtcXG4gICAgICB0b2dnbGVDbGFzcyhlbCwgdGhpcyQxLmNsYXNzTmFtZXMudmFsaWQsIHRoaXMkMS5mbGFncy52YWxpZCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKCFpc051bGxPclVuZGVmaW5lZCh0aGlzJDEuZmxhZ3MuaW52YWxpZCkgJiYgdGhpcyQxLmZsYWdzLnZhbGlkYXRlZCkge1xcbiAgICAgIHRvZ2dsZUNsYXNzKGVsLCB0aGlzJDEuY2xhc3NOYW1lcy5pbnZhbGlkLCB0aGlzJDEuZmxhZ3MuaW52YWxpZCk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBpZiAoIWlzQ2hlY2tib3hPclJhZGlvSW5wdXQodGhpcy5lbCkpIHtcXG4gICAgYXBwbHlDbGFzc2VzKHRoaXMuZWwpO1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICB2YXIgZWxzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgoXFxcImlucHV0W25hbWU9XFxcXFxcXCJcXFwiICsgKHRoaXMuZWwubmFtZSkgKyBcXFwiXFxcXFxcXCJdXFxcIikpO1xcbiAgdG9BcnJheShlbHMpLmZvckVhY2goYXBwbHlDbGFzc2VzKTtcXG59O1xcblxcbi8qKlxcbiAqIEFkZHMgdGhlIGxpc3RlbmVycyByZXF1aXJlZCBmb3IgYXV0b21hdGljIGNsYXNzZXMgYW5kIHNvbWUgZmxhZ3MuXFxuICovXFxuRmllbGQucHJvdG90eXBlLmFkZEFjdGlvbkxpc3RlbmVycyA9IGZ1bmN0aW9uIGFkZEFjdGlvbkxpc3RlbmVycyAoKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgLy8gcmVtb3ZlIHByZXZpb3VzIGxpc3RlbmVycy5cXG4gIHRoaXMudW53YXRjaCgvY2xhc3MvKTtcXG5cXG4gIGlmICghdGhpcy5lbCkgeyByZXR1cm47IH1cXG5cXG4gIHZhciBvbkJsdXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMkMS5mbGFncy50b3VjaGVkID0gdHJ1ZTtcXG4gICAgdGhpcyQxLmZsYWdzLnVudG91Y2hlZCA9IGZhbHNlO1xcbiAgICBpZiAodGhpcyQxLmNsYXNzZXMpIHtcXG4gICAgICB0b2dnbGVDbGFzcyh0aGlzJDEuZWwsIHRoaXMkMS5jbGFzc05hbWVzLnRvdWNoZWQsIHRydWUpO1xcbiAgICAgIHRvZ2dsZUNsYXNzKHRoaXMkMS5lbCwgdGhpcyQxLmNsYXNzTmFtZXMudW50b3VjaGVkLCBmYWxzZSk7XFxuICAgIH1cXG5cXG4gICAgLy8gb25seSBuZWVkZWQgb25jZS5cXG4gICAgdGhpcyQxLnVud2F0Y2goL15jbGFzc19ibHVyJC8pO1xcbiAgfTtcXG5cXG4gIHZhciBpbnB1dEV2ZW50ID0gaXNUZXh0SW5wdXQodGhpcy5lbCkgPyAnaW5wdXQnIDogJ2NoYW5nZSc7XFxuICB2YXIgb25JbnB1dCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcyQxLmZsYWdzLmRpcnR5ID0gdHJ1ZTtcXG4gICAgdGhpcyQxLmZsYWdzLnByaXN0aW5lID0gZmFsc2U7XFxuICAgIGlmICh0aGlzJDEuY2xhc3Nlcykge1xcbiAgICAgIHRvZ2dsZUNsYXNzKHRoaXMkMS5lbCwgdGhpcyQxLmNsYXNzTmFtZXMucHJpc3RpbmUsIGZhbHNlKTtcXG4gICAgICB0b2dnbGVDbGFzcyh0aGlzJDEuZWwsIHRoaXMkMS5jbGFzc05hbWVzLmRpcnR5LCB0cnVlKTtcXG4gICAgfVxcblxcbiAgICAvLyBvbmx5IG5lZWRlZCBvbmNlLlxcbiAgICB0aGlzJDEudW53YXRjaCgvXmNsYXNzX2lucHV0JC8pO1xcbiAgfTtcXG5cXG4gIGlmICh0aGlzLmNvbXBvbmVudEluc3RhbmNlICYmIGlzQ2FsbGFibGUodGhpcy5jb21wb25lbnRJbnN0YW5jZS4kb25jZSkpIHtcXG4gICAgdGhpcy5jb21wb25lbnRJbnN0YW5jZS4kb25jZSgnaW5wdXQnLCBvbklucHV0KTtcXG4gICAgdGhpcy5jb21wb25lbnRJbnN0YW5jZS4kb25jZSgnYmx1cicsIG9uQmx1cik7XFxuICAgIHRoaXMud2F0Y2hlcnMucHVzaCh7XFxuICAgICAgdGFnOiAnY2xhc3NfaW5wdXQnLFxcbiAgICAgIHVud2F0Y2g6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHRoaXMkMS5jb21wb25lbnRJbnN0YW5jZS4kb2ZmKCdpbnB1dCcsIG9uSW5wdXQpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICAgIHRoaXMud2F0Y2hlcnMucHVzaCh7XFxuICAgICAgdGFnOiAnY2xhc3NfYmx1cicsXFxuICAgICAgdW53YXRjaDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdGhpcyQxLmNvbXBvbmVudEluc3RhbmNlLiRvZmYoJ2JsdXInLCBvbkJsdXIpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGlmICghdGhpcy5lbCkgeyByZXR1cm47IH1cXG5cXG4gIGFkZEV2ZW50TGlzdGVuZXIodGhpcy5lbCwgaW5wdXRFdmVudCwgb25JbnB1dCk7XFxuICAvLyBDaGVja2JveGVzIGFuZCByYWRpbyBidXR0b25zIG9uIE1hYyBkb24ndCBlbWl0IGJsdXIgbmF0dXJhbGx5LCBzbyB3ZSBsaXN0ZW4gb24gY2xpY2sgaW5zdGVhZC5cXG4gIHZhciBibHVyRXZlbnQgPSBpc0NoZWNrYm94T3JSYWRpb0lucHV0KHRoaXMuZWwpID8gJ2NoYW5nZScgOiAnYmx1cic7XFxuICBhZGRFdmVudExpc3RlbmVyKHRoaXMuZWwsIGJsdXJFdmVudCwgb25CbHVyKTtcXG4gIHRoaXMud2F0Y2hlcnMucHVzaCh7XFxuICAgIHRhZzogJ2NsYXNzX2lucHV0JyxcXG4gICAgdW53YXRjaDogZnVuY3Rpb24gKCkge1xcbiAgICAgIHRoaXMkMS5lbC5yZW1vdmVFdmVudExpc3RlbmVyKGlucHV0RXZlbnQsIG9uSW5wdXQpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIHRoaXMud2F0Y2hlcnMucHVzaCh7XFxuICAgIHRhZzogJ2NsYXNzX2JsdXInLFxcbiAgICB1bndhdGNoOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdGhpcyQxLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoYmx1ckV2ZW50LCBvbkJsdXIpO1xcbiAgICB9XFxuICB9KTtcXG59O1xcblxcbkZpZWxkLnByb3RvdHlwZS5jaGVja1ZhbHVlQ2hhbmdlZCA9IGZ1bmN0aW9uIGNoZWNrVmFsdWVDaGFuZ2VkICgpIHtcXG4gIC8vIGhhbmRsZSBzb21lIHBlb3BsZSBpbml0aWFsaXplIHRoZSB2YWx1ZSB0byBudWxsLCBzaW5jZSB0ZXh0IGlucHV0cyBoYXZlIGVtcHR5IHN0cmluZyB2YWx1ZS5cXG4gIGlmICh0aGlzLmluaXRpYWxWYWx1ZSA9PT0gbnVsbCAmJiB0aGlzLnZhbHVlID09PSAnJyAmJiBpc1RleHRJbnB1dCh0aGlzLmVsKSkge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcy52YWx1ZSAhPT0gdGhpcy5pbml0aWFsVmFsdWU7XFxufTtcXG5cXG4vKipcXG4gKiBEZXRlcm1pbmVzIHRoZSBzdWl0YWJsZSBwcmltYXJ5IGV2ZW50IHRvIGxpc3RlbiBmb3IuXFxuICovXFxuRmllbGQucHJvdG90eXBlLl9kZXRlcm1pbmVJbnB1dEV2ZW50ID0gZnVuY3Rpb24gX2RldGVybWluZUlucHV0RXZlbnQgKCkge1xcbiAgLy8gaWYgaXRzIGEgY3VzdG9tIGNvbXBvbmVudCwgdXNlIHRoZSBjdXN0b21pemVkIG1vZGVsIGV2ZW50IG9yIHRoZSBpbnB1dCBldmVudC5cXG4gIGlmICh0aGlzLmNvbXBvbmVudEluc3RhbmNlKSB7XFxuICAgIHJldHVybiAodGhpcy5jb21wb25lbnRJbnN0YW5jZS4kb3B0aW9ucy5tb2RlbCAmJiB0aGlzLmNvbXBvbmVudEluc3RhbmNlLiRvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnO1xcbiAgfVxcblxcbiAgaWYgKHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC5sYXp5KSB7XFxuICAgIHJldHVybiAnY2hhbmdlJztcXG4gIH1cXG5cXG4gIGlmIChpc1RleHRJbnB1dCh0aGlzLmVsKSkge1xcbiAgICByZXR1cm4gJ2lucHV0JztcXG4gIH1cXG5cXG4gIHJldHVybiAnY2hhbmdlJztcXG59O1xcblxcbi8qKlxcbiAqIERldGVybWluZXMgdGhlIGxpc3Qgb2YgZXZlbnRzIHRvIGxpc3RlbiB0by5cXG4gKi9cXG5GaWVsZC5wcm90b3R5cGUuX2RldGVybWluZUV2ZW50TGlzdCA9IGZ1bmN0aW9uIF9kZXRlcm1pbmVFdmVudExpc3QgKGRlZmF1bHRJbnB1dEV2ZW50KSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgLy8gaWYgbm8gZXZlbnQgaXMgY29uZmlndXJlZCwgb3IgaXQgaXMgYSBjb21wb25lbnQgb3IgYSB0ZXh0IGlucHV0IHRoZW4gcmVzcGVjdCB0aGUgdXNlciBjaG9pY2UuXFxuICBpZiAoIXRoaXMuZXZlbnRzLmxlbmd0aCB8fCB0aGlzLmNvbXBvbmVudEluc3RhbmNlIHx8IGlzVGV4dElucHV0KHRoaXMuZWwpKSB7XFxuICAgIHJldHVybiBbXS5jb25jYXQoIHRoaXMuZXZlbnRzICkubWFwKGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICBpZiAoZXZ0ID09PSAnaW5wdXQnICYmIHRoaXMkMS5tb2RlbCAmJiB0aGlzJDEubW9kZWwubGF6eSkge1xcbiAgICAgICAgcmV0dXJuICdjaGFuZ2UnO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gZXZ0O1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIC8vIGZvcmNlIHN1aXRhYmxlIGV2ZW50IGZvciBub24tdGV4dCB0eXBlIGZpZWxkcy5cXG4gIHJldHVybiB0aGlzLmV2ZW50cy5tYXAoZnVuY3Rpb24gKGUpIHtcXG4gICAgaWYgKGUgPT09ICdpbnB1dCcpIHtcXG4gICAgICByZXR1cm4gZGVmYXVsdElucHV0RXZlbnQ7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGU7XFxuICB9KTtcXG59O1xcblxcbi8qKlxcbiAqIEFkZHMgdGhlIGxpc3RlbmVycyByZXF1aXJlZCBmb3IgdmFsaWRhdGlvbi5cXG4gKi9cXG5GaWVsZC5wcm90b3R5cGUuYWRkVmFsdWVMaXN0ZW5lcnMgPSBmdW5jdGlvbiBhZGRWYWx1ZUxpc3RlbmVycyAoKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgdGhpcy51bndhdGNoKC9eaW5wdXRfLisvKTtcXG4gIGlmICghdGhpcy5saXN0ZW4gfHwgIXRoaXMuZWwpIHsgcmV0dXJuOyB9XFxuXFxuICB2YXIgdG9rZW4gPSB7IGNhbmNlbGxlZDogZmFsc2UgfTtcXG4gIHZhciBmbiA9IHRoaXMudGFyZ2V0T2YgPyBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciB0YXJnZXQgPSB0aGlzJDEudmFsaWRhdG9yLl9yZXNvbHZlRmllbGQoKFxcXCIjXFxcIiArICh0aGlzJDEudGFyZ2V0T2YpKSk7XFxuICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0LmZsYWdzLnZhbGlkYXRlZCkge1xcbiAgICAgIHRoaXMkMS52YWxpZGF0b3IudmFsaWRhdGUoKFxcXCIjXFxcIiArICh0aGlzJDEudGFyZ2V0T2YpKSk7XFxuICAgIH1cXG4gIH0gOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcXG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xcblxcbiAgICAvLyBpZiBpdHMgYSBET00gZXZlbnQsIHJlc29sdmUgdGhlIHZhbHVlLCBvdGhlcndpc2UgdXNlIHRoZSBmaXJzdCBwYXJhbWV0ZXIgYXMgdGhlIHZhbHVlLlxcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDAgfHwgaXNFdmVudChhcmdzWzBdKSkge1xcbiAgICAgIGFyZ3NbMF0gPSB0aGlzJDEudmFsdWU7XFxuICAgIH1cXG5cXG4gICAgdGhpcyQxLmZsYWdzLnBlbmRpbmcgPSB0cnVlO1xcbiAgICB0aGlzJDEuX2NhbmNlbGxhdGlvblRva2VuID0gdG9rZW47XFxuICAgIHRoaXMkMS52YWxpZGF0b3IudmFsaWRhdGUoKFxcXCIjXFxcIiArICh0aGlzJDEuaWQpKSwgYXJnc1swXSk7XFxuICB9O1xcblxcbiAgdmFyIGlucHV0RXZlbnQgPSB0aGlzLl9kZXRlcm1pbmVJbnB1dEV2ZW50KCk7XFxuICB2YXIgZXZlbnRzID0gdGhpcy5fZGV0ZXJtaW5lRXZlbnRMaXN0KGlucHV0RXZlbnQpO1xcblxcbiAgLy8gaWYgb24gaW5wdXQgdmFsaWRhdGlvbiBpcyByZXF1ZXN0ZWQuXFxuICBpZiAoaW5jbHVkZXMoZXZlbnRzLCBpbnB1dEV2ZW50KSkge1xcbiAgICB2YXIgY3R4ID0gbnVsbDtcXG4gICAgdmFyIGV4cHJlc3Npb24gPSBudWxsO1xcbiAgICB2YXIgd2F0Y2hDdHhWbSA9IGZhbHNlO1xcbiAgICAvLyBpZiBpdHMgd2F0Y2hhYmxlIGZyb20gdGhlIGNvbnRleHQgdm0uXFxuICAgIGlmICh0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwuZXhwcmVzc2lvbikge1xcbiAgICAgIGN0eCA9IHRoaXMudm07XFxuICAgICAgZXhwcmVzc2lvbiA9IHRoaXMubW9kZWwuZXhwcmVzc2lvbjtcXG4gICAgICB3YXRjaEN0eFZtID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICAvLyB3YXRjaCBpdCBmcm9tIHRoZSBjdXN0b20gY29tcG9uZW50IHZtIGluc3RlYWQuXFxuICAgIGlmICghZXhwcmVzc2lvbiAmJiB0aGlzLmNvbXBvbmVudEluc3RhbmNlICYmIHRoaXMuY29tcG9uZW50SW5zdGFuY2UuJG9wdGlvbnMubW9kZWwpIHtcXG4gICAgICBjdHggPSB0aGlzLmNvbXBvbmVudEluc3RhbmNlO1xcbiAgICAgIGV4cHJlc3Npb24gPSB0aGlzLmNvbXBvbmVudEluc3RhbmNlLiRvcHRpb25zLm1vZGVsLnByb3AgfHwgJ3ZhbHVlJztcXG4gICAgfVxcblxcbiAgICBpZiAoY3R4ICYmIGV4cHJlc3Npb24pIHtcXG4gICAgICB2YXIgZGVib3VuY2VkRm4gPSBkZWJvdW5jZShmbiwgdGhpcy5kZWxheVtpbnB1dEV2ZW50XSwgdG9rZW4pO1xcbiAgICAgIHZhciB1bndhdGNoID0gY3R4LiR3YXRjaChleHByZXNzaW9uLCBkZWJvdW5jZWRGbik7XFxuICAgICAgdGhpcy53YXRjaGVycy5wdXNoKHtcXG4gICAgICAgIHRhZzogJ2lucHV0X21vZGVsJyxcXG4gICAgICAgIHVud2F0Y2g6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdGhpcyQxLnZtLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdW53YXRjaCgpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG5cXG4gICAgICAvLyBmaWx0ZXIgb3V0IGlucHV0IGV2ZW50IHdoZW4gd2UgYXJlIHdhdGNoaW5nIGZyb20gdGhlIGNvbnRleHQgdm0uXFxuICAgICAgaWYgKHdhdGNoQ3R4Vm0pIHtcXG4gICAgICAgIGV2ZW50cyA9IGV2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUgIT09IGlucHV0RXZlbnQ7IH0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gQWRkIGV2ZW50cy5cXG4gIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XFxuICAgIHZhciBkZWJvdW5jZWRGbiA9IGRlYm91bmNlKGZuLCB0aGlzJDEuZGVsYXlbZV0sIHRva2VuKTtcXG5cXG4gICAgdGhpcyQxLl9hZGRDb21wb25lbnRFdmVudExpc3RlbmVyKGUsIGRlYm91bmNlZEZuKTtcXG4gICAgdGhpcyQxLl9hZGRIVE1MRXZlbnRMaXN0ZW5lcihlLCBkZWJvdW5jZWRGbik7XFxuICB9KTtcXG59O1xcblxcbkZpZWxkLnByb3RvdHlwZS5fYWRkQ29tcG9uZW50RXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIF9hZGRDb21wb25lbnRFdmVudExpc3RlbmVyIChldnQsIHZhbGlkYXRlKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgaWYgKCF0aGlzLmNvbXBvbmVudEluc3RhbmNlKSB7IHJldHVybjsgfVxcblxcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZS4kb24oZXZ0LCB2YWxpZGF0ZSk7XFxuICB0aGlzLndhdGNoZXJzLnB1c2goe1xcbiAgICB0YWc6ICdpbnB1dF92dWUnLFxcbiAgICB1bndhdGNoOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdGhpcyQxLmNvbXBvbmVudEluc3RhbmNlLiRvZmYoZXZ0LCB2YWxpZGF0ZSk7XFxuICAgIH1cXG4gIH0pO1xcbn07XFxuXFxuRmllbGQucHJvdG90eXBlLl9hZGRIVE1MRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIF9hZGRIVE1MRXZlbnRMaXN0ZW5lciAoZXZ0LCB2YWxpZGF0ZSkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIGlmICghdGhpcy5lbCB8fCB0aGlzLmNvbXBvbmVudEluc3RhbmNlKSB7IHJldHVybjsgfVxcblxcbiAgLy8gbGlzdGVuIGZvciB0aGUgY3VycmVudCBlbGVtZW50LlxcbiAgdmFyIGFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGVsKSB7XFxuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGV2dCwgdmFsaWRhdGUpO1xcbiAgICB0aGlzJDEud2F0Y2hlcnMucHVzaCh7XFxuICAgICAgdGFnOiAnaW5wdXRfbmF0aXZlJyxcXG4gICAgICB1bndhdGNoOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgdmFsaWRhdGUpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9O1xcblxcbiAgYWRkTGlzdGVuZXIodGhpcy5lbCk7XFxuICBpZiAoIWlzQ2hlY2tib3hPclJhZGlvSW5wdXQodGhpcy5lbCkpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgdmFyIGVscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoKFxcXCJpbnB1dFtuYW1lPVxcXFxcXFwiXFxcIiArICh0aGlzLmVsLm5hbWUpICsgXFxcIlxcXFxcXFwiXVxcXCIpKTtcXG4gIHRvQXJyYXkoZWxzKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xcbiAgICAvLyBza2lwIGlmIGl0IGlzIGFkZGVkIGJ5IHYtdmFsaWRhdGUgYW5kIGlzIG5vdCB0aGUgY3VycmVudCBlbGVtZW50LlxcbiAgICBpZiAoZWwuX3ZlZVZhbGlkYXRlSWQgJiYgZWwgIT09IHRoaXMkMS5lbCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBhZGRMaXN0ZW5lcihlbCk7XFxuICB9KTtcXG59O1xcblxcbi8qKlxcbiAqIFVwZGF0ZXMgYXJpYSBhdHRyaWJ1dGVzIG9uIHRoZSBlbGVtZW50LlxcbiAqL1xcbkZpZWxkLnByb3RvdHlwZS51cGRhdGVBcmlhQXR0cnMgPSBmdW5jdGlvbiB1cGRhdGVBcmlhQXR0cnMgKCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIGlmICghdGhpcy5hcmlhIHx8ICF0aGlzLmVsIHx8ICFpc0NhbGxhYmxlKHRoaXMuZWwuc2V0QXR0cmlidXRlKSkgeyByZXR1cm47IH1cXG5cXG4gIHZhciBhcHBseUFyaWFBdHRycyA9IGZ1bmN0aW9uIChlbCkge1xcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtcmVxdWlyZWQnLCB0aGlzJDEuaXNSZXF1aXJlZCA/ICd0cnVlJyA6ICdmYWxzZScpO1xcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsIHRoaXMkMS5mbGFncy5pbnZhbGlkID8gJ3RydWUnIDogJ2ZhbHNlJyk7XFxuICB9O1xcblxcbiAgaWYgKCFpc0NoZWNrYm94T3JSYWRpb0lucHV0KHRoaXMuZWwpKSB7XFxuICAgIGFwcGx5QXJpYUF0dHJzKHRoaXMuZWwpO1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICB2YXIgZWxzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgoXFxcImlucHV0W25hbWU9XFxcXFxcXCJcXFwiICsgKHRoaXMuZWwubmFtZSkgKyBcXFwiXFxcXFxcXCJdXFxcIikpO1xcbiAgdG9BcnJheShlbHMpLmZvckVhY2goYXBwbHlBcmlhQXR0cnMpO1xcbn07XFxuXFxuLyoqXFxuICogVXBkYXRlcyB0aGUgY3VzdG9tIHZhbGlkaXR5IGZvciB0aGUgZmllbGQuXFxuICovXFxuRmllbGQucHJvdG90eXBlLnVwZGF0ZUN1c3RvbVZhbGlkaXR5ID0gZnVuY3Rpb24gdXBkYXRlQ3VzdG9tVmFsaWRpdHkgKCkge1xcbiAgaWYgKCF0aGlzLnZhbGlkaXR5IHx8ICF0aGlzLmVsIHx8ICFpc0NhbGxhYmxlKHRoaXMuZWwuc2V0Q3VzdG9tVmFsaWRpdHkpIHx8ICF0aGlzLnZhbGlkYXRvci5lcnJvcnMpIHsgcmV0dXJuOyB9XFxuXFxuICB0aGlzLmVsLnNldEN1c3RvbVZhbGlkaXR5KHRoaXMuZmxhZ3MudmFsaWQgPyAnJyA6ICh0aGlzLnZhbGlkYXRvci5lcnJvcnMuZmlyc3RCeUlkKHRoaXMuaWQpIHx8ICcnKSk7XFxufTtcXG5cXG4vKipcXG4gKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMuXFxuICovXFxuRmllbGQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95ICgpIHtcXG4gIC8vIGlnbm9yZSB0aGUgcmVzdWx0IG9mIGFueSBvbmdvaW5nIHZhbGlkYXRpb24uXFxuICBpZiAodGhpcy5fY2FuY2VsbGF0aW9uVG9rZW4pIHtcXG4gICAgdGhpcy5fY2FuY2VsbGF0aW9uVG9rZW4uY2FuY2VsbGVkID0gdHJ1ZTtcXG4gIH1cXG5cXG4gIHRoaXMudW53YXRjaCgpO1xcbiAgdGhpcy5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5maWVsZC5kZXN0cm95KCk7IH0pO1xcbiAgdGhpcy5kZXBlbmRlbmNpZXMgPSBbXTtcXG59O1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBGaWVsZC5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQxICk7XFxuXFxuLy8gXFxuXFxudmFyIEZpZWxkQmFnID0gZnVuY3Rpb24gRmllbGRCYWcgKGl0ZW1zKSB7XFxuICBpZiAoIGl0ZW1zID09PSB2b2lkIDAgKSBpdGVtcyA9IFtdO1xcblxcbiAgdGhpcy5pdGVtcyA9IGl0ZW1zIHx8IFtdO1xcbiAgdGhpcy5pdGVtc0J5SWQgPSB0aGlzLml0ZW1zLnJlZHVjZShmdW5jdGlvbiAoaXRlbXNCeUlkLCBpdGVtKSB7XFxuICAgIGl0ZW1zQnlJZFtpdGVtLmlkXSA9IGl0ZW07XFxuICAgIHJldHVybiBpdGVtc0J5SWQ7XFxuICB9LCB7fSk7XFxufTtcXG5cXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzJDIgPSB7IGxlbmd0aDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xcblxcbkZpZWxkQmFnLnByb3RvdHlwZVt0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nID8gU3ltYm9sLml0ZXJhdG9yIDogJ0BAaXRlcmF0b3InXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB2YXIgaW5kZXggPSAwO1xcbiAgcmV0dXJuIHtcXG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiB7IHZhbHVlOiB0aGlzJDEuaXRlbXNbaW5kZXgrK10sIGRvbmU6IGluZGV4ID4gdGhpcyQxLml0ZW1zLmxlbmd0aCB9O1xcbiAgICB9XFxuICB9O1xcbn07XFxuXFxuLyoqXFxuICogR2V0cyB0aGUgY3VycmVudCBpdGVtcyBsZW5ndGguXFxuICovXFxuXFxucHJvdG90eXBlQWNjZXNzb3JzJDIubGVuZ3RoLmdldCA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aDtcXG59O1xcblxcbi8qKlxcbiAqIEZpbmRzIHRoZSBmaXJzdCBmaWVsZCB0aGF0IG1hdGNoZXMgdGhlIHByb3ZpZGVkIG1hdGNoZXIgb2JqZWN0LlxcbiAqL1xcbkZpZWxkQmFnLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gZmluZCQxIChtYXRjaGVyKSB7XFxuICByZXR1cm4gZmluZCh0aGlzLml0ZW1zLCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5tYXRjaGVzKG1hdGNoZXIpOyB9KTtcXG59O1xcblxcbi8qKlxcbiAqIEZpbmRzIHRoZSBmaWVsZCB3aXRoIHRoZSBnaXZlbiBpZCwgdXNpbmcgYSBwbGFpbiBvYmplY3QgYXMgYSBtYXAgdG8gbGlua1xcbiAqIGlkcyB0byBpdGVtcyBmYXN0ZXIgdGhhbiBieSBsb29waW5nIG92ZXIgdGhlIGFycmF5IGFuZCBtYXRjaGluZy5cXG4gKi9cXG5GaWVsZEJhZy5wcm90b3R5cGUuZmluZEJ5SWQgPSBmdW5jdGlvbiBmaW5kQnlJZCAoaWQpIHtcXG4gIHJldHVybiB0aGlzLml0ZW1zQnlJZFtpZF0gfHwgbnVsbDtcXG59O1xcblxcbi8qKlxcbiAqIEZpbHRlcnMgdGhlIGl0ZW1zIGRvd24gdG8gdGhlIG1hdGNoZWQgZmllbGRzLlxcbiAqL1xcbkZpZWxkQmFnLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKG1hdGNoZXIpIHtcXG4gIC8vIG11bHRpcGxlIG1hdGNoZXJzIHRvIGJlIHRyaWVkLlxcbiAgaWYgKEFycmF5LmlzQXJyYXkobWF0Y2hlcikpIHtcXG4gICAgcmV0dXJuIHRoaXMuaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBtYXRjaGVyLnNvbWUoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIGl0ZW0ubWF0Y2hlcyhtKTsgfSk7IH0pO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXMuaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLm1hdGNoZXMobWF0Y2hlcik7IH0pO1xcbn07XFxuXFxuLyoqXFxuICogTWFwcyB0aGUgZmllbGQgaXRlbXMgdXNpbmcgdGhlIG1hcHBpbmcgZnVuY3Rpb24uXFxuICovXFxuRmllbGRCYWcucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAobWFwcGVyKSB7XFxuICByZXR1cm4gdGhpcy5pdGVtcy5tYXAobWFwcGVyKTtcXG59O1xcblxcbi8qKlxcbiAqIEZpbmRzIGFuZCByZW1vdmVzIHRoZSBmaXJzdCBmaWVsZCB0aGF0IG1hdGNoZXMgdGhlIHByb3ZpZGVkIG1hdGNoZXIgb2JqZWN0LCByZXR1cm5zIHRoZSByZW1vdmVkIGl0ZW0uXFxuICovXFxuRmllbGRCYWcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAobWF0Y2hlcikge1xcbiAgdmFyIGl0ZW0gPSBudWxsO1xcbiAgaWYgKG1hdGNoZXIgaW5zdGFuY2VvZiBGaWVsZCkge1xcbiAgICBpdGVtID0gbWF0Y2hlcjtcXG4gIH0gZWxzZSB7XFxuICAgIGl0ZW0gPSB0aGlzLmZpbmQobWF0Y2hlcik7XFxuICB9XFxuXFxuICBpZiAoIWl0ZW0pIHsgcmV0dXJuIG51bGw7IH1cXG5cXG4gIHZhciBpbmRleCA9IHRoaXMuaXRlbXMuaW5kZXhPZihpdGVtKTtcXG4gIHRoaXMuaXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcXG4gIGRlbGV0ZSB0aGlzLml0ZW1zQnlJZFtpdGVtLmlkXTtcXG5cXG4gIHJldHVybiBpdGVtO1xcbn07XFxuXFxuLyoqXFxuICogQWRkcyBhIGZpZWxkIGl0ZW0gdG8gdGhlIGxpc3QuXFxuICovXFxuRmllbGRCYWcucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChpdGVtKSB7XFxuICBpZiAoISAoaXRlbSBpbnN0YW5jZW9mIEZpZWxkKSkge1xcbiAgICB0aHJvdyBjcmVhdGVFcnJvcignRmllbGRCYWcgb25seSBhY2NlcHRzIGluc3RhbmNlcyBvZiBGaWVsZCB0aGF0IGhhcyBhbiBpZCBkZWZpbmVkLicpO1xcbiAgfVxcblxcbiAgaWYgKCFpdGVtLmlkKSB7XFxuICAgIHRocm93IGNyZWF0ZUVycm9yKCdGaWVsZCBpZCBtdXN0IGJlIGRlZmluZWQuJyk7XFxuICB9XFxuXFxuICBpZiAodGhpcy5maW5kQnlJZChpdGVtLmlkKSkge1xcbiAgICB0aHJvdyBjcmVhdGVFcnJvcigoXFxcIkZpZWxkIHdpdGggaWQgXFxcIiArIChpdGVtLmlkKSArIFxcXCIgaXMgYWxyZWFkeSBhZGRlZC5cXFwiKSk7XFxuICB9XFxuXFxuICB0aGlzLml0ZW1zLnB1c2goaXRlbSk7XFxuICB0aGlzLml0ZW1zQnlJZFtpdGVtLmlkXSA9IGl0ZW07XFxufTtcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggRmllbGRCYWcucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMiApO1xcblxcbnZhciBTY29wZWRWYWxpZGF0b3IgPSBmdW5jdGlvbiBTY29wZWRWYWxpZGF0b3IgKGJhc2UsIHZtKSB7XFxuICB0aGlzLmlkID0gdm0uX3VpZDtcXG4gIHRoaXMuX2Jhc2UgPSBiYXNlO1xcbiAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XFxuXFxuICAvLyBjcmVhdGUgYSBtaXJyb3IgYmFnIHdpdGggbGltaXRlZCBjb21wb25lbnQgc2NvcGUuXFxuICB0aGlzLmVycm9ycyA9IG5ldyBFcnJvckJhZyhiYXNlLmVycm9ycywgdGhpcy5pZCk7XFxufTtcXG5cXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzJDMgPSB7IGZsYWdzOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHJ1bGVzOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGZpZWxkczogeyBjb25maWd1cmFibGU6IHRydWUgfSxkaWN0aW9uYXJ5OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGxvY2FsZTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xcblxcbnByb3RvdHlwZUFjY2Vzc29ycyQzLmZsYWdzLmdldCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICByZXR1cm4gdGhpcy5fYmFzZS5maWVsZHMuaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLnZtSWQgPT09IHRoaXMkMS5pZDsgfSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGZpZWxkKSB7XFxuICAgIGlmIChmaWVsZC5zY29wZSkge1xcbiAgICAgIGlmICghYWNjWyhcXFwiJFxcXCIgKyAoZmllbGQuc2NvcGUpKV0pIHtcXG4gICAgICAgIGFjY1soXFxcIiRcXFwiICsgKGZpZWxkLnNjb3BlKSldID0ge307XFxuICAgICAgfVxcblxcbiAgICAgIGFjY1soXFxcIiRcXFwiICsgKGZpZWxkLnNjb3BlKSldW2ZpZWxkLm5hbWVdID0gZmllbGQuZmxhZ3M7XFxuICAgIH1cXG5cXG4gICAgYWNjW2ZpZWxkLm5hbWVdID0gZmllbGQuZmxhZ3M7XFxuXFxuICAgIHJldHVybiBhY2M7XFxuICB9LCB7fSk7XFxufTtcXG5cXG5wcm90b3R5cGVBY2Nlc3NvcnMkMy5ydWxlcy5nZXQgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gdGhpcy5fYmFzZS5ydWxlcztcXG59O1xcblxcbnByb3RvdHlwZUFjY2Vzc29ycyQzLmZpZWxkcy5nZXQgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gbmV3IEZpZWxkQmFnKHRoaXMuX2Jhc2UuZmllbGRzLmZpbHRlcih7IHZtSWQ6IHRoaXMuaWQgfSkpO1xcbn07XFxuXFxucHJvdG90eXBlQWNjZXNzb3JzJDMuZGljdGlvbmFyeS5nZXQgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gdGhpcy5fYmFzZS5kaWN0aW9uYXJ5O1xcbn07XFxuXFxucHJvdG90eXBlQWNjZXNzb3JzJDMubG9jYWxlLmdldCA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiB0aGlzLl9iYXNlLmxvY2FsZTtcXG59O1xcblxcbnByb3RvdHlwZUFjY2Vzc29ycyQzLmxvY2FsZS5zZXQgPSBmdW5jdGlvbiAodmFsKSB7XFxuICB0aGlzLl9iYXNlLmxvY2FsZSA9IHZhbDtcXG59O1xcblxcblNjb3BlZFZhbGlkYXRvci5wcm90b3R5cGUubG9jYWxpemUgPSBmdW5jdGlvbiBsb2NhbGl6ZSAoKSB7XFxuICAgIHZhciByZWY7XFxuXFxuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XFxuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XFxuICByZXR1cm4gKHJlZiA9IHRoaXMuX2Jhc2UpLmxvY2FsaXplLmFwcGx5KHJlZiwgYXJncyk7XFxufTtcXG5cXG5TY29wZWRWYWxpZGF0b3IucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XFxuICAgIHZhciByZWY7XFxuXFxuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XFxuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XFxuICByZXR1cm4gKHJlZiA9IHRoaXMuX2Jhc2UpLnVwZGF0ZS5hcHBseShyZWYsIGFyZ3MpO1xcbn07XFxuXFxuU2NvcGVkVmFsaWRhdG9yLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiBhdHRhY2ggKG9wdHMpIHtcXG4gIHZhciBhdHRhY2hPcHRzID0gYXNzaWduKHt9LCBvcHRzLCB7IHZtSWQ6IHRoaXMuaWQgfSk7XFxuXFxuICByZXR1cm4gdGhpcy5fYmFzZS5hdHRhY2goYXR0YWNoT3B0cyk7XFxufTtcXG5cXG5TY29wZWRWYWxpZGF0b3IucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UgKCkge1xcbiAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcXG59O1xcblxcblNjb3BlZFZhbGlkYXRvci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gcmVzdW1lICgpIHtcXG4gIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xcbn07XFxuXFxuU2NvcGVkVmFsaWRhdG9yLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKHJ1bGVOYW1lKSB7XFxuICByZXR1cm4gdGhpcy5fYmFzZS5yZW1vdmUocnVsZU5hbWUpO1xcbn07XFxuXFxuU2NvcGVkVmFsaWRhdG9yLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiBkZXRhY2ggKG5hbWUsIHNjb3BlKSB7XFxuICByZXR1cm4gdGhpcy5fYmFzZS5kZXRhY2gobmFtZSwgc2NvcGUsIHRoaXMuaWQpO1xcbn07XFxuXFxuU2NvcGVkVmFsaWRhdG9yLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQgKCkge1xcbiAgICB2YXIgcmVmO1xcblxcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xcbiAgcmV0dXJuIChyZWYgPSB0aGlzLl9iYXNlKS5leHRlbmQuYXBwbHkocmVmLCBhcmdzKTtcXG59O1xcblxcblNjb3BlZFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSAoZGVzY3JpcHRvciwgdmFsdWUsIG9wdHMpIHtcXG4gICAgaWYgKCBvcHRzID09PSB2b2lkIDAgKSBvcHRzID0ge307XFxuXFxuICBpZiAodGhpcy5fcGF1c2VkKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7IH1cXG5cXG4gIHJldHVybiB0aGlzLl9iYXNlLnZhbGlkYXRlKGRlc2NyaXB0b3IsIHZhbHVlLCBhc3NpZ24oe30sIHsgdm1JZDogdGhpcy5pZCB9LCBvcHRzIHx8IHt9KSk7XFxufTtcXG5cXG5TY29wZWRWYWxpZGF0b3IucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeSAoKSB7XFxuICAgIHZhciByZWY7XFxuXFxuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XFxuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XFxuICByZXR1cm4gKHJlZiA9IHRoaXMuX2Jhc2UpLnZlcmlmeS5hcHBseShyZWYsIGFyZ3MpO1xcbn07XFxuXFxuU2NvcGVkVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZUFsbCA9IGZ1bmN0aW9uIHZhbGlkYXRlQWxsICh2YWx1ZXMsIG9wdHMpIHtcXG4gICAgaWYgKCBvcHRzID09PSB2b2lkIDAgKSBvcHRzID0ge307XFxuXFxuICBpZiAodGhpcy5fcGF1c2VkKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7IH1cXG5cXG4gIHJldHVybiB0aGlzLl9iYXNlLnZhbGlkYXRlQWxsKHZhbHVlcywgYXNzaWduKHt9LCB7IHZtSWQ6IHRoaXMuaWQgfSwgb3B0cyB8fCB7fSkpO1xcbn07XFxuXFxuU2NvcGVkVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZVNjb3BlcyA9IGZ1bmN0aW9uIHZhbGlkYXRlU2NvcGVzIChvcHRzKSB7XFxuICAgIGlmICggb3B0cyA9PT0gdm9pZCAwICkgb3B0cyA9IHt9O1xcblxcbiAgaWYgKHRoaXMuX3BhdXNlZCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpOyB9XFxuXFxuICByZXR1cm4gdGhpcy5fYmFzZS52YWxpZGF0ZVNjb3Blcyhhc3NpZ24oe30sIHsgdm1JZDogdGhpcy5pZCB9LCBvcHRzIHx8IHt9KSk7XFxufTtcXG5cXG5TY29wZWRWYWxpZGF0b3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95ICgpIHtcXG4gIGRlbGV0ZSB0aGlzLmlkO1xcbiAgZGVsZXRlIHRoaXMuX2Jhc2U7XFxufTtcXG5cXG5TY29wZWRWYWxpZGF0b3IucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQgKG1hdGNoZXIpIHtcXG4gIHJldHVybiB0aGlzLl9iYXNlLnJlc2V0KE9iamVjdC5hc3NpZ24oe30sIG1hdGNoZXIgfHwge30sIHsgdm1JZDogdGhpcy5pZCB9KSk7XFxufTtcXG5cXG5TY29wZWRWYWxpZGF0b3IucHJvdG90eXBlLmZsYWcgPSBmdW5jdGlvbiBmbGFnICgpIHtcXG4gICAgdmFyIHJlZjtcXG5cXG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcXG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcXG4gIHJldHVybiAocmVmID0gdGhpcy5fYmFzZSkuZmxhZy5hcHBseShyZWYsIGFyZ3MuY29uY2F0KCBbdGhpcy5pZF0gKSk7XFxufTtcXG5cXG5TY29wZWRWYWxpZGF0b3IucHJvdG90eXBlLl9yZXNvbHZlRmllbGQgPSBmdW5jdGlvbiBfcmVzb2x2ZUZpZWxkICgpIHtcXG4gICAgdmFyIHJlZjtcXG5cXG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcXG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcXG4gIHJldHVybiAocmVmID0gdGhpcy5fYmFzZSkuX3Jlc29sdmVGaWVsZC5hcHBseShyZWYsIGFyZ3MpO1xcbn07XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFNjb3BlZFZhbGlkYXRvci5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQzICk7XFxuXFxudmFyIFZBTElEQVRPUiA9IG51bGw7XFxuXFxudmFyIGdldFZhbGlkYXRvciA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiBWQUxJREFUT1I7XFxufTtcXG5cXG52YXIgc2V0VmFsaWRhdG9yID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICBWQUxJREFUT1IgPSB2YWx1ZTtcXG5cXG4gIHJldHVybiB2YWx1ZTtcXG59O1xcblxcbi8vIFxcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBhIHBhcmVudCB2YWxpZGF0b3IgaW5zdGFuY2Ugd2FzIHJlcXVlc3RlZC5cXG4gKi9cXG52YXIgcmVxdWVzdHNWYWxpZGF0b3IgPSBmdW5jdGlvbiAoaW5qZWN0aW9ucykge1xcbiAgaWYgKGlzT2JqZWN0KGluamVjdGlvbnMpICYmIGluamVjdGlvbnMuJHZhbGlkYXRvcikge1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH1cXG5cXG4gIHJldHVybiBmYWxzZTtcXG59O1xcblxcbnZhciBtaXhpbiA9IHtcXG4gIHByb3ZpZGU6IGZ1bmN0aW9uIHByb3ZpZGUgKCkge1xcbiAgICBpZiAodGhpcy4kdmFsaWRhdG9yICYmICFpc0J1aWx0SW5Db21wb25lbnQodGhpcy4kdm5vZGUpKSB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgICR2YWxpZGF0b3I6IHRoaXMuJHZhbGlkYXRvclxcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHt9O1xcbiAgfSxcXG4gIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gYmVmb3JlQ3JlYXRlICgpIHtcXG4gICAgLy8gaWYgYnVpbHQgaW4gZG8gbm90aGluZy5cXG4gICAgaWYgKGlzQnVpbHRJbkNvbXBvbmVudCh0aGlzLiR2bm9kZSkgfHwgdGhpcy4kb3B0aW9ucy4kX192ZWVJbmplY3QgPT09IGZhbHNlKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIC8vIGlmIGl0cyBhIHJvb3QgaW5zdGFuY2Ugc2V0IHRoZSBjb25maWcgaWYgaXQgZXhpc3RzLlxcbiAgICBpZiAoIXRoaXMuJHBhcmVudCkge1xcbiAgICAgIHNldENvbmZpZyh0aGlzLiRvcHRpb25zLiRfdmVlVmFsaWRhdGUgfHwge30pO1xcbiAgICB9XFxuXFxuICAgIHZhciBvcHRpb25zID0gcmVzb2x2ZUNvbmZpZyh0aGlzKTtcXG5cXG4gICAgLy8gaWYgaXRzIGEgcm9vdCBpbnN0YW5jZSwgaW5qZWN0IGFueXdheXMsIG9yIGlmIGl0IHJlcXVlc3RlZCBhIG5ldyBpbnN0YW5jZS5cXG4gICAgaWYgKCF0aGlzLiRwYXJlbnQgfHwgKHRoaXMuJG9wdGlvbnMuJF92ZWVWYWxpZGF0ZSAmJiAvbmV3Ly50ZXN0KHRoaXMuJG9wdGlvbnMuJF92ZWVWYWxpZGF0ZS52YWxpZGF0b3IpKSkge1xcbiAgICAgIHRoaXMuJHZhbGlkYXRvciA9IG5ldyBTY29wZWRWYWxpZGF0b3IoZ2V0VmFsaWRhdG9yKCksIHRoaXMpO1xcbiAgICB9XFxuXFxuICAgIHZhciByZXF1ZXN0ZWQgPSByZXF1ZXN0c1ZhbGlkYXRvcih0aGlzLiRvcHRpb25zLmluamVjdCk7XFxuXFxuICAgIC8vIGlmIGF1dG9tYXRpYyBpbmplY3Rpb24gaXMgZW5hYmxlZCBhbmQgbm8gaW5zdGFuY2Ugd2FzIHJlcXVlc3RlZC5cXG4gICAgaWYgKCEgdGhpcy4kdmFsaWRhdG9yICYmIG9wdGlvbnMuaW5qZWN0ICYmICFyZXF1ZXN0ZWQpIHtcXG4gICAgICB0aGlzLiR2YWxpZGF0b3IgPSBuZXcgU2NvcGVkVmFsaWRhdG9yKGdldFZhbGlkYXRvcigpLCB0aGlzKTtcXG4gICAgfVxcblxcbiAgICAvLyBkb24ndCBpbmplY3QgZXJyb3JzIG9yIGZpZWxkQmFnIGFzIG5vIHZhbGlkYXRvciB3YXMgcmVzb2x2ZWQuXFxuICAgIGlmICghcmVxdWVzdGVkICYmICF0aGlzLiR2YWxpZGF0b3IpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgLy8gVGhlcmUgaXMgYSB2YWxpZGF0b3IgYnV0IGl0IGlzbid0IGluamVjdGVkLCBtYXJrIGFzIHJlYWN0aXZlLlxcbiAgICBpZiAoIXJlcXVlc3RlZCAmJiB0aGlzLiR2YWxpZGF0b3IpIHtcXG4gICAgICB2YXIgVnVlID0gdGhpcy4kb3B0aW9ucy5fYmFzZTsgLy8gdGhlIHZ1ZSBjb25zdHJ1Y3Rvci5cXG4gICAgICBWdWUudXRpbC5kZWZpbmVSZWFjdGl2ZSh0aGlzLiR2YWxpZGF0b3IsICdlcnJvcnMnLCB0aGlzLiR2YWxpZGF0b3IuZXJyb3JzKTtcXG4gICAgfVxcblxcbiAgICBpZiAoIXRoaXMuJG9wdGlvbnMuY29tcHV0ZWQpIHtcXG4gICAgICB0aGlzLiRvcHRpb25zLmNvbXB1dGVkID0ge307XFxuICAgIH1cXG5cXG4gICAgdGhpcy4kb3B0aW9ucy5jb21wdXRlZFtvcHRpb25zLmVycm9yQmFnTmFtZSB8fCAnZXJyb3JzJ10gPSBmdW5jdGlvbiBlcnJvckJhZ0dldHRlciAoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuJHZhbGlkYXRvci5lcnJvcnM7XFxuICAgIH07XFxuICAgIHRoaXMuJG9wdGlvbnMuY29tcHV0ZWRbb3B0aW9ucy5maWVsZHNCYWdOYW1lIHx8ICdmaWVsZHMnXSA9IGZ1bmN0aW9uIGZpZWxkQmFnR2V0dGVyICgpIHtcXG4gICAgICByZXR1cm4gdGhpcy4kdmFsaWRhdG9yLmZpZWxkcy5pdGVtcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZmllbGQpIHtcXG4gICAgICAgIGlmIChmaWVsZC5zY29wZSkge1xcbiAgICAgICAgICBpZiAoIWFjY1soXFxcIiRcXFwiICsgKGZpZWxkLnNjb3BlKSldKSB7XFxuICAgICAgICAgICAgYWNjWyhcXFwiJFxcXCIgKyAoZmllbGQuc2NvcGUpKV0gPSB7fTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhY2NbKFxcXCIkXFxcIiArIChmaWVsZC5zY29wZSkpXVtmaWVsZC5uYW1lXSA9IGZpZWxkLmZsYWdzO1xcblxcbiAgICAgICAgICByZXR1cm4gYWNjO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYWNjW2ZpZWxkLm5hbWVdID0gZmllbGQuZmxhZ3M7XFxuXFxuICAgICAgICByZXR1cm4gYWNjO1xcbiAgICAgIH0sIHt9KTtcXG4gICAgfTtcXG4gIH0sXFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95ICgpIHtcXG4gICAgaWYgKHRoaXMuJHZhbGlkYXRvciAmJiB0aGlzLl91aWQgPT09IHRoaXMuJHZhbGlkYXRvci5pZCkge1xcbiAgICAgIHRoaXMuJHZhbGlkYXRvci5lcnJvcnMuY2xlYXIoKTsgLy8gcmVtb3ZlIGVycm9ycyBnZW5lcmF0ZWQgYnkgdGhpcyBjb21wb25lbnQuXFxuICAgIH1cXG4gIH1cXG59O1xcblxcbi8vIFxcblxcbi8qKlxcbiAqIEZpbmRzIHRoZSByZXF1ZXN0ZWQgZmllbGQgYnkgaWQgZnJvbSB0aGUgY29udGV4dCBvYmplY3QuXFxuICovXFxuZnVuY3Rpb24gZmluZEZpZWxkIChlbCwgY29udGV4dCkge1xcbiAgaWYgKCFjb250ZXh0IHx8ICFjb250ZXh0LiR2YWxpZGF0b3IpIHtcXG4gICAgcmV0dXJuIG51bGw7XFxuICB9XFxuXFxuICByZXR1cm4gY29udGV4dC4kdmFsaWRhdG9yLmZpZWxkcy5maW5kQnlJZChlbC5fdmVlVmFsaWRhdGVJZCk7XFxufVxcbnZhciBkaXJlY3RpdmUgPSB7XFxuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgYmluZGluZywgdm5vZGUpIHtcXG4gICAgdmFyIHZhbGlkYXRvciA9IHZub2RlLmNvbnRleHQuJHZhbGlkYXRvcjtcXG4gICAgaWYgKCF2YWxpZGF0b3IpIHtcXG4gICAgICBpZiAodHJ1ZSkge1xcbiAgICAgICAgd2FybihcXFwiTm8gdmFsaWRhdG9yIGluc3RhbmNlIGlzIHByZXNlbnQgb24gdm0sIGRpZCB5b3UgZm9yZ2V0IHRvIGluamVjdCAnJHZhbGlkYXRvcic/XFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB2YXIgZmllbGRPcHRpb25zID0gUmVzb2x2ZXIuZ2VuZXJhdGUoZWwsIGJpbmRpbmcsIHZub2RlKTtcXG4gICAgdmFsaWRhdG9yLmF0dGFjaChmaWVsZE9wdGlvbnMpO1xcbiAgfSxcXG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XFxuICAgIHZhciBmaWVsZCA9IGZpbmRGaWVsZChlbCwgdm5vZGUuY29udGV4dCk7XFxuICAgIHZhciBzY29wZSA9IFJlc29sdmVyLnJlc29sdmVTY29wZShlbCwgYmluZGluZywgdm5vZGUpO1xcblxcbiAgICAvLyBza2lwIGlmIHNjb3BlIGhhc24ndCBjaGFuZ2VkLlxcbiAgICBpZiAoIWZpZWxkIHx8IHNjb3BlID09PSBmaWVsZC5zY29wZSkgeyByZXR1cm47IH1cXG5cXG4gICAgLy8gb25seSB1cGRhdGUgc2NvcGUuXFxuICAgIGZpZWxkLnVwZGF0ZSh7IHNjb3BlOiBzY29wZSB9KTtcXG5cXG4gICAgLy8gYWxsb3dzIHRoZSBmaWVsZCB0byByZS1ldmFsdWF0ZWQgb25jZSBtb3JlIGluIHRoZSB1cGRhdGUgaG9vay5cXG4gICAgZmllbGQudXBkYXRlZCA9IGZhbHNlO1xcbiAgfSxcXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgYmluZGluZywgdm5vZGUpIHtcXG4gICAgdmFyIGZpZWxkID0gZmluZEZpZWxkKGVsLCB2bm9kZS5jb250ZXh0KTtcXG5cXG4gICAgLy8gbWFrZSBzdXJlIHdlIGRvbid0IGRvIHVubmVjY2FzYXJ5IHdvcmsgaWYgbm8gaW1wb3J0YW50IGNoYW5nZSB3YXMgZG9uZS5cXG4gICAgaWYgKCFmaWVsZCB8fCAoZmllbGQudXBkYXRlZCAmJiBpc0VxdWFsKGJpbmRpbmcudmFsdWUsIGJpbmRpbmcub2xkVmFsdWUpKSkgeyByZXR1cm47IH1cXG4gICAgdmFyIHNjb3BlID0gUmVzb2x2ZXIucmVzb2x2ZVNjb3BlKGVsLCBiaW5kaW5nLCB2bm9kZSk7XFxuICAgIHZhciBydWxlcyA9IFJlc29sdmVyLnJlc29sdmVSdWxlcyhlbCwgYmluZGluZywgdm5vZGUpO1xcblxcbiAgICBmaWVsZC51cGRhdGUoe1xcbiAgICAgIHNjb3BlOiBzY29wZSxcXG4gICAgICBydWxlczogcnVsZXNcXG4gICAgfSk7XFxuICB9LFxcbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKGVsLCBiaW5kaW5nLCByZWYpIHtcXG4gICAgdmFyIGNvbnRleHQgPSByZWYuY29udGV4dDtcXG5cXG4gICAgdmFyIGZpZWxkID0gZmluZEZpZWxkKGVsLCBjb250ZXh0KTtcXG4gICAgaWYgKCFmaWVsZCkgeyByZXR1cm47IH1cXG5cXG4gICAgY29udGV4dC4kdmFsaWRhdG9yLmRldGFjaChmaWVsZCk7XFxuICB9XFxufTtcXG5cXG4vLyBcXG5cXG52YXIgVmFsaWRhdG9yID0gZnVuY3Rpb24gVmFsaWRhdG9yICh2YWxpZGF0aW9ucywgb3B0aW9ucywgcGx1Z2luQ29udGFpbmVyKSB7XFxuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7IGZhc3RFeGl0OiB0cnVlIH07XFxuICBpZiAoIHBsdWdpbkNvbnRhaW5lciA9PT0gdm9pZCAwICkgcGx1Z2luQ29udGFpbmVyID0gbnVsbDtcXG5cXG4gIHRoaXMuZXJyb3JzID0gbmV3IEVycm9yQmFnKCk7XFxuICB0aGlzLmZpZWxkcyA9IG5ldyBGaWVsZEJhZygpO1xcbiAgdGhpcy5fY3JlYXRlRmllbGRzKHZhbGlkYXRpb25zKTtcXG4gIHRoaXMucGF1c2VkID0gZmFsc2U7XFxuICB0aGlzLmZhc3RFeGl0ID0gIWlzTnVsbE9yVW5kZWZpbmVkKG9wdGlvbnMgJiYgb3B0aW9ucy5mYXN0RXhpdCkgPyBvcHRpb25zLmZhc3RFeGl0IDogdHJ1ZTtcXG4gIHRoaXMuJHZlZSA9IHBsdWdpbkNvbnRhaW5lciB8fCB7XFxuICAgIF92bToge1xcbiAgICAgICRuZXh0VGljazogZnVuY3Rpb24gKGNiKSB7IHJldHVybiBpc0NhbGxhYmxlKGNiKSA/IGNiKCkgOiBQcm9taXNlLnJlc29sdmUoKTsgfSxcXG4gICAgICAkZW1pdDogZnVuY3Rpb24gKCkge30sXFxuICAgICAgJG9mZjogZnVuY3Rpb24gKCkge31cXG4gICAgfVxcbiAgfTtcXG59O1xcblxcbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkNCA9IHsgcnVsZXM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sZGljdGlvbmFyeTogeyBjb25maWd1cmFibGU6IHRydWUgfSxmbGFnczogeyBjb25maWd1cmFibGU6IHRydWUgfSxsb2NhbGU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcXG52YXIgc3RhdGljQWNjZXNzb3JzJDEgPSB7IHJ1bGVzOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGRpY3Rpb25hcnk6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sbG9jYWxlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XFxuXFxuLyoqXFxuICogQGRlcHJlY2F0ZWRcXG4gKi9cXG5zdGF0aWNBY2Nlc3NvcnMkMS5ydWxlcy5nZXQgPSBmdW5jdGlvbiAoKSB7XFxuICBpZiAodHJ1ZSkge1xcbiAgICB3YXJuKCd0aGlzIGFjY2Vzc29yIHdpbGwgYmUgZGVwcmVjYXRlZCwgdXNlIGBpbXBvcnQgeyBydWxlcyB9IGZyb20gXFxcInZlZS12YWxpZGF0ZVxcXCJgIGluc3RlYWQuJyk7XFxuICB9XFxuXFxuICByZXR1cm4gUnVsZUNvbnRhaW5lci5ydWxlcztcXG59O1xcblxcbi8qKlxcbiAqIEBkZXByZWNhdGVkXFxuICovXFxucHJvdG90eXBlQWNjZXNzb3JzJDQucnVsZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xcbiAgaWYgKHRydWUpIHtcXG4gICAgd2FybigndGhpcyBhY2Nlc3NvciB3aWxsIGJlIGRlcHJlY2F0ZWQsIHVzZSBgaW1wb3J0IHsgcnVsZXMgfSBmcm9tIFxcXCJ2ZWUtdmFsaWRhdGVcXFwiYCBpbnN0ZWFkLicpO1xcbiAgfVxcblxcbiAgcmV0dXJuIFJ1bGVDb250YWluZXIucnVsZXM7XFxufTtcXG5cXG5wcm90b3R5cGVBY2Nlc3NvcnMkNC5kaWN0aW9uYXJ5LmdldCA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiBEaWN0aW9uYXJ5UmVzb2x2ZXIuZ2V0RHJpdmVyKCk7XFxufTtcXG5cXG5zdGF0aWNBY2Nlc3NvcnMkMS5kaWN0aW9uYXJ5LmdldCA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiBEaWN0aW9uYXJ5UmVzb2x2ZXIuZ2V0RHJpdmVyKCk7XFxufTtcXG5cXG5wcm90b3R5cGVBY2Nlc3NvcnMkNC5mbGFncy5nZXQgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gdGhpcy5maWVsZHMuaXRlbXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGZpZWxkKSB7XFxuICAgICAgdmFyIG9iajtcXG5cXG4gICAgaWYgKGZpZWxkLnNjb3BlKSB7XFxuICAgICAgYWNjWyhcXFwiJFxcXCIgKyAoZmllbGQuc2NvcGUpKV0gPSAoIG9iaiA9IHt9LCBvYmpbZmllbGQubmFtZV0gPSBmaWVsZC5mbGFncywgb2JqICk7XFxuXFxuICAgICAgcmV0dXJuIGFjYztcXG4gICAgfVxcblxcbiAgICBhY2NbZmllbGQubmFtZV0gPSBmaWVsZC5mbGFncztcXG5cXG4gICAgcmV0dXJuIGFjYztcXG4gIH0sIHt9KTtcXG59O1xcblxcbi8qKlxcbiAqIEdldHRlciBmb3IgdGhlIGN1cnJlbnQgbG9jYWxlLlxcbiAqL1xcbnByb3RvdHlwZUFjY2Vzc29ycyQ0LmxvY2FsZS5nZXQgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gVmFsaWRhdG9yLmxvY2FsZTtcXG59O1xcblxcbi8qKlxcbiAqIFNldHRlciBmb3IgdGhlIHZhbGlkYXRvciBsb2NhbGUuXFxuICovXFxucHJvdG90eXBlQWNjZXNzb3JzJDQubG9jYWxlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgVmFsaWRhdG9yLmxvY2FsZSA9IHZhbHVlO1xcbn07XFxuXFxuc3RhdGljQWNjZXNzb3JzJDEubG9jYWxlLmdldCA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiBEaWN0aW9uYXJ5UmVzb2x2ZXIuZ2V0RHJpdmVyKCkubG9jYWxlO1xcbn07XFxuXFxuLyoqXFxuICogU2V0dGVyIGZvciB0aGUgdmFsaWRhdG9yIGxvY2FsZS5cXG4gKi9cXG5zdGF0aWNBY2Nlc3NvcnMkMS5sb2NhbGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICB2YXIgaGFzQ2hhbmdlZCA9IHZhbHVlICE9PSBEaWN0aW9uYXJ5UmVzb2x2ZXIuZ2V0RHJpdmVyKCkubG9jYWxlO1xcbiAgRGljdGlvbmFyeVJlc29sdmVyLmdldERyaXZlcigpLmxvY2FsZSA9IHZhbHVlO1xcbiAgaWYgKGhhc0NoYW5nZWQgJiYgVmFsaWRhdG9yLiR2ZWUgJiYgVmFsaWRhdG9yLiR2ZWUuX3ZtKSB7XFxuICAgIFZhbGlkYXRvci4kdmVlLl92bS4kZW1pdCgnbG9jYWxlQ2hhbmdlZCcpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogU3RhdGljIGNvbnN0cnVjdG9yLlxcbiAqIEBkZXByZWNhdGVkXFxuICovXFxuVmFsaWRhdG9yLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSAodmFsaWRhdGlvbnMsIG9wdGlvbnMpIHtcXG4gIGlmICh0cnVlKSB7XFxuICAgIHdhcm4oJ1BsZWFzZSB1c2UgYG5ld2AgdG8gY3JlYXRlIG5ldyB2YWxpZGF0b3IgaW5zdGFuY2VzLicpO1xcbiAgfVxcblxcbiAgcmV0dXJuIG5ldyBWYWxpZGF0b3IodmFsaWRhdGlvbnMsIG9wdGlvbnMpO1xcbn07XFxuXFxuLyoqXFxuICogQWRkcyBhIGN1c3RvbSB2YWxpZGF0b3IgdG8gdGhlIGxpc3Qgb2YgdmFsaWRhdGlvbiBydWxlcy5cXG4gKi9cXG5WYWxpZGF0b3IuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kIChuYW1lLCB2YWxpZGF0b3IsIG9wdGlvbnMpIHtcXG4gICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XFxuXFxuICBWYWxpZGF0b3IuX2d1YXJkRXh0ZW5kKG5hbWUsIHZhbGlkYXRvcik7XFxuICAvLyBydWxlcyBpbXBvcnRlZCBmcm9tIHRoZSBtaW5pbWFsIGJ1bmRsZVxcbiAgLy8gd2lsbCBoYXZlIHRoZSBvcHRpb25zIGVtYmVkZGVkIGluIHRoZW1cXG4gIHZhciBtZXJnZWRPcHRzID0gdmFsaWRhdG9yLm9wdGlvbnMgfHwge307XFxuICBWYWxpZGF0b3IuX21lcmdlKG5hbWUsIHtcXG4gICAgdmFsaWRhdG9yOiB2YWxpZGF0b3IsXFxuICAgIHBhcmFtTmFtZXM6IChvcHRpb25zICYmIG9wdGlvbnMucGFyYW1OYW1lcykgfHwgdmFsaWRhdG9yLnBhcmFtTmFtZXMsXFxuICAgIG9wdGlvbnM6IGFzc2lnbih7IGhhc1RhcmdldDogZmFsc2UsIGltbWVkaWF0ZTogdHJ1ZSB9LCBtZXJnZWRPcHRzLCBvcHRpb25zIHx8IHt9KVxcbiAgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBSZW1vdmVzIGEgcnVsZSBmcm9tIHRoZSBsaXN0IG9mIHZhbGlkYXRvcnMuXFxuICogQGRlcHJlY2F0ZWRcXG4gKi9cXG5WYWxpZGF0b3IucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChuYW1lKSB7XFxuICBpZiAodHJ1ZSkge1xcbiAgICB3YXJuKCd0aGlzIG1ldGhvZCB3aWxsIGJlIGRlcHJlY2F0ZWQsIHlvdSBjYW4gc3RpbGwgb3ZlcnJpZGUgeW91ciBydWxlcyB3aXRoIGBleHRlbmRgJyk7XFxuICB9XFxuXFxuICBSdWxlQ29udGFpbmVyLnJlbW92ZShuYW1lKTtcXG59O1xcblxcbi8qKlxcbiAqIEFkZHMgYW5kIHNldHMgdGhlIGN1cnJlbnQgbG9jYWxlIGZvciB0aGUgdmFsaWRhdG9yLlxcbiovXFxuVmFsaWRhdG9yLnByb3RvdHlwZS5sb2NhbGl6ZSA9IGZ1bmN0aW9uIGxvY2FsaXplIChsYW5nLCBkaWN0aW9uYXJ5KSB7XFxuICBWYWxpZGF0b3IubG9jYWxpemUobGFuZywgZGljdGlvbmFyeSk7XFxufTtcXG5cXG4vKipcXG4gKiBBZGRzIGFuZCBzZXRzIHRoZSBjdXJyZW50IGxvY2FsZSBmb3IgdGhlIHZhbGlkYXRvci5cXG4gKi9cXG5WYWxpZGF0b3IubG9jYWxpemUgPSBmdW5jdGlvbiBsb2NhbGl6ZSAobGFuZywgZGljdGlvbmFyeSkge1xcbiAgICB2YXIgb2JqO1xcblxcbiAgaWYgKGlzT2JqZWN0KGxhbmcpKSB7XFxuICAgIERpY3Rpb25hcnlSZXNvbHZlci5nZXREcml2ZXIoKS5tZXJnZShsYW5nKTtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgLy8gbWVyZ2UgdGhlIGRpY3Rpb25hcnkuXFxuICBpZiAoZGljdGlvbmFyeSkge1xcbiAgICB2YXIgbG9jYWxlID0gbGFuZyB8fCBkaWN0aW9uYXJ5Lm5hbWU7XFxuICAgIGRpY3Rpb25hcnkgPSBhc3NpZ24oe30sIGRpY3Rpb25hcnkpO1xcbiAgICBEaWN0aW9uYXJ5UmVzb2x2ZXIuZ2V0RHJpdmVyKCkubWVyZ2UoKCBvYmogPSB7fSwgb2JqW2xvY2FsZV0gPSBkaWN0aW9uYXJ5LCBvYmogKSk7XFxuICB9XFxuXFxuICBpZiAobGFuZykge1xcbiAgICAvLyBzZXQgdGhlIGxvY2FsZS5cXG4gICAgVmFsaWRhdG9yLmxvY2FsZSA9IGxhbmc7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBSZWdpc3RlcnMgYSBmaWVsZCB0byBiZSB2YWxpZGF0ZWQuXFxuICovXFxuVmFsaWRhdG9yLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiBhdHRhY2ggKGZpZWxkT3B0cykge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIC8vIFdlIHNlYXJjaCBmb3IgYSBmaWVsZCB3aXRoIHRoZSBzYW1lIG5hbWUgJiBzY29wZSwgaGF2aW5nIHBlcnNpc3QgZW5hYmxlZFxcbiAgdmFyIG9sZEZpZWxkTWF0Y2hlciA9IHsgbmFtZTogZmllbGRPcHRzLm5hbWUsIHNjb3BlOiBmaWVsZE9wdHMuc2NvcGUsIHBlcnNpc3Q6IHRydWUgfTtcXG4gIHZhciBvbGRGaWVsZCA9IGZpZWxkT3B0cy5wZXJzaXN0ID8gdGhpcy5maWVsZHMuZmluZChvbGRGaWVsZE1hdGNoZXIpIDogbnVsbDtcXG5cXG4gIGlmIChvbGRGaWVsZCkge1xcbiAgICAvLyBXZSBrZWVwIHRoZSBmbGFncyBvZiB0aGUgb2xkIGZpZWxkLCB0aGVuIHdlIHJlbW92ZSBpdHMgaW5zdGFuY2VcXG4gICAgZmllbGRPcHRzLmZsYWdzID0gb2xkRmllbGQuZmxhZ3M7XFxuICAgIG9sZEZpZWxkLmRlc3Ryb3koKTtcXG4gICAgdGhpcy5maWVsZHMucmVtb3ZlKG9sZEZpZWxkKTtcXG4gIH1cXG5cXG4gIC8vIGZpeGVzIGluaXRpYWwgdmFsdWUgZGV0ZWN0aW9uIHdpdGggdi1tb2RlbCBhbmQgc2VsZWN0IGVsZW1lbnRzLlxcbiAgdmFyIHZhbHVlID0gZmllbGRPcHRzLmluaXRpYWxWYWx1ZTtcXG4gIHZhciBmaWVsZCA9IG5ldyBGaWVsZChmaWVsZE9wdHMpO1xcbiAgdGhpcy5maWVsZHMucHVzaChmaWVsZCk7XFxuXFxuICAvLyB2YWxpZGF0ZSB0aGUgZmllbGQgaW5pdGlhbGx5XFxuICBpZiAoZmllbGQuaW1tZWRpYXRlKSB7XFxuICAgIHRoaXMuJHZlZS5fdm0uJG5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS52YWxpZGF0ZSgoXFxcIiNcXFwiICsgKGZpZWxkLmlkKSksIHZhbHVlIHx8IGZpZWxkLnZhbHVlLCB7IHZtSWQ6IGZpZWxkT3B0cy52bUlkIH0pOyB9KTtcXG4gIH0gZWxzZSB7XFxuICAgIHRoaXMuX3ZhbGlkYXRlKGZpZWxkLCB2YWx1ZSB8fCBmaWVsZC52YWx1ZSwgeyBpbml0aWFsOiB0cnVlIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xcbiAgICAgIGZpZWxkLmZsYWdzLnZhbGlkID0gcmVzdWx0LnZhbGlkO1xcbiAgICAgIGZpZWxkLmZsYWdzLmludmFsaWQgPSAhcmVzdWx0LnZhbGlkO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHJldHVybiBmaWVsZDtcXG59O1xcblxcbi8qKlxcbiAqIFNldHMgdGhlIGZsYWdzIG9uIGEgZmllbGQuXFxuICovXFxuVmFsaWRhdG9yLnByb3RvdHlwZS5mbGFnID0gZnVuY3Rpb24gZmxhZyAobmFtZSwgZmxhZ3MsIHVpZCkge1xcbiAgICBpZiAoIHVpZCA9PT0gdm9pZCAwICkgdWlkID0gbnVsbDtcXG5cXG4gIHZhciBmaWVsZCA9IHRoaXMuX3Jlc29sdmVGaWVsZChuYW1lLCB1bmRlZmluZWQsIHVpZCk7XFxuICBpZiAoIWZpZWxkIHx8ICFmbGFncykge1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICBmaWVsZC5zZXRGbGFncyhmbGFncyk7XFxufTtcXG5cXG4vKipcXG4gKiBSZW1vdmVzIGEgZmllbGQgZnJvbSB0aGUgdmFsaWRhdG9yLlxcbiAqL1xcblZhbGlkYXRvci5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gZGV0YWNoIChuYW1lLCBzY29wZSwgdWlkKSB7XFxuICB2YXIgZmllbGQgPSBpc0NhbGxhYmxlKG5hbWUuZGVzdHJveSkgPyBuYW1lIDogdGhpcy5fcmVzb2x2ZUZpZWxkKG5hbWUsIHNjb3BlLCB1aWQpO1xcbiAgaWYgKCFmaWVsZCkgeyByZXR1cm47IH1cXG5cXG4gIC8vIFdlIGRlc3Ryb3kvcmVtb3ZlIHRoZSBmaWVsZCAmIGVycm9yIGluc3RhbmNlcyBpZiBpdCdzIG5vdCBhIGBwZXJzaXN0YCBvbmVcXG4gIGlmICghZmllbGQucGVyc2lzdCkge1xcbiAgICBmaWVsZC5kZXN0cm95KCk7XFxuICAgIHRoaXMuZXJyb3JzLnJlbW92ZShmaWVsZC5uYW1lLCBmaWVsZC5zY29wZSwgZmllbGQudm1JZCk7XFxuICAgIHRoaXMuZmllbGRzLnJlbW92ZShmaWVsZCk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBBZGRzIGEgY3VzdG9tIHZhbGlkYXRvciB0byB0aGUgbGlzdCBvZiB2YWxpZGF0aW9uIHJ1bGVzLlxcbiAqL1xcblZhbGlkYXRvci5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kIChuYW1lLCB2YWxpZGF0b3IsIG9wdGlvbnMpIHtcXG4gICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XFxuXFxuICBWYWxpZGF0b3IuZXh0ZW5kKG5hbWUsIHZhbGlkYXRvciwgb3B0aW9ucyk7XFxufTtcXG5cXG5WYWxpZGF0b3IucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQgKG1hdGNoZXIpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAvLyB0d28gdGlja3NcXG4gIHJldHVybiB0aGlzLiR2ZWUuX3ZtLiRuZXh0VGljaygpLnRoZW4oZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gdGhpcyQxLiR2ZWUuX3ZtLiRuZXh0VGljaygpO1xcbiAgfSkudGhlbihmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMkMS5maWVsZHMuZmlsdGVyKG1hdGNoZXIpLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XFxuICAgICAgZmllbGQud2FpdEZvcihudWxsKTtcXG4gICAgICBmaWVsZC5yZXNldCgpOyAvLyByZXNldCBmaWVsZCBmbGFncy5cXG4gICAgICB0aGlzJDEuZXJyb3JzLnJlbW92ZShmaWVsZC5uYW1lLCBmaWVsZC5zY29wZSwgbWF0Y2hlciAmJiBtYXRjaGVyLnZtSWQpO1xcbiAgICB9KTtcXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogVXBkYXRlcyBhIGZpZWxkLCB1cGRhdGluZyBib3RoIGVycm9ycyBhbmQgZmxhZ3MuXFxuICovXFxuVmFsaWRhdG9yLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKGlkLCByZWYpIHtcXG4gICAgdmFyIHNjb3BlID0gcmVmLnNjb3BlO1xcblxcbiAgdmFyIGZpZWxkID0gdGhpcy5fcmVzb2x2ZUZpZWxkKChcXFwiI1xcXCIgKyBpZCkpO1xcbiAgaWYgKCFmaWVsZCkgeyByZXR1cm47IH1cXG5cXG4gIC8vIHJlbW92ZSBvbGQgc2NvcGUuXFxuICB0aGlzLmVycm9ycy51cGRhdGUoaWQsIHsgc2NvcGU6IHNjb3BlIH0pO1xcbn07XFxuXFxuLyoqXFxuICogUmVtb3ZlcyBhIHJ1bGUgZnJvbSB0aGUgbGlzdCBvZiB2YWxpZGF0b3JzLlxcbiAqIEBkZXByZWNhdGVkXFxuICovXFxuVmFsaWRhdG9yLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKG5hbWUpIHtcXG4gIFZhbGlkYXRvci5yZW1vdmUobmFtZSk7XFxufTtcXG5cXG4vKipcXG4gKiBWYWxpZGF0ZXMgYSB2YWx1ZSBhZ2FpbnN0IGEgcmVnaXN0ZXJlZCBmaWVsZCB2YWxpZGF0aW9ucy5cXG4gKi9cXG5WYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUgKGZpZWxkRGVzY3JpcHRvciwgdmFsdWUsIHJlZikge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG4gICAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xcbiAgICB2YXIgc2lsZW50ID0gcmVmLnNpbGVudDtcXG4gICAgdmFyIHZtSWQgPSByZWYudm1JZDtcXG5cXG4gIGlmICh0aGlzLnBhdXNlZCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpOyB9XFxuXFxuICAvLyBvdmVybG9hZCB0byB2YWxpZGF0ZSBhbGwuXFxuICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoZmllbGREZXNjcmlwdG9yKSkge1xcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVNjb3Blcyh7IHNpbGVudDogc2lsZW50LCB2bUlkOiB2bUlkIH0pO1xcbiAgfVxcblxcbiAgLy8gb3ZlcmxvYWQgdG8gdmFsaWRhdGUgc2NvcGUtbGVzcyBmaWVsZHMuXFxuICBpZiAoZmllbGREZXNjcmlwdG9yID09PSAnKicpIHtcXG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGVBbGwodW5kZWZpbmVkLCB7IHNpbGVudDogc2lsZW50LCB2bUlkOiB2bUlkIH0pO1xcbiAgfVxcblxcbiAgLy8gaWYgc2NvcGUgdmFsaWRhdGlvbiB3YXMgcmVxdWVzdGVkLlxcbiAgaWYgKC9eKC4rKVxcXFwuXFxcXCokLy50ZXN0KGZpZWxkRGVzY3JpcHRvcikpIHtcXG4gICAgdmFyIG1hdGNoZWQgPSBmaWVsZERlc2NyaXB0b3IubWF0Y2goL14oLispXFxcXC5cXFxcKiQvKVsxXTtcXG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGVBbGwobWF0Y2hlZCk7XFxuICB9XFxuXFxuICB2YXIgZmllbGQgPSB0aGlzLl9yZXNvbHZlRmllbGQoZmllbGREZXNjcmlwdG9yKTtcXG4gIGlmICghZmllbGQpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2hhbmRsZUZpZWxkTm90Rm91bmQoZmllbGREZXNjcmlwdG9yKTtcXG4gIH1cXG5cXG4gIGlmICghc2lsZW50KSB7IGZpZWxkLmZsYWdzLnBlbmRpbmcgPSB0cnVlOyB9XFxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xcbiAgICB2YWx1ZSA9IGZpZWxkLnZhbHVlO1xcbiAgfVxcblxcbiAgdmFyIHZhbGlkYXRpb25Qcm9taXNlID0gdGhpcy5fdmFsaWRhdGUoZmllbGQsIHZhbHVlKTtcXG4gIGZpZWxkLndhaXRGb3IodmFsaWRhdGlvblByb21pc2UpO1xcblxcbiAgcmV0dXJuIHZhbGlkYXRpb25Qcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xcbiAgICBpZiAoIXNpbGVudCAmJiBmaWVsZC5pc1dhaXRpbmdGb3IodmFsaWRhdGlvblByb21pc2UpKSB7XFxuICAgICAgLy8gYWxsb3cgbmV4dCB2YWxpZGF0aW9uIHRvIG11dGF0ZSB0aGUgc3RhdGUuXFxuICAgICAgZmllbGQud2FpdEZvcihudWxsKTtcXG4gICAgICB0aGlzJDEuX2hhbmRsZVZhbGlkYXRpb25SZXN1bHRzKFtyZXN1bHRdLCB2bUlkKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gcmVzdWx0LnZhbGlkO1xcbiAgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBQYXVzZXMgdGhlIHZhbGlkYXRvci5cXG4gKi9cXG5WYWxpZGF0b3IucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UgKCkge1xcbiAgdGhpcy5wYXVzZWQgPSB0cnVlO1xcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSZXN1bWVzIHRoZSB2YWxpZGF0b3IuXFxuICovXFxuVmFsaWRhdG9yLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiByZXN1bWUgKCkge1xcbiAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogVmFsaWRhdGVzIGVhY2ggdmFsdWUgYWdhaW5zdCB0aGUgY29ycmVzcG9uZGluZyBmaWVsZCB2YWxpZGF0aW9ucy5cXG4gKi9cXG5WYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlQWxsID0gZnVuY3Rpb24gdmFsaWRhdGVBbGwgKHZhbHVlcywgcmVmKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcbiAgICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XFxuICAgIHZhciBzaWxlbnQgPSByZWYuc2lsZW50O1xcbiAgICB2YXIgdm1JZCA9IHJlZi52bUlkO1xcblxcbiAgaWYgKHRoaXMucGF1c2VkKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7IH1cXG5cXG4gIHZhciBtYXRjaGVyID0gbnVsbDtcXG4gIHZhciBwcm92aWRlZFZhbHVlcyA9IGZhbHNlO1xcblxcbiAgaWYgKHR5cGVvZiB2YWx1ZXMgPT09ICdzdHJpbmcnKSB7XFxuICAgIG1hdGNoZXIgPSB7IHNjb3BlOiB2YWx1ZXMsIHZtSWQ6IHZtSWQgfTtcXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWVzKSkge1xcbiAgICBtYXRjaGVyID0gT2JqZWN0LmtleXModmFsdWVzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xcbiAgICAgIHJldHVybiB7IG5hbWU6IGtleSwgdm1JZDogdm1JZCwgc2NvcGU6IG51bGwgfTtcXG4gICAgfSk7XFxuICAgIHByb3ZpZGVkVmFsdWVzID0gdHJ1ZTtcXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XFxuICAgIG1hdGNoZXIgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gJ29iamVjdCcgPyBPYmplY3QuYXNzaWduKHsgdm1JZDogdm1JZCB9LCBrZXkpIDogeyBuYW1lOiBrZXksIHZtSWQ6IHZtSWQgfTtcXG4gICAgfSk7XFxuICB9IGVsc2Uge1xcbiAgICBtYXRjaGVyID0geyBzY29wZTogbnVsbCwgdm1JZDogdm1JZCB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxcbiAgICB0aGlzLmZpZWxkcy5maWx0ZXIobWF0Y2hlcikubWFwKGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gdGhpcyQxLl92YWxpZGF0ZShmaWVsZCwgcHJvdmlkZWRWYWx1ZXMgPyB2YWx1ZXNbZmllbGQubmFtZV0gOiBmaWVsZC52YWx1ZSk7IH0pXFxuICApLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcXG4gICAgaWYgKCFzaWxlbnQpIHtcXG4gICAgICB0aGlzJDEuX2hhbmRsZVZhbGlkYXRpb25SZXN1bHRzKHJlc3VsdHMsIHZtSWQpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiByZXN1bHRzLmV2ZXJ5KGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LnZhbGlkOyB9KTtcXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogVmFsaWRhdGVzIGFsbCBzY29wZXMuXFxuICovXFxuVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZVNjb3BlcyA9IGZ1bmN0aW9uIHZhbGlkYXRlU2NvcGVzIChyZWYpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuICAgIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcXG4gICAgdmFyIHNpbGVudCA9IHJlZi5zaWxlbnQ7XFxuICAgIHZhciB2bUlkID0gcmVmLnZtSWQ7XFxuXFxuICBpZiAodGhpcy5wYXVzZWQpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTsgfVxcblxcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxcbiAgICB0aGlzLmZpZWxkcy5maWx0ZXIoeyB2bUlkOiB2bUlkIH0pLm1hcChmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIHRoaXMkMS5fdmFsaWRhdGUoZmllbGQsIGZpZWxkLnZhbHVlKTsgfSlcXG4gICkudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xcbiAgICBpZiAoIXNpbGVudCkge1xcbiAgICAgIHRoaXMkMS5faGFuZGxlVmFsaWRhdGlvblJlc3VsdHMocmVzdWx0cywgdm1JZCk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHJlc3VsdHMuZXZlcnkoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQudmFsaWQ7IH0pO1xcbiAgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBWYWxpZGF0ZXMgYSB2YWx1ZSBhZ2FpbnN0IHRoZSBydWxlcy5cXG4gKi9cXG5WYWxpZGF0b3IucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeSAodmFsdWUsIHJ1bGVzLCBvcHRpb25zKSB7XFxuICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xcblxcbiAgdmFyIGZpZWxkID0ge1xcbiAgICBuYW1lOiAob3B0aW9ucyAmJiBvcHRpb25zLm5hbWUpIHx8ICd7ZmllbGR9JyxcXG4gICAgcnVsZXM6IG5vcm1hbGl6ZVJ1bGVzKHJ1bGVzKSxcXG4gICAgYmFpbHM6IGdldFBhdGgoJ2JhaWxzJywgb3B0aW9ucywgdHJ1ZSksXFxuICAgIGZvcmNlUmVxdWlyZWQ6IGZhbHNlLFxcbiAgICBnZXQgaXNSZXF1aXJlZCAoKSB7XFxuICAgICAgcmV0dXJuICEhdGhpcy5ydWxlcy5yZXF1aXJlZCB8fCB0aGlzLmZvcmNlUmVxdWlyZWQ7XFxuICAgIH1cXG4gIH07XFxuXFxuICB2YXIgdGFyZ2V0UnVsZXMgPSBPYmplY3Qua2V5cyhmaWVsZC5ydWxlcykuZmlsdGVyKFJ1bGVDb250YWluZXIuaXNUYXJnZXRSdWxlKTtcXG4gIGlmICh0YXJnZXRSdWxlcy5sZW5ndGggJiYgb3B0aW9ucyAmJiBpc09iamVjdChvcHRpb25zLnZhbHVlcykpIHtcXG4gICAgZmllbGQuZGVwZW5kZW5jaWVzID0gdGFyZ2V0UnVsZXMubWFwKGZ1bmN0aW9uIChydWxlKSB7XFxuICAgICAgdmFyIHJlZiA9IGZpZWxkLnJ1bGVzW3J1bGVdO1xcbiAgICAgICAgdmFyIHRhcmdldEtleSA9IHJlZlswXTtcXG5cXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgbmFtZTogcnVsZSxcXG4gICAgICAgIGZpZWxkOiB7IHZhbHVlOiBvcHRpb25zLnZhbHVlc1t0YXJnZXRLZXldIH1cXG4gICAgICB9O1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzLl92YWxpZGF0ZShmaWVsZCwgdmFsdWUpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xcbiAgICB2YXIgZXJyb3JzID0gW107XFxuICAgIHZhciBydWxlTWFwID0ge307XFxuICAgIHJlc3VsdC5lcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xcbiAgICAgIGVycm9ycy5wdXNoKGUubXNnKTtcXG4gICAgICBydWxlTWFwW2UucnVsZV0gPSBlLm1zZztcXG4gICAgfSk7XFxuXFxuICAgIHJldHVybiB7XFxuICAgICAgdmFsaWQ6IHJlc3VsdC52YWxpZCxcXG4gICAgICBlcnJvcnM6IGVycm9ycyxcXG4gICAgICBmYWlsZWRSdWxlczogcnVsZU1hcFxcbiAgICB9O1xcbiAgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBQZXJmb3JtIGNsZWFudXAuXFxuICovXFxuVmFsaWRhdG9yLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSAoKSB7XFxuICB0aGlzLiR2ZWUuX3ZtLiRvZmYoJ2xvY2FsZUNoYW5nZWQnKTtcXG59O1xcblxcbi8qKlxcbiAqIENyZWF0ZXMgdGhlIGZpZWxkcyB0byBiZSB2YWxpZGF0ZWQuXFxuICovXFxuVmFsaWRhdG9yLnByb3RvdHlwZS5fY3JlYXRlRmllbGRzID0gZnVuY3Rpb24gX2NyZWF0ZUZpZWxkcyAodmFsaWRhdGlvbnMpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICBpZiAoIXZhbGlkYXRpb25zKSB7IHJldHVybjsgfVxcblxcbiAgT2JqZWN0LmtleXModmFsaWRhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XFxuICAgIHZhciBvcHRpb25zID0gYXNzaWduKHt9LCB7IG5hbWU6IGZpZWxkLCBydWxlczogdmFsaWRhdGlvbnNbZmllbGRdIH0pO1xcbiAgICB0aGlzJDEuYXR0YWNoKG9wdGlvbnMpO1xcbiAgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBEYXRlIHJ1bGVzIG5lZWQgdGhlIGV4aXN0ZW5jZSBvZiBhIGZvcm1hdCwgc28gZGF0ZV9mb3JtYXQgbXVzdCBiZSBzdXBwbGllZC5cXG4gKi9cXG5WYWxpZGF0b3IucHJvdG90eXBlLl9nZXREYXRlRm9ybWF0ID0gZnVuY3Rpb24gX2dldERhdGVGb3JtYXQgKHZhbGlkYXRpb25zKSB7XFxuICB2YXIgZm9ybWF0ID0gbnVsbDtcXG4gIGlmICh2YWxpZGF0aW9ucy5kYXRlX2Zvcm1hdCAmJiBBcnJheS5pc0FycmF5KHZhbGlkYXRpb25zLmRhdGVfZm9ybWF0KSkge1xcbiAgICBmb3JtYXQgPSB2YWxpZGF0aW9ucy5kYXRlX2Zvcm1hdFswXTtcXG4gIH1cXG5cXG4gIHJldHVybiBmb3JtYXQgfHwgRGljdGlvbmFyeVJlc29sdmVyLmdldERyaXZlcigpLmdldERhdGVGb3JtYXQodGhpcy5sb2NhbGUpO1xcbn07XFxuXFxuLyoqXFxuICogRm9ybWF0cyBhbiBlcnJvciBtZXNzYWdlIGZvciBmaWVsZCBhbmQgYSBydWxlLlxcbiAqL1xcblZhbGlkYXRvci5wcm90b3R5cGUuX2Zvcm1hdEVycm9yTWVzc2FnZSA9IGZ1bmN0aW9uIF9mb3JtYXRFcnJvck1lc3NhZ2UgKGZpZWxkLCBydWxlLCBkYXRhLCB0YXJnZXROYW1lKSB7XFxuICAgIGlmICggZGF0YSA9PT0gdm9pZCAwICkgZGF0YSA9IHt9O1xcbiAgICBpZiAoIHRhcmdldE5hbWUgPT09IHZvaWQgMCApIHRhcmdldE5hbWUgPSBudWxsO1xcblxcbiAgdmFyIG5hbWUgPSB0aGlzLl9nZXRGaWVsZERpc3BsYXlOYW1lKGZpZWxkKTtcXG4gIHZhciBwYXJhbXMgPSB0aGlzLl9nZXRMb2NhbGl6ZWRQYXJhbXMocnVsZSwgdGFyZ2V0TmFtZSk7XFxuXFxuICByZXR1cm4gRGljdGlvbmFyeVJlc29sdmVyLmdldERyaXZlcigpLmdldEZpZWxkTWVzc2FnZSh0aGlzLmxvY2FsZSwgZmllbGQubmFtZSwgcnVsZS5uYW1lLCBbbmFtZSwgcGFyYW1zLCBkYXRhXSk7XFxufTtcXG5cXG4vKipcXG4gKiBXZSBuZWVkIHRvIGNvbnZlcnQgYW55IG9iamVjdCBwYXJhbSB0byBhbiBhcnJheSBmb3JtYXQgc2luY2UgdGhlIGxvY2FsZXMgZG8gbm90IGhhbmRsZSBwYXJhbXMgYXMgb2JqZWN0cyB5ZXQuXFxuICovXFxuVmFsaWRhdG9yLnByb3RvdHlwZS5fY29udmVydFBhcmFtT2JqZWN0VG9BcnJheSA9IGZ1bmN0aW9uIF9jb252ZXJ0UGFyYW1PYmplY3RUb0FycmF5IChvYmosIHJ1bGVOYW1lKSB7XFxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XFxuICAgIHJldHVybiBvYmo7XFxuICB9XFxuXFxuICB2YXIgcGFyYW1OYW1lcyA9IFJ1bGVDb250YWluZXIuZ2V0UGFyYW1OYW1lcyhydWxlTmFtZSk7XFxuICBpZiAoIXBhcmFtTmFtZXMgfHwgIWlzT2JqZWN0KG9iaikpIHtcXG4gICAgcmV0dXJuIG9iajtcXG4gIH1cXG5cXG4gIHJldHVybiBwYXJhbU5hbWVzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgcGFyYW1OYW1lKSB7XFxuICAgIGlmIChwYXJhbU5hbWUgaW4gb2JqKSB7XFxuICAgICAgcHJldi5wdXNoKG9ialtwYXJhbU5hbWVdKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gcHJldjtcXG4gIH0sIFtdKTtcXG59O1xcblxcbi8qKlxcbiAqIFRyYW5zbGF0ZXMgdGhlIHBhcmFtZXRlcnMgcGFzc2VkIHRvIHRoZSBydWxlIChtYWlubHkgZm9yIHRhcmdldCBmaWVsZHMpLlxcbiAqL1xcblZhbGlkYXRvci5wcm90b3R5cGUuX2dldExvY2FsaXplZFBhcmFtcyA9IGZ1bmN0aW9uIF9nZXRMb2NhbGl6ZWRQYXJhbXMgKHJ1bGUsIHRhcmdldE5hbWUpIHtcXG4gICAgaWYgKCB0YXJnZXROYW1lID09PSB2b2lkIDAgKSB0YXJnZXROYW1lID0gbnVsbDtcXG5cXG4gIHZhciBwYXJhbXMgPSB0aGlzLl9jb252ZXJ0UGFyYW1PYmplY3RUb0FycmF5KHJ1bGUucGFyYW1zLCBydWxlLm5hbWUpO1xcbiAgaWYgKHJ1bGUub3B0aW9ucy5oYXNUYXJnZXQgJiYgcGFyYW1zICYmIHBhcmFtc1swXSkge1xcbiAgICB2YXIgbG9jYWxpemVkTmFtZSA9IHRhcmdldE5hbWUgfHwgRGljdGlvbmFyeVJlc29sdmVyLmdldERyaXZlcigpLmdldEF0dHJpYnV0ZSh0aGlzLmxvY2FsZSwgcGFyYW1zWzBdLCBwYXJhbXNbMF0pO1xcbiAgICByZXR1cm4gW2xvY2FsaXplZE5hbWVdLmNvbmNhdChwYXJhbXMuc2xpY2UoMSkpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHBhcmFtcztcXG59O1xcblxcbi8qKlxcbiAqIFJlc29sdmVzIGFuIGFwcHJvcHJpYXRlIGRpc3BsYXkgbmFtZSwgZmlyc3QgY2hlY2tpbmcgJ2RhdGEtYXMnIG9yIHRoZSByZWdpc3RlcmVkICdwcmV0dHlOYW1lJ1xcbiAqL1xcblZhbGlkYXRvci5wcm90b3R5cGUuX2dldEZpZWxkRGlzcGxheU5hbWUgPSBmdW5jdGlvbiBfZ2V0RmllbGREaXNwbGF5TmFtZSAoZmllbGQpIHtcXG4gIHJldHVybiBmaWVsZC5hbGlhcyB8fCBEaWN0aW9uYXJ5UmVzb2x2ZXIuZ2V0RHJpdmVyKCkuZ2V0QXR0cmlidXRlKHRoaXMubG9jYWxlLCBmaWVsZC5uYW1lLCBmaWVsZC5uYW1lKTtcXG59O1xcblxcbi8qKlxcbiAqIENvbnZlcnRzIGFuIGFycmF5IG9mIHBhcmFtcyB0byBhbiBvYmplY3Qgd2l0aCBuYW1lZCBwcm9wZXJ0aWVzLlxcbiAqIE9ubHkgd29ya3MgaWYgdGhlIHJ1bGUgaXMgY29uZmlndXJlZCB3aXRoIGEgcGFyYW1OYW1lcyBhcnJheS5cXG4gKiBSZXR1cm5zIHRoZSBzYW1lIHBhcmFtcyBpZiBpdCBjYW5ub3QgY29udmVydCBpdC5cXG4gKi9cXG5WYWxpZGF0b3IucHJvdG90eXBlLl9jb252ZXJ0UGFyYW1BcnJheVRvT2JqID0gZnVuY3Rpb24gX2NvbnZlcnRQYXJhbUFycmF5VG9PYmogKHBhcmFtcywgcnVsZU5hbWUpIHtcXG4gIHZhciBwYXJhbU5hbWVzID0gUnVsZUNvbnRhaW5lci5nZXRQYXJhbU5hbWVzKHJ1bGVOYW1lKTtcXG4gIGlmICghcGFyYW1OYW1lcykge1xcbiAgICByZXR1cm4gcGFyYW1zO1xcbiAgfVxcblxcbiAgaWYgKGlzT2JqZWN0KHBhcmFtcykpIHtcXG4gICAgLy8gY2hlY2sgaWYgdGhlIG9iamVjdCBpcyBlaXRoZXIgYSBjb25maWcgb2JqZWN0IG9yIGEgc2luZ2xlIHBhcmFtZXRlciB0aGF0IGlzIGFuIG9iamVjdC5cXG4gICAgdmFyIGhhc0tleXMgPSBwYXJhbU5hbWVzLnNvbWUoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIE9iamVjdC5rZXlzKHBhcmFtcykuaW5kZXhPZihuYW1lKSAhPT0gLTE7IH0pO1xcbiAgICAvLyBpZiBpdCBoYXMgc29tZSBvZiB0aGUga2V5cywgcmV0dXJuIGl0IGFzIGlzLlxcbiAgICBpZiAoaGFzS2V5cykge1xcbiAgICAgIHJldHVybiBwYXJhbXM7XFxuICAgIH1cXG4gICAgLy8gb3RoZXJ3aXNlIHdyYXAgdGhlIG9iamVjdCBpbiBhbiBhcnJheS5cXG4gICAgcGFyYW1zID0gW3BhcmFtc107XFxuICB9XFxuXFxuICAvLyBSZWR1Y2UgdGhlIHBhcmFtc05hbWVzIHRvIGEgcGFyYW0gb2JqZWN0LlxcbiAgcmV0dXJuIHBhcmFtcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIHZhbHVlLCBpZHgpIHtcXG4gICAgcHJldltwYXJhbU5hbWVzW2lkeF1dID0gdmFsdWU7XFxuXFxuICAgIHJldHVybiBwcmV2O1xcbiAgfSwge30pO1xcbn07XFxuXFxuLyoqXFxuICogVGVzdHMgYSBzaW5nbGUgaW5wdXQgdmFsdWUgYWdhaW5zdCBhIHJ1bGUuXFxuICovXFxuVmFsaWRhdG9yLnByb3RvdHlwZS5fdGVzdCA9IGZ1bmN0aW9uIF90ZXN0IChmaWVsZCwgdmFsdWUsIHJ1bGUpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB2YXIgdmFsaWRhdG9yID0gUnVsZUNvbnRhaW5lci5nZXRWYWxpZGF0b3JNZXRob2QocnVsZS5uYW1lKTtcXG4gIHZhciBwYXJhbXMgPSBBcnJheS5pc0FycmF5KHJ1bGUucGFyYW1zKSA/IHRvQXJyYXkocnVsZS5wYXJhbXMpIDogcnVsZS5wYXJhbXM7XFxuICBpZiAoIXBhcmFtcykge1xcbiAgICBwYXJhbXMgPSBbXTtcXG4gIH1cXG5cXG4gIHZhciB0YXJnZXROYW1lID0gbnVsbDtcXG4gIGlmICghdmFsaWRhdG9yIHx8IHR5cGVvZiB2YWxpZGF0b3IgIT09ICdmdW5jdGlvbicpIHtcXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNyZWF0ZUVycm9yKChcXFwiTm8gc3VjaCB2YWxpZGF0b3IgJ1xcXCIgKyAocnVsZS5uYW1lKSArIFxcXCInIGV4aXN0cy5cXFwiKSkpO1xcbiAgfVxcblxcbiAgLy8gaGFzIGZpZWxkIGRlcGVuZGVuY2llcy5cXG4gIGlmIChydWxlLm9wdGlvbnMuaGFzVGFyZ2V0ICYmIGZpZWxkLmRlcGVuZGVuY2llcykge1xcbiAgICB2YXIgdGFyZ2V0ID0gZmluZChmaWVsZC5kZXBlbmRlbmNpZXMsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09IHJ1bGUubmFtZTsgfSk7XFxuICAgIGlmICh0YXJnZXQpIHtcXG4gICAgICB0YXJnZXROYW1lID0gdGFyZ2V0LmZpZWxkLmFsaWFzO1xcbiAgICAgIHBhcmFtcyA9IFt0YXJnZXQuZmllbGQudmFsdWVdLmNvbmNhdChwYXJhbXMuc2xpY2UoMSkpO1xcbiAgICB9XFxuICB9IGVsc2UgaWYgKHJ1bGUubmFtZSA9PT0gJ3JlcXVpcmVkJyAmJiBmaWVsZC5yZWplY3RzRmFsc2UpIHtcXG4gICAgLy8gaW52YWxpZGF0ZSBmYWxzZSBpZiBubyBhcmdzIHdlcmUgc3BlY2lmaWVkIGFuZCB0aGUgZmllbGQgcmVqZWN0cyBmYWxzZSBieSBkZWZhdWx0LlxcbiAgICBwYXJhbXMgPSBwYXJhbXMubGVuZ3RoID8gcGFyYW1zIDogW3RydWVdO1xcbiAgfVxcblxcbiAgaWYgKHJ1bGUub3B0aW9ucy5pc0RhdGUpIHtcXG4gICAgdmFyIGRhdGVGb3JtYXQgPSB0aGlzLl9nZXREYXRlRm9ybWF0KGZpZWxkLnJ1bGVzKTtcXG4gICAgaWYgKHJ1bGUubmFtZSAhPT0gJ2RhdGVfZm9ybWF0Jykge1xcbiAgICAgIHBhcmFtcy5wdXNoKGRhdGVGb3JtYXQpO1xcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgcmVzdWx0ID0gdmFsaWRhdG9yKHZhbHVlLCB0aGlzLl9jb252ZXJ0UGFyYW1BcnJheVRvT2JqKHBhcmFtcywgcnVsZS5uYW1lKSk7XFxuXFxuICAvLyBJZiBpdCBpcyBhIHByb21pc2UuXFxuICBpZiAoaXNDYWxsYWJsZShyZXN1bHQudGhlbikpIHtcXG4gICAgcmV0dXJuIHJlc3VsdC50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcXG4gICAgICB2YXIgYWxsVmFsaWQgPSB0cnVlO1xcbiAgICAgIHZhciBkYXRhID0ge307XFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xcbiAgICAgICAgYWxsVmFsaWQgPSB2YWx1ZXMuZXZlcnkoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIChpc09iamVjdCh0KSA/IHQudmFsaWQgOiB0KTsgfSk7XFxuICAgICAgfSBlbHNlIHsgLy8gSXMgYSBzaW5nbGUgb2JqZWN0L2Jvb2xlYW4uXFxuICAgICAgICBhbGxWYWxpZCA9IGlzT2JqZWN0KHZhbHVlcykgPyB2YWx1ZXMudmFsaWQgOiB2YWx1ZXM7XFxuICAgICAgICBkYXRhID0gdmFsdWVzLmRhdGE7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB7XFxuICAgICAgICB2YWxpZDogYWxsVmFsaWQsXFxuICAgICAgICBkYXRhOiByZXN1bHQuZGF0YSxcXG4gICAgICAgIGVycm9yczogYWxsVmFsaWQgPyBbXSA6IFt0aGlzJDEuX2NyZWF0ZUZpZWxkRXJyb3IoZmllbGQsIHJ1bGUsIGRhdGEsIHRhcmdldE5hbWUpXVxcbiAgICAgIH07XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgaWYgKCFpc09iamVjdChyZXN1bHQpKSB7XFxuICAgIHJlc3VsdCA9IHsgdmFsaWQ6IHJlc3VsdCwgZGF0YToge30gfTtcXG4gIH1cXG5cXG4gIHJldHVybiB7XFxuICAgIHZhbGlkOiByZXN1bHQudmFsaWQsXFxuICAgIGRhdGE6IHJlc3VsdC5kYXRhLFxcbiAgICBlcnJvcnM6IHJlc3VsdC52YWxpZCA/IFtdIDogW3RoaXMuX2NyZWF0ZUZpZWxkRXJyb3IoZmllbGQsIHJ1bGUsIHJlc3VsdC5kYXRhLCB0YXJnZXROYW1lKV1cXG4gIH07XFxufTtcXG5cXG4vKipcXG4gKiBNZXJnZXMgYSB2YWxpZGF0b3Igb2JqZWN0IGludG8gdGhlIFJVTEVTIGFuZCBNZXNzYWdlcy5cXG4gKi9cXG5WYWxpZGF0b3IuX21lcmdlID0gZnVuY3Rpb24gX21lcmdlIChuYW1lLCByZWYpIHtcXG4gICAgdmFyIHZhbGlkYXRvciA9IHJlZi52YWxpZGF0b3I7XFxuICAgIHZhciBvcHRpb25zID0gcmVmLm9wdGlvbnM7XFxuICAgIHZhciBwYXJhbU5hbWVzID0gcmVmLnBhcmFtTmFtZXM7XFxuXFxuICB2YXIgdmFsaWRhdGUgPSBpc0NhbGxhYmxlKHZhbGlkYXRvcikgPyB2YWxpZGF0b3IgOiB2YWxpZGF0b3IudmFsaWRhdGU7XFxuICBpZiAodmFsaWRhdG9yLmdldE1lc3NhZ2UpIHtcXG4gICAgRGljdGlvbmFyeVJlc29sdmVyLmdldERyaXZlcigpLnNldE1lc3NhZ2UoVmFsaWRhdG9yLmxvY2FsZSwgbmFtZSwgdmFsaWRhdG9yLmdldE1lc3NhZ2UpO1xcbiAgfVxcblxcbiAgUnVsZUNvbnRhaW5lci5hZGQobmFtZSwge1xcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGUsXFxuICAgIG9wdGlvbnM6IG9wdGlvbnMsXFxuICAgIHBhcmFtTmFtZXM6IHBhcmFtTmFtZXNcXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogR3VhcmRzIGZyb20gZXh0ZW5zaW9uIHZpb2xhdGlvbnMuXFxuICovXFxuVmFsaWRhdG9yLl9ndWFyZEV4dGVuZCA9IGZ1bmN0aW9uIF9ndWFyZEV4dGVuZCAobmFtZSwgdmFsaWRhdG9yKSB7XFxuICBpZiAoaXNDYWxsYWJsZSh2YWxpZGF0b3IpKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGlmICghaXNDYWxsYWJsZSh2YWxpZGF0b3IudmFsaWRhdGUpKSB7XFxuICAgIHRocm93IGNyZWF0ZUVycm9yKFxcbiAgICAgIChcXFwiRXh0ZW5zaW9uIEVycm9yOiBUaGUgdmFsaWRhdG9yICdcXFwiICsgbmFtZSArIFxcXCInIG11c3QgYmUgYSBmdW5jdGlvbiBvciBoYXZlIGEgJ3ZhbGlkYXRlJyBtZXRob2QuXFxcIilcXG4gICAgKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIENyZWF0ZXMgYSBGaWVsZCBFcnJvciBPYmplY3QuXFxuICovXFxuVmFsaWRhdG9yLnByb3RvdHlwZS5fY3JlYXRlRmllbGRFcnJvciA9IGZ1bmN0aW9uIF9jcmVhdGVGaWVsZEVycm9yIChmaWVsZCwgcnVsZSwgZGF0YSwgdGFyZ2V0TmFtZSkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIHJldHVybiB7XFxuICAgIGlkOiBmaWVsZC5pZCxcXG4gICAgdm1JZDogZmllbGQudm1JZCxcXG4gICAgZmllbGQ6IGZpZWxkLm5hbWUsXFxuICAgIG1zZzogdGhpcy5fZm9ybWF0RXJyb3JNZXNzYWdlKGZpZWxkLCBydWxlLCBkYXRhLCB0YXJnZXROYW1lKSxcXG4gICAgcnVsZTogcnVsZS5uYW1lLFxcbiAgICBzY29wZTogZmllbGQuc2NvcGUsXFxuICAgIHJlZ2VuZXJhdGU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gdGhpcyQxLl9mb3JtYXRFcnJvck1lc3NhZ2UoZmllbGQsIHJ1bGUsIGRhdGEsIHRhcmdldE5hbWUpO1xcbiAgICB9XFxuICB9O1xcbn07XFxuXFxuLyoqXFxuICogVHJpZXMgZGlmZmVyZW50IHN0cmF0ZWdpZXMgdG8gZmluZCBhIGZpZWxkLlxcbiAqL1xcblZhbGlkYXRvci5wcm90b3R5cGUuX3Jlc29sdmVGaWVsZCA9IGZ1bmN0aW9uIF9yZXNvbHZlRmllbGQgKG5hbWUsIHNjb3BlLCB1aWQpIHtcXG4gIGlmIChuYW1lWzBdID09PSAnIycpIHtcXG4gICAgcmV0dXJuIHRoaXMuZmllbGRzLmZpbmRCeUlkKG5hbWUuc2xpY2UoMSkpO1xcbiAgfVxcblxcbiAgaWYgKCFpc051bGxPclVuZGVmaW5lZChzY29wZSkpIHtcXG4gICAgcmV0dXJuIHRoaXMuZmllbGRzLmZpbmQoeyBuYW1lOiBuYW1lLCBzY29wZTogc2NvcGUsIHZtSWQ6IHVpZCB9KTtcXG4gIH1cXG5cXG4gIGlmIChpbmNsdWRlcyhuYW1lLCAnLicpKSB7XFxuICAgIHZhciByZWYgPSBuYW1lLnNwbGl0KCcuJyk7XFxuICAgICAgdmFyIGZpZWxkU2NvcGUgPSByZWZbMF07XFxuICAgICAgdmFyIGZpZWxkTmFtZSA9IHJlZi5zbGljZSgxKTtcXG4gICAgdmFyIGZpZWxkID0gdGhpcy5maWVsZHMuZmluZCh7IG5hbWU6IGZpZWxkTmFtZS5qb2luKCcuJyksIHNjb3BlOiBmaWVsZFNjb3BlLCB2bUlkOiB1aWQgfSk7XFxuICAgIGlmIChmaWVsZCkge1xcbiAgICAgIHJldHVybiBmaWVsZDtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXMuZmllbGRzLmZpbmQoeyBuYW1lOiBuYW1lLCBzY29wZTogbnVsbCwgdm1JZDogdWlkIH0pO1xcbn07XFxuXFxuLyoqXFxuICogSGFuZGxlcyB3aGVuIGEgZmllbGQgaXMgbm90IGZvdW5kLlxcbiAqL1xcblZhbGlkYXRvci5wcm90b3R5cGUuX2hhbmRsZUZpZWxkTm90Rm91bmQgPSBmdW5jdGlvbiBfaGFuZGxlRmllbGROb3RGb3VuZCAobmFtZSwgc2NvcGUpIHtcXG4gIHZhciBmdWxsTmFtZSA9IGlzTnVsbE9yVW5kZWZpbmVkKHNjb3BlKSA/IG5hbWUgOiAoXFxcIlxcXCIgKyAoIWlzTnVsbE9yVW5kZWZpbmVkKHNjb3BlKSA/IHNjb3BlICsgJy4nIDogJycpICsgbmFtZSk7XFxuXFxuICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY3JlYXRlRXJyb3IoXFxuICAgIChcXFwiVmFsaWRhdGluZyBhIG5vbi1leGlzdGVudCBmaWVsZDogXFxcXFxcXCJcXFwiICsgZnVsbE5hbWUgKyBcXFwiXFxcXFxcXCIuIFVzZSBcXFxcXFxcImF0dGFjaCgpXFxcXFxcXCIgZmlyc3QuXFxcIilcXG4gICkpO1xcbn07XFxuXFxuLyoqXFxuICogSGFuZGxlcyB2YWxpZGF0aW9uIHJlc3VsdHMuXFxuICovXFxuVmFsaWRhdG9yLnByb3RvdHlwZS5faGFuZGxlVmFsaWRhdGlvblJlc3VsdHMgPSBmdW5jdGlvbiBfaGFuZGxlVmFsaWRhdGlvblJlc3VsdHMgKHJlc3VsdHMsIHZtSWQpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB2YXIgbWF0Y2hlcnMgPSByZXN1bHRzLm1hcChmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiAoeyBpZDogcmVzdWx0LmlkIH0pOyB9KTtcXG4gIHRoaXMuZXJyb3JzLnJlbW92ZUJ5SWQobWF0Y2hlcnMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmlkOyB9KSk7XFxuICAvLyByZW1vdmUgYnkgbmFtZSBhbmQgc2NvcGUgdG8gcmVtb3ZlIGFueSBjdXN0b20gZXJyb3JzIGFkZGVkLlxcbiAgcmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcXG4gICAgdGhpcyQxLmVycm9ycy5yZW1vdmUocmVzdWx0LmZpZWxkLCByZXN1bHQuc2NvcGUsIHZtSWQpO1xcbiAgfSk7XFxuICB2YXIgYWxsRXJyb3JzID0gcmVzdWx0cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcXG4gICAgcHJldi5wdXNoLmFwcGx5KHByZXYsIGN1cnIuZXJyb3JzKTtcXG5cXG4gICAgcmV0dXJuIHByZXY7XFxuICB9LCBbXSk7XFxuXFxuICB0aGlzLmVycm9ycy5hZGQoYWxsRXJyb3JzKTtcXG5cXG4gIC8vIGhhbmRsZSBmbGFncy5cXG4gIHRoaXMuZmllbGRzLmZpbHRlcihtYXRjaGVycykuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcXG4gICAgdmFyIHJlc3VsdCA9IGZpbmQocmVzdWx0cywgZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIuaWQgPT09IGZpZWxkLmlkOyB9KTtcXG4gICAgZmllbGQuc2V0RmxhZ3Moe1xcbiAgICAgIHBlbmRpbmc6IGZhbHNlLFxcbiAgICAgIHZhbGlkOiByZXN1bHQudmFsaWQsXFxuICAgICAgdmFsaWRhdGVkOiB0cnVlXFxuICAgIH0pO1xcbiAgfSk7XFxufTtcXG5cXG5WYWxpZGF0b3IucHJvdG90eXBlLl9zaG91bGRTa2lwID0gZnVuY3Rpb24gX3Nob3VsZFNraXAgKGZpZWxkLCB2YWx1ZSkge1xcbiAgLy8gZmllbGQgaXMgY29uZmlndXJlZCB0byBydW4gdGhyb3VnaCB0aGUgcGlwZWxpbmUgcmVnYXJkbGVzc1xcbiAgaWYgKGZpZWxkLmJhaWxzID09PSBmYWxzZSkge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICAvLyBkaXNhYmxlZCBmaWVsZHMgYXJlIHNraXBwZWQgaWYgdXNlQ29uc3RyYWludEF0dHJzIGlzIGVuYWJsZWQgaW4gY29uZmlnXFxuICBpZiAoZmllbGQuaXNEaXNhYmxlZCAmJiBnZXRDb25maWcoKS51c2VDb25zdHJhaW50QXR0cnMpIHtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuXFxuICAvLyBza2lwIGlmIHRoZSBmaWVsZCBpcyBub3QgcmVxdWlyZWQgYW5kIGhhcyBhbiBlbXB0eSB2YWx1ZS5cXG4gIHJldHVybiAhZmllbGQuaXNSZXF1aXJlZCAmJiAoaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSAnJyB8fCBpc0VtcHR5QXJyYXkodmFsdWUpKTtcXG59O1xcblxcblZhbGlkYXRvci5wcm90b3R5cGUuX3Nob3VsZEJhaWwgPSBmdW5jdGlvbiBfc2hvdWxkQmFpbCAoZmllbGQpIHtcXG4gIC8vIGlmIHRoZSBmaWVsZCB3YXMgY29uZmlndXJlZCBleHBsaWNpdGx5LlxcbiAgaWYgKGZpZWxkLmJhaWxzICE9PSB1bmRlZmluZWQpIHtcXG4gICAgcmV0dXJuIGZpZWxkLmJhaWxzO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXMuZmFzdEV4aXQ7XFxufTtcXG5cXG4vKipcXG4gKiBTdGFydHMgdGhlIHZhbGlkYXRpb24gcHJvY2Vzcy5cXG4gKi9cXG5WYWxpZGF0b3IucHJvdG90eXBlLl92YWxpZGF0ZSA9IGZ1bmN0aW9uIF92YWxpZGF0ZSAoZmllbGQsIHZhbHVlLCByZWYpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuICAgIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcXG4gICAgdmFyIGluaXRpYWwgPSByZWYuaW5pdGlhbDtcXG5cXG4gIHZhciByZXF1aXJlUnVsZXMgPSBPYmplY3Qua2V5cyhmaWVsZC5ydWxlcykuZmlsdGVyKFJ1bGVDb250YWluZXIuaXNSZXF1aXJlUnVsZSk7XFxuXFxuICBmaWVsZC5mb3JjZVJlcXVpcmVkID0gZmFsc2U7XFxuICByZXF1aXJlUnVsZXMuZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xcbiAgICB2YXIgcnVsZU9wdGlvbnMgPSBSdWxlQ29udGFpbmVyLmdldE9wdGlvbnMocnVsZSk7XFxuICAgIHZhciByZXN1bHQgPSB0aGlzJDEuX3Rlc3QoZmllbGQsIHZhbHVlLCB7IG5hbWU6IHJ1bGUsIHBhcmFtczogZmllbGQucnVsZXNbcnVsZV0sIG9wdGlvbnM6IHJ1bGVPcHRpb25zIH0pO1xcblxcbiAgICBpZiAoaXNDYWxsYWJsZShyZXN1bHQudGhlbikpIHsgdGhyb3cgY3JlYXRlRXJyb3IoJ1JlcXVpcmUgcnVsZXMgY2Fubm90IGJlIGFzeW5jJyk7IH1cXG4gICAgaWYgKCFpc09iamVjdChyZXN1bHQpKSB7IHRocm93IGNyZWF0ZUVycm9yKCdSZXF1aXJlIHJ1bGVzIGhhcyB0byByZXR1cm4gYW4gb2JqZWN0IChzZWUgZG9jcyknKTsgfVxcblxcbiAgICBpZiAocmVzdWx0LmRhdGEucmVxdWlyZWQgPT09IHRydWUpIHtcXG4gICAgICBmaWVsZC5mb3JjZVJlcXVpcmVkID0gdHJ1ZTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICBpZiAodGhpcy5fc2hvdWxkU2tpcChmaWVsZCwgdmFsdWUpKSB7XFxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB2YWxpZDogdHJ1ZSwgaWQ6IGZpZWxkLmlkLCBmaWVsZDogZmllbGQubmFtZSwgc2NvcGU6IGZpZWxkLnNjb3BlLCBlcnJvcnM6IFtdIH0pO1xcbiAgfVxcblxcbiAgdmFyIHByb21pc2VzID0gW107XFxuICB2YXIgZXJyb3JzID0gW107XFxuICB2YXIgaXNFeGl0RWFybHkgPSBmYWxzZTtcXG4gIGlmIChpc0NhbGxhYmxlKGZpZWxkLmNoZWNrVmFsdWVDaGFuZ2VkKSkge1xcbiAgICBmaWVsZC5mbGFncy5jaGFuZ2VkID0gZmllbGQuY2hlY2tWYWx1ZUNoYW5nZWQoKTtcXG4gIH1cXG5cXG4gIC8vIHVzZSBvZiAnLnNvbWUoKScgaXMgdG8gYnJlYWsgaXRlcmF0aW9uIGluIG1pZGRsZSBieSByZXR1cm5pbmcgdHJ1ZVxcbiAgT2JqZWN0LmtleXMoZmllbGQucnVsZXMpLmZpbHRlcihmdW5jdGlvbiAocnVsZSkge1xcbiAgICBpZiAoIWluaXRpYWwgfHwgIVJ1bGVDb250YWluZXIuaGFzKHJ1bGUpKSB7IHJldHVybiB0cnVlOyB9XFxuXFxuICAgIHJldHVybiBSdWxlQ29udGFpbmVyLmlzSW1tZWRpYXRlKHJ1bGUpO1xcbiAgfSkuc29tZShmdW5jdGlvbiAocnVsZSkge1xcbiAgICB2YXIgcnVsZU9wdGlvbnMgPSBSdWxlQ29udGFpbmVyLmdldE9wdGlvbnMocnVsZSk7XFxuICAgIHZhciByZXN1bHQgPSB0aGlzJDEuX3Rlc3QoZmllbGQsIHZhbHVlLCB7IG5hbWU6IHJ1bGUsIHBhcmFtczogZmllbGQucnVsZXNbcnVsZV0sIG9wdGlvbnM6IHJ1bGVPcHRpb25zIH0pO1xcbiAgICBpZiAoaXNDYWxsYWJsZShyZXN1bHQudGhlbikpIHtcXG4gICAgICBwcm9taXNlcy5wdXNoKHJlc3VsdCk7XFxuICAgIH0gZWxzZSBpZiAoIXJlc3VsdC52YWxpZCAmJiB0aGlzJDEuX3Nob3VsZEJhaWwoZmllbGQpKSB7XFxuICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCByZXN1bHQuZXJyb3JzKTtcXG4gICAgICBpc0V4aXRFYXJseSA9IHRydWU7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gcHJvbWlzaWZ5IHRoZSByZXN1bHQuXFxuICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gcmVzb2x2ZShyZXN1bHQpOyB9KSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGlzRXhpdEVhcmx5O1xcbiAgfSk7XFxuXFxuICBpZiAoaXNFeGl0RWFybHkpIHtcXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHZhbGlkOiBmYWxzZSwgZXJyb3JzOiBlcnJvcnMsIGlkOiBmaWVsZC5pZCwgZmllbGQ6IGZpZWxkLm5hbWUsIHNjb3BlOiBmaWVsZC5zY29wZSB9KTtcXG4gIH1cXG5cXG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xcbiAgICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIHYpIHtcXG4gICAgICAgIHZhciByZWY7XFxuXFxuICAgICAgaWYgKCF2LnZhbGlkKSB7XFxuICAgICAgICAocmVmID0gcHJldi5lcnJvcnMpLnB1c2guYXBwbHkocmVmLCB2LmVycm9ycyk7XFxuICAgICAgfVxcblxcbiAgICAgIHByZXYudmFsaWQgPSBwcmV2LnZhbGlkICYmIHYudmFsaWQ7XFxuXFxuICAgICAgcmV0dXJuIHByZXY7XFxuICAgIH0sIHsgdmFsaWQ6IHRydWUsIGVycm9yczogZXJyb3JzLCBpZDogZmllbGQuaWQsIGZpZWxkOiBmaWVsZC5uYW1lLCBzY29wZTogZmllbGQuc2NvcGUgfSk7XFxuICB9KTtcXG59O1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWYWxpZGF0b3IucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkNCApO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWYWxpZGF0b3IsIHN0YXRpY0FjY2Vzc29ycyQxICk7XFxuXFxuLy8gXFxuXFxudmFyIG5vcm1hbGl6ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XFxuICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBrZXkpIHtcXG4gICAgICBwcmV2W2tleV0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZVtrZXldKTtcXG5cXG4gICAgICByZXR1cm4gcHJldjtcXG4gICAgfSwge30pO1xcbiAgfVxcblxcbiAgaWYgKGlzQ2FsbGFibGUodmFsdWUpKSB7XFxuICAgIHJldHVybiB2YWx1ZSgnezB9JywgWyd7MX0nLCAnezJ9JywgJ3szfSddKTtcXG4gIH1cXG5cXG4gIHJldHVybiB2YWx1ZTtcXG59O1xcblxcbnZhciBub3JtYWxpemVGb3JtYXQgPSBmdW5jdGlvbiAobG9jYWxlKSB7XFxuICAvLyBub3JtYWxpemUgbWVzc2FnZXNcXG4gIHZhciBkaWN0aW9uYXJ5ID0ge307XFxuICBpZiAobG9jYWxlLm1lc3NhZ2VzKSB7XFxuICAgIGRpY3Rpb25hcnkubWVzc2FnZXMgPSBub3JtYWxpemVWYWx1ZShsb2NhbGUubWVzc2FnZXMpO1xcbiAgfVxcblxcbiAgaWYgKGxvY2FsZS5jdXN0b20pIHtcXG4gICAgZGljdGlvbmFyeS5jdXN0b20gPSBub3JtYWxpemVWYWx1ZShsb2NhbGUuY3VzdG9tKTtcXG4gIH1cXG5cXG4gIGlmIChsb2NhbGUuYXR0cmlidXRlcykge1xcbiAgICBkaWN0aW9uYXJ5LmF0dHJpYnV0ZXMgPSBsb2NhbGUuYXR0cmlidXRlcztcXG4gIH1cXG5cXG4gIGlmICghaXNOdWxsT3JVbmRlZmluZWQobG9jYWxlLmRhdGVGb3JtYXQpKSB7XFxuICAgIGRpY3Rpb25hcnkuZGF0ZUZvcm1hdCA9IGxvY2FsZS5kYXRlRm9ybWF0O1xcbiAgfVxcblxcbiAgcmV0dXJuIGRpY3Rpb25hcnk7XFxufTtcXG5cXG52YXIgSTE4bkRpY3Rpb25hcnkgPSBmdW5jdGlvbiBJMThuRGljdGlvbmFyeSAoaTE4biwgcm9vdEtleSkge1xcbiAgdGhpcy5pMThuID0gaTE4bjtcXG4gIHRoaXMucm9vdEtleSA9IHJvb3RLZXk7XFxufTtcXG5cXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzJDUgPSB7IGxvY2FsZTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xcblxcbnByb3RvdHlwZUFjY2Vzc29ycyQ1LmxvY2FsZS5nZXQgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gdGhpcy5pMThuLmxvY2FsZTtcXG59O1xcblxcbnByb3RvdHlwZUFjY2Vzc29ycyQ1LmxvY2FsZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG4gIHdhcm4oJ0Nhbm5vdCBzZXQgbG9jYWxlIGZyb20gdGhlIHZhbGlkYXRvciB3aGVuIHVzaW5nIHZ1ZS1pMThuLCB1c2UgaTE4bi5sb2NhbGUgc2V0dGVyIGluc3RlYWQnKTtcXG59O1xcblxcbkkxOG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXREYXRlRm9ybWF0ID0gZnVuY3Rpb24gZ2V0RGF0ZUZvcm1hdCAobG9jYWxlKSB7XFxuICByZXR1cm4gdGhpcy5pMThuLmdldERhdGVUaW1lRm9ybWF0KGxvY2FsZSB8fCB0aGlzLmxvY2FsZSk7XFxufTtcXG5cXG5JMThuRGljdGlvbmFyeS5wcm90b3R5cGUuc2V0RGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHNldERhdGVGb3JtYXQgKGxvY2FsZSwgdmFsdWUpIHtcXG4gIHRoaXMuaTE4bi5zZXREYXRlVGltZUZvcm1hdChsb2NhbGUgfHwgdGhpcy5sb2NhbGUsIHZhbHVlKTtcXG59O1xcblxcbkkxOG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRNZXNzYWdlID0gZnVuY3Rpb24gZ2V0TWVzc2FnZSAoXywga2V5LCBkYXRhKSB7XFxuICB2YXIgcGF0aCA9ICh0aGlzLnJvb3RLZXkpICsgXFxcIi5tZXNzYWdlcy5cXFwiICsga2V5O1xcbiAgdmFyIGRhdGFPcHRpb25zID0gZGF0YTtcXG5cXG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XFxuICAgIGRhdGFPcHRpb25zID0gW10uY29uY2F0LmFwcGx5KFtdLCBkYXRhKTtcXG4gIH1cXG5cXG4gIGlmICh0aGlzLmkxOG4udGUocGF0aCkpIHtcXG4gICAgcmV0dXJuIHRoaXMuaTE4bi50KHBhdGgsIGRhdGFPcHRpb25zKTtcXG4gIH1cXG5cXG4gIC8vIGZhbGxiYWNrIHRvIHRoZSBmYWxsYmFjayBtZXNzYWdlXFxuICBpZiAodGhpcy5pMThuLnRlKHBhdGgsIHRoaXMuaTE4bi5mYWxsYmFja0xvY2FsZSkpIHtcXG4gICAgcmV0dXJuIHRoaXMuaTE4bi50KHBhdGgsIHRoaXMuaTE4bi5mYWxsYmFja0xvY2FsZSwgZGF0YU9wdGlvbnMpO1xcbiAgfVxcblxcbiAgLy8gZmFsbGJhY2sgdG8gdGhlIHJvb3QgbWVzc2FnZVxcbiAgcmV0dXJuIHRoaXMuaTE4bi50KCgodGhpcy5yb290S2V5KSArIFxcXCIubWVzc2FnZXMuX2RlZmF1bHRcXFwiKSwgZGF0YU9wdGlvbnMpO1xcbn07XFxuXFxuSTE4bkRpY3Rpb25hcnkucHJvdG90eXBlLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZSAoXywga2V5LCBmYWxsYmFjaykge1xcbiAgICBpZiAoIGZhbGxiYWNrID09PSB2b2lkIDAgKSBmYWxsYmFjayA9ICcnO1xcblxcbiAgdmFyIHBhdGggPSAodGhpcy5yb290S2V5KSArIFxcXCIuYXR0cmlidXRlcy5cXFwiICsga2V5O1xcbiAgaWYgKHRoaXMuaTE4bi50ZShwYXRoKSkge1xcbiAgICByZXR1cm4gdGhpcy5pMThuLnQocGF0aCk7XFxuICB9XFxuXFxuICByZXR1cm4gZmFsbGJhY2s7XFxufTtcXG5cXG5JMThuRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0RmllbGRNZXNzYWdlID0gZnVuY3Rpb24gZ2V0RmllbGRNZXNzYWdlIChfLCBmaWVsZCwga2V5LCBkYXRhKSB7XFxuICB2YXIgcGF0aCA9ICh0aGlzLnJvb3RLZXkpICsgXFxcIi5jdXN0b20uXFxcIiArIGZpZWxkICsgXFxcIi5cXFwiICsga2V5O1xcbiAgaWYgKHRoaXMuaTE4bi50ZShwYXRoKSkge1xcbiAgICByZXR1cm4gdGhpcy5pMThuLnQocGF0aCwgZGF0YSk7XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcy5nZXRNZXNzYWdlKF8sIGtleSwgZGF0YSk7XFxufTtcXG5cXG5JMThuRGljdGlvbmFyeS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSQxIChkaWN0aW9uYXJ5KSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgT2JqZWN0LmtleXMoZGljdGlvbmFyeSkuZm9yRWFjaChmdW5jdGlvbiAobG9jYWxlS2V5KSB7XFxuICAgICAgdmFyIG9iajtcXG5cXG4gICAgLy8gaTE4biBkb2Vzbid0IGRlZXAgbWVyZ2VcXG4gICAgLy8gZmlyc3QgY2xvbmUgdGhlIGV4aXN0aW5nIGxvY2FsZSAoYXZvaWQgbXV0YXRpb25zIHRvIGxvY2FsZSlcXG4gICAgdmFyIGNsb25lID0gbWVyZ2Uoe30sIGdldFBhdGgoKGxvY2FsZUtleSArIFxcXCIuXFxcIiArICh0aGlzJDEucm9vdEtleSkpLCB0aGlzJDEuaTE4bi5tZXNzYWdlcywge30pKTtcXG4gICAgLy8gTWVyZ2UgY2xvbmVkIGxvY2FsZSB3aXRoIG5ldyBvbmVcXG4gICAgdmFyIGxvY2FsZSA9IG1lcmdlKGNsb25lLCBub3JtYWxpemVGb3JtYXQoZGljdGlvbmFyeVtsb2NhbGVLZXldKSk7XFxuICAgIHRoaXMkMS5pMThuLm1lcmdlTG9jYWxlTWVzc2FnZShsb2NhbGVLZXksICggb2JqID0ge30sIG9ialt0aGlzJDEucm9vdEtleV0gPSBsb2NhbGUsIG9iaiApKTtcXG4gICAgaWYgKGxvY2FsZS5kYXRlRm9ybWF0KSB7XFxuICAgICAgdGhpcyQxLmkxOG4uc2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlS2V5LCBsb2NhbGUuZGF0ZUZvcm1hdCk7XFxuICAgIH1cXG4gIH0pO1xcbn07XFxuXFxuSTE4bkRpY3Rpb25hcnkucHJvdG90eXBlLnNldE1lc3NhZ2UgPSBmdW5jdGlvbiBzZXRNZXNzYWdlIChsb2NhbGUsIGtleSwgdmFsdWUpIHtcXG4gICAgdmFyIG9iaiwgb2JqJDE7XFxuXFxuICB0aGlzLm1lcmdlKCggb2JqJDEgPSB7fSwgb2JqJDFbbG9jYWxlXSA9IHtcXG4gICAgICBtZXNzYWdlczogKCBvYmogPSB7fSwgb2JqW2tleV0gPSB2YWx1ZSwgb2JqIClcXG4gICAgfSwgb2JqJDEgKSk7XFxufTtcXG5cXG5JMThuRGljdGlvbmFyeS5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gc2V0QXR0cmlidXRlIChsb2NhbGUsIGtleSwgdmFsdWUpIHtcXG4gICAgdmFyIG9iaiwgb2JqJDE7XFxuXFxuICB0aGlzLm1lcmdlKCggb2JqJDEgPSB7fSwgb2JqJDFbbG9jYWxlXSA9IHtcXG4gICAgICBhdHRyaWJ1dGVzOiAoIG9iaiA9IHt9LCBvYmpba2V5XSA9IHZhbHVlLCBvYmogKVxcbiAgICB9LCBvYmokMSApKTtcXG59O1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBJMThuRGljdGlvbmFyeS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQ1ICk7XFxuXFxudmFyIGFnZ3Jlc3NpdmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xcbiAgb246IFsnaW5wdXQnXVxcbn0pOyB9O1xcblxcbnZhciBsYXp5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcXG4gIG9uOiBbJ2NoYW5nZSddXFxufSk7IH07XFxuXFxudmFyIGVhZ2VyID0gZnVuY3Rpb24gKHJlZikge1xcbiAgdmFyIGVycm9ycyA9IHJlZi5lcnJvcnM7XFxuXFxuICBpZiAoZXJyb3JzLmxlbmd0aCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIG9uOiBbJ2lucHV0J11cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiB7XFxuICAgIG9uOiBbJ2NoYW5nZScsICdibHVyJ11cXG4gIH07XFxufTtcXG5cXG52YXIgcGFzc2l2ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XFxuICBvbjogW11cXG59KTsgfTtcXG5cXG52YXIgbW9kZXMgPSB7XFxuICBhZ2dyZXNzaXZlOiBhZ2dyZXNzaXZlLFxcbiAgZWFnZXI6IGVhZ2VyLFxcbiAgcGFzc2l2ZTogcGFzc2l2ZSxcXG4gIGxhenk6IGxhenlcXG59O1xcblxcbi8vIFxcblxcbnZhciBWdWU7XFxudmFyIHBlbmRpbmdQbHVnaW5zO1xcbnZhciBwbHVnaW5JbnN0YW5jZTtcXG5cXG52YXIgVmVlVmFsaWRhdGUkMSA9IGZ1bmN0aW9uIFZlZVZhbGlkYXRlIChjb25maWcsIF9WdWUpIHtcXG4gIHRoaXMuY29uZmlndXJlKGNvbmZpZyk7XFxuICBwbHVnaW5JbnN0YW5jZSA9IHRoaXM7XFxuICBpZiAoX1Z1ZSkge1xcbiAgICBWdWUgPSBfVnVlO1xcbiAgfVxcbiAgdGhpcy5fdmFsaWRhdG9yID0gc2V0VmFsaWRhdG9yKFxcbiAgICBuZXcgVmFsaWRhdG9yKG51bGwsIHsgZmFzdEV4aXQ6IGNvbmZpZyAmJiBjb25maWcuZmFzdEV4aXQgfSwgdGhpcylcXG4gICk7XFxuICB0aGlzLl9pbml0Vk0odGhpcy5jb25maWcpO1xcbiAgdGhpcy5faW5pdEkxOG4odGhpcy5jb25maWcpO1xcbn07XFxuXFxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyQ2ID0geyBpMThuRHJpdmVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGNvbmZpZzogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xcbnZhciBzdGF0aWNBY2Nlc3NvcnMkMiA9IHsgaTE4bkRyaXZlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxjb25maWc6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcXG5cXG5WZWVWYWxpZGF0ZSQxLnNldEkxOG5Ecml2ZXIgPSBmdW5jdGlvbiBzZXRJMThuRHJpdmVyIChkcml2ZXIsIGluc3RhbmNlKSB7XFxuICBEaWN0aW9uYXJ5UmVzb2x2ZXIuc2V0RHJpdmVyKGRyaXZlciwgaW5zdGFuY2UpO1xcbn07XFxuXFxuVmVlVmFsaWRhdGUkMS5jb25maWd1cmUgPSBmdW5jdGlvbiBjb25maWd1cmUgKGNmZykge1xcbiAgc2V0Q29uZmlnKGNmZyk7XFxufTtcXG5cXG5WZWVWYWxpZGF0ZSQxLnNldE1vZGUgPSBmdW5jdGlvbiBzZXRNb2RlIChtb2RlLCBpbXBsZW1lbnRhdGlvbikge1xcbiAgc2V0Q29uZmlnKHsgbW9kZTogbW9kZSB9KTtcXG4gIGlmICghaW1wbGVtZW50YXRpb24pIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgaWYgKCFpc0NhbGxhYmxlKGltcGxlbWVudGF0aW9uKSkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgbW9kZSBpbXBsZW1lbnRhdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcXG4gIH1cXG5cXG4gIG1vZGVzW21vZGVdID0gaW1wbGVtZW50YXRpb247XFxufTtcXG5cXG5WZWVWYWxpZGF0ZSQxLnVzZSA9IGZ1bmN0aW9uIHVzZSAocGx1Z2luLCBvcHRpb25zKSB7XFxuICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xcblxcbiAgaWYgKCFpc0NhbGxhYmxlKHBsdWdpbikpIHtcXG4gICAgcmV0dXJuIHdhcm4oJ1RoZSBwbHVnaW4gbXVzdCBiZSBhIGNhbGxhYmxlIGZ1bmN0aW9uJyk7XFxuICB9XFxuXFxuICAvLyBEb24ndCBpbnN0YWxsIHBsdWdpbnMgdW50aWwgdmVlLXZhbGlkYXRlIGlzIGluc3RhbGxlZC5cXG4gIGlmICghcGx1Z2luSW5zdGFuY2UpIHtcXG4gICAgaWYgKCFwZW5kaW5nUGx1Z2lucykge1xcbiAgICAgIHBlbmRpbmdQbHVnaW5zID0gW107XFxuICAgIH1cXG4gICAgcGVuZGluZ1BsdWdpbnMucHVzaCh7IHBsdWdpbjogcGx1Z2luLCBvcHRpb25zOiBvcHRpb25zIH0pO1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICBwbHVnaW4oeyBWYWxpZGF0b3I6IFZhbGlkYXRvciwgRXJyb3JCYWc6IEVycm9yQmFnLCBSdWxlczogVmFsaWRhdG9yLnJ1bGVzIH0sIG9wdGlvbnMpO1xcbn07XFxuVmVlVmFsaWRhdGUkMS5pbnN0YWxsID0gZnVuY3Rpb24gaW5zdGFsbCAoX1Z1ZSwgb3B0cykge1xcbiAgaWYgKFZ1ZSAmJiBfVnVlID09PSBWdWUpIHtcXG4gICAgaWYgKHRydWUpIHtcXG4gICAgICB3YXJuKCdhbHJlYWR5IGluc3RhbGxlZCwgVnVlLnVzZShWZWVWYWxpZGF0ZSkgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uY2UuJyk7XFxuICAgIH1cXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgVnVlID0gX1Z1ZTtcXG4gIHBsdWdpbkluc3RhbmNlID0gbmV3IFZlZVZhbGlkYXRlJDEob3B0cyk7XFxuICAvLyBpbmplY3QgdGhlIHBsdWdpbiBjb250YWluZXIgc3RhdGljYWxseSBpbnRvIHRoZSB2YWxpZGF0b3IgY2xhc3NcXG4gIFZhbGlkYXRvci4kdmVlID0gcGx1Z2luSW5zdGFuY2U7XFxuXFxuICBkZXRlY3RQYXNzaXZlU3VwcG9ydCgpO1xcblxcbiAgVnVlLm1peGluKG1peGluKTtcXG4gIFZ1ZS5kaXJlY3RpdmUoJ3ZhbGlkYXRlJywgZGlyZWN0aXZlKTtcXG4gIGlmIChwZW5kaW5nUGx1Z2lucykge1xcbiAgICBwZW5kaW5nUGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcXG4gICAgICAgIHZhciBwbHVnaW4gPSByZWYucGx1Z2luO1xcbiAgICAgICAgdmFyIG9wdGlvbnMgPSByZWYub3B0aW9ucztcXG5cXG4gICAgICBWZWVWYWxpZGF0ZSQxLnVzZShwbHVnaW4sIG9wdGlvbnMpO1xcbiAgICB9KTtcXG4gICAgcGVuZGluZ1BsdWdpbnMgPSBudWxsO1xcbiAgfVxcbn07XFxuXFxucHJvdG90eXBlQWNjZXNzb3JzJDYuaTE4bkRyaXZlci5nZXQgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gRGljdGlvbmFyeVJlc29sdmVyLmdldERyaXZlcigpO1xcbn07XFxuXFxuc3RhdGljQWNjZXNzb3JzJDIuaTE4bkRyaXZlci5nZXQgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gRGljdGlvbmFyeVJlc29sdmVyLmdldERyaXZlcigpO1xcbn07XFxuXFxucHJvdG90eXBlQWNjZXNzb3JzJDYuY29uZmlnLmdldCA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiBnZXRDb25maWcoKTtcXG59O1xcblxcbnN0YXRpY0FjY2Vzc29ycyQyLmNvbmZpZy5nZXQgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gZ2V0Q29uZmlnKCk7XFxufTtcXG5cXG5WZWVWYWxpZGF0ZSQxLnByb3RvdHlwZS5faW5pdFZNID0gZnVuY3Rpb24gX2luaXRWTSAoY29uZmlnKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgdGhpcy5fdm0gPSBuZXcgVnVlKHtcXG4gICAgZGF0YTogZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcXG4gICAgICBlcnJvcnM6IHRoaXMkMS5fdmFsaWRhdG9yLmVycm9ycyxcXG4gICAgICBmaWVsZHM6IHRoaXMkMS5fdmFsaWRhdG9yLmZpZWxkc1xcbiAgICB9KTsgfVxcbiAgfSk7XFxufTtcXG5cXG5WZWVWYWxpZGF0ZSQxLnByb3RvdHlwZS5faW5pdEkxOG4gPSBmdW5jdGlvbiBfaW5pdEkxOG4gKGNvbmZpZykge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIHZhciBkaWN0aW9uYXJ5ID0gY29uZmlnLmRpY3Rpb25hcnk7XFxuICAgIHZhciBpMThuID0gY29uZmlnLmkxOG47XFxuICAgIHZhciBpMThuUm9vdEtleSA9IGNvbmZpZy5pMThuUm9vdEtleTtcXG4gICAgdmFyIGxvY2FsZSA9IGNvbmZpZy5sb2NhbGU7XFxuICB2YXIgb25Mb2NhbGVDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoZGljdGlvbmFyeSkge1xcbiAgICAgIHRoaXMkMS5pMThuRHJpdmVyLm1lcmdlKGRpY3Rpb25hcnkpO1xcbiAgICB9XFxuXFxuICAgIHRoaXMkMS5fdmFsaWRhdG9yLmVycm9ycy5yZWdlbmVyYXRlKCk7XFxuICB9O1xcblxcbiAgLy8gaTE4IGlzIGJlaW5nIHVzZWQgZm9yIGxvY2FsaXphdGlvbi5cXG4gIGlmIChpMThuKSB7XFxuICAgIFZlZVZhbGlkYXRlJDEuc2V0STE4bkRyaXZlcignaTE4bicsIG5ldyBJMThuRGljdGlvbmFyeShpMThuLCBpMThuUm9vdEtleSkpO1xcbiAgICBpMThuLl92bS4kd2F0Y2goJ2xvY2FsZScsIG9uTG9jYWxlQ2hhbmdlZCk7XFxuICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XFxuICAgIHRoaXMuX3ZtLiRvbignbG9jYWxlQ2hhbmdlZCcsIG9uTG9jYWxlQ2hhbmdlZCk7XFxuICB9XFxuXFxuICBpZiAoZGljdGlvbmFyeSkge1xcbiAgICB0aGlzLmkxOG5Ecml2ZXIubWVyZ2UoZGljdGlvbmFyeSk7XFxuICB9XFxuXFxuICBpZiAobG9jYWxlICYmICFpMThuKSB7XFxuICAgIHRoaXMuX3ZhbGlkYXRvci5sb2NhbGl6ZShsb2NhbGUpO1xcbiAgfVxcbn07XFxuXFxuVmVlVmFsaWRhdGUkMS5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gY29uZmlndXJlIChjZmcpIHtcXG4gIHNldENvbmZpZyhjZmcpO1xcbn07XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZlZVZhbGlkYXRlJDEucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkNiApO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWZWVWYWxpZGF0ZSQxLCBzdGF0aWNBY2Nlc3NvcnMkMiApO1xcblxcblZlZVZhbGlkYXRlJDEubWl4aW4gPSBtaXhpbjtcXG5WZWVWYWxpZGF0ZSQxLmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcXG5WZWVWYWxpZGF0ZSQxLlZhbGlkYXRvciA9IFZhbGlkYXRvcjtcXG5WZWVWYWxpZGF0ZSQxLkVycm9yQmFnID0gRXJyb3JCYWc7XFxuXFxuLyoqXFxuICogRm9ybWF0ZXMgZmlsZSBzaXplLlxcbiAqXFxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBzaXplXFxuICovXFxudmFyIGZvcm1hdEZpbGVTaXplID0gZnVuY3Rpb24gKHNpemUpIHtcXG4gIHZhciB1bml0cyA9IFsnQnl0ZScsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddO1xcbiAgdmFyIHRocmVzaG9sZCA9IDEwMjQ7XFxuICBzaXplID0gTnVtYmVyKHNpemUpICogdGhyZXNob2xkO1xcbiAgdmFyIGkgPSBzaXplID09PSAwID8gMCA6IE1hdGguZmxvb3IoTWF0aC5sb2coc2l6ZSkgLyBNYXRoLmxvZyh0aHJlc2hvbGQpKTtcXG4gIHJldHVybiAoKChzaXplIC8gTWF0aC5wb3codGhyZXNob2xkLCBpKSkudG9GaXhlZCgyKSAqIDEpICsgXFxcIiBcXFwiICsgKHVuaXRzW2ldKSk7XFxufTtcXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgdmVlLXZhbGlkYXRlIGlzIGRlZmluZWQgZ2xvYmFsbHkuXFxuICovXFxudmFyIGlzRGVmaW5lZEdsb2JhbGx5ID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIHR5cGVvZiBWZWVWYWxpZGF0ZSAhPT0gJ3VuZGVmaW5lZCc7XFxufTtcXG5cXG52YXIgb2JqO1xcblxcbnZhciBtZXNzYWdlcyA9IHtcXG4gIF9kZWZhdWx0OiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcXFwiVGhlIFxcXCIgKyBmaWVsZCArIFxcXCIgdmFsdWUgaXMgbm90IHZhbGlkLlxcXCIpOyB9LFxcbiAgYWZ0ZXI6IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XFxuICAgIHZhciB0YXJnZXQgPSByZWZbMF07XFxuICAgIHZhciBpbmNsdXNpb24gPSByZWZbMV07XFxuXFxuICAgIHJldHVybiAoXFxcIlRoZSBcXFwiICsgZmllbGQgKyBcXFwiIG11c3QgYmUgYWZ0ZXIgXFxcIiArIChpbmNsdXNpb24gPyAnb3IgZXF1YWwgdG8gJyA6ICcnKSArIHRhcmdldCArIFxcXCIuXFxcIik7XFxufSxcXG4gIGFscGhhOiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcXFwiVGhlIFxcXCIgKyBmaWVsZCArIFxcXCIgZmllbGQgbWF5IG9ubHkgY29udGFpbiBhbHBoYWJldGljIGNoYXJhY3RlcnMuXFxcIik7IH0sXFxuICBhbHBoYV9kYXNoOiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcXFwiVGhlIFxcXCIgKyBmaWVsZCArIFxcXCIgZmllbGQgbWF5IGNvbnRhaW4gYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzIGFzIHdlbGwgYXMgZGFzaGVzIGFuZCB1bmRlcnNjb3Jlcy5cXFwiKTsgfSxcXG4gIGFscGhhX251bTogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXFxcIlRoZSBcXFwiICsgZmllbGQgKyBcXFwiIGZpZWxkIG1heSBvbmx5IGNvbnRhaW4gYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzLlxcXCIpOyB9LFxcbiAgYWxwaGFfc3BhY2VzOiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcXFwiVGhlIFxcXCIgKyBmaWVsZCArIFxcXCIgZmllbGQgbWF5IG9ubHkgY29udGFpbiBhbHBoYWJldGljIGNoYXJhY3RlcnMgYXMgd2VsbCBhcyBzcGFjZXMuXFxcIik7IH0sXFxuICBiZWZvcmU6IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XFxuICAgIHZhciB0YXJnZXQgPSByZWZbMF07XFxuICAgIHZhciBpbmNsdXNpb24gPSByZWZbMV07XFxuXFxuICAgIHJldHVybiAoXFxcIlRoZSBcXFwiICsgZmllbGQgKyBcXFwiIG11c3QgYmUgYmVmb3JlIFxcXCIgKyAoaW5jbHVzaW9uID8gJ29yIGVxdWFsIHRvICcgOiAnJykgKyB0YXJnZXQgKyBcXFwiLlxcXCIpO1xcbn0sXFxuICBiZXR3ZWVuOiBmdW5jdGlvbiAoZmllbGQsIHJlZikge1xcbiAgICB2YXIgbWluID0gcmVmWzBdO1xcbiAgICB2YXIgbWF4ID0gcmVmWzFdO1xcblxcbiAgICByZXR1cm4gKFxcXCJUaGUgXFxcIiArIGZpZWxkICsgXFxcIiBmaWVsZCBtdXN0IGJlIGJldHdlZW4gXFxcIiArIG1pbiArIFxcXCIgYW5kIFxcXCIgKyBtYXggKyBcXFwiLlxcXCIpO1xcbn0sXFxuICBjb25maXJtZWQ6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFxcXCJUaGUgXFxcIiArIGZpZWxkICsgXFxcIiBjb25maXJtYXRpb24gZG9lcyBub3QgbWF0Y2guXFxcIik7IH0sXFxuICBjcmVkaXRfY2FyZDogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXFxcIlRoZSBcXFwiICsgZmllbGQgKyBcXFwiIGZpZWxkIGlzIGludmFsaWQuXFxcIik7IH0sXFxuICBkYXRlX2JldHdlZW46IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XFxuICAgIHZhciBtaW4gPSByZWZbMF07XFxuICAgIHZhciBtYXggPSByZWZbMV07XFxuXFxuICAgIHJldHVybiAoXFxcIlRoZSBcXFwiICsgZmllbGQgKyBcXFwiIG11c3QgYmUgYmV0d2VlbiBcXFwiICsgbWluICsgXFxcIiBhbmQgXFxcIiArIG1heCArIFxcXCIuXFxcIik7XFxufSxcXG4gIGRhdGVfZm9ybWF0OiBmdW5jdGlvbiAoZmllbGQsIHJlZikge1xcbiAgICB2YXIgZm9ybWF0ID0gcmVmWzBdO1xcblxcbiAgICByZXR1cm4gKFxcXCJUaGUgXFxcIiArIGZpZWxkICsgXFxcIiBtdXN0IGJlIGluIHRoZSBmb3JtYXQgXFxcIiArIGZvcm1hdCArIFxcXCIuXFxcIik7XFxufSxcXG4gIGRlY2ltYWw6IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XFxuICAgIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSBbXTtcXG4gICAgdmFyIGRlY2ltYWxzID0gcmVmWzBdOyBpZiAoIGRlY2ltYWxzID09PSB2b2lkIDAgKSBkZWNpbWFscyA9ICcqJztcXG5cXG4gICAgcmV0dXJuIChcXFwiVGhlIFxcXCIgKyBmaWVsZCArIFxcXCIgZmllbGQgbXVzdCBiZSBudW1lcmljIGFuZCBtYXkgY29udGFpblxcXCIgKyAoIWRlY2ltYWxzIHx8IGRlY2ltYWxzID09PSAnKicgPyAnJyA6ICcgJyArIGRlY2ltYWxzKSArIFxcXCIgZGVjaW1hbCBwb2ludHMuXFxcIik7XFxufSxcXG4gIGRpZ2l0czogZnVuY3Rpb24gKGZpZWxkLCByZWYpIHtcXG4gICAgdmFyIGxlbmd0aCA9IHJlZlswXTtcXG5cXG4gICAgcmV0dXJuIChcXFwiVGhlIFxcXCIgKyBmaWVsZCArIFxcXCIgZmllbGQgbXVzdCBiZSBudW1lcmljIGFuZCBjb250YWlucyBleGFjdGx5IFxcXCIgKyBsZW5ndGggKyBcXFwiIGRpZ2l0cy5cXFwiKTtcXG59LFxcbiAgZGltZW5zaW9uczogZnVuY3Rpb24gKGZpZWxkLCByZWYpIHtcXG4gICAgdmFyIHdpZHRoID0gcmVmWzBdO1xcbiAgICB2YXIgaGVpZ2h0ID0gcmVmWzFdO1xcblxcbiAgICByZXR1cm4gKFxcXCJUaGUgXFxcIiArIGZpZWxkICsgXFxcIiBmaWVsZCBtdXN0IGJlIFxcXCIgKyB3aWR0aCArIFxcXCIgcGl4ZWxzIGJ5IFxcXCIgKyBoZWlnaHQgKyBcXFwiIHBpeGVscy5cXFwiKTtcXG59LFxcbiAgZW1haWw6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFxcXCJUaGUgXFxcIiArIGZpZWxkICsgXFxcIiBmaWVsZCBtdXN0IGJlIGEgdmFsaWQgZW1haWwuXFxcIik7IH0sXFxuICBleGNsdWRlZDogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXFxcIlRoZSBcXFwiICsgZmllbGQgKyBcXFwiIGZpZWxkIG11c3QgYmUgYSB2YWxpZCB2YWx1ZS5cXFwiKTsgfSxcXG4gIGV4dDogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXFxcIlRoZSBcXFwiICsgZmllbGQgKyBcXFwiIGZpZWxkIG11c3QgYmUgYSB2YWxpZCBmaWxlLlxcXCIpOyB9LFxcbiAgaW1hZ2U6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFxcXCJUaGUgXFxcIiArIGZpZWxkICsgXFxcIiBmaWVsZCBtdXN0IGJlIGFuIGltYWdlLlxcXCIpOyB9LFxcbiAgaW5jbHVkZWQ6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFxcXCJUaGUgXFxcIiArIGZpZWxkICsgXFxcIiBmaWVsZCBtdXN0IGJlIGEgdmFsaWQgdmFsdWUuXFxcIik7IH0sXFxuICBpbnRlZ2VyOiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcXFwiVGhlIFxcXCIgKyBmaWVsZCArIFxcXCIgZmllbGQgbXVzdCBiZSBhbiBpbnRlZ2VyLlxcXCIpOyB9LFxcbiAgaXA6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFxcXCJUaGUgXFxcIiArIGZpZWxkICsgXFxcIiBmaWVsZCBtdXN0IGJlIGEgdmFsaWQgaXAgYWRkcmVzcy5cXFwiKTsgfSxcXG4gIGlwX29yX2ZxZG46IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFxcXCJUaGUgXFxcIiArIGZpZWxkICsgXFxcIiBmaWVsZCBtdXN0IGJlIGEgdmFsaWQgaXAgYWRkcmVzcyBvciBGUUROLlxcXCIpOyB9LFxcbiAgbGVuZ3RoOiBmdW5jdGlvbiAoZmllbGQsIHJlZikge1xcbiAgICB2YXIgbGVuZ3RoID0gcmVmWzBdO1xcbiAgICB2YXIgbWF4ID0gcmVmWzFdO1xcblxcbiAgICBpZiAobWF4KSB7XFxuICAgICAgcmV0dXJuIChcXFwiVGhlIFxcXCIgKyBmaWVsZCArIFxcXCIgbGVuZ3RoIG11c3QgYmUgYmV0d2VlbiBcXFwiICsgbGVuZ3RoICsgXFxcIiBhbmQgXFxcIiArIG1heCArIFxcXCIuXFxcIik7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIChcXFwiVGhlIFxcXCIgKyBmaWVsZCArIFxcXCIgbGVuZ3RoIG11c3QgYmUgXFxcIiArIGxlbmd0aCArIFxcXCIuXFxcIik7XFxuICB9LFxcbiAgbWF4OiBmdW5jdGlvbiAoZmllbGQsIHJlZikge1xcbiAgICB2YXIgbGVuZ3RoID0gcmVmWzBdO1xcblxcbiAgICByZXR1cm4gKFxcXCJUaGUgXFxcIiArIGZpZWxkICsgXFxcIiBmaWVsZCBtYXkgbm90IGJlIGdyZWF0ZXIgdGhhbiBcXFwiICsgbGVuZ3RoICsgXFxcIiBjaGFyYWN0ZXJzLlxcXCIpO1xcbn0sXFxuICBtYXhfdmFsdWU6IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XFxuICAgIHZhciBtYXggPSByZWZbMF07XFxuXFxuICAgIHJldHVybiAoXFxcIlRoZSBcXFwiICsgZmllbGQgKyBcXFwiIGZpZWxkIG11c3QgYmUgXFxcIiArIG1heCArIFxcXCIgb3IgbGVzcy5cXFwiKTtcXG59LFxcbiAgbWltZXM6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFxcXCJUaGUgXFxcIiArIGZpZWxkICsgXFxcIiBmaWVsZCBtdXN0IGhhdmUgYSB2YWxpZCBmaWxlIHR5cGUuXFxcIik7IH0sXFxuICBtaW46IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XFxuICAgIHZhciBsZW5ndGggPSByZWZbMF07XFxuXFxuICAgIHJldHVybiAoXFxcIlRoZSBcXFwiICsgZmllbGQgKyBcXFwiIGZpZWxkIG11c3QgYmUgYXQgbGVhc3QgXFxcIiArIGxlbmd0aCArIFxcXCIgY2hhcmFjdGVycy5cXFwiKTtcXG59LFxcbiAgbWluX3ZhbHVlOiBmdW5jdGlvbiAoZmllbGQsIHJlZikge1xcbiAgICB2YXIgbWluID0gcmVmWzBdO1xcblxcbiAgICByZXR1cm4gKFxcXCJUaGUgXFxcIiArIGZpZWxkICsgXFxcIiBmaWVsZCBtdXN0IGJlIFxcXCIgKyBtaW4gKyBcXFwiIG9yIG1vcmUuXFxcIik7XFxufSxcXG4gIG51bWVyaWM6IGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gKFxcXCJUaGUgXFxcIiArIGZpZWxkICsgXFxcIiBmaWVsZCBtYXkgb25seSBjb250YWluIG51bWVyaWMgY2hhcmFjdGVycy5cXFwiKTsgfSxcXG4gIHJlZ2V4OiBmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChcXFwiVGhlIFxcXCIgKyBmaWVsZCArIFxcXCIgZmllbGQgZm9ybWF0IGlzIGludmFsaWQuXFxcIik7IH0sXFxuICByZXF1aXJlZDogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXFxcIlRoZSBcXFwiICsgZmllbGQgKyBcXFwiIGZpZWxkIGlzIHJlcXVpcmVkLlxcXCIpOyB9LFxcbiAgcmVxdWlyZWRfaWY6IGZ1bmN0aW9uIChmaWVsZCwgcmVmKSB7XFxuICAgIHZhciB0YXJnZXQgPSByZWZbMF07XFxuXFxuICAgIHJldHVybiAoXFxcIlRoZSBcXFwiICsgZmllbGQgKyBcXFwiIGZpZWxkIGlzIHJlcXVpcmVkIHdoZW4gdGhlIFxcXCIgKyB0YXJnZXQgKyBcXFwiIGZpZWxkIGhhcyB0aGlzIHZhbHVlLlxcXCIpO1xcbn0sXFxuICBzaXplOiBmdW5jdGlvbiAoZmllbGQsIHJlZikge1xcbiAgICB2YXIgc2l6ZSA9IHJlZlswXTtcXG5cXG4gICAgcmV0dXJuIChcXFwiVGhlIFxcXCIgKyBmaWVsZCArIFxcXCIgc2l6ZSBtdXN0IGJlIGxlc3MgdGhhbiBcXFwiICsgKGZvcm1hdEZpbGVTaXplKHNpemUpKSArIFxcXCIuXFxcIik7XFxufSxcXG4gIHVybDogZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAoXFxcIlRoZSBcXFwiICsgZmllbGQgKyBcXFwiIGZpZWxkIGlzIG5vdCBhIHZhbGlkIFVSTC5cXFwiKTsgfVxcbn07XFxuXFxudmFyIGxvY2FsZSA9IHtcXG4gIG5hbWU6ICdlbicsXFxuICBtZXNzYWdlczogbWVzc2FnZXMsXFxuICBhdHRyaWJ1dGVzOiB7fVxcbn07XFxuXFxuaWYgKGlzRGVmaW5lZEdsb2JhbGx5KCkpIHtcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxcbiAgVmVlVmFsaWRhdGUuVmFsaWRhdG9yLmxvY2FsaXplKCggb2JqID0ge30sIG9ialtsb2NhbGUubmFtZV0gPSBsb2NhbGUsIG9iaiApKTtcXG59XFxuXFxuZnVuY3Rpb24gdG9JbnRlZ2VyIChkaXJ0eU51bWJlcikge1xcbiAgaWYgKGRpcnR5TnVtYmVyID09PSBudWxsIHx8IGRpcnR5TnVtYmVyID09PSB0cnVlIHx8IGRpcnR5TnVtYmVyID09PSBmYWxzZSkge1xcbiAgICByZXR1cm4gTmFOXFxuICB9XFxuXFxuICB2YXIgbnVtYmVyID0gTnVtYmVyKGRpcnR5TnVtYmVyKTtcXG5cXG4gIGlmIChpc05hTihudW1iZXIpKSB7XFxuICAgIHJldHVybiBudW1iZXJcXG4gIH1cXG5cXG4gIHJldHVybiBudW1iZXIgPCAwID8gTWF0aC5jZWlsKG51bWJlcikgOiBNYXRoLmZsb29yKG51bWJlcilcXG59XFxuXFxudmFyIE1JTExJU0VDT05EU19JTl9NSU5VVEUgPSA2MDAwMDtcXG5cXG4vKipcXG4gKiBHb29nbGUgQ2hyb21lIGFzIG9mIDY3LjAuMzM5Ni44NyBpbnRyb2R1Y2VkIHRpbWV6b25lcyB3aXRoIG9mZnNldCB0aGF0IGluY2x1ZGVzIHNlY29uZHMuXFxuICogVGhleSB1c3VhbGx5IGFwcGVhciBmb3IgZGF0ZXMgdGhhdCBkZW5vdGUgdGltZSBiZWZvcmUgdGhlIHRpbWV6b25lcyB3ZXJlIGludHJvZHVjZWRcXG4gKiAoZS5nLiBmb3IgJ0V1cm9wZS9QcmFndWUnIHRpbWV6b25lIHRoZSBvZmZzZXQgaXMgR01UKzAwOjU3OjQ0IGJlZm9yZSAxIE9jdG9iZXIgMTg5MVxcbiAqIGFuZCBHTVQrMDE6MDA6MDAgYWZ0ZXIgdGhhdCBkYXRlKVxcbiAqXFxuICogRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIHRoZSBvZmZzZXQgaW4gbWludXRlcyBhbmQgd291bGQgcmV0dXJuIDU3IGZvciB0aGUgZXhhbXBsZSBhYm92ZSxcXG4gKiB3aGljaCB3b3VsZCBsZWFkIHRvIGluY29ycmVjdCBjYWxjdWxhdGlvbnMuXFxuICpcXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHRpbWV6b25lIG9mZnNldCBpbiBtaWxsaXNlY29uZHMgdGhhdCB0YWtlcyBzZWNvbmRzIGluIGFjY291bnQuXFxuICovXFxuZnVuY3Rpb24gZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyAoZGlydHlEYXRlKSB7XFxuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKGRpcnR5RGF0ZS5nZXRUaW1lKCkpO1xcbiAgdmFyIGJhc2VUaW1lem9uZU9mZnNldCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcXG4gIGRhdGUuc2V0U2Vjb25kcygwLCAwKTtcXG4gIHZhciBtaWxsaXNlY29uZHNQYXJ0T2ZUaW1lem9uZU9mZnNldCA9IGRhdGUuZ2V0VGltZSgpICUgTUlMTElTRUNPTkRTX0lOX01JTlVURTtcXG5cXG4gIHJldHVybiBiYXNlVGltZXpvbmVPZmZzZXQgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFICsgbWlsbGlzZWNvbmRzUGFydE9mVGltZXpvbmVPZmZzZXRcXG59XFxuXFxudmFyIE1JTExJU0VDT05EU19JTl9IT1VSID0gMzYwMDAwMDtcXG52YXIgTUlMTElTRUNPTkRTX0lOX01JTlVURSQxID0gNjAwMDA7XFxudmFyIERFRkFVTFRfQURESVRJT05BTF9ESUdJVFMgPSAyO1xcblxcbnZhciBwYXR0ZXJucyA9IHtcXG4gIGRhdGVUaW1lRGVsaW1ldGVyOiAvW1QgXS8sXFxuICBwbGFpblRpbWU6IC86LyxcXG4gIHRpbWVab25lRGVsaW1ldGVyOiAvW1ogXS9pLFxcblxcbiAgLy8geWVhciB0b2tlbnNcXG4gIFlZOiAvXihcXFxcZHsyfSkkLyxcXG4gIFlZWTogW1xcbiAgICAvXihbKy1dXFxcXGR7Mn0pJC8sIC8vIDAgYWRkaXRpb25hbCBkaWdpdHNcXG4gICAgL14oWystXVxcXFxkezN9KSQvLCAvLyAxIGFkZGl0aW9uYWwgZGlnaXRcXG4gICAgL14oWystXVxcXFxkezR9KSQvIC8vIDIgYWRkaXRpb25hbCBkaWdpdHNcXG4gIF0sXFxuICBZWVlZOiAvXihcXFxcZHs0fSkvLFxcbiAgWVlZWVk6IFtcXG4gICAgL14oWystXVxcXFxkezR9KS8sIC8vIDAgYWRkaXRpb25hbCBkaWdpdHNcXG4gICAgL14oWystXVxcXFxkezV9KS8sIC8vIDEgYWRkaXRpb25hbCBkaWdpdFxcbiAgICAvXihbKy1dXFxcXGR7Nn0pLyAvLyAyIGFkZGl0aW9uYWwgZGlnaXRzXFxuICBdLFxcblxcbiAgLy8gZGF0ZSB0b2tlbnNcXG4gIE1NOiAvXi0oXFxcXGR7Mn0pJC8sXFxuICBEREQ6IC9eLT8oXFxcXGR7M30pJC8sXFxuICBNTUREOiAvXi0/KFxcXFxkezJ9KS0/KFxcXFxkezJ9KSQvLFxcbiAgV3d3OiAvXi0/VyhcXFxcZHsyfSkkLyxcXG4gIFd3d0Q6IC9eLT9XKFxcXFxkezJ9KS0/KFxcXFxkezF9KSQvLFxcblxcbiAgSEg6IC9eKFxcXFxkezJ9KFsuLF1cXFxcZCopPykkLyxcXG4gIEhITU06IC9eKFxcXFxkezJ9KTo/KFxcXFxkezJ9KFsuLF1cXFxcZCopPykkLyxcXG4gIEhITU1TUzogL14oXFxcXGR7Mn0pOj8oXFxcXGR7Mn0pOj8oXFxcXGR7Mn0oWy4sXVxcXFxkKik/KSQvLFxcblxcbiAgLy8gdGltZXpvbmUgdG9rZW5zXFxuICB0aW1lem9uZTogLyhbWistXS4qKSQvLFxcbiAgdGltZXpvbmVaOiAvXihaKSQvLFxcbiAgdGltZXpvbmVISDogL14oWystXSkoXFxcXGR7Mn0pJC8sXFxuICB0aW1lem9uZUhITU06IC9eKFsrLV0pKFxcXFxkezJ9KTo/KFxcXFxkezJ9KSQvXFxufTtcXG5cXG4vKipcXG4gKiBAbmFtZSB0b0RhdGVcXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcXG4gKiBAc3VtbWFyeSBDb252ZXJ0IHRoZSBnaXZlbiBhcmd1bWVudCB0byBhbiBpbnN0YW5jZSBvZiBEYXRlLlxcbiAqXFxuICogQGRlc2NyaXB0aW9uXFxuICogQ29udmVydCB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cXG4gKlxcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBEYXRlLCB0aGUgZnVuY3Rpb24gcmV0dXJucyBpdHMgY2xvbmUuXFxuICpcXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYSBudW1iZXIsIGl0IGlzIHRyZWF0ZWQgYXMgYSB0aW1lc3RhbXAuXFxuICpcXG4gKiBJZiBhbiBhcmd1bWVudCBpcyBhIHN0cmluZywgdGhlIGZ1bmN0aW9uIHRyaWVzIHRvIHBhcnNlIGl0LlxcbiAqIEZ1bmN0aW9uIGFjY2VwdHMgY29tcGxldGUgSVNPIDg2MDEgZm9ybWF0cyBhcyB3ZWxsIGFzIHBhcnRpYWwgaW1wbGVtZW50YXRpb25zLlxcbiAqIElTTyA4NjAxOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxXFxuICogSWYgdGhlIGZ1bmN0aW9uIGNhbm5vdCBwYXJzZSB0aGUgc3RyaW5nIG9yIHRoZSB2YWx1ZXMgYXJlIGludmFsaWQsIGl0IHJldHVybnMgSW52YWxpZCBEYXRlLlxcbiAqXFxuICogSWYgdGhlIGFyZ3VtZW50IGlzIG5vbmUgb2YgdGhlIGFib3ZlLCB0aGUgZnVuY3Rpb24gcmV0dXJucyBJbnZhbGlkIERhdGUuXFxuICpcXG4gKiAqKk5vdGUqKjogKmFsbCogRGF0ZSBhcmd1bWVudHMgcGFzc2VkIHRvIGFueSAqZGF0ZS1mbnMqIGZ1bmN0aW9uIGlzIHByb2Nlc3NlZCBieSBgdG9EYXRlYC5cXG4gKiBBbGwgKmRhdGUtZm5zKiBmdW5jdGlvbnMgd2lsbCB0aHJvdyBgUmFuZ2VFcnJvcmAgaWYgYG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0c2AgaXMgbm90IDAsIDEsIDIgb3IgdW5kZWZpbmVkLlxcbiAqXFxuICogQHBhcmFtIHtEYXRlfFN0cmluZ3xOdW1iZXJ9IGFyZ3VtZW50IC0gdGhlIHZhbHVlIHRvIGNvbnZlcnRcXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zLiBTZWUgW09wdGlvbnNde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvT3B0aW9uc31cXG4gKiBAcGFyYW0gezB8MXwyfSBbb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzPTJdIC0gdGhlIGFkZGl0aW9uYWwgbnVtYmVyIG9mIGRpZ2l0cyBpbiB0aGUgZXh0ZW5kZWQgeWVhciBmb3JtYXRcXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIHBhcnNlZCBkYXRlIGluIHRoZSBsb2NhbCB0aW1lIHpvbmVcXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxcbiAqXFxuICogQGV4YW1wbGVcXG4gKiAvLyBDb252ZXJ0IHN0cmluZyAnMjAxNC0wMi0xMVQxMTozMDozMCcgdG8gZGF0ZTpcXG4gKiB2YXIgcmVzdWx0ID0gdG9EYXRlKCcyMDE0LTAyLTExVDExOjMwOjMwJylcXG4gKiAvLz0+IFR1ZSBGZWIgMTEgMjAxNCAxMTozMDozMFxcbiAqXFxuICogQGV4YW1wbGVcXG4gKiAvLyBDb252ZXJ0IHN0cmluZyAnKzAyMDE0MTAxJyB0byBkYXRlLFxcbiAqIC8vIGlmIHRoZSBhZGRpdGlvbmFsIG51bWJlciBvZiBkaWdpdHMgaW4gdGhlIGV4dGVuZGVkIHllYXIgZm9ybWF0IGlzIDE6XFxuICogdmFyIHJlc3VsdCA9IHRvRGF0ZSgnKzAyMDE0MTAxJywge2FkZGl0aW9uYWxEaWdpdHM6IDF9KVxcbiAqIC8vPT4gRnJpIEFwciAxMSAyMDE0IDAwOjAwOjAwXFxuICovXFxuZnVuY3Rpb24gdG9EYXRlIChhcmd1bWVudCwgZGlydHlPcHRpb25zKSB7XFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxcbiAgfVxcblxcbiAgaWYgKGFyZ3VtZW50ID09PSBudWxsKSB7XFxuICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXFxuICB9XFxuXFxuICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcXG5cXG4gIHZhciBhZGRpdGlvbmFsRGlnaXRzID0gb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzID09IG51bGwgPyBERUZBVUxUX0FERElUSU9OQUxfRElHSVRTIDogdG9JbnRlZ2VyKG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0cyk7XFxuICBpZiAoYWRkaXRpb25hbERpZ2l0cyAhPT0gMiAmJiBhZGRpdGlvbmFsRGlnaXRzICE9PSAxICYmIGFkZGl0aW9uYWxEaWdpdHMgIT09IDApIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2FkZGl0aW9uYWxEaWdpdHMgbXVzdCBiZSAwLCAxIG9yIDInKVxcbiAgfVxcblxcbiAgLy8gQ2xvbmUgdGhlIGRhdGVcXG4gIGlmIChhcmd1bWVudCBpbnN0YW5jZW9mIERhdGUgfHxcXG4gICAgKHR5cGVvZiBhcmd1bWVudCA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50KSA9PT0gJ1tvYmplY3QgRGF0ZV0nKVxcbiAgKSB7XFxuICAgIC8vIFByZXZlbnQgdGhlIGRhdGUgdG8gbG9zZSB0aGUgbWlsbGlzZWNvbmRzIHdoZW4gcGFzc2VkIHRvIG5ldyBEYXRlKCkgaW4gSUUxMFxcbiAgICByZXR1cm4gbmV3IERhdGUoYXJndW1lbnQuZ2V0VGltZSgpKVxcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnQgPT09ICdudW1iZXInIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudCkgPT09ICdbb2JqZWN0IE51bWJlcl0nKSB7XFxuICAgIHJldHVybiBuZXcgRGF0ZShhcmd1bWVudClcXG4gIH0gZWxzZSBpZiAoISh0eXBlb2YgYXJndW1lbnQgPT09ICdzdHJpbmcnIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudCkgPT09ICdbb2JqZWN0IFN0cmluZ10nKSkge1xcbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxcbiAgfVxcblxcbiAgdmFyIGRhdGVTdHJpbmdzID0gc3BsaXREYXRlU3RyaW5nKGFyZ3VtZW50KTtcXG5cXG4gIHZhciBwYXJzZVllYXJSZXN1bHQgPSBwYXJzZVllYXIoZGF0ZVN0cmluZ3MuZGF0ZSwgYWRkaXRpb25hbERpZ2l0cyk7XFxuICB2YXIgeWVhciA9IHBhcnNlWWVhclJlc3VsdC55ZWFyO1xcbiAgdmFyIHJlc3REYXRlU3RyaW5nID0gcGFyc2VZZWFyUmVzdWx0LnJlc3REYXRlU3RyaW5nO1xcblxcbiAgdmFyIGRhdGUgPSBwYXJzZURhdGUocmVzdERhdGVTdHJpbmcsIHllYXIpO1xcblxcbiAgaWYgKGlzTmFOKGRhdGUpKSB7XFxuICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXFxuICB9XFxuXFxuICBpZiAoZGF0ZSkge1xcbiAgICB2YXIgdGltZXN0YW1wID0gZGF0ZS5nZXRUaW1lKCk7XFxuICAgIHZhciB0aW1lID0gMDtcXG4gICAgdmFyIG9mZnNldDtcXG5cXG4gICAgaWYgKGRhdGVTdHJpbmdzLnRpbWUpIHtcXG4gICAgICB0aW1lID0gcGFyc2VUaW1lKGRhdGVTdHJpbmdzLnRpbWUpO1xcblxcbiAgICAgIGlmIChpc05hTih0aW1lKSkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGRhdGVTdHJpbmdzLnRpbWV6b25lKSB7XFxuICAgICAgb2Zmc2V0ID0gcGFyc2VUaW1lem9uZShkYXRlU3RyaW5ncy50aW1lem9uZSk7XFxuICAgICAgaWYgKGlzTmFOKG9mZnNldCkpIHtcXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIGdldCBvZmZzZXQgYWNjdXJhdGUgdG8gaG91ciBpbiB0aW1lem9uZXMgdGhhdCBjaGFuZ2Ugb2Zmc2V0XFxuICAgICAgb2Zmc2V0ID0gZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyhuZXcgRGF0ZSh0aW1lc3RhbXAgKyB0aW1lKSk7XFxuICAgICAgb2Zmc2V0ID0gZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyhuZXcgRGF0ZSh0aW1lc3RhbXAgKyB0aW1lICsgb2Zmc2V0KSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG5ldyBEYXRlKHRpbWVzdGFtcCArIHRpbWUgKyBvZmZzZXQpXFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBzcGxpdERhdGVTdHJpbmcgKGRhdGVTdHJpbmcpIHtcXG4gIHZhciBkYXRlU3RyaW5ncyA9IHt9O1xcbiAgdmFyIGFycmF5ID0gZGF0ZVN0cmluZy5zcGxpdChwYXR0ZXJucy5kYXRlVGltZURlbGltZXRlcik7XFxuICB2YXIgdGltZVN0cmluZztcXG5cXG4gIGlmIChwYXR0ZXJucy5wbGFpblRpbWUudGVzdChhcnJheVswXSkpIHtcXG4gICAgZGF0ZVN0cmluZ3MuZGF0ZSA9IG51bGw7XFxuICAgIHRpbWVTdHJpbmcgPSBhcnJheVswXTtcXG4gIH0gZWxzZSB7XFxuICAgIGRhdGVTdHJpbmdzLmRhdGUgPSBhcnJheVswXTtcXG4gICAgdGltZVN0cmluZyA9IGFycmF5WzFdO1xcbiAgICBpZiAocGF0dGVybnMudGltZVpvbmVEZWxpbWV0ZXIudGVzdChkYXRlU3RyaW5ncy5kYXRlKSkge1xcbiAgICAgIGRhdGVTdHJpbmdzLmRhdGUgPSBkYXRlU3RyaW5nLnNwbGl0KHBhdHRlcm5zLnRpbWVab25lRGVsaW1ldGVyKVswXTtcXG4gICAgICB0aW1lU3RyaW5nID0gZGF0ZVN0cmluZy5zdWJzdHIoZGF0ZVN0cmluZ3MuZGF0ZS5sZW5ndGgsIGRhdGVTdHJpbmcubGVuZ3RoKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKHRpbWVTdHJpbmcpIHtcXG4gICAgdmFyIHRva2VuID0gcGF0dGVybnMudGltZXpvbmUuZXhlYyh0aW1lU3RyaW5nKTtcXG4gICAgaWYgKHRva2VuKSB7XFxuICAgICAgZGF0ZVN0cmluZ3MudGltZSA9IHRpbWVTdHJpbmcucmVwbGFjZSh0b2tlblsxXSwgJycpO1xcbiAgICAgIGRhdGVTdHJpbmdzLnRpbWV6b25lID0gdG9rZW5bMV07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZGF0ZVN0cmluZ3MudGltZSA9IHRpbWVTdHJpbmc7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBkYXRlU3RyaW5nc1xcbn1cXG5cXG5mdW5jdGlvbiBwYXJzZVllYXIgKGRhdGVTdHJpbmcsIGFkZGl0aW9uYWxEaWdpdHMpIHtcXG4gIHZhciBwYXR0ZXJuWVlZID0gcGF0dGVybnMuWVlZW2FkZGl0aW9uYWxEaWdpdHNdO1xcbiAgdmFyIHBhdHRlcm5ZWVlZWSA9IHBhdHRlcm5zLllZWVlZW2FkZGl0aW9uYWxEaWdpdHNdO1xcblxcbiAgdmFyIHRva2VuO1xcblxcbiAgLy8gWVlZWSBvciDCsVlZWVlZXFxuICB0b2tlbiA9IHBhdHRlcm5zLllZWVkuZXhlYyhkYXRlU3RyaW5nKSB8fCBwYXR0ZXJuWVlZWVkuZXhlYyhkYXRlU3RyaW5nKTtcXG4gIGlmICh0b2tlbikge1xcbiAgICB2YXIgeWVhclN0cmluZyA9IHRva2VuWzFdO1xcbiAgICByZXR1cm4ge1xcbiAgICAgIHllYXI6IHBhcnNlSW50KHllYXJTdHJpbmcsIDEwKSxcXG4gICAgICByZXN0RGF0ZVN0cmluZzogZGF0ZVN0cmluZy5zbGljZSh5ZWFyU3RyaW5nLmxlbmd0aClcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gWVkgb3IgwrFZWVlcXG4gIHRva2VuID0gcGF0dGVybnMuWVkuZXhlYyhkYXRlU3RyaW5nKSB8fCBwYXR0ZXJuWVlZLmV4ZWMoZGF0ZVN0cmluZyk7XFxuICBpZiAodG9rZW4pIHtcXG4gICAgdmFyIGNlbnR1cnlTdHJpbmcgPSB0b2tlblsxXTtcXG4gICAgcmV0dXJuIHtcXG4gICAgICB5ZWFyOiBwYXJzZUludChjZW50dXJ5U3RyaW5nLCAxMCkgKiAxMDAsXFxuICAgICAgcmVzdERhdGVTdHJpbmc6IGRhdGVTdHJpbmcuc2xpY2UoY2VudHVyeVN0cmluZy5sZW5ndGgpXFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCB5ZWFyXFxuICByZXR1cm4ge1xcbiAgICB5ZWFyOiBudWxsXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHBhcnNlRGF0ZSAoZGF0ZVN0cmluZywgeWVhcikge1xcbiAgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIHllYXJcXG4gIGlmICh5ZWFyID09PSBudWxsKSB7XFxuICAgIHJldHVybiBudWxsXFxuICB9XFxuXFxuICB2YXIgdG9rZW47XFxuICB2YXIgZGF0ZTtcXG4gIHZhciBtb250aDtcXG4gIHZhciB3ZWVrO1xcblxcbiAgLy8gWVlZWVxcbiAgaWYgKGRhdGVTdHJpbmcubGVuZ3RoID09PSAwKSB7XFxuICAgIGRhdGUgPSBuZXcgRGF0ZSgwKTtcXG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyKTtcXG4gICAgcmV0dXJuIGRhdGVcXG4gIH1cXG5cXG4gIC8vIFlZWVktTU1cXG4gIHRva2VuID0gcGF0dGVybnMuTU0uZXhlYyhkYXRlU3RyaW5nKTtcXG4gIGlmICh0b2tlbikge1xcbiAgICBkYXRlID0gbmV3IERhdGUoMCk7XFxuICAgIG1vbnRoID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKSAtIDE7XFxuXFxuICAgIGlmICghdmFsaWRhdGVEYXRlKHllYXIsIG1vbnRoKSkge1xcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXFxuICAgIH1cXG5cXG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyLCBtb250aCk7XFxuICAgIHJldHVybiBkYXRlXFxuICB9XFxuXFxuICAvLyBZWVlZLURERCBvciBZWVlZREREXFxuICB0b2tlbiA9IHBhdHRlcm5zLkRERC5leGVjKGRhdGVTdHJpbmcpO1xcbiAgaWYgKHRva2VuKSB7XFxuICAgIGRhdGUgPSBuZXcgRGF0ZSgwKTtcXG4gICAgdmFyIGRheU9mWWVhciA9IHBhcnNlSW50KHRva2VuWzFdLCAxMCk7XFxuXFxuICAgIGlmICghdmFsaWRhdGVEYXlPZlllYXJEYXRlKHllYXIsIGRheU9mWWVhcikpIHtcXG4gICAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxcbiAgICB9XFxuXFxuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgMCwgZGF5T2ZZZWFyKTtcXG4gICAgcmV0dXJuIGRhdGVcXG4gIH1cXG5cXG4gIC8vIFlZWVktTU0tREQgb3IgWVlZWU1NRERcXG4gIHRva2VuID0gcGF0dGVybnMuTU1ERC5leGVjKGRhdGVTdHJpbmcpO1xcbiAgaWYgKHRva2VuKSB7XFxuICAgIGRhdGUgPSBuZXcgRGF0ZSgwKTtcXG4gICAgbW9udGggPSBwYXJzZUludCh0b2tlblsxXSwgMTApIC0gMTtcXG4gICAgdmFyIGRheSA9IHBhcnNlSW50KHRva2VuWzJdLCAxMCk7XFxuXFxuICAgIGlmICghdmFsaWRhdGVEYXRlKHllYXIsIG1vbnRoLCBkYXkpKSB7XFxuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcXG4gICAgfVxcblxcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIG1vbnRoLCBkYXkpO1xcbiAgICByZXR1cm4gZGF0ZVxcbiAgfVxcblxcbiAgLy8gWVlZWS1Xd3cgb3IgWVlZWVd3d1xcbiAgdG9rZW4gPSBwYXR0ZXJucy5Xd3cuZXhlYyhkYXRlU3RyaW5nKTtcXG4gIGlmICh0b2tlbikge1xcbiAgICB3ZWVrID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKSAtIDE7XFxuXFxuICAgIGlmICghdmFsaWRhdGVXZWVrRGF0ZSh5ZWFyLCB3ZWVrKSkge1xcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGRheU9mSVNPV2Vla1llYXIoeWVhciwgd2VlaylcXG4gIH1cXG5cXG4gIC8vIFlZWVktV3d3LUQgb3IgWVlZWVd3d0RcXG4gIHRva2VuID0gcGF0dGVybnMuV3d3RC5leGVjKGRhdGVTdHJpbmcpO1xcbiAgaWYgKHRva2VuKSB7XFxuICAgIHdlZWsgPSBwYXJzZUludCh0b2tlblsxXSwgMTApIC0gMTtcXG4gICAgdmFyIGRheU9mV2VlayA9IHBhcnNlSW50KHRva2VuWzJdLCAxMCkgLSAxO1xcblxcbiAgICBpZiAoIXZhbGlkYXRlV2Vla0RhdGUoeWVhciwgd2VlaywgZGF5T2ZXZWVrKSkge1xcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGRheU9mSVNPV2Vla1llYXIoeWVhciwgd2VlaywgZGF5T2ZXZWVrKVxcbiAgfVxcblxcbiAgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIGRhdGVcXG4gIHJldHVybiBudWxsXFxufVxcblxcbmZ1bmN0aW9uIHBhcnNlVGltZSAodGltZVN0cmluZykge1xcbiAgdmFyIHRva2VuO1xcbiAgdmFyIGhvdXJzO1xcbiAgdmFyIG1pbnV0ZXM7XFxuXFxuICAvLyBoaFxcbiAgdG9rZW4gPSBwYXR0ZXJucy5ISC5leGVjKHRpbWVTdHJpbmcpO1xcbiAgaWYgKHRva2VuKSB7XFxuICAgIGhvdXJzID0gcGFyc2VGbG9hdCh0b2tlblsxXS5yZXBsYWNlKCcsJywgJy4nKSk7XFxuXFxuICAgIGlmICghdmFsaWRhdGVUaW1lKGhvdXJzKSkge1xcbiAgICAgIHJldHVybiBOYU5cXG4gICAgfVxcblxcbiAgICByZXR1cm4gKGhvdXJzICUgMjQpICogTUlMTElTRUNPTkRTX0lOX0hPVVJcXG4gIH1cXG5cXG4gIC8vIGhoOm1tIG9yIGhobW1cXG4gIHRva2VuID0gcGF0dGVybnMuSEhNTS5leGVjKHRpbWVTdHJpbmcpO1xcbiAgaWYgKHRva2VuKSB7XFxuICAgIGhvdXJzID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKTtcXG4gICAgbWludXRlcyA9IHBhcnNlRmxvYXQodG9rZW5bMl0ucmVwbGFjZSgnLCcsICcuJykpO1xcblxcbiAgICBpZiAoIXZhbGlkYXRlVGltZShob3VycywgbWludXRlcykpIHtcXG4gICAgICByZXR1cm4gTmFOXFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIChob3VycyAlIDI0KSAqIE1JTExJU0VDT05EU19JTl9IT1VSICtcXG4gICAgICBtaW51dGVzICogTUlMTElTRUNPTkRTX0lOX01JTlVURSQxXFxuICB9XFxuXFxuICAvLyBoaDptbTpzcyBvciBoaG1tc3NcXG4gIHRva2VuID0gcGF0dGVybnMuSEhNTVNTLmV4ZWModGltZVN0cmluZyk7XFxuICBpZiAodG9rZW4pIHtcXG4gICAgaG91cnMgPSBwYXJzZUludCh0b2tlblsxXSwgMTApO1xcbiAgICBtaW51dGVzID0gcGFyc2VJbnQodG9rZW5bMl0sIDEwKTtcXG4gICAgdmFyIHNlY29uZHMgPSBwYXJzZUZsb2F0KHRva2VuWzNdLnJlcGxhY2UoJywnLCAnLicpKTtcXG5cXG4gICAgaWYgKCF2YWxpZGF0ZVRpbWUoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpKSB7XFxuICAgICAgcmV0dXJuIE5hTlxcbiAgICB9XFxuXFxuICAgIHJldHVybiAoaG91cnMgJSAyNCkgKiBNSUxMSVNFQ09ORFNfSU5fSE9VUiArXFxuICAgICAgbWludXRlcyAqIE1JTExJU0VDT05EU19JTl9NSU5VVEUkMSArXFxuICAgICAgc2Vjb25kcyAqIDEwMDBcXG4gIH1cXG5cXG4gIC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCB0aW1lXFxuICByZXR1cm4gbnVsbFxcbn1cXG5cXG5mdW5jdGlvbiBwYXJzZVRpbWV6b25lICh0aW1lem9uZVN0cmluZykge1xcbiAgdmFyIHRva2VuO1xcbiAgdmFyIGFic29sdXRlT2Zmc2V0O1xcblxcbiAgLy8gWlxcbiAgdG9rZW4gPSBwYXR0ZXJucy50aW1lem9uZVouZXhlYyh0aW1lem9uZVN0cmluZyk7XFxuICBpZiAodG9rZW4pIHtcXG4gICAgcmV0dXJuIDBcXG4gIH1cXG5cXG4gIHZhciBob3VycztcXG5cXG4gIC8vIMKxaGhcXG4gIHRva2VuID0gcGF0dGVybnMudGltZXpvbmVISC5leGVjKHRpbWV6b25lU3RyaW5nKTtcXG4gIGlmICh0b2tlbikge1xcbiAgICBob3VycyA9IHBhcnNlSW50KHRva2VuWzJdLCAxMCk7XFxuXFxuICAgIGlmICghdmFsaWRhdGVUaW1lem9uZShob3VycykpIHtcXG4gICAgICByZXR1cm4gTmFOXFxuICAgIH1cXG5cXG4gICAgYWJzb2x1dGVPZmZzZXQgPSBob3VycyAqIE1JTExJU0VDT05EU19JTl9IT1VSO1xcbiAgICByZXR1cm4gKHRva2VuWzFdID09PSAnKycpID8gLWFic29sdXRlT2Zmc2V0IDogYWJzb2x1dGVPZmZzZXRcXG4gIH1cXG5cXG4gIC8vIMKxaGg6bW0gb3IgwrFoaG1tXFxuICB0b2tlbiA9IHBhdHRlcm5zLnRpbWV6b25lSEhNTS5leGVjKHRpbWV6b25lU3RyaW5nKTtcXG4gIGlmICh0b2tlbikge1xcbiAgICBob3VycyA9IHBhcnNlSW50KHRva2VuWzJdLCAxMCk7XFxuICAgIHZhciBtaW51dGVzID0gcGFyc2VJbnQodG9rZW5bM10sIDEwKTtcXG5cXG4gICAgaWYgKCF2YWxpZGF0ZVRpbWV6b25lKGhvdXJzLCBtaW51dGVzKSkge1xcbiAgICAgIHJldHVybiBOYU5cXG4gICAgfVxcblxcbiAgICBhYnNvbHV0ZU9mZnNldCA9IGhvdXJzICogTUlMTElTRUNPTkRTX0lOX0hPVVIgKyBtaW51dGVzICogTUlMTElTRUNPTkRTX0lOX01JTlVURSQxO1xcbiAgICByZXR1cm4gKHRva2VuWzFdID09PSAnKycpID8gLWFic29sdXRlT2Zmc2V0IDogYWJzb2x1dGVPZmZzZXRcXG4gIH1cXG5cXG4gIHJldHVybiAwXFxufVxcblxcbmZ1bmN0aW9uIGRheU9mSVNPV2Vla1llYXIgKGlzb1dlZWtZZWFyLCB3ZWVrLCBkYXkpIHtcXG4gIHdlZWsgPSB3ZWVrIHx8IDA7XFxuICBkYXkgPSBkYXkgfHwgMDtcXG4gIHZhciBkYXRlID0gbmV3IERhdGUoMCk7XFxuICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGlzb1dlZWtZZWFyLCAwLCA0KTtcXG4gIHZhciBmb3VydGhPZkphbnVhcnlEYXkgPSBkYXRlLmdldFVUQ0RheSgpIHx8IDc7XFxuICB2YXIgZGlmZiA9IHdlZWsgKiA3ICsgZGF5ICsgMSAtIGZvdXJ0aE9mSmFudWFyeURheTtcXG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIGRpZmYpO1xcbiAgcmV0dXJuIGRhdGVcXG59XFxuXFxuLy8gVmFsaWRhdGlvbiBmdW5jdGlvbnNcXG5cXG52YXIgREFZU19JTl9NT05USCA9IFszMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTtcXG52YXIgREFZU19JTl9NT05USF9MRUFQX1lFQVIgPSBbMzEsIDI5LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XFxuXFxuZnVuY3Rpb24gaXNMZWFwWWVhckluZGV4ICh5ZWFyKSB7XFxuICByZXR1cm4geWVhciAlIDQwMCA9PT0gMCB8fCAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMClcXG59XFxuXFxuZnVuY3Rpb24gdmFsaWRhdGVEYXRlICh5ZWFyLCBtb250aCwgZGF0ZSkge1xcbiAgaWYgKG1vbnRoIDwgMCB8fCBtb250aCA+IDExKSB7XFxuICAgIHJldHVybiBmYWxzZVxcbiAgfVxcblxcbiAgaWYgKGRhdGUgIT0gbnVsbCkge1xcbiAgICBpZiAoZGF0ZSA8IDEpIHtcXG4gICAgICByZXR1cm4gZmFsc2VcXG4gICAgfVxcblxcbiAgICB2YXIgaXNMZWFwWWVhciA9IGlzTGVhcFllYXJJbmRleCh5ZWFyKTtcXG4gICAgaWYgKGlzTGVhcFllYXIgJiYgZGF0ZSA+IERBWVNfSU5fTU9OVEhfTEVBUF9ZRUFSW21vbnRoXSkge1xcbiAgICAgIHJldHVybiBmYWxzZVxcbiAgICB9XFxuICAgIGlmICghaXNMZWFwWWVhciAmJiBkYXRlID4gREFZU19JTl9NT05USFttb250aF0pIHtcXG4gICAgICByZXR1cm4gZmFsc2VcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHRydWVcXG59XFxuXFxuZnVuY3Rpb24gdmFsaWRhdGVEYXlPZlllYXJEYXRlICh5ZWFyLCBkYXlPZlllYXIpIHtcXG4gIGlmIChkYXlPZlllYXIgPCAxKSB7XFxuICAgIHJldHVybiBmYWxzZVxcbiAgfVxcblxcbiAgdmFyIGlzTGVhcFllYXIgPSBpc0xlYXBZZWFySW5kZXgoeWVhcik7XFxuICBpZiAoaXNMZWFwWWVhciAmJiBkYXlPZlllYXIgPiAzNjYpIHtcXG4gICAgcmV0dXJuIGZhbHNlXFxuICB9XFxuICBpZiAoIWlzTGVhcFllYXIgJiYgZGF5T2ZZZWFyID4gMzY1KSB7XFxuICAgIHJldHVybiBmYWxzZVxcbiAgfVxcblxcbiAgcmV0dXJuIHRydWVcXG59XFxuXFxuZnVuY3Rpb24gdmFsaWRhdGVXZWVrRGF0ZSAoeWVhciwgd2VlaywgZGF5KSB7XFxuICBpZiAod2VlayA8IDAgfHwgd2VlayA+IDUyKSB7XFxuICAgIHJldHVybiBmYWxzZVxcbiAgfVxcblxcbiAgaWYgKGRheSAhPSBudWxsICYmIChkYXkgPCAwIHx8IGRheSA+IDYpKSB7XFxuICAgIHJldHVybiBmYWxzZVxcbiAgfVxcblxcbiAgcmV0dXJuIHRydWVcXG59XFxuXFxuZnVuY3Rpb24gdmFsaWRhdGVUaW1lIChob3VycywgbWludXRlcywgc2Vjb25kcykge1xcbiAgaWYgKGhvdXJzICE9IG51bGwgJiYgKGhvdXJzIDwgMCB8fCBob3VycyA+PSAyNSkpIHtcXG4gICAgcmV0dXJuIGZhbHNlXFxuICB9XFxuXFxuICBpZiAobWludXRlcyAhPSBudWxsICYmIChtaW51dGVzIDwgMCB8fCBtaW51dGVzID49IDYwKSkge1xcbiAgICByZXR1cm4gZmFsc2VcXG4gIH1cXG5cXG4gIGlmIChzZWNvbmRzICE9IG51bGwgJiYgKHNlY29uZHMgPCAwIHx8IHNlY29uZHMgPj0gNjApKSB7XFxuICAgIHJldHVybiBmYWxzZVxcbiAgfVxcblxcbiAgcmV0dXJuIHRydWVcXG59XFxuXFxuZnVuY3Rpb24gdmFsaWRhdGVUaW1lem9uZSAoaG91cnMsIG1pbnV0ZXMpIHtcXG4gIGlmIChtaW51dGVzICE9IG51bGwgJiYgKG1pbnV0ZXMgPCAwIHx8IG1pbnV0ZXMgPiA1OSkpIHtcXG4gICAgcmV0dXJuIGZhbHNlXFxuICB9XFxuXFxuICByZXR1cm4gdHJ1ZVxcbn1cXG5cXG4vKipcXG4gKiBAbmFtZSBhZGRNaWxsaXNlY29uZHNcXG4gKiBAY2F0ZWdvcnkgTWlsbGlzZWNvbmQgSGVscGVyc1xcbiAqIEBzdW1tYXJ5IEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhlIGdpdmVuIGRhdGUuXFxuICpcXG4gKiBAZGVzY3JpcHRpb25cXG4gKiBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRoZSBnaXZlbiBkYXRlLlxcbiAqXFxuICogQHBhcmFtIHtEYXRlfFN0cmluZ3xOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBiZSBjaGFuZ2VkXFxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIHRvIGJlIGFkZGVkXFxuICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gLSB0aGUgb2JqZWN0IHdpdGggb3B0aW9ucy4gU2VlIFtPcHRpb25zXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL09wdGlvbnN9XFxuICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHBhc3NlZCB0byBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgbmV3IGRhdGUgd2l0aCB0aGUgbWlsbGlzZWNvbmRzIGFkZGVkXFxuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIG11c3QgYmUgMCwgMSBvciAyXFxuICpcXG4gKiBAZXhhbXBsZVxcbiAqIC8vIEFkZCA3NTAgbWlsbGlzZWNvbmRzIHRvIDEwIEp1bHkgMjAxNCAxMjo0NTozMC4wMDA6XFxuICogdmFyIHJlc3VsdCA9IGFkZE1pbGxpc2Vjb25kcyhuZXcgRGF0ZSgyMDE0LCA2LCAxMCwgMTIsIDQ1LCAzMCwgMCksIDc1MClcXG4gKiAvLz0+IFRodSBKdWwgMTAgMjAxNCAxMjo0NTozMC43NTBcXG4gKi9cXG5mdW5jdGlvbiBhZGRNaWxsaXNlY29uZHMgKGRpcnR5RGF0ZSwgZGlydHlBbW91bnQsIGRpcnR5T3B0aW9ucykge1xcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpXFxuICB9XFxuXFxuICB2YXIgdGltZXN0YW1wID0gdG9EYXRlKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKS5nZXRUaW1lKCk7XFxuICB2YXIgYW1vdW50ID0gdG9JbnRlZ2VyKGRpcnR5QW1vdW50KTtcXG4gIHJldHVybiBuZXcgRGF0ZSh0aW1lc3RhbXAgKyBhbW91bnQpXFxufVxcblxcbi8qKlxcbiAqIEBuYW1lIGlzVmFsaWRcXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcXG4gKiBAc3VtbWFyeSBJcyB0aGUgZ2l2ZW4gZGF0ZSB2YWxpZD9cXG4gKlxcbiAqIEBkZXNjcmlwdGlvblxcbiAqIFJldHVybnMgZmFsc2UgaWYgYXJndW1lbnQgaXMgSW52YWxpZCBEYXRlIGFuZCB0cnVlIG90aGVyd2lzZS5cXG4gKiBBcmd1bWVudCBpcyBjb252ZXJ0ZWQgdG8gRGF0ZSB1c2luZyBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxcbiAqIEludmFsaWQgRGF0ZSBpcyBhIERhdGUsIHdob3NlIHRpbWUgdmFsdWUgaXMgTmFOLlxcbiAqXFxuICogVGltZSB2YWx1ZSBvZiBEYXRlOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjkuMS4xXFxuICpcXG4gKiBAcGFyYW0geyp9IGRhdGUgLSB0aGUgZGF0ZSB0byBjaGVja1xcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIC0gdGhlIG9iamVjdCB3aXRoIG9wdGlvbnMuIFNlZSBbT3B0aW9uc117QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9PcHRpb25zfVxcbiAqIEBwYXJhbSB7MHwxfDJ9IFtvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHM9Ml0gLSBwYXNzZWQgdG8gYHRvRGF0ZWAuIFNlZSBbdG9EYXRlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3RvRGF0ZX1cXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdGhlIGRhdGUgaXMgdmFsaWRcXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxcbiAqXFxuICogQGV4YW1wbGVcXG4gKiAvLyBGb3IgdGhlIHZhbGlkIGRhdGU6XFxuICogdmFyIHJlc3VsdCA9IGlzVmFsaWQobmV3IERhdGUoMjAxNCwgMSwgMzEpKVxcbiAqIC8vPT4gdHJ1ZVxcbiAqXFxuICogQGV4YW1wbGVcXG4gKiAvLyBGb3IgdGhlIHZhbHVlLCBjb252ZXJ0YWJsZSBpbnRvIGEgZGF0ZTpcXG4gKiB2YXIgcmVzdWx0ID0gaXNWYWxpZCgnMjAxNC0wMi0zMScpXFxuICogLy89PiB0cnVlXFxuICpcXG4gKiBAZXhhbXBsZVxcbiAqIC8vIEZvciB0aGUgaW52YWxpZCBkYXRlOlxcbiAqIHZhciByZXN1bHQgPSBpc1ZhbGlkKG5ldyBEYXRlKCcnKSlcXG4gKiAvLz0+IGZhbHNlXFxuICovXFxuZnVuY3Rpb24gaXNWYWxpZCAoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpXFxuICB9XFxuXFxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XFxuICByZXR1cm4gIWlzTmFOKGRhdGUpXFxufVxcblxcbnZhciBmb3JtYXREaXN0YW5jZUxvY2FsZSA9IHtcXG4gIGxlc3NUaGFuWFNlY29uZHM6IHtcXG4gICAgb25lOiAnbGVzcyB0aGFuIGEgc2Vjb25kJyxcXG4gICAgb3RoZXI6ICdsZXNzIHRoYW4ge3tjb3VudH19IHNlY29uZHMnXFxuICB9LFxcblxcbiAgeFNlY29uZHM6IHtcXG4gICAgb25lOiAnMSBzZWNvbmQnLFxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSBzZWNvbmRzJ1xcbiAgfSxcXG5cXG4gIGhhbGZBTWludXRlOiAnaGFsZiBhIG1pbnV0ZScsXFxuXFxuICBsZXNzVGhhblhNaW51dGVzOiB7XFxuICAgIG9uZTogJ2xlc3MgdGhhbiBhIG1pbnV0ZScsXFxuICAgIG90aGVyOiAnbGVzcyB0aGFuIHt7Y291bnR9fSBtaW51dGVzJ1xcbiAgfSxcXG5cXG4gIHhNaW51dGVzOiB7XFxuICAgIG9uZTogJzEgbWludXRlJyxcXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gbWludXRlcydcXG4gIH0sXFxuXFxuICBhYm91dFhIb3Vyczoge1xcbiAgICBvbmU6ICdhYm91dCAxIGhvdXInLFxcbiAgICBvdGhlcjogJ2Fib3V0IHt7Y291bnR9fSBob3VycydcXG4gIH0sXFxuXFxuICB4SG91cnM6IHtcXG4gICAgb25lOiAnMSBob3VyJyxcXG4gICAgb3RoZXI6ICd7e2NvdW50fX0gaG91cnMnXFxuICB9LFxcblxcbiAgeERheXM6IHtcXG4gICAgb25lOiAnMSBkYXknLFxcbiAgICBvdGhlcjogJ3t7Y291bnR9fSBkYXlzJ1xcbiAgfSxcXG5cXG4gIGFib3V0WE1vbnRoczoge1xcbiAgICBvbmU6ICdhYm91dCAxIG1vbnRoJyxcXG4gICAgb3RoZXI6ICdhYm91dCB7e2NvdW50fX0gbW9udGhzJ1xcbiAgfSxcXG5cXG4gIHhNb250aHM6IHtcXG4gICAgb25lOiAnMSBtb250aCcsXFxuICAgIG90aGVyOiAne3tjb3VudH19IG1vbnRocydcXG4gIH0sXFxuXFxuICBhYm91dFhZZWFyczoge1xcbiAgICBvbmU6ICdhYm91dCAxIHllYXInLFxcbiAgICBvdGhlcjogJ2Fib3V0IHt7Y291bnR9fSB5ZWFycydcXG4gIH0sXFxuXFxuICB4WWVhcnM6IHtcXG4gICAgb25lOiAnMSB5ZWFyJyxcXG4gICAgb3RoZXI6ICd7e2NvdW50fX0geWVhcnMnXFxuICB9LFxcblxcbiAgb3ZlclhZZWFyczoge1xcbiAgICBvbmU6ICdvdmVyIDEgeWVhcicsXFxuICAgIG90aGVyOiAnb3ZlciB7e2NvdW50fX0geWVhcnMnXFxuICB9LFxcblxcbiAgYWxtb3N0WFllYXJzOiB7XFxuICAgIG9uZTogJ2FsbW9zdCAxIHllYXInLFxcbiAgICBvdGhlcjogJ2FsbW9zdCB7e2NvdW50fX0geWVhcnMnXFxuICB9XFxufTtcXG5cXG5mdW5jdGlvbiBmb3JtYXREaXN0YW5jZSAodG9rZW4sIGNvdW50LCBvcHRpb25zKSB7XFxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG4gIHZhciByZXN1bHQ7XFxuICBpZiAodHlwZW9mIGZvcm1hdERpc3RhbmNlTG9jYWxlW3Rva2VuXSA9PT0gJ3N0cmluZycpIHtcXG4gICAgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2VMb2NhbGVbdG9rZW5dO1xcbiAgfSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xcbiAgICByZXN1bHQgPSBmb3JtYXREaXN0YW5jZUxvY2FsZVt0b2tlbl0ub25lO1xcbiAgfSBlbHNlIHtcXG4gICAgcmVzdWx0ID0gZm9ybWF0RGlzdGFuY2VMb2NhbGVbdG9rZW5dLm90aGVyLnJlcGxhY2UoJ3t7Y291bnR9fScsIGNvdW50KTtcXG4gIH1cXG5cXG4gIGlmIChvcHRpb25zLmFkZFN1ZmZpeCkge1xcbiAgICBpZiAob3B0aW9ucy5jb21wYXJpc29uID4gMCkge1xcbiAgICAgIHJldHVybiAnaW4gJyArIHJlc3VsdFxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiByZXN1bHQgKyAnIGFnbydcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHJlc3VsdFxcbn1cXG5cXG5mdW5jdGlvbiBidWlsZEZvcm1hdExvbmdGbiAoYXJncykge1xcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXJ0eU9wdGlvbnMpIHtcXG4gICAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XFxuICAgIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGggPyBTdHJpbmcob3B0aW9ucy53aWR0aCkgOiBhcmdzLmRlZmF1bHRXaWR0aDtcXG4gICAgdmFyIGZvcm1hdCA9IGFyZ3MuZm9ybWF0c1t3aWR0aF0gfHwgYXJncy5mb3JtYXRzW2FyZ3MuZGVmYXVsdFdpZHRoXTtcXG4gICAgcmV0dXJuIGZvcm1hdFxcbiAgfVxcbn1cXG5cXG52YXIgZGF0ZUZvcm1hdHMgPSB7XFxuICBmdWxsOiAnRUVFRSwgTU1NTSBkbywgeScsXFxuICBsb25nOiAnTU1NTSBkbywgeScsXFxuICBtZWRpdW06ICdNTU0gZCwgeScsXFxuICBzaG9ydDogJ01NL2RkL3l5eXknXFxufTtcXG5cXG52YXIgdGltZUZvcm1hdHMgPSB7XFxuICBmdWxsOiAnaDptbTpzcyBhIHp6enonLFxcbiAgbG9uZzogJ2g6bW06c3MgYSB6JyxcXG4gIG1lZGl1bTogJ2g6bW06c3MgYScsXFxuICBzaG9ydDogJ2g6bW0gYSdcXG59O1xcblxcbnZhciBkYXRlVGltZUZvcm1hdHMgPSB7XFxuICBmdWxsOiBcXFwie3tkYXRlfX0gJ2F0JyB7e3RpbWV9fVxcXCIsXFxuICBsb25nOiBcXFwie3tkYXRlfX0gJ2F0JyB7e3RpbWV9fVxcXCIsXFxuICBtZWRpdW06ICd7e2RhdGV9fSwge3t0aW1lfX0nLFxcbiAgc2hvcnQ6ICd7e2RhdGV9fSwge3t0aW1lfX0nXFxufTtcXG5cXG52YXIgZm9ybWF0TG9uZyA9IHtcXG4gIGRhdGU6IGJ1aWxkRm9ybWF0TG9uZ0ZuKHtcXG4gICAgZm9ybWF0czogZGF0ZUZvcm1hdHMsXFxuICAgIGRlZmF1bHRXaWR0aDogJ2Z1bGwnXFxuICB9KSxcXG5cXG4gIHRpbWU6IGJ1aWxkRm9ybWF0TG9uZ0ZuKHtcXG4gICAgZm9ybWF0czogdGltZUZvcm1hdHMsXFxuICAgIGRlZmF1bHRXaWR0aDogJ2Z1bGwnXFxuICB9KSxcXG5cXG4gIGRhdGVUaW1lOiBidWlsZEZvcm1hdExvbmdGbih7XFxuICAgIGZvcm1hdHM6IGRhdGVUaW1lRm9ybWF0cyxcXG4gICAgZGVmYXVsdFdpZHRoOiAnZnVsbCdcXG4gIH0pXFxufTtcXG5cXG52YXIgZm9ybWF0UmVsYXRpdmVMb2NhbGUgPSB7XFxuICBsYXN0V2VlazogXFxcIidsYXN0JyBlZWVlICdhdCcgcFxcXCIsXFxuICB5ZXN0ZXJkYXk6IFxcXCIneWVzdGVyZGF5IGF0JyBwXFxcIixcXG4gIHRvZGF5OiBcXFwiJ3RvZGF5IGF0JyBwXFxcIixcXG4gIHRvbW9ycm93OiBcXFwiJ3RvbW9ycm93IGF0JyBwXFxcIixcXG4gIG5leHRXZWVrOiBcXFwiZWVlZSAnYXQnIHBcXFwiLFxcbiAgb3RoZXI6ICdQJ1xcbn07XFxuXFxuZnVuY3Rpb24gZm9ybWF0UmVsYXRpdmUgKHRva2VuLCBkYXRlLCBiYXNlRGF0ZSwgb3B0aW9ucykge1xcbiAgcmV0dXJuIGZvcm1hdFJlbGF0aXZlTG9jYWxlW3Rva2VuXVxcbn1cXG5cXG5mdW5jdGlvbiBidWlsZExvY2FsaXplRm4gKGFyZ3MpIHtcXG4gIHJldHVybiBmdW5jdGlvbiAoZGlydHlJbmRleCwgZGlydHlPcHRpb25zKSB7XFxuICAgIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xcbiAgICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoID8gU3RyaW5nKG9wdGlvbnMud2lkdGgpIDogYXJncy5kZWZhdWx0V2lkdGg7XFxuICAgIHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0ID8gU3RyaW5nKG9wdGlvbnMuY29udGV4dCkgOiAnc3RhbmRhbG9uZSc7XFxuXFxuICAgIHZhciB2YWx1ZXNBcnJheTtcXG4gICAgaWYgKGNvbnRleHQgPT09ICdmb3JtYXR0aW5nJyAmJiBhcmdzLmZvcm1hdHRpbmdWYWx1ZXMpIHtcXG4gICAgICB2YWx1ZXNBcnJheSA9IGFyZ3MuZm9ybWF0dGluZ1ZhbHVlc1t3aWR0aF0gfHwgYXJncy5mb3JtYXR0aW5nVmFsdWVzW2FyZ3MuZGVmYXVsdEZvcm1hdHRpbmdXaWR0aF07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFsdWVzQXJyYXkgPSBhcmdzLnZhbHVlc1t3aWR0aF0gfHwgYXJncy52YWx1ZXNbYXJncy5kZWZhdWx0V2lkdGhdO1xcbiAgICB9XFxuICAgIHZhciBpbmRleCA9IGFyZ3MuYXJndW1lbnRDYWxsYmFjayA/IGFyZ3MuYXJndW1lbnRDYWxsYmFjayhkaXJ0eUluZGV4KSA6IGRpcnR5SW5kZXg7XFxuICAgIHJldHVybiB2YWx1ZXNBcnJheVtpbmRleF1cXG4gIH1cXG59XFxuXFxudmFyIGVyYVZhbHVlcyA9IHtcXG4gIG5hcnJvdzogWydCJywgJ0EnXSxcXG4gIGFiYnJldmlhdGVkOiBbJ0JDJywgJ0FEJ10sXFxuICB3aWRlOiBbJ0JlZm9yZSBDaHJpc3QnLCAnQW5ubyBEb21pbmknXVxcbn07XFxuXFxudmFyIHF1YXJ0ZXJWYWx1ZXMgPSB7XFxuICBuYXJyb3c6IFsnMScsICcyJywgJzMnLCAnNCddLFxcbiAgYWJicmV2aWF0ZWQ6IFsnUTEnLCAnUTInLCAnUTMnLCAnUTQnXSxcXG4gIHdpZGU6IFsnMXN0IHF1YXJ0ZXInLCAnMm5kIHF1YXJ0ZXInLCAnM3JkIHF1YXJ0ZXInLCAnNHRoIHF1YXJ0ZXInXVxcbn07XFxuXFxuLy8gTm90ZTogaW4gRW5nbGlzaCwgdGhlIG5hbWVzIG9mIGRheXMgb2YgdGhlIHdlZWsgYW5kIG1vbnRocyBhcmUgY2FwaXRhbGl6ZWQuXFxuLy8gSWYgeW91IGFyZSBtYWtpbmcgYSBuZXcgbG9jYWxlIGJhc2VkIG9uIHRoaXMgb25lLCBjaGVjayBpZiB0aGUgc2FtZSBpcyB0cnVlIGZvciB0aGUgbGFuZ3VhZ2UgeW91J3JlIHdvcmtpbmcgb24uXFxuLy8gR2VuZXJhbGx5LCBmb3JtYXR0ZWQgZGF0ZXMgc2hvdWxkIGxvb2sgbGlrZSB0aGV5IGFyZSBpbiB0aGUgbWlkZGxlIG9mIGEgc2VudGVuY2UsXFxuLy8gZS5nLiBpbiBTcGFuaXNoIGxhbmd1YWdlIHRoZSB3ZWVrZGF5cyBhbmQgbW9udGhzIHNob3VsZCBiZSBpbiB0aGUgbG93ZXJjYXNlLlxcbnZhciBtb250aFZhbHVlcyA9IHtcXG4gIG5hcnJvdzogWydKJywgJ0YnLCAnTScsICdBJywgJ00nLCAnSicsICdKJywgJ0EnLCAnUycsICdPJywgJ04nLCAnRCddLFxcbiAgYWJicmV2aWF0ZWQ6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcXG4gIHdpZGU6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddXFxufTtcXG5cXG52YXIgZGF5VmFsdWVzID0ge1xcbiAgbmFycm93OiBbJ1MnLCAnTScsICdUJywgJ1cnLCAnVCcsICdGJywgJ1MnXSxcXG4gIHNob3J0OiBbJ1N1JywgJ01vJywgJ1R1JywgJ1dlJywgJ1RoJywgJ0ZyJywgJ1NhJ10sXFxuICBhYmJyZXZpYXRlZDogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcXG4gIHdpZGU6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXVxcbn07XFxuXFxudmFyIGRheVBlcmlvZFZhbHVlcyA9IHtcXG4gIG5hcnJvdzoge1xcbiAgICBhbTogJ2EnLFxcbiAgICBwbTogJ3AnLFxcbiAgICBtaWRuaWdodDogJ21pJyxcXG4gICAgbm9vbjogJ24nLFxcbiAgICBtb3JuaW5nOiAnbW9ybmluZycsXFxuICAgIGFmdGVybm9vbjogJ2FmdGVybm9vbicsXFxuICAgIGV2ZW5pbmc6ICdldmVuaW5nJyxcXG4gICAgbmlnaHQ6ICduaWdodCdcXG4gIH0sXFxuICBhYmJyZXZpYXRlZDoge1xcbiAgICBhbTogJ0FNJyxcXG4gICAgcG06ICdQTScsXFxuICAgIG1pZG5pZ2h0OiAnbWlkbmlnaHQnLFxcbiAgICBub29uOiAnbm9vbicsXFxuICAgIG1vcm5pbmc6ICdtb3JuaW5nJyxcXG4gICAgYWZ0ZXJub29uOiAnYWZ0ZXJub29uJyxcXG4gICAgZXZlbmluZzogJ2V2ZW5pbmcnLFxcbiAgICBuaWdodDogJ25pZ2h0J1xcbiAgfSxcXG4gIHdpZGU6IHtcXG4gICAgYW06ICdhLm0uJyxcXG4gICAgcG06ICdwLm0uJyxcXG4gICAgbWlkbmlnaHQ6ICdtaWRuaWdodCcsXFxuICAgIG5vb246ICdub29uJyxcXG4gICAgbW9ybmluZzogJ21vcm5pbmcnLFxcbiAgICBhZnRlcm5vb246ICdhZnRlcm5vb24nLFxcbiAgICBldmVuaW5nOiAnZXZlbmluZycsXFxuICAgIG5pZ2h0OiAnbmlnaHQnXFxuICB9XFxufTtcXG52YXIgZm9ybWF0dGluZ0RheVBlcmlvZFZhbHVlcyA9IHtcXG4gIG5hcnJvdzoge1xcbiAgICBhbTogJ2EnLFxcbiAgICBwbTogJ3AnLFxcbiAgICBtaWRuaWdodDogJ21pJyxcXG4gICAgbm9vbjogJ24nLFxcbiAgICBtb3JuaW5nOiAnaW4gdGhlIG1vcm5pbmcnLFxcbiAgICBhZnRlcm5vb246ICdpbiB0aGUgYWZ0ZXJub29uJyxcXG4gICAgZXZlbmluZzogJ2luIHRoZSBldmVuaW5nJyxcXG4gICAgbmlnaHQ6ICdhdCBuaWdodCdcXG4gIH0sXFxuICBhYmJyZXZpYXRlZDoge1xcbiAgICBhbTogJ0FNJyxcXG4gICAgcG06ICdQTScsXFxuICAgIG1pZG5pZ2h0OiAnbWlkbmlnaHQnLFxcbiAgICBub29uOiAnbm9vbicsXFxuICAgIG1vcm5pbmc6ICdpbiB0aGUgbW9ybmluZycsXFxuICAgIGFmdGVybm9vbjogJ2luIHRoZSBhZnRlcm5vb24nLFxcbiAgICBldmVuaW5nOiAnaW4gdGhlIGV2ZW5pbmcnLFxcbiAgICBuaWdodDogJ2F0IG5pZ2h0J1xcbiAgfSxcXG4gIHdpZGU6IHtcXG4gICAgYW06ICdhLm0uJyxcXG4gICAgcG06ICdwLm0uJyxcXG4gICAgbWlkbmlnaHQ6ICdtaWRuaWdodCcsXFxuICAgIG5vb246ICdub29uJyxcXG4gICAgbW9ybmluZzogJ2luIHRoZSBtb3JuaW5nJyxcXG4gICAgYWZ0ZXJub29uOiAnaW4gdGhlIGFmdGVybm9vbicsXFxuICAgIGV2ZW5pbmc6ICdpbiB0aGUgZXZlbmluZycsXFxuICAgIG5pZ2h0OiAnYXQgbmlnaHQnXFxuICB9XFxufTtcXG5cXG5mdW5jdGlvbiBvcmRpbmFsTnVtYmVyIChkaXJ0eU51bWJlciwgZGlydHlPcHRpb25zKSB7XFxuICB2YXIgbnVtYmVyID0gTnVtYmVyKGRpcnR5TnVtYmVyKTtcXG5cXG4gIC8vIElmIG9yZGluYWwgbnVtYmVycyBkZXBlbmQgb24gY29udGV4dCwgZm9yIGV4YW1wbGUsXFxuICAvLyBpZiB0aGV5IGFyZSBkaWZmZXJlbnQgZm9yIGRpZmZlcmVudCBncmFtbWF0aWNhbCBnZW5kZXJzLFxcbiAgLy8gdXNlIGBvcHRpb25zLnVuaXRgOlxcbiAgLy9cXG4gIC8vICAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge31cXG4gIC8vICAgdmFyIHVuaXQgPSBTdHJpbmcob3B0aW9ucy51bml0KVxcbiAgLy9cXG4gIC8vIHdoZXJlIGB1bml0YCBjYW4gYmUgJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RhdGUnLCAnZGF5T2ZZZWFyJyxcXG4gIC8vICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJ1xcblxcbiAgdmFyIHJlbTEwMCA9IG51bWJlciAlIDEwMDtcXG4gIGlmIChyZW0xMDAgPiAyMCB8fCByZW0xMDAgPCAxMCkge1xcbiAgICBzd2l0Y2ggKHJlbTEwMCAlIDEwKSB7XFxuICAgICAgY2FzZSAxOlxcbiAgICAgICAgcmV0dXJuIG51bWJlciArICdzdCdcXG4gICAgICBjYXNlIDI6XFxuICAgICAgICByZXR1cm4gbnVtYmVyICsgJ25kJ1xcbiAgICAgIGNhc2UgMzpcXG4gICAgICAgIHJldHVybiBudW1iZXIgKyAncmQnXFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBudW1iZXIgKyAndGgnXFxufVxcblxcbnZhciBsb2NhbGl6ZSA9IHtcXG4gIG9yZGluYWxOdW1iZXI6IG9yZGluYWxOdW1iZXIsXFxuXFxuICBlcmE6IGJ1aWxkTG9jYWxpemVGbih7XFxuICAgIHZhbHVlczogZXJhVmFsdWVzLFxcbiAgICBkZWZhdWx0V2lkdGg6ICd3aWRlJ1xcbiAgfSksXFxuXFxuICBxdWFydGVyOiBidWlsZExvY2FsaXplRm4oe1xcbiAgICB2YWx1ZXM6IHF1YXJ0ZXJWYWx1ZXMsXFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnLFxcbiAgICBhcmd1bWVudENhbGxiYWNrOiBmdW5jdGlvbiAocXVhcnRlcikge1xcbiAgICAgIHJldHVybiBOdW1iZXIocXVhcnRlcikgLSAxXFxuICAgIH1cXG4gIH0pLFxcblxcbiAgbW9udGg6IGJ1aWxkTG9jYWxpemVGbih7XFxuICAgIHZhbHVlczogbW9udGhWYWx1ZXMsXFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnXFxuICB9KSxcXG5cXG4gIGRheTogYnVpbGRMb2NhbGl6ZUZuKHtcXG4gICAgdmFsdWVzOiBkYXlWYWx1ZXMsXFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnXFxuICB9KSxcXG5cXG4gIGRheVBlcmlvZDogYnVpbGRMb2NhbGl6ZUZuKHtcXG4gICAgdmFsdWVzOiBkYXlQZXJpb2RWYWx1ZXMsXFxuICAgIGRlZmF1bHRXaWR0aDogJ3dpZGUnLFxcbiAgICBmb3JtYXR0aW5nVmFsdWVzOiBmb3JtYXR0aW5nRGF5UGVyaW9kVmFsdWVzLFxcbiAgICBkZWZhdWxGb3JtYXR0aW5nV2lkdGg6ICd3aWRlJ1xcbiAgfSlcXG59O1xcblxcbmZ1bmN0aW9uIGJ1aWxkTWF0Y2hQYXR0ZXJuRm4gKGFyZ3MpIHtcXG4gIHJldHVybiBmdW5jdGlvbiAoZGlydHlTdHJpbmcsIGRpcnR5T3B0aW9ucykge1xcbiAgICB2YXIgc3RyaW5nID0gU3RyaW5nKGRpcnR5U3RyaW5nKTtcXG4gICAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XFxuXFxuICAgIHZhciBtYXRjaFJlc3VsdCA9IHN0cmluZy5tYXRjaChhcmdzLm1hdGNoUGF0dGVybik7XFxuICAgIGlmICghbWF0Y2hSZXN1bHQpIHtcXG4gICAgICByZXR1cm4gbnVsbFxcbiAgICB9XFxuICAgIHZhciBtYXRjaGVkU3RyaW5nID0gbWF0Y2hSZXN1bHRbMF07XFxuXFxuICAgIHZhciBwYXJzZVJlc3VsdCA9IHN0cmluZy5tYXRjaChhcmdzLnBhcnNlUGF0dGVybik7XFxuICAgIGlmICghcGFyc2VSZXN1bHQpIHtcXG4gICAgICByZXR1cm4gbnVsbFxcbiAgICB9XFxuICAgIHZhciB2YWx1ZSA9IGFyZ3MudmFsdWVDYWxsYmFjayA/IGFyZ3MudmFsdWVDYWxsYmFjayhwYXJzZVJlc3VsdFswXSkgOiBwYXJzZVJlc3VsdFswXTtcXG4gICAgdmFsdWUgPSBvcHRpb25zLnZhbHVlQ2FsbGJhY2sgPyBvcHRpb25zLnZhbHVlQ2FsbGJhY2sodmFsdWUpIDogdmFsdWU7XFxuXFxuICAgIHJldHVybiB7XFxuICAgICAgdmFsdWU6IHZhbHVlLFxcbiAgICAgIHJlc3Q6IHN0cmluZy5zbGljZShtYXRjaGVkU3RyaW5nLmxlbmd0aClcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBidWlsZE1hdGNoRm4gKGFyZ3MpIHtcXG4gIHJldHVybiBmdW5jdGlvbiAoZGlydHlTdHJpbmcsIGRpcnR5T3B0aW9ucykge1xcbiAgICB2YXIgc3RyaW5nID0gU3RyaW5nKGRpcnR5U3RyaW5nKTtcXG4gICAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XFxuICAgIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGg7XFxuXFxuICAgIHZhciBtYXRjaFBhdHRlcm4gPSAod2lkdGggJiYgYXJncy5tYXRjaFBhdHRlcm5zW3dpZHRoXSkgfHwgYXJncy5tYXRjaFBhdHRlcm5zW2FyZ3MuZGVmYXVsdE1hdGNoV2lkdGhdO1xcbiAgICB2YXIgbWF0Y2hSZXN1bHQgPSBzdHJpbmcubWF0Y2gobWF0Y2hQYXR0ZXJuKTtcXG5cXG4gICAgaWYgKCFtYXRjaFJlc3VsdCkge1xcbiAgICAgIHJldHVybiBudWxsXFxuICAgIH1cXG4gICAgdmFyIG1hdGNoZWRTdHJpbmcgPSBtYXRjaFJlc3VsdFswXTtcXG5cXG4gICAgdmFyIHBhcnNlUGF0dGVybnMgPSAod2lkdGggJiYgYXJncy5wYXJzZVBhdHRlcm5zW3dpZHRoXSkgfHwgYXJncy5wYXJzZVBhdHRlcm5zW2FyZ3MuZGVmYXVsdFBhcnNlV2lkdGhdO1xcblxcbiAgICB2YXIgdmFsdWU7XFxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocGFyc2VQYXR0ZXJucykgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcXG4gICAgICB2YWx1ZSA9IHBhcnNlUGF0dGVybnMuZmluZEluZGV4KGZ1bmN0aW9uIChwYXR0ZXJuKSB7XFxuICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KHN0cmluZylcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB2YWx1ZSA9IGZpbmRLZXkocGFyc2VQYXR0ZXJucywgZnVuY3Rpb24gKHBhdHRlcm4pIHtcXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3Qoc3RyaW5nKVxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIHZhbHVlID0gYXJncy52YWx1ZUNhbGxiYWNrID8gYXJncy52YWx1ZUNhbGxiYWNrKHZhbHVlKSA6IHZhbHVlO1xcbiAgICB2YWx1ZSA9IG9wdGlvbnMudmFsdWVDYWxsYmFjayA/IG9wdGlvbnMudmFsdWVDYWxsYmFjayh2YWx1ZSkgOiB2YWx1ZTtcXG5cXG4gICAgcmV0dXJuIHtcXG4gICAgICB2YWx1ZTogdmFsdWUsXFxuICAgICAgcmVzdDogc3RyaW5nLnNsaWNlKG1hdGNoZWRTdHJpbmcubGVuZ3RoKVxcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGZpbmRLZXkgKG9iamVjdCwgcHJlZGljYXRlKSB7XFxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XFxuICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBwcmVkaWNhdGUob2JqZWN0W2tleV0pKSB7XFxuICAgICAgcmV0dXJuIGtleVxcbiAgICB9XFxuICB9XFxufVxcblxcbnZhciBtYXRjaE9yZGluYWxOdW1iZXJQYXR0ZXJuID0gL14oXFxcXGQrKSh0aHxzdHxuZHxyZCk/L2k7XFxudmFyIHBhcnNlT3JkaW5hbE51bWJlclBhdHRlcm4gPSAvXFxcXGQrL2k7XFxuXFxudmFyIG1hdGNoRXJhUGF0dGVybnMgPSB7XFxuICBuYXJyb3c6IC9eKGJ8YSkvaSxcXG4gIGFiYnJldmlhdGVkOiAvXihiXFxcXC4/XFxcXHM/Y1xcXFwuP3xiXFxcXC4/XFxcXHM/Y1xcXFwuP1xcXFxzP2VcXFxcLj98YVxcXFwuP1xcXFxzP2RcXFxcLj98Y1xcXFwuP1xcXFxzP2VcXFxcLj8pL2ksXFxuICB3aWRlOiAvXihiZWZvcmUgY2hyaXN0fGJlZm9yZSBjb21tb24gZXJhfGFubm8gZG9taW5pfGNvbW1vbiBlcmEpL2lcXG59O1xcbnZhciBwYXJzZUVyYVBhdHRlcm5zID0ge1xcbiAgYW55OiBbL15iL2ksIC9eKGF8YykvaV1cXG59O1xcblxcbnZhciBtYXRjaFF1YXJ0ZXJQYXR0ZXJucyA9IHtcXG4gIG5hcnJvdzogL15bMTIzNF0vaSxcXG4gIGFiYnJldmlhdGVkOiAvXnFbMTIzNF0vaSxcXG4gIHdpZGU6IC9eWzEyMzRdKHRofHN0fG5kfHJkKT8gcXVhcnRlci9pXFxufTtcXG52YXIgcGFyc2VRdWFydGVyUGF0dGVybnMgPSB7XFxuICBhbnk6IFsvMS9pLCAvMi9pLCAvMy9pLCAvNC9pXVxcbn07XFxuXFxudmFyIG1hdGNoTW9udGhQYXR0ZXJucyA9IHtcXG4gIG5hcnJvdzogL15bamZtYXNvbmRdL2ksXFxuICBhYmJyZXZpYXRlZDogL14oamFufGZlYnxtYXJ8YXByfG1heXxqdW58anVsfGF1Z3xzZXB8b2N0fG5vdnxkZWMpL2ksXFxuICB3aWRlOiAvXihqYW51YXJ5fGZlYnJ1YXJ5fG1hcmNofGFwcmlsfG1heXxqdW5lfGp1bHl8YXVndXN0fHNlcHRlbWJlcnxvY3RvYmVyfG5vdmVtYmVyfGRlY2VtYmVyKS9pXFxufTtcXG52YXIgcGFyc2VNb250aFBhdHRlcm5zID0ge1xcbiAgbmFycm93OiBbL15qL2ksIC9eZi9pLCAvXm0vaSwgL15hL2ksIC9ebS9pLCAvXmovaSwgL15qL2ksIC9eYS9pLCAvXnMvaSwgL15vL2ksIC9ebi9pLCAvXmQvaV0sXFxuICBhbnk6IFsvXmphL2ksIC9eZi9pLCAvXm1hci9pLCAvXmFwL2ksIC9ebWF5L2ksIC9eanVuL2ksIC9eanVsL2ksIC9eYXUvaSwgL15zL2ksIC9eby9pLCAvXm4vaSwgL15kL2ldXFxufTtcXG5cXG52YXIgbWF0Y2hEYXlQYXR0ZXJucyA9IHtcXG4gIG5hcnJvdzogL15bc210d2ZdL2ksXFxuICBzaG9ydDogL14oc3V8bW98dHV8d2V8dGh8ZnJ8c2EpL2ksXFxuICBhYmJyZXZpYXRlZDogL14oc3VufG1vbnx0dWV8d2VkfHRodXxmcml8c2F0KS9pLFxcbiAgd2lkZTogL14oc3VuZGF5fG1vbmRheXx0dWVzZGF5fHdlZG5lc2RheXx0aHVyc2RheXxmcmlkYXl8c2F0dXJkYXkpL2lcXG59O1xcbnZhciBwYXJzZURheVBhdHRlcm5zID0ge1xcbiAgbmFycm93OiBbL15zL2ksIC9ebS9pLCAvXnQvaSwgL153L2ksIC9edC9pLCAvXmYvaSwgL15zL2ldLFxcbiAgYW55OiBbL15zdS9pLCAvXm0vaSwgL150dS9pLCAvXncvaSwgL150aC9pLCAvXmYvaSwgL15zYS9pXVxcbn07XFxuXFxudmFyIG1hdGNoRGF5UGVyaW9kUGF0dGVybnMgPSB7XFxuICBuYXJyb3c6IC9eKGF8cHxtaXxufChpbiB0aGV8YXQpIChtb3JuaW5nfGFmdGVybm9vbnxldmVuaW5nfG5pZ2h0KSkvaSxcXG4gIGFueTogL14oW2FwXVxcXFwuP1xcXFxzP21cXFxcLj98bWlkbmlnaHR8bm9vbnwoaW4gdGhlfGF0KSAobW9ybmluZ3xhZnRlcm5vb258ZXZlbmluZ3xuaWdodCkpL2lcXG59O1xcbnZhciBwYXJzZURheVBlcmlvZFBhdHRlcm5zID0ge1xcbiAgYW55OiB7XFxuICAgIGFtOiAvXmEvaSxcXG4gICAgcG06IC9ecC9pLFxcbiAgICBtaWRuaWdodDogL15taS9pLFxcbiAgICBub29uOiAvXm5vL2ksXFxuICAgIG1vcm5pbmc6IC9tb3JuaW5nL2ksXFxuICAgIGFmdGVybm9vbjogL2FmdGVybm9vbi9pLFxcbiAgICBldmVuaW5nOiAvZXZlbmluZy9pLFxcbiAgICBuaWdodDogL25pZ2h0L2lcXG4gIH1cXG59O1xcblxcbnZhciBtYXRjaCA9IHtcXG4gIG9yZGluYWxOdW1iZXI6IGJ1aWxkTWF0Y2hQYXR0ZXJuRm4oe1xcbiAgICBtYXRjaFBhdHRlcm46IG1hdGNoT3JkaW5hbE51bWJlclBhdHRlcm4sXFxuICAgIHBhcnNlUGF0dGVybjogcGFyc2VPcmRpbmFsTnVtYmVyUGF0dGVybixcXG4gICAgdmFsdWVDYWxsYmFjazogZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMClcXG4gICAgfVxcbiAgfSksXFxuXFxuICBlcmE6IGJ1aWxkTWF0Y2hGbih7XFxuICAgIG1hdGNoUGF0dGVybnM6IG1hdGNoRXJhUGF0dGVybnMsXFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnd2lkZScsXFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlRXJhUGF0dGVybnMsXFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55J1xcbiAgfSksXFxuXFxuICBxdWFydGVyOiBidWlsZE1hdGNoRm4oe1xcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaFF1YXJ0ZXJQYXR0ZXJucyxcXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICd3aWRlJyxcXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VRdWFydGVyUGF0dGVybnMsXFxuICAgIGRlZmF1bHRQYXJzZVdpZHRoOiAnYW55JyxcXG4gICAgdmFsdWVDYWxsYmFjazogZnVuY3Rpb24gKGluZGV4KSB7XFxuICAgICAgcmV0dXJuIGluZGV4ICsgMVxcbiAgICB9XFxuICB9KSxcXG5cXG4gIG1vbnRoOiBidWlsZE1hdGNoRm4oe1xcbiAgICBtYXRjaFBhdHRlcm5zOiBtYXRjaE1vbnRoUGF0dGVybnMsXFxuICAgIGRlZmF1bHRNYXRjaFdpZHRoOiAnd2lkZScsXFxuICAgIHBhcnNlUGF0dGVybnM6IHBhcnNlTW9udGhQYXR0ZXJucyxcXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6ICdhbnknXFxuICB9KSxcXG5cXG4gIGRheTogYnVpbGRNYXRjaEZuKHtcXG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hEYXlQYXR0ZXJucyxcXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICd3aWRlJyxcXG4gICAgcGFyc2VQYXR0ZXJuczogcGFyc2VEYXlQYXR0ZXJucyxcXG4gICAgZGVmYXVsdFBhcnNlV2lkdGg6ICdhbnknXFxuICB9KSxcXG5cXG4gIGRheVBlcmlvZDogYnVpbGRNYXRjaEZuKHtcXG4gICAgbWF0Y2hQYXR0ZXJuczogbWF0Y2hEYXlQZXJpb2RQYXR0ZXJucyxcXG4gICAgZGVmYXVsdE1hdGNoV2lkdGg6ICdhbnknLFxcbiAgICBwYXJzZVBhdHRlcm5zOiBwYXJzZURheVBlcmlvZFBhdHRlcm5zLFxcbiAgICBkZWZhdWx0UGFyc2VXaWR0aDogJ2FueSdcXG4gIH0pXFxufTtcXG5cXG4vKipcXG4gKiBAdHlwZSB7TG9jYWxlfVxcbiAqIEBjYXRlZ29yeSBMb2NhbGVzXFxuICogQHN1bW1hcnkgRW5nbGlzaCBsb2NhbGUgKFVuaXRlZCBTdGF0ZXMpLlxcbiAqIEBsYW5ndWFnZSBFbmdsaXNoXFxuICogQGlzby02MzktMiBlbmdcXG4gKiBAYXV0aG9yIFNhc2hhIEtvc3MgW0Brb3Nzbm9jb3JwXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20va29zc25vY29ycH1cXG4gKiBAYXV0aG9yIExlc2hhIEtvc3MgW0BsZXNoYWtvc3Nde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9sZXNoYWtvc3N9XFxuICovXFxudmFyIGxvY2FsZSQxID0ge1xcbiAgZm9ybWF0RGlzdGFuY2U6IGZvcm1hdERpc3RhbmNlLFxcbiAgZm9ybWF0TG9uZzogZm9ybWF0TG9uZyxcXG4gIGZvcm1hdFJlbGF0aXZlOiBmb3JtYXRSZWxhdGl2ZSxcXG4gIGxvY2FsaXplOiBsb2NhbGl6ZSxcXG4gIG1hdGNoOiBtYXRjaCxcXG4gIG9wdGlvbnM6IHtcXG4gICAgd2Vla1N0YXJ0c09uOiAwIC8qIFN1bmRheSAqLyxcXG4gICAgZmlyc3RXZWVrQ29udGFpbnNEYXRlOiAxXFxuICB9XFxufTtcXG5cXG52YXIgTUlMTElTRUNPTkRTX0lOX0RBWSA9IDg2NDAwMDAwO1xcblxcbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxcbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcXG5mdW5jdGlvbiBnZXRVVENEYXlPZlllYXIgKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKSB7XFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxcbiAgfVxcblxcbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xcbiAgdmFyIHRpbWVzdGFtcCA9IGRhdGUuZ2V0VGltZSgpO1xcbiAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcXG4gIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XFxuICB2YXIgc3RhcnRPZlllYXJUaW1lc3RhbXAgPSBkYXRlLmdldFRpbWUoKTtcXG4gIHZhciBkaWZmZXJlbmNlID0gdGltZXN0YW1wIC0gc3RhcnRPZlllYXJUaW1lc3RhbXA7XFxuICByZXR1cm4gTWF0aC5mbG9vcihkaWZmZXJlbmNlIC8gTUlMTElTRUNPTkRTX0lOX0RBWSkgKyAxXFxufVxcblxcbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxcbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcXG5mdW5jdGlvbiBzdGFydE9mVVRDSVNPV2VlayAoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpXFxuICB9XFxuXFxuICB2YXIgd2Vla1N0YXJ0c09uID0gMTtcXG5cXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKTtcXG4gIHZhciBkYXkgPSBkYXRlLmdldFVUQ0RheSgpO1xcbiAgdmFyIGRpZmYgPSAoZGF5IDwgd2Vla1N0YXJ0c09uID8gNyA6IDApICsgZGF5IC0gd2Vla1N0YXJ0c09uO1xcblxcbiAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gZGlmZik7XFxuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xcbiAgcmV0dXJuIGRhdGVcXG59XFxuXFxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXFxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxcbmZ1bmN0aW9uIGdldFVUQ0lTT1dlZWtZZWFyIChkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucykge1xcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50JylcXG4gIH1cXG5cXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKTtcXG4gIHZhciB5ZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xcblxcbiAgdmFyIGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIgPSBuZXcgRGF0ZSgwKTtcXG4gIGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIuc2V0VVRDRnVsbFllYXIoeWVhciArIDEsIDAsIDQpO1xcbiAgZm91cnRoT2ZKYW51YXJ5T2ZOZXh0WWVhci5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcXG4gIHZhciBzdGFydE9mTmV4dFllYXIgPSBzdGFydE9mVVRDSVNPV2Vlayhmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyLCBkaXJ0eU9wdGlvbnMpO1xcblxcbiAgdmFyIGZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIgPSBuZXcgRGF0ZSgwKTtcXG4gIGZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIuc2V0VVRDRnVsbFllYXIoeWVhciwgMCwgNCk7XFxuICBmb3VydGhPZkphbnVhcnlPZlRoaXNZZWFyLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xcbiAgdmFyIHN0YXJ0T2ZUaGlzWWVhciA9IHN0YXJ0T2ZVVENJU09XZWVrKGZvdXJ0aE9mSmFudWFyeU9mVGhpc1llYXIsIGRpcnR5T3B0aW9ucyk7XFxuXFxuICBpZiAoZGF0ZS5nZXRUaW1lKCkgPj0gc3RhcnRPZk5leHRZZWFyLmdldFRpbWUoKSkge1xcbiAgICByZXR1cm4geWVhciArIDFcXG4gIH0gZWxzZSBpZiAoZGF0ZS5nZXRUaW1lKCkgPj0gc3RhcnRPZlRoaXNZZWFyLmdldFRpbWUoKSkge1xcbiAgICByZXR1cm4geWVhclxcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIHllYXIgLSAxXFxuICB9XFxufVxcblxcbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxcbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcXG5mdW5jdGlvbiBzdGFydE9mVVRDSVNPV2Vla1llYXIgKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKSB7XFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxcbiAgfVxcblxcbiAgdmFyIHllYXIgPSBnZXRVVENJU09XZWVrWWVhcihkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XFxuICB2YXIgZm91cnRoT2ZKYW51YXJ5ID0gbmV3IERhdGUoMCk7XFxuICBmb3VydGhPZkphbnVhcnkuc2V0VVRDRnVsbFllYXIoeWVhciwgMCwgNCk7XFxuICBmb3VydGhPZkphbnVhcnkuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XFxuICB2YXIgZGF0ZSA9IHN0YXJ0T2ZVVENJU09XZWVrKGZvdXJ0aE9mSmFudWFyeSwgZGlydHlPcHRpb25zKTtcXG4gIHJldHVybiBkYXRlXFxufVxcblxcbnZhciBNSUxMSVNFQ09ORFNfSU5fV0VFSyA9IDYwNDgwMDAwMDtcXG5cXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XFxuZnVuY3Rpb24gZ2V0VVRDSVNPV2VlayAoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpXFxuICB9XFxuXFxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XFxuICB2YXIgZGlmZiA9IHN0YXJ0T2ZVVENJU09XZWVrKGRhdGUsIGRpcnR5T3B0aW9ucykuZ2V0VGltZSgpIC0gc3RhcnRPZlVUQ0lTT1dlZWtZZWFyKGRhdGUsIGRpcnR5T3B0aW9ucykuZ2V0VGltZSgpO1xcblxcbiAgLy8gUm91bmQgdGhlIG51bWJlciBvZiBkYXlzIHRvIHRoZSBuZWFyZXN0IGludGVnZXJcXG4gIC8vIGJlY2F1c2UgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaW4gYSB3ZWVrIGlzIG5vdCBjb25zdGFudFxcbiAgLy8gKGUuZy4gaXQncyBkaWZmZXJlbnQgaW4gdGhlIHdlZWsgb2YgdGhlIGRheWxpZ2h0IHNhdmluZyB0aW1lIGNsb2NrIHNoaWZ0KVxcbiAgcmV0dXJuIE1hdGgucm91bmQoZGlmZiAvIE1JTExJU0VDT05EU19JTl9XRUVLKSArIDFcXG59XFxuXFxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGEgcGFydCBvZiBwdWJsaWMgQVBJIHdoZW4gVVRDIGZ1bmN0aW9uIHdpbGwgYmUgaW1wbGVtZW50ZWQuXFxuLy8gU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvaXNzdWVzLzM3NlxcbmZ1bmN0aW9uIHN0YXJ0T2ZVVENXZWVrIChkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucykge1xcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50JylcXG4gIH1cXG5cXG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xcbiAgdmFyIGxvY2FsZSA9IG9wdGlvbnMubG9jYWxlO1xcbiAgdmFyIGxvY2FsZVdlZWtTdGFydHNPbiA9IGxvY2FsZSAmJiBsb2NhbGUub3B0aW9ucyAmJiBsb2NhbGUub3B0aW9ucy53ZWVrU3RhcnRzT247XFxuICB2YXIgZGVmYXVsdFdlZWtTdGFydHNPbiA9IGxvY2FsZVdlZWtTdGFydHNPbiA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihsb2NhbGVXZWVrU3RhcnRzT24pO1xcbiAgdmFyIHdlZWtTdGFydHNPbiA9IG9wdGlvbnMud2Vla1N0YXJ0c09uID09IG51bGwgPyBkZWZhdWx0V2Vla1N0YXJ0c09uIDogdG9JbnRlZ2VyKG9wdGlvbnMud2Vla1N0YXJ0c09uKTtcXG5cXG4gIC8vIFRlc3QgaWYgd2Vla1N0YXJ0c09uIGlzIGJldHdlZW4gMCBhbmQgNiBfYW5kXyBpcyBub3QgTmFOXFxuICBpZiAoISh3ZWVrU3RhcnRzT24gPj0gMCAmJiB3ZWVrU3RhcnRzT24gPD0gNikpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3dlZWtTdGFydHNPbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgNiBpbmNsdXNpdmVseScpXFxuICB9XFxuXFxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIG9wdGlvbnMpO1xcbiAgdmFyIGRheSA9IGRhdGUuZ2V0VVRDRGF5KCk7XFxuICB2YXIgZGlmZiA9IChkYXkgPCB3ZWVrU3RhcnRzT24gPyA3IDogMCkgKyBkYXkgLSB3ZWVrU3RhcnRzT247XFxuXFxuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSBkaWZmKTtcXG4gIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XFxuICByZXR1cm4gZGF0ZVxcbn1cXG5cXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XFxuZnVuY3Rpb24gZ2V0VVRDV2Vla1llYXIgKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKSB7XFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxcbiAgfVxcblxcbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xcbiAgdmFyIHllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XFxuXFxuICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcXG4gIHZhciBsb2NhbGUgPSBvcHRpb25zLmxvY2FsZTtcXG4gIHZhciBsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUgPSBsb2NhbGUgJiZcXG4gICAgbG9jYWxlLm9wdGlvbnMgJiZcXG4gICAgbG9jYWxlLm9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlO1xcbiAgdmFyIGRlZmF1bHRGaXJzdFdlZWtDb250YWluc0RhdGUgPVxcbiAgICBsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUgPT0gbnVsbFxcbiAgICAgID8gMVxcbiAgICAgIDogdG9JbnRlZ2VyKGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XFxuICB2YXIgZmlyc3RXZWVrQ29udGFpbnNEYXRlID1cXG4gICAgb3B0aW9ucy5maXJzdFdlZWtDb250YWluc0RhdGUgPT0gbnVsbFxcbiAgICAgID8gZGVmYXVsdEZpcnN0V2Vla0NvbnRhaW5zRGF0ZVxcbiAgICAgIDogdG9JbnRlZ2VyKG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcXG5cXG4gIC8vIFRlc3QgaWYgd2Vla1N0YXJ0c09uIGlzIGJldHdlZW4gMSBhbmQgNyBfYW5kXyBpcyBub3QgTmFOXFxuICBpZiAoIShmaXJzdFdlZWtDb250YWluc0RhdGUgPj0gMSAmJiBmaXJzdFdlZWtDb250YWluc0RhdGUgPD0gNykpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2ZpcnN0V2Vla0NvbnRhaW5zRGF0ZSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNyBpbmNsdXNpdmVseScpXFxuICB9XFxuXFxuICB2YXIgZmlyc3RXZWVrT2ZOZXh0WWVhciA9IG5ldyBEYXRlKDApO1xcbiAgZmlyc3RXZWVrT2ZOZXh0WWVhci5zZXRVVENGdWxsWWVhcih5ZWFyICsgMSwgMCwgZmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcXG4gIGZpcnN0V2Vla09mTmV4dFllYXIuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XFxuICB2YXIgc3RhcnRPZk5leHRZZWFyID0gc3RhcnRPZlVUQ1dlZWsoZmlyc3RXZWVrT2ZOZXh0WWVhciwgZGlydHlPcHRpb25zKTtcXG5cXG4gIHZhciBmaXJzdFdlZWtPZlRoaXNZZWFyID0gbmV3IERhdGUoMCk7XFxuICBmaXJzdFdlZWtPZlRoaXNZZWFyLnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XFxuICBmaXJzdFdlZWtPZlRoaXNZZWFyLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xcbiAgdmFyIHN0YXJ0T2ZUaGlzWWVhciA9IHN0YXJ0T2ZVVENXZWVrKGZpcnN0V2Vla09mVGhpc1llYXIsIGRpcnR5T3B0aW9ucyk7XFxuXFxuICBpZiAoZGF0ZS5nZXRUaW1lKCkgPj0gc3RhcnRPZk5leHRZZWFyLmdldFRpbWUoKSkge1xcbiAgICByZXR1cm4geWVhciArIDFcXG4gIH0gZWxzZSBpZiAoZGF0ZS5nZXRUaW1lKCkgPj0gc3RhcnRPZlRoaXNZZWFyLmdldFRpbWUoKSkge1xcbiAgICByZXR1cm4geWVhclxcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIHllYXIgLSAxXFxuICB9XFxufVxcblxcbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxcbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcXG5mdW5jdGlvbiBzdGFydE9mVVRDV2Vla1llYXIgKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKSB7XFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxcbiAgfVxcblxcbiAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge307XFxuICB2YXIgbG9jYWxlID0gb3B0aW9ucy5sb2NhbGU7XFxuICB2YXIgbG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlID0gbG9jYWxlICYmXFxuICAgIGxvY2FsZS5vcHRpb25zICYmXFxuICAgIGxvY2FsZS5vcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZTtcXG4gIHZhciBkZWZhdWx0Rmlyc3RXZWVrQ29udGFpbnNEYXRlID1cXG4gICAgbG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlID09IG51bGxcXG4gICAgICA/IDFcXG4gICAgICA6IHRvSW50ZWdlcihsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUpO1xcbiAgdmFyIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9XFxuICAgIG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlID09IG51bGxcXG4gICAgICA/IGRlZmF1bHRGaXJzdFdlZWtDb250YWluc0RhdGVcXG4gICAgICA6IHRvSW50ZWdlcihvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XFxuXFxuICB2YXIgeWVhciA9IGdldFVUQ1dlZWtZZWFyKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKTtcXG4gIHZhciBmaXJzdFdlZWsgPSBuZXcgRGF0ZSgwKTtcXG4gIGZpcnN0V2Vlay5zZXRVVENGdWxsWWVhcih5ZWFyLCAwLCBmaXJzdFdlZWtDb250YWluc0RhdGUpO1xcbiAgZmlyc3RXZWVrLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xcbiAgdmFyIGRhdGUgPSBzdGFydE9mVVRDV2VlayhmaXJzdFdlZWssIGRpcnR5T3B0aW9ucyk7XFxuICByZXR1cm4gZGF0ZVxcbn1cXG5cXG52YXIgTUlMTElTRUNPTkRTX0lOX1dFRUskMSA9IDYwNDgwMDAwMDtcXG5cXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XFxuZnVuY3Rpb24gZ2V0VVRDV2VlayAoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpIHtcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpXFxuICB9XFxuXFxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XFxuICB2YXIgZGlmZiA9IHN0YXJ0T2ZVVENXZWVrKGRhdGUsIGRpcnR5T3B0aW9ucykuZ2V0VGltZSgpIC0gc3RhcnRPZlVUQ1dlZWtZZWFyKGRhdGUsIGRpcnR5T3B0aW9ucykuZ2V0VGltZSgpO1xcblxcbiAgLy8gUm91bmQgdGhlIG51bWJlciBvZiBkYXlzIHRvIHRoZSBuZWFyZXN0IGludGVnZXJcXG4gIC8vIGJlY2F1c2UgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaW4gYSB3ZWVrIGlzIG5vdCBjb25zdGFudFxcbiAgLy8gKGUuZy4gaXQncyBkaWZmZXJlbnQgaW4gdGhlIHdlZWsgb2YgdGhlIGRheWxpZ2h0IHNhdmluZyB0aW1lIGNsb2NrIHNoaWZ0KVxcbiAgcmV0dXJuIE1hdGgucm91bmQoZGlmZiAvIE1JTExJU0VDT05EU19JTl9XRUVLJDEpICsgMVxcbn1cXG5cXG52YXIgZGF5UGVyaW9kRW51bSA9IHtcXG4gIGFtOiAnYW0nLFxcbiAgcG06ICdwbScsXFxuICBtaWRuaWdodDogJ21pZG5pZ2h0JyxcXG4gIG5vb246ICdub29uJyxcXG4gIG1vcm5pbmc6ICdtb3JuaW5nJyxcXG4gIGFmdGVybm9vbjogJ2FmdGVybm9vbicsXFxuICBldmVuaW5nOiAnZXZlbmluZycsXFxuICBuaWdodDogJ25pZ2h0J1xcbn07XFxuXFxuLypcXG4gKiB8ICAgICB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICB8XFxuICogfC0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxcbiAqIHwgIGEgIHwgQU0sIFBNICAgICAgICAgICAgICAgICAgICAgICAgIHwgIEEqIHwgTWlsbGlzZWNvbmRzIGluIGRheSAgICAgICAgICAgIHxcXG4gKiB8ICBiICB8IEFNLCBQTSwgbm9vbiwgbWlkbmlnaHQgICAgICAgICB8ICBCICB8IEZsZXhpYmxlIGRheSBwZXJpb2QgICAgICAgICAgICB8XFxuICogfCAgYyAgfCBTdGFuZC1hbG9uZSBsb2NhbCBkYXkgb2Ygd2VlayAgfCAgQyogfCBMb2NhbGl6ZWQgaG91ciB3LyBkYXkgcGVyaW9kICAgfFxcbiAqIHwgIGQgIHwgRGF5IG9mIG1vbnRoICAgICAgICAgICAgICAgICAgIHwgIEQgIHwgRGF5IG9mIHllYXIgICAgICAgICAgICAgICAgICAgIHxcXG4gKiB8ICBlICB8IExvY2FsIGRheSBvZiB3ZWVrICAgICAgICAgICAgICB8ICBFICB8IERheSBvZiB3ZWVrICAgICAgICAgICAgICAgICAgICB8XFxuICogfCAgZiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgRiogfCBEYXkgb2Ygd2VlayBpbiBtb250aCAgICAgICAgICAgfFxcbiAqIHwgIGcqIHwgTW9kaWZpZWQgSnVsaWFuIGRheSAgICAgICAgICAgIHwgIEcgIHwgRXJhICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcXG4gKiB8ICBoICB8IEhvdXIgWzEtMTJdICAgICAgICAgICAgICAgICAgICB8ICBIICB8IEhvdXIgWzAtMjNdICAgICAgICAgICAgICAgICAgICB8XFxuICogfCAgaSEgfCBJU08gZGF5IG9mIHdlZWsgICAgICAgICAgICAgICAgfCAgSSEgfCBJU08gd2VlayBvZiB5ZWFyICAgICAgICAgICAgICAgfFxcbiAqIHwgIGoqIHwgTG9jYWxpemVkIGhvdXIgdy8gZGF5IHBlcmlvZCAgIHwgIEoqIHwgTG9jYWxpemVkIGhvdXIgdy9vIGRheSBwZXJpb2QgIHxcXG4gKiB8ICBrICB8IEhvdXIgWzEtMjRdICAgICAgICAgICAgICAgICAgICB8ICBLICB8IEhvdXIgWzAtMTFdICAgICAgICAgICAgICAgICAgICB8XFxuICogfCAgbCogfCAoZGVwcmVjYXRlZCkgICAgICAgICAgICAgICAgICAgfCAgTCAgfCBTdGFuZC1hbG9uZSBtb250aCAgICAgICAgICAgICAgfFxcbiAqIHwgIG0gIHwgTWludXRlICAgICAgICAgICAgICAgICAgICAgICAgIHwgIE0gIHwgTW9udGggICAgICAgICAgICAgICAgICAgICAgICAgIHxcXG4gKiB8ICBuICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBOICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XFxuICogfCAgbyEgfCBPcmRpbmFsIG51bWJlciBtb2RpZmllciAgICAgICAgfCAgTyAgfCBUaW1lem9uZSAoR01UKSAgICAgICAgICAgICAgICAgfFxcbiAqIHwgIHAhIHwgTG9uZyBsb2NhbGl6ZWQgdGltZSAgICAgICAgICAgIHwgIFAhIHwgTG9uZyBsb2NhbGl6ZWQgZGF0ZSAgICAgICAgICAgIHxcXG4gKiB8ICBxICB8IFN0YW5kLWFsb25lIHF1YXJ0ZXIgICAgICAgICAgICB8ICBRICB8IFF1YXJ0ZXIgICAgICAgICAgICAgICAgICAgICAgICB8XFxuICogfCAgciogfCBSZWxhdGVkIEdyZWdvcmlhbiB5ZWFyICAgICAgICAgfCAgUiEgfCBJU08gd2Vlay1udW1iZXJpbmcgeWVhciAgICAgICAgfFxcbiAqIHwgIHMgIHwgU2Vjb25kICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFMgIHwgRnJhY3Rpb24gb2Ygc2Vjb25kICAgICAgICAgICAgIHxcXG4gKiB8ICB0ISB8IFNlY29uZHMgdGltZXN0YW1wICAgICAgICAgICAgICB8ICBUISB8IE1pbGxpc2Vjb25kcyB0aW1lc3RhbXAgICAgICAgICB8XFxuICogfCAgdSAgfCBFeHRlbmRlZCB5ZWFyICAgICAgICAgICAgICAgICAgfCAgVSogfCBDeWNsaWMgeWVhciAgICAgICAgICAgICAgICAgICAgfFxcbiAqIHwgIHYqIHwgVGltZXpvbmUgKGdlbmVyaWMgbm9uLWxvY2F0LikgIHwgIFYqIHwgVGltZXpvbmUgKGxvY2F0aW9uKSAgICAgICAgICAgIHxcXG4gKiB8ICB3ICB8IExvY2FsIHdlZWsgb2YgeWVhciAgICAgICAgICAgICB8ICBXKiB8IFdlZWsgb2YgbW9udGggICAgICAgICAgICAgICAgICB8XFxuICogfCAgeCAgfCBUaW1lem9uZSAoSVNPLTg2MDEgdy9vIFopICAgICAgfCAgWCAgfCBUaW1lem9uZSAoSVNPLTg2MDEpICAgICAgICAgICAgfFxcbiAqIHwgIHkgIHwgWWVhciAoYWJzKSAgICAgICAgICAgICAgICAgICAgIHwgIFkgIHwgTG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhciAgICAgIHxcXG4gKiB8ICB6ICB8IFRpbWV6b25lIChzcGVjaWZpYyBub24tbG9jYXQuKSB8ICBaKiB8IFRpbWV6b25lIChhbGlhc2VzKSAgICAgICAgICAgICB8XFxuICpcXG4gKiBMZXR0ZXJzIG1hcmtlZCBieSAqIGFyZSBub3QgaW1wbGVtZW50ZWQgYnV0IHJlc2VydmVkIGJ5IFVuaWNvZGUgc3RhbmRhcmQuXFxuICpcXG4gKiBMZXR0ZXJzIG1hcmtlZCBieSAhIGFyZSBub24tc3RhbmRhcmQsIGJ1dCBpbXBsZW1lbnRlZCBieSBkYXRlLWZuczpcXG4gKiAtIGBvYCBtb2RpZmllcyB0aGUgcHJldmlvdXMgdG9rZW4gdG8gdHVybiBpdCBpbnRvIGFuIG9yZGluYWwgKHNlZSBgZm9ybWF0YCBkb2NzKVxcbiAqIC0gYGlgIGlzIElTTyBkYXkgb2Ygd2Vlay4gRm9yIGBpYCBhbmQgYGlpYCBpcyByZXR1cm5zIG51bWVyaWMgSVNPIHdlZWsgZGF5cyxcXG4gKiAgIGkuZS4gNyBmb3IgU3VuZGF5LCAxIGZvciBNb25kYXksIGV0Yy5cXG4gKiAtIGBJYCBpcyBJU08gd2VlayBvZiB5ZWFyLCBhcyBvcHBvc2VkIHRvIGB3YCB3aGljaCBpcyBsb2NhbCB3ZWVrIG9mIHllYXIuXFxuICogLSBgUmAgaXMgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIsIGFzIG9wcG9zZWQgdG8gYFlgIHdoaWNoIGlzIGxvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIuXFxuICogICBgUmAgaXMgc3VwcG9zZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBJYCBhbmQgYGlgXFxuICogICBmb3IgdW5pdmVyc2FsIElTTyB3ZWVrLW51bWJlcmluZyBkYXRlLCB3aGVyZWFzXFxuICogICBgWWAgaXMgc3VwcG9zZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGB3YCBhbmQgYGVgXFxuICogICBmb3Igd2Vlay1udW1iZXJpbmcgZGF0ZSBzcGVjaWZpYyB0byB0aGUgbG9jYWxlLlxcbiAqIC0gYFBgIGlzIGxvbmcgbG9jYWxpemVkIGRhdGUgZm9ybWF0XFxuICogLSBgcGAgaXMgbG9uZyBsb2NhbGl6ZWQgdGltZSBmb3JtYXRcXG4gKi9cXG5cXG52YXIgZm9ybWF0dGVycyA9IHtcXG4gIC8vIEVyYVxcbiAgRzogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xcbiAgICB2YXIgZXJhID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpID4gMCA/IDEgOiAwO1xcbiAgICBzd2l0Y2ggKHRva2VuKSB7XFxuICAgICAgLy8gQUQsIEJDXFxuICAgICAgY2FzZSAnRyc6XFxuICAgICAgY2FzZSAnR0cnOlxcbiAgICAgIGNhc2UgJ0dHRyc6XFxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZXJhKGVyYSwge3dpZHRoOiAnYWJicmV2aWF0ZWQnfSlcXG4gICAgICAvLyBBLCBCXFxuICAgICAgY2FzZSAnR0dHR0cnOlxcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmVyYShlcmEsIHt3aWR0aDogJ25hcnJvdyd9KVxcbiAgICAgIC8vIEFubm8gRG9taW5pLCBCZWZvcmUgQ2hyaXN0XFxuICAgICAgY2FzZSAnR0dHRyc6XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5lcmEoZXJhLCB7d2lkdGg6ICd3aWRlJ30pXFxuICAgIH1cXG4gIH0sXFxuXFxuICAvLyBZZWFyXFxuICB5OiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplLCBvcHRpb25zKSB7XFxuICAgIC8vIEZyb20gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS0zMS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9Gb3JtYXRfdG9rZW5zXFxuICAgIC8vIHwgWWVhciAgICAgfCAgICAgeSB8IHl5IHwgICB5eXkgfCAgeXl5eSB8IHl5eXl5IHxcXG4gICAgLy8gfC0tLS0tLS0tLS18LS0tLS0tLXwtLS0tfC0tLS0tLS18LS0tLS0tLXwtLS0tLS0tfFxcbiAgICAvLyB8IEFEIDEgICAgIHwgICAgIDEgfCAwMSB8ICAgMDAxIHwgIDAwMDEgfCAwMDAwMSB8XFxuICAgIC8vIHwgQUQgMTIgICAgfCAgICAxMiB8IDEyIHwgICAwMTIgfCAgMDAxMiB8IDAwMDEyIHxcXG4gICAgLy8gfCBBRCAxMjMgICB8ICAgMTIzIHwgMjMgfCAgIDEyMyB8ICAwMTIzIHwgMDAxMjMgfFxcbiAgICAvLyB8IEFEIDEyMzQgIHwgIDEyMzQgfCAzNCB8ICAxMjM0IHwgIDEyMzQgfCAwMTIzNCB8XFxuICAgIC8vIHwgQUQgMTIzNDUgfCAxMjM0NSB8IDQ1IHwgMTIzNDUgfCAxMjM0NSB8IDEyMzQ1IHxcXG5cXG4gICAgdmFyIHNpZ25lZFllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XFxuXFxuICAgIC8vIFJldHVybnMgMSBmb3IgMSBCQyAod2hpY2ggaXMgeWVhciAwIGluIEphdmFTY3JpcHQpXFxuICAgIHZhciB5ZWFyID0gc2lnbmVkWWVhciA+IDAgPyBzaWduZWRZZWFyIDogMSAtIHNpZ25lZFllYXI7XFxuXFxuICAgIC8vIFR3byBkaWdpdCB5ZWFyXFxuICAgIGlmICh0b2tlbiA9PT0gJ3l5Jykge1xcbiAgICAgIHZhciB0d29EaWdpdFllYXIgPSB5ZWFyICUgMTAwO1xcbiAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3ModHdvRGlnaXRZZWFyLCAyKVxcbiAgICB9XFxuXFxuICAgIC8vIE9yZGluYWwgbnVtYmVyXFxuICAgIGlmICh0b2tlbiA9PT0gJ3lvJykge1xcbiAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKHllYXIsIHt1bml0OiAneWVhcid9KVxcbiAgICB9XFxuXFxuICAgIC8vIFBhZGRpbmdcXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyh5ZWFyLCB0b2tlbi5sZW5ndGgpXFxuICB9LFxcblxcbiAgLy8gTG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhclxcbiAgWTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xcbiAgICB2YXIgc2lnbmVkV2Vla1llYXIgPSBnZXRVVENXZWVrWWVhcihkYXRlLCBvcHRpb25zKTtcXG4gICAgdmFyIHdlZWtZZWFyID0gc2lnbmVkV2Vla1llYXIgPiAwID8gc2lnbmVkV2Vla1llYXIgOiAxIC0gc2lnbmVkV2Vla1llYXI7XFxuXFxuICAgIC8vIFR3byBkaWdpdCB5ZWFyXFxuICAgIGlmICh0b2tlbiA9PT0gJ1lZJykge1xcbiAgICAgIHZhciB0d29EaWdpdFllYXIgPSB3ZWVrWWVhciAlIDEwMDtcXG4gICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHR3b0RpZ2l0WWVhciwgMilcXG4gICAgfVxcblxcbiAgICAvLyBPcmRpbmFsIG51bWJlclxcbiAgICBpZiAodG9rZW4gPT09ICdZbycpIHtcXG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcih3ZWVrWWVhciwge3VuaXQ6ICd5ZWFyJ30pXFxuICAgIH1cXG5cXG4gICAgLy8gUGFkZGluZ1xcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHdlZWtZZWFyLCB0b2tlbi5sZW5ndGgpXFxuICB9LFxcblxcbiAgLy8gSVNPIHdlZWstbnVtYmVyaW5nIHllYXJcXG4gIFI6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcXG4gICAgdmFyIGlzb1dlZWtZZWFyID0gZ2V0VVRDSVNPV2Vla1llYXIoZGF0ZSwgb3B0aW9ucyk7XFxuXFxuICAgIC8vIFBhZGRpbmdcXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhpc29XZWVrWWVhciwgdG9rZW4ubGVuZ3RoKVxcbiAgfSxcXG5cXG4gIC8vIEV4dGVuZGVkIHllYXIuIFRoaXMgaXMgYSBzaW5nbGUgbnVtYmVyIGRlc2lnbmF0aW5nIHRoZSB5ZWFyIG9mIHRoaXMgY2FsZW5kYXIgc3lzdGVtLlxcbiAgLy8gVGhlIG1haW4gZGlmZmVyZW5jZSBiZXR3ZWVuIGB5YCBhbmQgYHVgIGxvY2FsaXplcnMgYXJlIEIuQy4geWVhcnM6XFxuICAvLyB8IFllYXIgfCBgeWAgfCBgdWAgfFxcbiAgLy8gfC0tLS0tLXwtLS0tLXwtLS0tLXxcXG4gIC8vIHwgQUMgMSB8ICAgMSB8ICAgMSB8XFxuICAvLyB8IEJDIDEgfCAgIDEgfCAgIDAgfFxcbiAgLy8gfCBCQyAyIHwgICAyIHwgIC0xIHxcXG4gIC8vIEFsc28gYHl5YCBhbHdheXMgcmV0dXJucyB0aGUgbGFzdCB0d28gZGlnaXRzIG9mIGEgeWVhcixcXG4gIC8vIHdoaWxlIGB1dWAgcGFkcyBzaW5nbGUgZGlnaXQgeWVhcnMgdG8gMiBjaGFyYWN0ZXJzIGFuZCByZXR1cm5zIG90aGVyIHllYXJzIHVuY2hhbmdlZC5cXG4gIHU6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcXG4gICAgdmFyIHllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XFxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoeWVhciwgdG9rZW4ubGVuZ3RoKVxcbiAgfSxcXG5cXG4gIC8vIFF1YXJ0ZXJcXG4gIFE6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcXG4gICAgdmFyIHF1YXJ0ZXIgPSBNYXRoLmNlaWwoKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpIC8gMyk7XFxuICAgIHN3aXRjaCAodG9rZW4pIHtcXG4gICAgICAvLyAxLCAyLCAzLCA0XFxuICAgICAgY2FzZSAnUSc6XFxuICAgICAgICByZXR1cm4gU3RyaW5nKHF1YXJ0ZXIpXFxuICAgICAgLy8gMDEsIDAyLCAwMywgMDRcXG4gICAgICBjYXNlICdRUSc6XFxuICAgICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHF1YXJ0ZXIsIDIpXFxuICAgICAgLy8gMXN0LCAybmQsIDNyZCwgNHRoXFxuICAgICAgY2FzZSAnUW8nOlxcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIocXVhcnRlciwge3VuaXQ6ICdxdWFydGVyJ30pXFxuICAgICAgLy8gUTEsIFEyLCBRMywgUTRcXG4gICAgICBjYXNlICdRUVEnOlxcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLnF1YXJ0ZXIocXVhcnRlciwge3dpZHRoOiAnYWJicmV2aWF0ZWQnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KVxcbiAgICAgIC8vIDEsIDIsIDMsIDQgKG5hcnJvdyBxdWFydGVyOyBjb3VsZCBiZSBub3QgbnVtZXJpY2FsKVxcbiAgICAgIGNhc2UgJ1FRUVFRJzpcXG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHt3aWR0aDogJ25hcnJvdycsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pXFxuICAgICAgLy8gMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi5cXG4gICAgICBjYXNlICdRUVFRJzpcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLnF1YXJ0ZXIocXVhcnRlciwge3dpZHRoOiAnd2lkZScsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pXFxuICAgIH1cXG4gIH0sXFxuXFxuICAvLyBTdGFuZC1hbG9uZSBxdWFydGVyXFxuICBxOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplLCBvcHRpb25zKSB7XFxuICAgIHZhciBxdWFydGVyID0gTWF0aC5jZWlsKChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSAvIDMpO1xcbiAgICBzd2l0Y2ggKHRva2VuKSB7XFxuICAgICAgLy8gMSwgMiwgMywgNFxcbiAgICAgIGNhc2UgJ3EnOlxcbiAgICAgICAgcmV0dXJuIFN0cmluZyhxdWFydGVyKVxcbiAgICAgIC8vIDAxLCAwMiwgMDMsIDA0XFxuICAgICAgY2FzZSAncXEnOlxcbiAgICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhxdWFydGVyLCAyKVxcbiAgICAgIC8vIDFzdCwgMm5kLCAzcmQsIDR0aFxcbiAgICAgIGNhc2UgJ3FvJzpcXG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKHF1YXJ0ZXIsIHt1bml0OiAncXVhcnRlcid9KVxcbiAgICAgIC8vIFExLCBRMiwgUTMsIFE0XFxuICAgICAgY2FzZSAncXFxJzpcXG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHt3aWR0aDogJ2FiYnJldmlhdGVkJywgY29udGV4dDogJ3N0YW5kYWxvbmUnfSlcXG4gICAgICAvLyAxLCAyLCAzLCA0IChuYXJyb3cgcXVhcnRlcjsgY291bGQgYmUgbm90IG51bWVyaWNhbClcXG4gICAgICBjYXNlICdxcXFxcSc6XFxuICAgICAgICByZXR1cm4gbG9jYWxpemUucXVhcnRlcihxdWFydGVyLCB7d2lkdGg6ICduYXJyb3cnLCBjb250ZXh0OiAnc3RhbmRhbG9uZSd9KVxcbiAgICAgIC8vIDFzdCBxdWFydGVyLCAybmQgcXVhcnRlciwgLi4uXFxuICAgICAgY2FzZSAncXFxcSc6XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5xdWFydGVyKHF1YXJ0ZXIsIHt3aWR0aDogJ3dpZGUnLCBjb250ZXh0OiAnc3RhbmRhbG9uZSd9KVxcbiAgICB9XFxuICB9LFxcblxcbiAgLy8gTW9udGhcXG4gIE06IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcXG4gICAgdmFyIG1vbnRoID0gZGF0ZS5nZXRVVENNb250aCgpO1xcbiAgICBzd2l0Y2ggKHRva2VuKSB7XFxuICAgICAgLy8gMSwgMiwgLi4uLCAxMlxcbiAgICAgIGNhc2UgJ00nOlxcbiAgICAgICAgcmV0dXJuIFN0cmluZyhtb250aCArIDEpXFxuICAgICAgLy8gMDEsIDAyLCAuLi4sIDEyXFxuICAgICAgY2FzZSAnTU0nOlxcbiAgICAgICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhtb250aCArIDEsIDIpXFxuICAgICAgLy8gMXN0LCAybmQsIC4uLiwgMTJ0aFxcbiAgICAgIGNhc2UgJ01vJzpcXG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKG1vbnRoICsgMSwge3VuaXQ6ICdtb250aCd9KVxcbiAgICAgIC8vIEphbiwgRmViLCAuLi4sIERlY1xcbiAgICAgIGNhc2UgJ01NTSc6XFxuICAgICAgICByZXR1cm4gbG9jYWxpemUubW9udGgobW9udGgsIHt3aWR0aDogJ2FiYnJldmlhdGVkJywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgICAvLyBKLCBGLCAuLi4sIERcXG4gICAgICBjYXNlICdNTU1NTSc6XFxuICAgICAgICByZXR1cm4gbG9jYWxpemUubW9udGgobW9udGgsIHt3aWR0aDogJ25hcnJvdycsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pXFxuICAgICAgLy8gSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXJcXG4gICAgICBjYXNlICdNTU1NJzpcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7d2lkdGg6ICd3aWRlJywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8vIFN0YW5kLWFsb25lIG1vbnRoXFxuICBMOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplLCBvcHRpb25zKSB7XFxuICAgIHZhciBtb250aCA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcXG4gICAgc3dpdGNoICh0b2tlbikge1xcbiAgICAgIC8vIDEsIDIsIC4uLiwgMTJcXG4gICAgICBjYXNlICdMJzpcXG4gICAgICAgIHJldHVybiBTdHJpbmcobW9udGggKyAxKVxcbiAgICAgIC8vIDAxLCAwMiwgLi4uLCAxMlxcbiAgICAgIGNhc2UgJ0xMJzpcXG4gICAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MobW9udGggKyAxLCAyKVxcbiAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDEydGhcXG4gICAgICBjYXNlICdMbyc6XFxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihtb250aCArIDEsIHt1bml0OiAnbW9udGgnfSlcXG4gICAgICAvLyBKYW4sIEZlYiwgLi4uLCBEZWNcXG4gICAgICBjYXNlICdMTEwnOlxcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7d2lkdGg6ICdhYmJyZXZpYXRlZCcsIGNvbnRleHQ6ICdzdGFuZGFsb25lJ30pXFxuICAgICAgLy8gSiwgRiwgLi4uLCBEXFxuICAgICAgY2FzZSAnTExMTEwnOlxcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm1vbnRoKG1vbnRoLCB7d2lkdGg6ICduYXJyb3cnLCBjb250ZXh0OiAnc3RhbmRhbG9uZSd9KVxcbiAgICAgIC8vIEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyXFxuICAgICAgY2FzZSAnTExMTCc6XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5tb250aChtb250aCwge3dpZHRoOiAnd2lkZScsIGNvbnRleHQ6ICdzdGFuZGFsb25lJ30pXFxuICAgIH1cXG4gIH0sXFxuXFxuICAvLyBMb2NhbCB3ZWVrIG9mIHllYXJcXG4gIHc6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcXG4gICAgdmFyIHdlZWsgPSBnZXRVVENXZWVrKGRhdGUsIG9wdGlvbnMpO1xcblxcbiAgICBpZiAodG9rZW4gPT09ICd3bycpIHtcXG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcih3ZWVrLCB7dW5pdDogJ3dlZWsnfSlcXG4gICAgfVxcblxcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHdlZWssIHRva2VuLmxlbmd0aClcXG4gIH0sXFxuXFxuICAvLyBJU08gd2VlayBvZiB5ZWFyXFxuICBJOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplLCBvcHRpb25zKSB7XFxuICAgIHZhciBpc29XZWVrID0gZ2V0VVRDSVNPV2VlayhkYXRlLCBvcHRpb25zKTtcXG5cXG4gICAgaWYgKHRva2VuID09PSAnSW8nKSB7XFxuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoaXNvV2Vlaywge3VuaXQ6ICd3ZWVrJ30pXFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhpc29XZWVrLCB0b2tlbi5sZW5ndGgpXFxuICB9LFxcblxcbiAgLy8gRGF5IG9mIHRoZSBtb250aFxcbiAgZDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xcbiAgICB2YXIgZGF5T2ZNb250aCA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xcblxcbiAgICBpZiAodG9rZW4gPT09ICdkbycpIHtcXG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihkYXlPZk1vbnRoLCB7dW5pdDogJ2RhdGUnfSlcXG4gICAgfVxcblxcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRheU9mTW9udGgsIHRva2VuLmxlbmd0aClcXG4gIH0sXFxuXFxuICAvLyBEYXkgb2YgeWVhclxcbiAgRDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xcbiAgICB2YXIgZGF5T2ZZZWFyID0gZ2V0VVRDRGF5T2ZZZWFyKGRhdGUsIG9wdGlvbnMpO1xcblxcbiAgICBpZiAodG9rZW4gPT09ICdEbycpIHtcXG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihkYXlPZlllYXIsIHt1bml0OiAnZGF5T2ZZZWFyJ30pXFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXlPZlllYXIsIHRva2VuLmxlbmd0aClcXG4gIH0sXFxuXFxuICAvLyBEYXkgb2Ygd2Vla1xcbiAgRTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xcbiAgICB2YXIgZGF5T2ZXZWVrID0gZGF0ZS5nZXRVVENEYXkoKTtcXG4gICAgc3dpdGNoICh0b2tlbikge1xcbiAgICAgIC8vIFR1ZVxcbiAgICAgIGNhc2UgJ0UnOlxcbiAgICAgIGNhc2UgJ0VFJzpcXG4gICAgICBjYXNlICdFRUUnOlxcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHt3aWR0aDogJ2FiYnJldmlhdGVkJywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgICAvLyBUXFxuICAgICAgY2FzZSAnRUVFRUUnOlxcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHt3aWR0aDogJ25hcnJvdycsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pXFxuICAgICAgLy8gVHVcXG4gICAgICBjYXNlICdFRUVFRUUnOlxcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHt3aWR0aDogJ3Nob3J0JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgICAvLyBUdWVzZGF5XFxuICAgICAgY2FzZSAnRUVFRSc6XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7d2lkdGg6ICd3aWRlJywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8vIExvY2FsIGRheSBvZiB3ZWVrXFxuICBlOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplLCBvcHRpb25zKSB7XFxuICAgIHZhciBkYXlPZldlZWsgPSBkYXRlLmdldFVUQ0RheSgpO1xcbiAgICB2YXIgbG9jYWxEYXlPZldlZWsgPSAoKGRheU9mV2VlayAtIG9wdGlvbnMud2Vla1N0YXJ0c09uICsgOCkgJSA3KSB8fCA3O1xcbiAgICBzd2l0Y2ggKHRva2VuKSB7XFxuICAgICAgLy8gTnVtZXJpY2FsIHZhbHVlIChOdGggZGF5IG9mIHdlZWsgd2l0aCBjdXJyZW50IGxvY2FsZSBvciB3ZWVrU3RhcnRzT24pXFxuICAgICAgY2FzZSAnZSc6XFxuICAgICAgICByZXR1cm4gU3RyaW5nKGxvY2FsRGF5T2ZXZWVrKVxcbiAgICAgIC8vIFBhZGRlZCBudW1lcmljYWwgdmFsdWVcXG4gICAgICBjYXNlICdlZSc6XFxuICAgICAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGxvY2FsRGF5T2ZXZWVrLCAyKVxcbiAgICAgIC8vIDFzdCwgMm5kLCAuLi4sIDd0aFxcbiAgICAgIGNhc2UgJ2VvJzpcXG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5vcmRpbmFsTnVtYmVyKGxvY2FsRGF5T2ZXZWVrLCB7dW5pdDogJ2RheSd9KVxcbiAgICAgIGNhc2UgJ2VlZSc6XFxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge3dpZHRoOiAnYWJicmV2aWF0ZWQnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KVxcbiAgICAgIC8vIFRcXG4gICAgICBjYXNlICdlZWVlZSc6XFxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgICAvLyBUdVxcbiAgICAgIGNhc2UgJ2VlZWVlZSc6XFxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge3dpZHRoOiAnc2hvcnQnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KVxcbiAgICAgIC8vIFR1ZXNkYXlcXG4gICAgICBjYXNlICdlZWVlJzpcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHt3aWR0aDogJ3dpZGUnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KVxcbiAgICB9XFxuICB9LFxcblxcbiAgLy8gU3RhbmQtYWxvbmUgbG9jYWwgZGF5IG9mIHdlZWtcXG4gIGM6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcXG4gICAgdmFyIGRheU9mV2VlayA9IGRhdGUuZ2V0VVRDRGF5KCk7XFxuICAgIHZhciBsb2NhbERheU9mV2VlayA9ICgoZGF5T2ZXZWVrIC0gb3B0aW9ucy53ZWVrU3RhcnRzT24gKyA4KSAlIDcpIHx8IDc7XFxuICAgIHN3aXRjaCAodG9rZW4pIHtcXG4gICAgICAvLyBOdW1lcmljYWwgdmFsdWUgKHNhbWUgYXMgaW4gYGVgKVxcbiAgICAgIGNhc2UgJ2MnOlxcbiAgICAgICAgcmV0dXJuIFN0cmluZyhsb2NhbERheU9mV2VlaylcXG4gICAgICAvLyBQYWRkZWQgbnVtYmVyaWNhbCB2YWx1ZVxcbiAgICAgIGNhc2UgJ2NjJzpcXG4gICAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MobG9jYWxEYXlPZldlZWssIHRva2VuLmxlbmd0aClcXG4gICAgICAvLyAxc3QsIDJuZCwgLi4uLCA3dGhcXG4gICAgICBjYXNlICdjbyc6XFxuICAgICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihsb2NhbERheU9mV2Vlaywge3VuaXQ6ICdkYXknfSlcXG4gICAgICBjYXNlICdjY2MnOlxcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHt3aWR0aDogJ2FiYnJldmlhdGVkJywgY29udGV4dDogJ3N0YW5kYWxvbmUnfSlcXG4gICAgICAvLyBUXFxuICAgICAgY2FzZSAnY2NjY2MnOlxcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHt3aWR0aDogJ25hcnJvdycsIGNvbnRleHQ6ICdzdGFuZGFsb25lJ30pXFxuICAgICAgLy8gVHVcXG4gICAgICBjYXNlICdjY2NjY2MnOlxcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHt3aWR0aDogJ3Nob3J0JywgY29udGV4dDogJ3N0YW5kYWxvbmUnfSlcXG4gICAgICAvLyBUdWVzZGF5XFxuICAgICAgY2FzZSAnY2NjYyc6XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXkoZGF5T2ZXZWVrLCB7d2lkdGg6ICd3aWRlJywgY29udGV4dDogJ3N0YW5kYWxvbmUnfSlcXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8vIElTTyBkYXkgb2Ygd2Vla1xcbiAgaTogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xcbiAgICB2YXIgZGF5T2ZXZWVrID0gZGF0ZS5nZXRVVENEYXkoKTtcXG4gICAgdmFyIGlzb0RheU9mV2VlayA9IGRheU9mV2VlayA9PT0gMCA/IDcgOiBkYXlPZldlZWs7XFxuICAgIHN3aXRjaCAodG9rZW4pIHtcXG4gICAgICAvLyAyXFxuICAgICAgY2FzZSAnaSc6XFxuICAgICAgICByZXR1cm4gU3RyaW5nKGlzb0RheU9mV2VlaylcXG4gICAgICAvLyAwMlxcbiAgICAgIGNhc2UgJ2lpJzpcXG4gICAgICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoaXNvRGF5T2ZXZWVrLCB0b2tlbi5sZW5ndGgpXFxuICAgICAgLy8gMm5kXFxuICAgICAgY2FzZSAnaW8nOlxcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoaXNvRGF5T2ZXZWVrLCB7dW5pdDogJ2RheSd9KVxcbiAgICAgIC8vIFR1ZVxcbiAgICAgIGNhc2UgJ2lpaSc6XFxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge3dpZHRoOiAnYWJicmV2aWF0ZWQnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KVxcbiAgICAgIC8vIFRcXG4gICAgICBjYXNlICdpaWlpaSc6XFxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgICAvLyBUdVxcbiAgICAgIGNhc2UgJ2lpaWlpaSc6XFxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5KGRheU9mV2Vlaywge3dpZHRoOiAnc2hvcnQnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KVxcbiAgICAgIC8vIFR1ZXNkYXlcXG4gICAgICBjYXNlICdpaWlpJzpcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheShkYXlPZldlZWssIHt3aWR0aDogJ3dpZGUnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KVxcbiAgICB9XFxuICB9LFxcblxcbiAgLy8gQU0gb3IgUE1cXG4gIGE6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUpIHtcXG4gICAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpO1xcbiAgICB2YXIgZGF5UGVyaW9kRW51bVZhbHVlID0gKGhvdXJzIC8gMTIpID49IDEgPyAncG0nIDogJ2FtJztcXG5cXG4gICAgc3dpdGNoICh0b2tlbikge1xcbiAgICAgIGNhc2UgJ2EnOlxcbiAgICAgIGNhc2UgJ2FhJzpcXG4gICAgICBjYXNlICdhYWEnOlxcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHt3aWR0aDogJ2FiYnJldmlhdGVkJywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgICBjYXNlICdhYWFhYSc6XFxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgICBjYXNlICdhYWFhJzpcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHt3aWR0aDogJ3dpZGUnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KVxcbiAgICB9XFxuICB9LFxcblxcbiAgLy8gQU0sIFBNLCBtaWRuaWdodCwgbm9vblxcbiAgYjogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xcbiAgICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XFxuICAgIHZhciBkYXlQZXJpb2RFbnVtVmFsdWU7XFxuICAgIGlmIChob3VycyA9PT0gMTIpIHtcXG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLm5vb247XFxuICAgIH0gZWxzZSBpZiAoaG91cnMgPT09IDApIHtcXG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLm1pZG5pZ2h0O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IChob3VycyAvIDEyKSA+PSAxID8gJ3BtJyA6ICdhbSc7XFxuICAgIH1cXG5cXG4gICAgc3dpdGNoICh0b2tlbikge1xcbiAgICAgIGNhc2UgJ2InOlxcbiAgICAgIGNhc2UgJ2JiJzpcXG4gICAgICBjYXNlICdiYmInOlxcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHt3aWR0aDogJ2FiYnJldmlhdGVkJywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgICBjYXNlICdiYmJiYic6XFxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgICBjYXNlICdiYmJiJzpcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgcmV0dXJuIGxvY2FsaXplLmRheVBlcmlvZChkYXlQZXJpb2RFbnVtVmFsdWUsIHt3aWR0aDogJ3dpZGUnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KVxcbiAgICB9XFxuICB9LFxcblxcbiAgLy8gaW4gdGhlIG1vcm5pbmcsIGluIHRoZSBhZnRlcm5vb24sIGluIHRoZSBldmVuaW5nLCBhdCBuaWdodFxcbiAgQjogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSkge1xcbiAgICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XFxuICAgIHZhciBkYXlQZXJpb2RFbnVtVmFsdWU7XFxuICAgIGlmIChob3VycyA+PSAxNykge1xcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRheVBlcmlvZEVudW0uZXZlbmluZztcXG4gICAgfSBlbHNlIGlmIChob3VycyA+PSAxMikge1xcbiAgICAgIGRheVBlcmlvZEVudW1WYWx1ZSA9IGRheVBlcmlvZEVudW0uYWZ0ZXJub29uO1xcbiAgICB9IGVsc2UgaWYgKGhvdXJzID49IDQpIHtcXG4gICAgICBkYXlQZXJpb2RFbnVtVmFsdWUgPSBkYXlQZXJpb2RFbnVtLm1vcm5pbmc7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZGF5UGVyaW9kRW51bVZhbHVlID0gZGF5UGVyaW9kRW51bS5uaWdodDtcXG4gICAgfVxcblxcbiAgICBzd2l0Y2ggKHRva2VuKSB7XFxuICAgICAgY2FzZSAnQic6XFxuICAgICAgY2FzZSAnQkInOlxcbiAgICAgIGNhc2UgJ0JCQic6XFxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge3dpZHRoOiAnYWJicmV2aWF0ZWQnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KVxcbiAgICAgIGNhc2UgJ0JCQkJCJzpcXG4gICAgICAgIHJldHVybiBsb2NhbGl6ZS5kYXlQZXJpb2QoZGF5UGVyaW9kRW51bVZhbHVlLCB7d2lkdGg6ICduYXJyb3cnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KVxcbiAgICAgIGNhc2UgJ0JCQkInOlxcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICByZXR1cm4gbG9jYWxpemUuZGF5UGVyaW9kKGRheVBlcmlvZEVudW1WYWx1ZSwge3dpZHRoOiAnd2lkZScsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pXFxuICAgIH1cXG4gIH0sXFxuXFxuICAvLyBIb3VyIFsxLTEyXVxcbiAgaDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xcbiAgICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCkgJSAxMjtcXG5cXG4gICAgaWYgKGhvdXJzID09PSAwKSB7XFxuICAgICAgaG91cnMgPSAxMjtcXG4gICAgfVxcblxcbiAgICBpZiAodG9rZW4gPT09ICdobycpIHtcXG4gICAgICByZXR1cm4gbG9jYWxpemUub3JkaW5hbE51bWJlcihob3Vycywge3VuaXQ6ICdob3VyJ30pXFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhob3VycywgdG9rZW4ubGVuZ3RoKVxcbiAgfSxcXG5cXG4gIC8vIEhvdXIgWzAtMjNdXFxuICBIOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplLCBvcHRpb25zKSB7XFxuICAgIHZhciBob3VycyA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcXG5cXG4gICAgaWYgKHRva2VuID09PSAnSG8nKSB7XFxuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoaG91cnMsIHt1bml0OiAnaG91cid9KVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoaG91cnMsIHRva2VuLmxlbmd0aClcXG4gIH0sXFxuXFxuICAvLyBIb3VyIFswLTExXVxcbiAgSzogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xcbiAgICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCkgJSAxMjtcXG5cXG4gICAgaWYgKHRva2VuID09PSAnS28nKSB7XFxuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoaG91cnMsIHt1bml0OiAnaG91cid9KVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoaG91cnMsIHRva2VuLmxlbmd0aClcXG4gIH0sXFxuXFxuICAvLyBIb3VyIFsxLTI0XVxcbiAgazogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xcbiAgICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XFxuXFxuICAgIGlmIChob3VycyA9PT0gMCkge1xcbiAgICAgIGhvdXJzID0gMjQ7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRva2VuID09PSAna28nKSB7XFxuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoaG91cnMsIHt1bml0OiAnaG91cid9KVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoaG91cnMsIHRva2VuLmxlbmd0aClcXG4gIH0sXFxuXFxuICAvLyBNaW51dGVcXG4gIG06IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcXG4gICAgdmFyIG1pbnV0ZXMgPSBkYXRlLmdldFVUQ01pbnV0ZXMoKTtcXG5cXG4gICAgaWYgKHRva2VuID09PSAnbW8nKSB7XFxuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIobWludXRlcywge3VuaXQ6ICdtaW51dGUnfSlcXG4gICAgfVxcblxcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKG1pbnV0ZXMsIHRva2VuLmxlbmd0aClcXG4gIH0sXFxuXFxuICAvLyBTZWNvbmRcXG4gIHM6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcXG4gICAgdmFyIHNlY29uZHMgPSBkYXRlLmdldFVUQ1NlY29uZHMoKTtcXG5cXG4gICAgaWYgKHRva2VuID09PSAnc28nKSB7XFxuICAgICAgcmV0dXJuIGxvY2FsaXplLm9yZGluYWxOdW1iZXIoc2Vjb25kcywge3VuaXQ6ICdzZWNvbmQnfSlcXG4gICAgfVxcblxcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKHNlY29uZHMsIHRva2VuLmxlbmd0aClcXG4gIH0sXFxuXFxuICAvLyBGcmFjdGlvbiBvZiBzZWNvbmRcXG4gIFM6IGZ1bmN0aW9uIChkYXRlLCB0b2tlbiwgbG9jYWxpemUsIG9wdGlvbnMpIHtcXG4gICAgdmFyIG51bWJlck9mRGlnaXRzID0gdG9rZW4ubGVuZ3RoO1xcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcXG4gICAgdmFyIGZyYWN0aW9uYWxTZWNvbmRzID0gTWF0aC5mbG9vcihtaWxsaXNlY29uZHMgKiBNYXRoLnBvdygxMCwgbnVtYmVyT2ZEaWdpdHMgLSAzKSk7XFxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZnJhY3Rpb25hbFNlY29uZHMsIG51bWJlck9mRGlnaXRzKVxcbiAgfSxcXG5cXG4gIC8vIFRpbWV6b25lIChJU08tODYwMS4gSWYgb2Zmc2V0IGlzIDAsIG91dHB1dCBpcyBhbHdheXMgYCdaJ2ApXFxuICBYOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplLCBvcHRpb25zKSB7XFxuICAgIHZhciBvcmlnaW5hbERhdGUgPSBvcHRpb25zLl9vcmlnaW5hbERhdGUgfHwgZGF0ZTtcXG4gICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gb3JpZ2luYWxEYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XFxuXFxuICAgIGlmICh0aW1lem9uZU9mZnNldCA9PT0gMCkge1xcbiAgICAgIHJldHVybiAnWidcXG4gICAgfVxcblxcbiAgICBzd2l0Y2ggKHRva2VuKSB7XFxuICAgICAgLy8gSG91cnMgYW5kIG9wdGlvbmFsIG1pbnV0ZXNcXG4gICAgICBjYXNlICdYJzpcXG4gICAgICAgIHJldHVybiBmb3JtYXRUaW1lem9uZVdpdGhPcHRpb25hbE1pbnV0ZXModGltZXpvbmVPZmZzZXQpXFxuXFxuICAgICAgLy8gSG91cnMsIG1pbnV0ZXMgYW5kIG9wdGlvbmFsIHNlY29uZHMgd2l0aG91dCBgOmAgZGVsaW1ldGVyXFxuICAgICAgLy8gTm90ZTogbmVpdGhlciBJU08tODYwMSBub3IgSmF2YVNjcmlwdCBzdXBwb3J0cyBzZWNvbmRzIGluIHRpbWV6b25lIG9mZnNldHNcXG4gICAgICAvLyBzbyB0aGlzIHRva2VuIGFsd2F5cyBoYXMgdGhlIHNhbWUgb3V0cHV0IGFzIGBYWGBcXG4gICAgICBjYXNlICdYWFhYJzpcXG4gICAgICBjYXNlICdYWCc6IC8vIEhvdXJzIGFuZCBtaW51dGVzIHdpdGhvdXQgYDpgIGRlbGltZXRlclxcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0KVxcblxcbiAgICAgIC8vIEhvdXJzLCBtaW51dGVzIGFuZCBvcHRpb25hbCBzZWNvbmRzIHdpdGggYDpgIGRlbGltZXRlclxcbiAgICAgIC8vIE5vdGU6IG5laXRoZXIgSVNPLTg2MDEgbm9yIEphdmFTY3JpcHQgc3VwcG9ydHMgc2Vjb25kcyBpbiB0aW1lem9uZSBvZmZzZXRzXFxuICAgICAgLy8gc28gdGhpcyB0b2tlbiBhbHdheXMgaGFzIHRoZSBzYW1lIG91dHB1dCBhcyBgWFhYYFxcbiAgICAgIGNhc2UgJ1hYWFhYJzpcXG4gICAgICBjYXNlICdYWFgnOiAvLyBIb3VycyBhbmQgbWludXRlcyB3aXRoIGA6YCBkZWxpbWV0ZXJcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCAnOicpXFxuICAgIH1cXG4gIH0sXFxuXFxuICAvLyBUaW1lem9uZSAoSVNPLTg2MDEuIElmIG9mZnNldCBpcyAwLCBvdXRwdXQgaXMgYCcrMDA6MDAnYCBvciBlcXVpdmFsZW50KVxcbiAgeDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xcbiAgICB2YXIgb3JpZ2luYWxEYXRlID0gb3B0aW9ucy5fb3JpZ2luYWxEYXRlIHx8IGRhdGU7XFxuICAgIHZhciB0aW1lem9uZU9mZnNldCA9IG9yaWdpbmFsRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xcblxcbiAgICBzd2l0Y2ggKHRva2VuKSB7XFxuICAgICAgLy8gSG91cnMgYW5kIG9wdGlvbmFsIG1pbnV0ZXNcXG4gICAgICBjYXNlICd4JzpcXG4gICAgICAgIHJldHVybiBmb3JtYXRUaW1lem9uZVdpdGhPcHRpb25hbE1pbnV0ZXModGltZXpvbmVPZmZzZXQpXFxuXFxuICAgICAgLy8gSG91cnMsIG1pbnV0ZXMgYW5kIG9wdGlvbmFsIHNlY29uZHMgd2l0aG91dCBgOmAgZGVsaW1ldGVyXFxuICAgICAgLy8gTm90ZTogbmVpdGhlciBJU08tODYwMSBub3IgSmF2YVNjcmlwdCBzdXBwb3J0cyBzZWNvbmRzIGluIHRpbWV6b25lIG9mZnNldHNcXG4gICAgICAvLyBzbyB0aGlzIHRva2VuIGFsd2F5cyBoYXMgdGhlIHNhbWUgb3V0cHV0IGFzIGB4eGBcXG4gICAgICBjYXNlICd4eHh4JzpcXG4gICAgICBjYXNlICd4eCc6IC8vIEhvdXJzIGFuZCBtaW51dGVzIHdpdGhvdXQgYDpgIGRlbGltZXRlclxcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0KVxcblxcbiAgICAgIC8vIEhvdXJzLCBtaW51dGVzIGFuZCBvcHRpb25hbCBzZWNvbmRzIHdpdGggYDpgIGRlbGltZXRlclxcbiAgICAgIC8vIE5vdGU6IG5laXRoZXIgSVNPLTg2MDEgbm9yIEphdmFTY3JpcHQgc3VwcG9ydHMgc2Vjb25kcyBpbiB0aW1lem9uZSBvZmZzZXRzXFxuICAgICAgLy8gc28gdGhpcyB0b2tlbiBhbHdheXMgaGFzIHRoZSBzYW1lIG91dHB1dCBhcyBgeHh4YFxcbiAgICAgIGNhc2UgJ3h4eHh4JzpcXG4gICAgICBjYXNlICd4eHgnOiAvLyBIb3VycyBhbmQgbWludXRlcyB3aXRoIGA6YCBkZWxpbWV0ZXJcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCAnOicpXFxuICAgIH1cXG4gIH0sXFxuXFxuICAvLyBUaW1lem9uZSAoR01UKVxcbiAgTzogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xcbiAgICB2YXIgb3JpZ2luYWxEYXRlID0gb3B0aW9ucy5fb3JpZ2luYWxEYXRlIHx8IGRhdGU7XFxuICAgIHZhciB0aW1lem9uZU9mZnNldCA9IG9yaWdpbmFsRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xcblxcbiAgICBzd2l0Y2ggKHRva2VuKSB7XFxuICAgICAgLy8gU2hvcnRcXG4gICAgICBjYXNlICdPJzpcXG4gICAgICBjYXNlICdPTyc6XFxuICAgICAgY2FzZSAnT09PJzpcXG4gICAgICAgIHJldHVybiAnR01UJyArIGZvcm1hdFRpbWV6b25lU2hvcnQodGltZXpvbmVPZmZzZXQsICc6JylcXG4gICAgICAvLyBMb25nXFxuICAgICAgY2FzZSAnT09PTyc6XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIHJldHVybiAnR01UJyArIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCAnOicpXFxuICAgIH1cXG4gIH0sXFxuXFxuICAvLyBUaW1lem9uZSAoc3BlY2lmaWMgbm9uLWxvY2F0aW9uKVxcbiAgejogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xcbiAgICB2YXIgb3JpZ2luYWxEYXRlID0gb3B0aW9ucy5fb3JpZ2luYWxEYXRlIHx8IGRhdGU7XFxuICAgIHZhciB0aW1lem9uZU9mZnNldCA9IG9yaWdpbmFsRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xcblxcbiAgICBzd2l0Y2ggKHRva2VuKSB7XFxuICAgICAgLy8gU2hvcnRcXG4gICAgICBjYXNlICd6JzpcXG4gICAgICBjYXNlICd6eic6XFxuICAgICAgY2FzZSAnenp6JzpcXG4gICAgICAgIHJldHVybiAnR01UJyArIGZvcm1hdFRpbWV6b25lU2hvcnQodGltZXpvbmVPZmZzZXQsICc6JylcXG4gICAgICAvLyBMb25nXFxuICAgICAgY2FzZSAnenp6eic6XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIHJldHVybiAnR01UJyArIGZvcm1hdFRpbWV6b25lKHRpbWV6b25lT2Zmc2V0LCAnOicpXFxuICAgIH1cXG4gIH0sXFxuXFxuICAvLyBTZWNvbmRzIHRpbWVzdGFtcFxcbiAgdDogZnVuY3Rpb24gKGRhdGUsIHRva2VuLCBsb2NhbGl6ZSwgb3B0aW9ucykge1xcbiAgICB2YXIgb3JpZ2luYWxEYXRlID0gb3B0aW9ucy5fb3JpZ2luYWxEYXRlIHx8IGRhdGU7XFxuICAgIHZhciB0aW1lc3RhbXAgPSBNYXRoLmZsb29yKG9yaWdpbmFsRGF0ZS5nZXRUaW1lKCkgLyAxMDAwKTtcXG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyh0aW1lc3RhbXAsIHRva2VuLmxlbmd0aClcXG4gIH0sXFxuXFxuICAvLyBNaWxsaXNlY29uZHMgdGltZXN0YW1wXFxuICBUOiBmdW5jdGlvbiAoZGF0ZSwgdG9rZW4sIGxvY2FsaXplLCBvcHRpb25zKSB7XFxuICAgIHZhciBvcmlnaW5hbERhdGUgPSBvcHRpb25zLl9vcmlnaW5hbERhdGUgfHwgZGF0ZTtcXG4gICAgdmFyIHRpbWVzdGFtcCA9IG9yaWdpbmFsRGF0ZS5nZXRUaW1lKCk7XFxuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3ModGltZXN0YW1wLCB0b2tlbi5sZW5ndGgpXFxuICB9XFxufTtcXG5cXG5mdW5jdGlvbiBhZGRMZWFkaW5nWmVyb3MgKG51bWJlciwgdGFyZ2V0TGVuZ3RoKSB7XFxuICB2YXIgc2lnbiA9IG51bWJlciA8IDAgPyAnLScgOiAnJztcXG4gIHZhciBvdXRwdXQgPSBNYXRoLmFicyhudW1iZXIpLnRvU3RyaW5nKCk7XFxuICB3aGlsZSAob3V0cHV0Lmxlbmd0aCA8IHRhcmdldExlbmd0aCkge1xcbiAgICBvdXRwdXQgPSAnMCcgKyBvdXRwdXQ7XFxuICB9XFxuICByZXR1cm4gc2lnbiArIG91dHB1dFxcbn1cXG5cXG5mdW5jdGlvbiBmb3JtYXRUaW1lem9uZSAob2Zmc2V0LCBkaXJ0eURlbGltZXRlcikge1xcbiAgdmFyIGRlbGltZXRlciA9IGRpcnR5RGVsaW1ldGVyIHx8ICcnO1xcbiAgdmFyIHNpZ24gPSBvZmZzZXQgPiAwID8gJy0nIDogJysnO1xcbiAgdmFyIGFic09mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XFxuICB2YXIgaG91cnMgPSBhZGRMZWFkaW5nWmVyb3MoTWF0aC5mbG9vcihhYnNPZmZzZXQgLyA2MCksIDIpO1xcbiAgdmFyIG1pbnV0ZXMgPSBhZGRMZWFkaW5nWmVyb3MoYWJzT2Zmc2V0ICUgNjAsIDIpO1xcbiAgcmV0dXJuIHNpZ24gKyBob3VycyArIGRlbGltZXRlciArIG1pbnV0ZXNcXG59XFxuXFxuZnVuY3Rpb24gZm9ybWF0VGltZXpvbmVXaXRoT3B0aW9uYWxNaW51dGVzIChvZmZzZXQsIGRpcnR5RGVsaW1ldGVyKSB7XFxuICBpZiAob2Zmc2V0ICUgNjAgPT09IDApIHtcXG4gICAgdmFyIHNpZ24gPSBvZmZzZXQgPiAwID8gJy0nIDogJysnO1xcbiAgICByZXR1cm4gc2lnbiArIGFkZExlYWRpbmdaZXJvcyhNYXRoLmFicyhvZmZzZXQpIC8gNjAsIDIpXFxuICB9XFxuICByZXR1cm4gZm9ybWF0VGltZXpvbmUob2Zmc2V0LCBkaXJ0eURlbGltZXRlcilcXG59XFxuXFxuZnVuY3Rpb24gZm9ybWF0VGltZXpvbmVTaG9ydCAob2Zmc2V0LCBkaXJ0eURlbGltZXRlcikge1xcbiAgdmFyIHNpZ24gPSBvZmZzZXQgPiAwID8gJy0nIDogJysnO1xcbiAgdmFyIGFic09mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XFxuICB2YXIgaG91cnMgPSBNYXRoLmZsb29yKGFic09mZnNldCAvIDYwKTtcXG4gIHZhciBtaW51dGVzID0gYWJzT2Zmc2V0ICUgNjA7XFxuICBpZiAobWludXRlcyA9PT0gMCkge1xcbiAgICByZXR1cm4gc2lnbiArIFN0cmluZyhob3VycylcXG4gIH1cXG4gIHZhciBkZWxpbWV0ZXIgPSBkaXJ0eURlbGltZXRlciB8fCAnJztcXG4gIHJldHVybiBzaWduICsgU3RyaW5nKGhvdXJzKSArIGRlbGltZXRlciArIGFkZExlYWRpbmdaZXJvcyhtaW51dGVzLCAyKVxcbn1cXG5cXG5mdW5jdGlvbiBkYXRlTG9uZ0Zvcm1hdHRlciAocGF0dGVybiwgZm9ybWF0TG9uZywgb3B0aW9ucykge1xcbiAgc3dpdGNoIChwYXR0ZXJuKSB7XFxuICAgIGNhc2UgJ1AnOlxcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLmRhdGUoe3dpZHRoOiAnc2hvcnQnfSlcXG4gICAgY2FzZSAnUFAnOlxcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLmRhdGUoe3dpZHRoOiAnbWVkaXVtJ30pXFxuICAgIGNhc2UgJ1BQUCc6XFxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcuZGF0ZSh7d2lkdGg6ICdsb25nJ30pXFxuICAgIGNhc2UgJ1BQUFAnOlxcbiAgICBkZWZhdWx0OlxcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLmRhdGUoe3dpZHRoOiAnZnVsbCd9KVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiB0aW1lTG9uZ0Zvcm1hdHRlciAocGF0dGVybiwgZm9ybWF0TG9uZywgb3B0aW9ucykge1xcbiAgc3dpdGNoIChwYXR0ZXJuKSB7XFxuICAgIGNhc2UgJ3AnOlxcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLnRpbWUoe3dpZHRoOiAnc2hvcnQnfSlcXG4gICAgY2FzZSAncHAnOlxcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLnRpbWUoe3dpZHRoOiAnbWVkaXVtJ30pXFxuICAgIGNhc2UgJ3BwcCc6XFxuICAgICAgcmV0dXJuIGZvcm1hdExvbmcudGltZSh7d2lkdGg6ICdsb25nJ30pXFxuICAgIGNhc2UgJ3BwcHAnOlxcbiAgICBkZWZhdWx0OlxcbiAgICAgIHJldHVybiBmb3JtYXRMb25nLnRpbWUoe3dpZHRoOiAnZnVsbCd9KVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBkYXRlVGltZUxvbmdGb3JtYXR0ZXIgKHBhdHRlcm4sIGZvcm1hdExvbmcsIG9wdGlvbnMpIHtcXG4gIHZhciBtYXRjaFJlc3VsdCA9IHBhdHRlcm4ubWF0Y2goLyhQKykocCspPy8pO1xcbiAgdmFyIGRhdGVQYXR0ZXJuID0gbWF0Y2hSZXN1bHRbMV07XFxuICB2YXIgdGltZVBhdHRlcm4gPSBtYXRjaFJlc3VsdFsyXTtcXG5cXG4gIGlmICghdGltZVBhdHRlcm4pIHtcXG4gICAgcmV0dXJuIGRhdGVMb25nRm9ybWF0dGVyKHBhdHRlcm4sIGZvcm1hdExvbmcsIG9wdGlvbnMpXFxuICB9XFxuXFxuICB2YXIgZGF0ZVRpbWVGb3JtYXQ7XFxuXFxuICBzd2l0Y2ggKGRhdGVQYXR0ZXJuKSB7XFxuICAgIGNhc2UgJ1AnOlxcbiAgICAgIGRhdGVUaW1lRm9ybWF0ID0gZm9ybWF0TG9uZy5kYXRlVGltZSh7d2lkdGg6ICdzaG9ydCd9KTtcXG4gICAgICBicmVha1xcbiAgICBjYXNlICdQUCc6XFxuICAgICAgZGF0ZVRpbWVGb3JtYXQgPSBmb3JtYXRMb25nLmRhdGVUaW1lKHt3aWR0aDogJ21lZGl1bSd9KTtcXG4gICAgICBicmVha1xcbiAgICBjYXNlICdQUFAnOlxcbiAgICAgIGRhdGVUaW1lRm9ybWF0ID0gZm9ybWF0TG9uZy5kYXRlVGltZSh7d2lkdGg6ICdsb25nJ30pO1xcbiAgICAgIGJyZWFrXFxuICAgIGNhc2UgJ1BQUFAnOlxcbiAgICBkZWZhdWx0OlxcbiAgICAgIGRhdGVUaW1lRm9ybWF0ID0gZm9ybWF0TG9uZy5kYXRlVGltZSh7d2lkdGg6ICdmdWxsJ30pO1xcbiAgICAgIGJyZWFrXFxuICB9XFxuXFxuICByZXR1cm4gZGF0ZVRpbWVGb3JtYXRcXG4gICAgLnJlcGxhY2UoJ3t7ZGF0ZX19JywgZGF0ZUxvbmdGb3JtYXR0ZXIoZGF0ZVBhdHRlcm4sIGZvcm1hdExvbmcsIG9wdGlvbnMpKVxcbiAgICAucmVwbGFjZSgne3t0aW1lfX0nLCB0aW1lTG9uZ0Zvcm1hdHRlcih0aW1lUGF0dGVybiwgZm9ybWF0TG9uZywgb3B0aW9ucykpXFxufVxcblxcbnZhciBsb25nRm9ybWF0dGVycyA9IHtcXG4gIHA6IHRpbWVMb25nRm9ybWF0dGVyLFxcbiAgUDogZGF0ZVRpbWVMb25nRm9ybWF0dGVyXFxufTtcXG5cXG4vKipcXG4gKiBAbmFtZSBzdWJNaWxsaXNlY29uZHNcXG4gKiBAY2F0ZWdvcnkgTWlsbGlzZWNvbmQgSGVscGVyc1xcbiAqIEBzdW1tYXJ5IFN1YnRyYWN0IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBnaXZlbiBkYXRlLlxcbiAqXFxuICogQGRlc2NyaXB0aW9uXFxuICogU3VidHJhY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGdpdmVuIGRhdGUuXFxuICpcXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZSAtIHRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gYmUgc3VidHJhY3RlZFxcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIC0gdGhlIG9iamVjdCB3aXRoIG9wdGlvbnMuIFNlZSBbT3B0aW9uc117QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9PcHRpb25zfVxcbiAqIEBwYXJhbSB7MHwxfDJ9IFtvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHM9Ml0gLSBwYXNzZWQgdG8gYHRvRGF0ZWAuIFNlZSBbdG9EYXRlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3RvRGF0ZX1cXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIG5ldyBkYXRlIHdpdGggdGhlIG1pbGxpc2Vjb25kcyBzdWJ0cmFjdGVkXFxuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIG11c3QgYmUgMCwgMSBvciAyXFxuICpcXG4gKiBAZXhhbXBsZVxcbiAqIC8vIFN1YnRyYWN0IDc1MCBtaWxsaXNlY29uZHMgZnJvbSAxMCBKdWx5IDIwMTQgMTI6NDU6MzAuMDAwOlxcbiAqIHZhciByZXN1bHQgPSBzdWJNaWxsaXNlY29uZHMobmV3IERhdGUoMjAxNCwgNiwgMTAsIDEyLCA0NSwgMzAsIDApLCA3NTApXFxuICogLy89PiBUaHUgSnVsIDEwIDIwMTQgMTI6NDU6MjkuMjUwXFxuICovXFxuZnVuY3Rpb24gc3ViTWlsbGlzZWNvbmRzIChkaXJ0eURhdGUsIGRpcnR5QW1vdW50LCBkaXJ0eU9wdGlvbnMpIHtcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxcbiAgfVxcblxcbiAgdmFyIGFtb3VudCA9IHRvSW50ZWdlcihkaXJ0eUFtb3VudCk7XFxuICByZXR1cm4gYWRkTWlsbGlzZWNvbmRzKGRpcnR5RGF0ZSwgLWFtb3VudCwgZGlydHlPcHRpb25zKVxcbn1cXG5cXG52YXIgcHJvdGVjdGVkVG9rZW5zID0gWydEJywgJ0REJywgJ1lZJywgJ1lZWVknXTtcXG5cXG5mdW5jdGlvbiBpc1Byb3RlY3RlZFRva2VuKHRva2VuKSB7XFxuICByZXR1cm4gcHJvdGVjdGVkVG9rZW5zLmluZGV4T2YodG9rZW4pICE9PSAtMVxcbn1cXG5cXG5mdW5jdGlvbiB0aHJvd1Byb3RlY3RlZEVycm9yKHRva2VuKSB7XFxuICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcXG4gICAgJ2BvcHRpb25zLmF3YXJlT2ZVbmljb2RlVG9rZW5zYCBtdXN0IGJlIHNldCB0byBgdHJ1ZWAgdG8gdXNlIGAnICtcXG4gICAgICB0b2tlbiArXFxuICAgICAgJ2AgdG9rZW47IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXInXFxuICApXFxufVxcblxcbi8vIFRoaXMgUmVnRXhwIGNvbnNpc3RzIG9mIHRocmVlIHBhcnRzIHNlcGFyYXRlZCBieSBgfGA6XFxuLy8gLSBbeVlRcU1Md0lkRGVjaWhIS2ttc11vIG1hdGNoZXMgYW55IGF2YWlsYWJsZSBvcmRpbmFsIG51bWJlciB0b2tlblxcbi8vICAgKG9uZSBvZiB0aGUgY2VydGFpbiBsZXR0ZXJzIGZvbGxvd2VkIGJ5IGBvYClcXG4vLyAtIChcXFxcdylcXFxcMSogbWF0Y2hlcyBhbnkgc2VxdWVuY2VzIG9mIHRoZSBzYW1lIGxldHRlclxcbi8vIC0gJycgbWF0Y2hlcyB0d28gcXVvdGUgY2hhcmFjdGVycyBpbiBhIHJvd1xcbi8vIC0gJygnJ3xbXiddKSsoJ3wkKSBtYXRjaGVzIGFueXRoaW5nIHN1cnJvdW5kZWQgYnkgdHdvIHF1b3RlIGNoYXJhY3RlcnMgKCcpLFxcbi8vICAgZXhjZXB0IGEgc2luZ2xlIHF1b3RlIHN5bWJvbCwgd2hpY2ggZW5kcyB0aGUgc2VxdWVuY2UuXFxuLy8gICBUd28gcXVvdGUgY2hhcmFjdGVycyBkbyBub3QgZW5kIHRoZSBzZXF1ZW5jZS5cXG4vLyAgIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHNpbmdsZSBxdW90ZVxcbi8vICAgdGhlbiB0aGUgc2VxdWVuY2Ugd2lsbCBjb250aW51ZSB1bnRpbCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcuXFxuLy8gLSAuIG1hdGNoZXMgYW55IHNpbmdsZSBjaGFyYWN0ZXIgdW5tYXRjaGVkIGJ5IHByZXZpb3VzIHBhcnRzIG9mIHRoZSBSZWdFeHBzXFxudmFyIGZvcm1hdHRpbmdUb2tlbnNSZWdFeHAgPSAvW3lZUXFNTHdJZERlY2loSEtrbXNdb3woXFxcXHcpXFxcXDEqfCcnfCcoJyd8W14nXSkrKCd8JCl8Li9nO1xcblxcbi8vIFRoaXMgUmVnRXhwIGNhdGNoZXMgc3ltYm9scyBlc2NhcGVkIGJ5IHF1b3RlcywgYW5kIGFsc29cXG4vLyBzZXF1ZW5jZXMgb2Ygc3ltYm9scyBQLCBwLCBhbmQgdGhlIGNvbWJpbmF0aW9ucyBsaWtlIGBQUFBQUFBQcHBwcHBgXFxudmFyIGxvbmdGb3JtYXR0aW5nVG9rZW5zUmVnRXhwID0gL1ArcCt8UCt8cCt8Jyd8JygnJ3xbXiddKSsoJ3wkKXwuL2c7XFxuXFxudmFyIGVzY2FwZWRTdHJpbmdSZWdFeHAgPSAvXicoLio/KSc/JC87XFxudmFyIGRvdWJsZVF1b3RlUmVnRXhwID0gLycnL2c7XFxuXFxuLyoqXFxuICogQG5hbWUgZm9ybWF0XFxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXFxuICogQHN1bW1hcnkgRm9ybWF0IHRoZSBkYXRlLlxcbiAqXFxuICogQGRlc2NyaXB0aW9uXFxuICogUmV0dXJuIHRoZSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcgaW4gdGhlIGdpdmVuIGZvcm1hdC4gVGhlIHJlc3VsdCBtYXkgdmFyeSBieSBsb2NhbGUuXFxuICpcXG4gKiA+IOKaoO+4jyBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBgZm9ybWF0YCB0b2tlbnMgZGlmZmVyIGZyb20gTW9tZW50LmpzIGFuZCBvdGhlciBsaWJyYXJpZXMuXFxuICogPiBTZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXFxuICpcXG4gKiBUaGUgY2hhcmFjdGVycyB3cmFwcGVkIGJldHdlZW4gdHdvIHNpbmdsZSBxdW90ZXMgY2hhcmFjdGVycyAoJykgYXJlIGVzY2FwZWQuXFxuICogVHdvIHNpbmdsZSBxdW90ZXMgaW4gYSByb3csIHdoZXRoZXIgaW5zaWRlIG9yIG91dHNpZGUgYSBxdW90ZWQgc2VxdWVuY2UsIHJlcHJlc2VudCBhICdyZWFsJyBzaW5nbGUgcXVvdGUuXFxuICogKHNlZSB0aGUgbGFzdCBleGFtcGxlKVxcbiAqXFxuICogRm9ybWF0IG9mIHRoZSBzdHJpbmcgaXMgYmFzZWQgb24gVW5pY29kZSBUZWNobmljYWwgU3RhbmRhcmQgIzM1OlxcbiAqIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9GaWVsZF9TeW1ib2xfVGFibGVcXG4gKiB3aXRoIGEgZmV3IGFkZGl0aW9ucyAoc2VlIG5vdGUgNyBiZWxvdyB0aGUgdGFibGUpLlxcbiAqXFxuICogQWNjZXB0ZWQgcGF0dGVybnM6XFxuICogfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUGF0dGVybiB8IFJlc3VsdCBleGFtcGxlcyAgICAgICAgICAgICAgICAgICB8IE5vdGVzIHxcXG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tfFxcbiAqIHwgRXJhICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEcuLkdHRyAgfCBBRCwgQkMgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgR0dHRyAgICB8IEFubm8gRG9taW5pLCBCZWZvcmUgQ2hyaXN0ICAgICAgICB8IDIgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBHR0dHRyAgIHwgQSwgQiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgQ2FsZW5kYXIgeWVhciAgICAgICAgICAgICAgICAgICB8IHkgICAgICAgfCA0NCwgMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICAgICAgfCA1ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeW8gICAgICB8IDQ0dGgsIDFzdCwgMHRoLCAxN3RoICAgICAgICAgICAgICB8IDUsNyAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB5eSAgICAgIHwgNDQsIDAxLCAwMCwgMTcgICAgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHl5eSAgICAgfCAwNDQsIDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICAgfCA1ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeXl5eSAgICB8IDAwNDQsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICB8IDUgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB5eXl5eSAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw1ICAgfFxcbiAqIHwgTG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhciAgICAgICB8IFkgICAgICAgfCA0NCwgMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICAgICAgfCA1ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWW8gICAgICB8IDQ0dGgsIDFzdCwgMTkwMHRoLCAyMDE3dGggICAgICAgICB8IDUsNyAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBZWSAgICAgIHwgNDQsIDAxLCAwMCwgMTcgICAgICAgICAgICAgICAgICAgIHwgNSw4ICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFlZWSAgICAgfCAwNDQsIDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICAgfCA1ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWVlZWSAgICB8IDAwNDQsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgICB8IDUsOCAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBZWVlZWSAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw1ICAgfFxcbiAqIHwgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICAgICB8IFIgICAgICAgfCAtNDMsIDAsIDEsIDE5MDAsIDIwMTcgICAgICAgICAgICAgfCA1LDcgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUlIgICAgICB8IC00MywgMDAsIDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICB8IDUsNyAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBSUlIgICAgIHwgLTA0MywgMDAwLCAwMDEsIDE5MDAsIDIwMTcgICAgICAgIHwgNSw3ICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFJSUlIgICAgfCAtMDA0MywgMDAwMCwgMDAwMSwgMTkwMCwgMjAxNyAgICAgfCA1LDcgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUlJSUlIgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMsNSw3IHxcXG4gKiB8IEV4dGVuZGVkIHllYXIgICAgICAgICAgICAgICAgICAgfCB1ICAgICAgIHwgLTQzLCAwLCAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgIHwgNSAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHV1ICAgICAgfCAtNDMsIDAxLCAxOTAwLCAyMDE3ICAgICAgICAgICAgICAgfCA1ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdXV1ICAgICB8IC0wNDMsIDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgICB8IDUgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB1dXV1ICAgIHwgLTAwNDMsIDAwMDEsIDE5MDAsIDIwMTcgICAgICAgICAgIHwgNSAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHV1dXV1ICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAzLDUgICB8XFxuICogfCBRdWFydGVyIChmb3JtYXR0aW5nKSAgICAgICAgICAgIHwgUSAgICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBRbyAgICAgIHwgMXN0LCAybmQsIDNyZCwgNHRoICAgICAgICAgICAgICAgIHwgNyAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFFRICAgICAgfCAwMSwgMDIsIDAzLCAwNCAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUVFRICAgICB8IFExLCBRMiwgUTMsIFE0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBRUVFRICAgIHwgMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi4gICAgIHwgMiAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFFRUVFRICAgfCAxLCAyLCAzLCA0ICAgICAgICAgICAgICAgICAgICAgICAgfCA0ICAgICB8XFxuICogfCBRdWFydGVyIChzdGFuZC1hbG9uZSkgICAgICAgICAgIHwgcSAgICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBxbyAgICAgIHwgMXN0LCAybmQsIDNyZCwgNHRoICAgICAgICAgICAgICAgIHwgNyAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHFxICAgICAgfCAwMSwgMDIsIDAzLCAwNCAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcXFxICAgICB8IFExLCBRMiwgUTMsIFE0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBxcXFxICAgIHwgMXN0IHF1YXJ0ZXIsIDJuZCBxdWFydGVyLCAuLi4gICAgIHwgMiAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHFxcXFxICAgfCAxLCAyLCAzLCA0ICAgICAgICAgICAgICAgICAgICAgICAgfCA0ICAgICB8XFxuICogfCBNb250aCAoZm9ybWF0dGluZykgICAgICAgICAgICAgIHwgTSAgICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBNbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMTJ0aCAgICAgICAgICAgICAgIHwgNyAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE1NICAgICAgfCAwMSwgMDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTU1NICAgICB8IEphbiwgRmViLCAuLi4sIERlYyAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTU1NICAgIHwgSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXIgIHwgMiAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE1NTU1NICAgfCBKLCBGLCAuLi4sIEQgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCBNb250aCAoc3RhbmQtYWxvbmUpICAgICAgICAgICAgIHwgTCAgICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBMbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMTJ0aCAgICAgICAgICAgICAgIHwgNyAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IExMICAgICAgfCAwMSwgMDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTExMICAgICB8IEphbiwgRmViLCAuLi4sIERlYyAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBMTExMICAgIHwgSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXIgIHwgMiAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IExMTExMICAgfCBKLCBGLCAuLi4sIEQgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCBMb2NhbCB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgIHwgdyAgICAgICB8IDEsIDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB3byAgICAgIHwgMXN0LCAybmQsIC4uLiwgNTN0aCAgICAgICAgICAgICAgIHwgNyAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHd3ICAgICAgfCAwMSwgMDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCBJU08gd2VlayBvZiB5ZWFyICAgICAgICAgICAgICAgIHwgSSAgICAgICB8IDEsIDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBJbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgNTN0aCAgICAgICAgICAgICAgIHwgNyAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IElJICAgICAgfCAwMSwgMDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XFxuICogfCBEYXkgb2YgbW9udGggICAgICAgICAgICAgICAgICAgIHwgZCAgICAgICB8IDEsIDIsIC4uLiwgMzEgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBkbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMzFzdCAgICAgICAgICAgICAgIHwgNyAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGRkICAgICAgfCAwMSwgMDIsIC4uLiwgMzEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCBEYXkgb2YgeWVhciAgICAgICAgICAgICAgICAgICAgIHwgRCAgICAgICB8IDEsIDIsIC4uLiwgMzY1LCAzNjYgICAgICAgICAgICAgICB8IDggICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBEbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMzY1dGgsIDM2NnRoICAgICAgIHwgNyAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEREICAgICAgfCAwMSwgMDIsIC4uLiwgMzY1LCAzNjYgICAgICAgICAgICAgfCA4ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgREREICAgICB8IDAwMSwgMDAyLCAuLi4sIDM2NSwgMzY2ICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBEREREICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyAgICAgfFxcbiAqIHwgRGF5IG9mIHdlZWsgKGZvcm1hdHRpbmcpICAgICAgICB8IEUuLkVFRSAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1ICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgRUVFRSAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBFRUVFRSAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEVFRUVFRSAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFN1LCBTYSAgICAgICAgfCAgICAgICB8XFxuICogfCBJU08gZGF5IG9mIHdlZWsgKGZvcm1hdHRpbmcpICAgIHwgaSAgICAgICB8IDEsIDIsIDMsIC4uLiwgNyAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgN3RoICAgICAgICAgICAgICAgIHwgNyAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlpICAgICAgfCAwMSwgMDIsIC4uLiwgMDcgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaWlpICAgICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3UgICAgICAgICAgICB8IDcgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBpaWlpICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiw3ICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlpaWlpICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCA3ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaWlpaWlpICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU3UsIFNhICAgICAgICB8IDcgICAgIHxcXG4gKiB8IExvY2FsIGRheSBvZiB3ZWVrIChmb3JtYXR0aW5nKSAgfCBlICAgICAgIHwgMiwgMywgNCwgLi4uLCAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVvICAgICAgfCAybmQsIDNyZCwgLi4uLCAxc3QgICAgICAgICAgICAgICAgfCA3ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWUgICAgICB8IDAyLCAwMywgLi4uLCAwMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlZWUgICAgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdSAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVlZWUgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWVlZWUgICB8IE0sIFQsIFcsIFQsIEYsIFMsIFMgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlZWVlZWUgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTdSwgU2EgICAgICAgIHwgICAgICAgfFxcbiAqIHwgTG9jYWwgZGF5IG9mIHdlZWsgKHN0YW5kLWFsb25lKSB8IGMgICAgICAgfCAyLCAzLCA0LCAuLi4sIDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY28gICAgICB8IDJuZCwgM3JkLCAuLi4sIDFzdCAgICAgICAgICAgICAgICB8IDcgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjYyAgICAgIHwgMDIsIDAzLCAuLi4sIDAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNjYyAgICAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1ICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2NjYyAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjY2NjYyAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNjY2NjYyAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFN1LCBTYSAgICAgICAgfCAgICAgICB8XFxuICogfCBBTSwgUE0gICAgICAgICAgICAgICAgICAgICAgICAgIHwgYS4uYWFhICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBhYWFhICAgIHwgYS5tLiwgcC5tLiAgICAgICAgICAgICAgICAgICAgICAgIHwgMiAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGFhYWFhICAgfCBhLCBwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCBBTSwgUE0sIG5vb24sIG1pZG5pZ2h0ICAgICAgICAgIHwgYi4uYmJiICB8IEFNLCBQTSwgbm9vbiwgbWlkbmlnaHQgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBiYmJiICAgIHwgYS5tLiwgcC5tLiwgbm9vbiwgbWlkbmlnaHQgICAgICAgIHwgMiAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGJiYmJiICAgfCBhLCBwLCBuLCBtaSAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCBGbGV4aWJsZSBkYXkgcGVyaW9kICAgICAgICAgICAgIHwgQi4uQkJCICB8IGF0IG5pZ2h0LCBpbiB0aGUgbW9ybmluZywgLi4uICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBCQkJCICAgIHwgYXQgbmlnaHQsIGluIHRoZSBtb3JuaW5nLCAuLi4gICAgIHwgMiAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEJCQkJCICAgfCBhdCBuaWdodCwgaW4gdGhlIG1vcm5pbmcsIC4uLiAgICAgfCAgICAgICB8XFxuICogfCBIb3VyIFsxLTEyXSAgICAgICAgICAgICAgICAgICAgIHwgaCAgICAgICB8IDEsIDIsIC4uLiwgMTEsIDEyICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBobyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMTF0aCwgMTJ0aCAgICAgICAgIHwgNyAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGhoICAgICAgfCAwMSwgMDIsIC4uLiwgMTEsIDEyICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCBIb3VyIFswLTIzXSAgICAgICAgICAgICAgICAgICAgIHwgSCAgICAgICB8IDAsIDEsIDIsIC4uLiwgMjMgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBIbyAgICAgIHwgMHRoLCAxc3QsIDJuZCwgLi4uLCAyM3JkICAgICAgICAgIHwgNyAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEhIICAgICAgfCAwMCwgMDEsIDAyLCAuLi4sIDIzICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCBIb3VyIFswLTExXSAgICAgICAgICAgICAgICAgICAgIHwgSyAgICAgICB8IDEsIDIsIC4uLiwgMTEsIDAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBLbyAgICAgIHwgMXN0LCAybmQsIC4uLiwgMTF0aCwgMHRoICAgICAgICAgIHwgNyAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEtLICAgICAgfCAxLCAyLCAuLi4sIDExLCAwICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCBIb3VyIFsxLTI0XSAgICAgICAgICAgICAgICAgICAgIHwgayAgICAgICB8IDI0LCAxLCAyLCAuLi4sIDIzICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBrbyAgICAgIHwgMjR0aCwgMXN0LCAybmQsIC4uLiwgMjNyZCAgICAgICAgIHwgNyAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGtrICAgICAgfCAyNCwgMDEsIDAyLCAuLi4sIDIzICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCBNaW51dGUgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbSAgICAgICB8IDAsIDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBtbyAgICAgIHwgMHRoLCAxc3QsIC4uLiwgNTl0aCAgICAgICAgICAgICAgIHwgNyAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG1tICAgICAgfCAwMCwgMDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCBTZWNvbmQgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcyAgICAgICB8IDAsIDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBzbyAgICAgIHwgMHRoLCAxc3QsIC4uLiwgNTl0aCAgICAgICAgICAgICAgIHwgNyAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHNzICAgICAgfCAwMCwgMDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCBGcmFjdGlvbiBvZiBzZWNvbmQgICAgICAgICAgICAgIHwgUyAgICAgICB8IDAsIDEsIC4uLiwgOSAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBTUyAgICAgIHwgMDAsIDAxLCAuLi4sIDk5ICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFNTUyAgICAgfCAwMDAsIDAwMDEsIC4uLiwgOTk5ICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgU1NTUyAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMgICAgIHxcXG4gKiB8IFRpbWV6b25lIChJU08tODYwMSB3LyBaKSAgICAgICAgfCBYICAgICAgIHwgLTA4LCArMDUzMCwgWiAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFhYICAgICAgfCAtMDgwMCwgKzA1MzAsIFogICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgWFhYICAgICB8IC0wODowMCwgKzA1OjMwLCBaICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBYWFhYICAgIHwgLTA4MDAsICswNTMwLCBaLCArMTIzNDU2ICAgICAgICAgIHwgMiAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFhYWFhYICAgfCAtMDg6MDAsICswNTozMCwgWiwgKzEyOjM0OjU2ICAgICAgfCAgICAgICB8XFxuICogfCBUaW1lem9uZSAoSVNPLTg2MDEgdy9vIFopICAgICAgIHwgeCAgICAgICB8IC0wOCwgKzA1MzAsICswMCAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB4eCAgICAgIHwgLTA4MDAsICswNTMwLCArMDAwMCAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHh4eCAgICAgfCAtMDg6MDAsICswNTozMCwgKzAwOjAwICAgICAgICAgICAgfCAyICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgeHh4eCAgICB8IC0wODAwLCArMDUzMCwgKzAwMDAsICsxMjM0NTYgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB4eHh4eCAgIHwgLTA4OjAwLCArMDU6MzAsICswMDowMCwgKzEyOjM0OjU2IHwgICAgICAgfFxcbiAqIHwgVGltZXpvbmUgKEdNVCkgICAgICAgICAgICAgICAgICB8IE8uLi5PT08gfCBHTVQtOCwgR01UKzU6MzAsIEdNVCswICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgT09PTyAgICB8IEdNVC0wODowMCwgR01UKzA1OjMwLCBHTVQrMDA6MDAgICB8IDIgICAgIHxcXG4gKiB8IFRpbWV6b25lIChzcGVjaWZpYyBub24tbG9jYXQuKSAgfCB6Li4uenp6IHwgR01ULTgsIEdNVCs1OjMwLCBHTVQrMCAgICAgICAgICAgIHwgNiAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHp6enogICAgfCBHTVQtMDg6MDAsIEdNVCswNTozMCwgR01UKzAwOjAwICAgfCAyLDYgICB8XFxuICogfCBTZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICAgICAgIHwgdCAgICAgICB8IDUxMjk2OTUyMCAgICAgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0dCAgICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMyw3ICAgfFxcbiAqIHwgTWlsbGlzZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICB8IFQgICAgICAgfCA1MTI5Njk1MjA5MDAgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgVFQgICAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDMsNyAgIHxcXG4gKiB8IExvbmcgbG9jYWxpemVkIGRhdGUgICAgICAgICAgICAgfCBQICAgICAgIHwgMDUvMjkvMTQ1MyAgICAgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBQICAgICAgfCBNYXkgMjksIDE0NTMgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUFBQICAgICB8IE1heSAyOXRoLCAxNDUzICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQUFBQICAgIHwgU3VuZGF5LCBNYXkgMjl0aCwgMTQ1MyAgICAgICAgICAgIHwgMiw3ICAgfFxcbiAqIHwgTG9uZyBsb2NhbGl6ZWQgdGltZSAgICAgICAgICAgICB8IHAgICAgICAgfCAxMjowMCBBTSAgICAgICAgICAgICAgICAgICAgICAgICAgfCA3ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgcHAgICAgICB8IDEyOjAwOjAwIEFNICAgICAgICAgICAgICAgICAgICAgICB8IDcgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBwcHAgICAgIHwgMTI6MDA6MDAgQU0gR01UKzIgICAgICAgICAgICAgICAgIHwgNyAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHBwcHAgICAgfCAxMjowMDowMCBBTSBHTVQrMDI6MDAgICAgICAgICAgICAgfCAyLDcgICB8XFxuICogfCBDb21iaW5hdGlvbiBvZiBkYXRlIGFuZCB0aW1lICAgIHwgUHAgICAgICB8IDA1LzI5LzE0NTMsIDEyOjAwIEFNICAgICAgICAgICAgICB8IDcgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBQUHBwICAgIHwgTWF5IDI5LCAxNDUzLCAxMjowMDowMCBBTSAgICAgICAgIHwgNyAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFBQUHBwcCAgfCBNYXkgMjl0aCwgMTQ1MyBhdCAuLi4gICAgICAgICAgICAgfCA3ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgUFBQUHBwcHB8IFN1bmRheSwgTWF5IDI5dGgsIDE0NTMgYXQgLi4uICAgICB8IDIsNyAgIHxcXG4gKiBOb3RlczpcXG4gKiAxLiBcXFwiRm9ybWF0dGluZ1xcXCIgdW5pdHMgKGUuZy4gZm9ybWF0dGluZyBxdWFydGVyKSBpbiB0aGUgZGVmYXVsdCBlbi1VUyBsb2NhbGVcXG4gKiAgICBhcmUgdGhlIHNhbWUgYXMgXFxcInN0YW5kLWFsb25lXFxcIiB1bml0cywgYnV0IGFyZSBkaWZmZXJlbnQgaW4gc29tZSBsYW5ndWFnZXMuXFxuICogICAgXFxcIkZvcm1hdHRpbmdcXFwiIHVuaXRzIGFyZSBkZWNsaW5lZCBhY2NvcmRpbmcgdG8gdGhlIHJ1bGVzIG9mIHRoZSBsYW5ndWFnZVxcbiAqICAgIGluIHRoZSBjb250ZXh0IG9mIGEgZGF0ZS4gXFxcIlN0YW5kLWFsb25lXFxcIiB1bml0cyBhcmUgYWx3YXlzIG5vbWluYXRpdmUgc2luZ3VsYXI6XFxuICpcXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ2RvIExMTEwnLCB7bG9jYWxlOiBjc30pIC8vPT4gJzYuIGxpc3RvcGFkJ2BcXG4gKlxcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAnZG8gTU1NTScsIHtsb2NhbGU6IGNzfSkgLy89PiAnNi4gbGlzdG9wYWR1J2BcXG4gKlxcbiAqIDIuIEFueSBzZXF1ZW5jZSBvZiB0aGUgaWRlbnRpY2FsIGxldHRlcnMgaXMgYSBwYXR0ZXJuLCB1bmxlc3MgaXQgaXMgZXNjYXBlZCBieVxcbiAqICAgIHRoZSBzaW5nbGUgcXVvdGUgY2hhcmFjdGVycyAoc2VlIGJlbG93KS5cXG4gKiAgICBJZiB0aGUgc2VxdWVuY2UgaXMgbG9uZ2VyIHRoYW4gbGlzdGVkIGluIHRhYmxlIChlLmcuIGBFRUVFRUVFRUVFRWApXFxuICogICAgdGhlIG91dHB1dCB3aWxsIGJlIHRoZSBzYW1lIGFzIGRlZmF1bHQgcGF0dGVybiBmb3IgdGhpcyB1bml0LCB1c3VhbGx5XFxuICogICAgdGhlIGxvbmdlc3Qgb25lIChpbiBjYXNlIG9mIElTTyB3ZWVrZGF5cywgYEVFRUVgKS4gRGVmYXVsdCBwYXR0ZXJucyBmb3IgdW5pdHNcXG4gKiAgICBhcmUgbWFya2VkIHdpdGggXFxcIjJcXFwiIGluIHRoZSBsYXN0IGNvbHVtbiBvZiB0aGUgdGFibGUuXFxuICpcXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTScpIC8vPT4gJ05vdidgXFxuICpcXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTU0nKSAvLz0+ICdOb3ZlbWJlcidgXFxuICpcXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTU1NJykgLy89PiAnTidgXFxuICpcXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ01NTU1NTScpIC8vPT4gJ05vdmVtYmVyJ2BcXG4gKlxcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAnTU1NTU1NTScpIC8vPT4gJ05vdmVtYmVyJ2BcXG4gKlxcbiAqIDMuIFNvbWUgcGF0dGVybnMgY291bGQgYmUgdW5saW1pdGVkIGxlbmd0aCAoc3VjaCBhcyBgeXl5eXl5eXlgKS5cXG4gKiAgICBUaGUgb3V0cHV0IHdpbGwgYmUgcGFkZGVkIHdpdGggemVyb3MgdG8gbWF0Y2ggdGhlIGxlbmd0aCBvZiB0aGUgcGF0dGVybi5cXG4gKlxcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAneXl5eXl5eXknKSAvLz0+ICcwMDAwMjAxNydgXFxuICpcXG4gKiA0LiBgUVFRUVFgIGFuZCBgcXFxcXFgIGNvdWxkIGJlIG5vdCBzdHJpY3RseSBudW1lcmljYWwgaW4gc29tZSBsb2NhbGVzLlxcbiAqICAgIFRoZXNlIHRva2VucyByZXByZXNlbnQgdGhlIHNob3J0ZXN0IGZvcm0gb2YgdGhlIHF1YXJ0ZXIuXFxuICpcXG4gKiA1LiBUaGUgbWFpbiBkaWZmZXJlbmNlIGJldHdlZW4gYHlgIGFuZCBgdWAgcGF0dGVybnMgYXJlIEIuQy4geWVhcnM6XFxuICpcXG4gKiAgICB8IFllYXIgfCBgeWAgfCBgdWAgfFxcbiAqICAgIHwtLS0tLS18LS0tLS18LS0tLS18XFxuICogICAgfCBBQyAxIHwgICAxIHwgICAxIHxcXG4gKiAgICB8IEJDIDEgfCAgIDEgfCAgIDAgfFxcbiAqICAgIHwgQkMgMiB8ICAgMiB8ICAtMSB8XFxuICpcXG4gKiAgICBBbHNvIGB5eWAgYWx3YXlzIHJldHVybnMgdGhlIGxhc3QgdHdvIGRpZ2l0cyBvZiBhIHllYXIsXFxuICogICAgd2hpbGUgYHV1YCBwYWRzIHNpbmdsZSBkaWdpdCB5ZWFycyB0byAyIGNoYXJhY3RlcnMgYW5kIHJldHVybnMgb3RoZXIgeWVhcnMgdW5jaGFuZ2VkOlxcbiAqXFxuICogICAgfCBZZWFyIHwgYHl5YCB8IGB1dWAgfFxcbiAqICAgIHwtLS0tLS18LS0tLS0tfC0tLS0tLXxcXG4gKiAgICB8IDEgICAgfCAgIDAxIHwgICAwMSB8XFxuICogICAgfCAxNCAgIHwgICAxNCB8ICAgMTQgfFxcbiAqICAgIHwgMzc2ICB8ICAgNzYgfCAgMzc2IHxcXG4gKiAgICB8IDE0NTMgfCAgIDUzIHwgMTQ1MyB8XFxuICpcXG4gKiAgICBUaGUgc2FtZSBkaWZmZXJlbmNlIGlzIHRydWUgZm9yIGxvY2FsIGFuZCBJU08gd2Vlay1udW1iZXJpbmcgeWVhcnMgKGBZYCBhbmQgYFJgKSxcXG4gKiAgICBleGNlcHQgbG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhcnMgYXJlIGRlcGVuZGVudCBvbiBgb3B0aW9ucy53ZWVrU3RhcnRzT25gXFxuICogICAgYW5kIGBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZWAgKGNvbXBhcmUgW2dldElTT1dlZWtZZWFyXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL2dldElTT1dlZWtZZWFyfVxcbiAqICAgIGFuZCBbZ2V0V2Vla1llYXJde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvZ2V0V2Vla1llYXJ9KS5cXG4gKlxcbiAqIDYuIFNwZWNpZmljIG5vbi1sb2NhdGlvbiB0aW1lem9uZXMgYXJlIGN1cnJlbnRseSB1bmF2YWlsYWJsZSBpbiBgZGF0ZS1mbnNgLFxcbiAqICAgIHNvIHJpZ2h0IG5vdyB0aGVzZSB0b2tlbnMgZmFsbCBiYWNrIHRvIEdNVCB0aW1lem9uZXMuXFxuICpcXG4gKiA3LiBUaGVzZSBwYXR0ZXJucyBhcmUgbm90IGluIHRoZSBVbmljb2RlIFRlY2huaWNhbCBTdGFuZGFyZCAjMzU6XFxuICogICAgLSBgaWA6IElTTyBkYXkgb2Ygd2Vla1xcbiAqICAgIC0gYElgOiBJU08gd2VlayBvZiB5ZWFyXFxuICogICAgLSBgUmA6IElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyXFxuICogICAgLSBgdGA6IHNlY29uZHMgdGltZXN0YW1wXFxuICogICAgLSBgVGA6IG1pbGxpc2Vjb25kcyB0aW1lc3RhbXBcXG4gKiAgICAtIGBvYDogb3JkaW5hbCBudW1iZXIgbW9kaWZpZXJcXG4gKiAgICAtIGBQYDogbG9uZyBsb2NhbGl6ZWQgZGF0ZVxcbiAqICAgIC0gYHBgOiBsb25nIGxvY2FsaXplZCB0aW1lXFxuICpcXG4gKiA4LiBUaGVzZSB0b2tlbnMgYXJlIG9mdGVuIGNvbmZ1c2VkIHdpdGggb3RoZXJzLiBTZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXFxuICpcXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZSAtIHRoZSBvcmlnaW5hbCBkYXRlXFxuICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdCAtIHRoZSBzdHJpbmcgb2YgdG9rZW5zXFxuICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gLSB0aGUgb2JqZWN0IHdpdGggb3B0aW9ucy4gU2VlIFtPcHRpb25zXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL09wdGlvbnN9XFxuICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHBhc3NlZCB0byBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxcbiAqIEBwYXJhbSB7MHwxfDJ8M3w0fDV8Nn0gW29wdGlvbnMud2Vla1N0YXJ0c09uPTBdIC0gdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgKDAgLSBTdW5kYXkpXFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZT0xXSAtIHRoZSBkYXkgb2YgSmFudWFyeSwgd2hpY2ggaXNcXG4gKiBAcGFyYW0ge0xvY2FsZX0gW29wdGlvbnMubG9jYWxlPWRlZmF1bHRMb2NhbGVdIC0gdGhlIGxvY2FsZSBvYmplY3QuIFNlZSBbTG9jYWxlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL0xvY2FsZX1cXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF3YXJlT2ZVbmljb2RlVG9rZW5zPWZhbHNlXSAtIGlmIHRydWUsIGFsbG93cyB1c2FnZSBvZiBVbmljb2RlIHRva2VucyBjYXVzZXMgY29uZnVzaW9uOlxcbiAqICAgLSBTb21lIG9mIHRoZSBkYXkgb2YgeWVhciB0b2tlbnMgKGBEYCwgYEREYCkgdGhhdCBhcmUgY29uZnVzZWQgd2l0aCB0aGUgZGF5IG9mIG1vbnRoIHRva2VucyAoYGRgLCBgZGRgKS5cXG4gKiAgIC0gU29tZSBvZiB0aGUgbG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhciB0b2tlbnMgKGBZWWAsIGBZWVlZYCkgdGhhdCBhcmUgY29uZnVzZWQgd2l0aCB0aGUgY2FsZW5kYXIgeWVhciB0b2tlbnMgKGB5eWAsIGB5eXl5YCkuXFxuICogICBTZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXFxuICogQHJldHVybnMge1N0cmluZ30gdGhlIGZvcm1hdHRlZCBkYXRlIHN0cmluZ1xcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmxvY2FsZWAgbXVzdCBjb250YWluIGBsb2NhbGl6ZWAgcHJvcGVydHlcXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5sb2NhbGVgIG11c3QgY29udGFpbiBgZm9ybWF0TG9uZ2AgcHJvcGVydHlcXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy53ZWVrU3RhcnRzT25gIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA2XFxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlYCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgN1xcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmF3YXJlT2ZVbmljb2RlVG9rZW5zYCBtdXN0IGJlIHNldCB0byBgdHJ1ZWAgdG8gdXNlIGBYWGAgdG9rZW47IHNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcXG4gKlxcbiAqIEBleGFtcGxlXFxuICogLy8gUmVwcmVzZW50IDExIEZlYnJ1YXJ5IDIwMTQgaW4gbWlkZGxlLWVuZGlhbiBmb3JtYXQ6XFxuICogdmFyIHJlc3VsdCA9IGZvcm1hdChcXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDEsIDExKSxcXG4gKiAgICdNTS9kZC95eXl5J1xcbiAqIClcXG4gKiAvLz0+ICcwMi8xMS8yMDE0J1xcbiAqXFxuICogQGV4YW1wbGVcXG4gKiAvLyBSZXByZXNlbnQgMiBKdWx5IDIwMTQgaW4gRXNwZXJhbnRvOlxcbiAqIGltcG9ydCB7IGVvTG9jYWxlIH0gZnJvbSAnZGF0ZS1mbnMvbG9jYWxlL2VvJ1xcbiAqIHZhciByZXN1bHQgPSBmb3JtYXQoXFxuICogICBuZXcgRGF0ZSgyMDE0LCA2LCAyKSxcXG4gKiAgIFxcXCJkbyAnZGUnIE1NTU0geXl5eVxcXCIsXFxuICogICB7bG9jYWxlOiBlb0xvY2FsZX1cXG4gKiApXFxuICogLy89PiAnMi1hIGRlIGp1bGlvIDIwMTQnXFxuICpcXG4gKiBAZXhhbXBsZVxcbiAqIC8vIEVzY2FwZSBzdHJpbmcgYnkgc2luZ2xlIHF1b3RlIGNoYXJhY3RlcnM6XFxuICogdmFyIHJlc3VsdCA9IGZvcm1hdChcXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDYsIDIsIDE1KSxcXG4gKiAgIFxcXCJoICdvJydjbG9jaydcXFwiXFxuICogKVxcbiAqIC8vPT4gXFxcIjMgbydjbG9ja1xcXCJcXG4gKi9cXG5mdW5jdGlvbiBmb3JtYXQoZGlydHlEYXRlLCBkaXJ0eUZvcm1hdFN0ciwgZGlydHlPcHRpb25zKSB7XFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXG4gICAgICAnMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50J1xcbiAgICApXFxuICB9XFxuXFxuICB2YXIgZm9ybWF0U3RyID0gU3RyaW5nKGRpcnR5Rm9ybWF0U3RyKTtcXG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xcblxcbiAgdmFyIGxvY2FsZSA9IG9wdGlvbnMubG9jYWxlIHx8IGxvY2FsZSQxO1xcblxcbiAgdmFyIGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9XFxuICAgIGxvY2FsZS5vcHRpb25zICYmIGxvY2FsZS5vcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZTtcXG4gIHZhciBkZWZhdWx0Rmlyc3RXZWVrQ29udGFpbnNEYXRlID1cXG4gICAgbG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlID09IG51bGxcXG4gICAgICA/IDFcXG4gICAgICA6IHRvSW50ZWdlcihsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUpO1xcbiAgdmFyIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9XFxuICAgIG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlID09IG51bGxcXG4gICAgICA/IGRlZmF1bHRGaXJzdFdlZWtDb250YWluc0RhdGVcXG4gICAgICA6IHRvSW50ZWdlcihvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XFxuXFxuICAvLyBUZXN0IGlmIHdlZWtTdGFydHNPbiBpcyBiZXR3ZWVuIDEgYW5kIDcgX2FuZF8gaXMgbm90IE5hTlxcbiAgaWYgKCEoZmlyc3RXZWVrQ29udGFpbnNEYXRlID49IDEgJiYgZmlyc3RXZWVrQ29udGFpbnNEYXRlIDw9IDcpKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxcbiAgICAgICdmaXJzdFdlZWtDb250YWluc0RhdGUgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDcgaW5jbHVzaXZlbHknXFxuICAgIClcXG4gIH1cXG5cXG4gIHZhciBsb2NhbGVXZWVrU3RhcnRzT24gPSBsb2NhbGUub3B0aW9ucyAmJiBsb2NhbGUub3B0aW9ucy53ZWVrU3RhcnRzT247XFxuICB2YXIgZGVmYXVsdFdlZWtTdGFydHNPbiA9XFxuICAgIGxvY2FsZVdlZWtTdGFydHNPbiA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihsb2NhbGVXZWVrU3RhcnRzT24pO1xcbiAgdmFyIHdlZWtTdGFydHNPbiA9XFxuICAgIG9wdGlvbnMud2Vla1N0YXJ0c09uID09IG51bGxcXG4gICAgICA/IGRlZmF1bHRXZWVrU3RhcnRzT25cXG4gICAgICA6IHRvSW50ZWdlcihvcHRpb25zLndlZWtTdGFydHNPbik7XFxuXFxuICAvLyBUZXN0IGlmIHdlZWtTdGFydHNPbiBpcyBiZXR3ZWVuIDAgYW5kIDYgX2FuZF8gaXMgbm90IE5hTlxcbiAgaWYgKCEod2Vla1N0YXJ0c09uID49IDAgJiYgd2Vla1N0YXJ0c09uIDw9IDYpKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd3ZWVrU3RhcnRzT24gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYgaW5jbHVzaXZlbHknKVxcbiAgfVxcblxcbiAgaWYgKCFsb2NhbGUubG9jYWxpemUpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2xvY2FsZSBtdXN0IGNvbnRhaW4gbG9jYWxpemUgcHJvcGVydHknKVxcbiAgfVxcblxcbiAgaWYgKCFsb2NhbGUuZm9ybWF0TG9uZykge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbG9jYWxlIG11c3QgY29udGFpbiBmb3JtYXRMb25nIHByb3BlcnR5JylcXG4gIH1cXG5cXG4gIHZhciBvcmlnaW5hbERhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBvcHRpb25zKTtcXG5cXG4gIGlmICghaXNWYWxpZChvcmlnaW5hbERhdGUsIG9wdGlvbnMpKSB7XFxuICAgIHJldHVybiAnSW52YWxpZCBEYXRlJ1xcbiAgfVxcblxcbiAgLy8gQ29udmVydCB0aGUgZGF0ZSBpbiBzeXN0ZW0gdGltZXpvbmUgdG8gdGhlIHNhbWUgZGF0ZSBpbiBVVEMrMDA6MDAgdGltZXpvbmUuXFxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB3aGVuIFVUQyBmdW5jdGlvbnMgd2lsbCBiZSBpbXBsZW1lbnRlZCwgbG9jYWxlcyB3aWxsIGJlIGNvbXBhdGlibGUgd2l0aCB0aGVtLlxcbiAgLy8gU2VlIGFuIGlzc3VlIGFib3V0IFVUQyBmdW5jdGlvbnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XFxuICB2YXIgdGltZXpvbmVPZmZzZXQgPSBnZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzKG9yaWdpbmFsRGF0ZSk7XFxuICB2YXIgdXRjRGF0ZSA9IHN1Yk1pbGxpc2Vjb25kcyhvcmlnaW5hbERhdGUsIHRpbWV6b25lT2Zmc2V0LCBvcHRpb25zKTtcXG5cXG4gIHZhciBmb3JtYXR0ZXJPcHRpb25zID0ge1xcbiAgICBmaXJzdFdlZWtDb250YWluc0RhdGU6IGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSxcXG4gICAgd2Vla1N0YXJ0c09uOiB3ZWVrU3RhcnRzT24sXFxuICAgIGxvY2FsZTogbG9jYWxlLFxcbiAgICBfb3JpZ2luYWxEYXRlOiBvcmlnaW5hbERhdGVcXG4gIH07XFxuXFxuICB2YXIgcmVzdWx0ID0gZm9ybWF0U3RyXFxuICAgIC5tYXRjaChsb25nRm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cClcXG4gICAgLm1hcChmdW5jdGlvbihzdWJzdHJpbmcpIHtcXG4gICAgICB2YXIgZmlyc3RDaGFyYWN0ZXIgPSBzdWJzdHJpbmdbMF07XFxuICAgICAgaWYgKGZpcnN0Q2hhcmFjdGVyID09PSAncCcgfHwgZmlyc3RDaGFyYWN0ZXIgPT09ICdQJykge1xcbiAgICAgICAgdmFyIGxvbmdGb3JtYXR0ZXIgPSBsb25nRm9ybWF0dGVyc1tmaXJzdENoYXJhY3Rlcl07XFxuICAgICAgICByZXR1cm4gbG9uZ0Zvcm1hdHRlcihzdWJzdHJpbmcsIGxvY2FsZS5mb3JtYXRMb25nLCBmb3JtYXR0ZXJPcHRpb25zKVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gc3Vic3RyaW5nXFxuICAgIH0pXFxuICAgIC5qb2luKCcnKVxcbiAgICAubWF0Y2goZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cClcXG4gICAgLm1hcChmdW5jdGlvbihzdWJzdHJpbmcpIHtcXG4gICAgICAvLyBSZXBsYWNlIHR3byBzaW5nbGUgcXVvdGUgY2hhcmFjdGVycyB3aXRoIG9uZSBzaW5nbGUgcXVvdGUgY2hhcmFjdGVyXFxuICAgICAgaWYgKHN1YnN0cmluZyA9PT0gXFxcIicnXFxcIikge1xcbiAgICAgICAgcmV0dXJuIFxcXCInXFxcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgZmlyc3RDaGFyYWN0ZXIgPSBzdWJzdHJpbmdbMF07XFxuICAgICAgaWYgKGZpcnN0Q2hhcmFjdGVyID09PSBcXFwiJ1xcXCIpIHtcXG4gICAgICAgIHJldHVybiBjbGVhbkVzY2FwZWRTdHJpbmcoc3Vic3RyaW5nKVxcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgZm9ybWF0dGVyID0gZm9ybWF0dGVyc1tmaXJzdENoYXJhY3Rlcl07XFxuICAgICAgaWYgKGZvcm1hdHRlcikge1xcbiAgICAgICAgaWYgKCFvcHRpb25zLmF3YXJlT2ZVbmljb2RlVG9rZW5zICYmIGlzUHJvdGVjdGVkVG9rZW4oc3Vic3RyaW5nKSkge1xcbiAgICAgICAgICB0aHJvd1Byb3RlY3RlZEVycm9yKHN1YnN0cmluZyk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyKHV0Y0RhdGUsIHN1YnN0cmluZywgbG9jYWxlLmxvY2FsaXplLCBmb3JtYXR0ZXJPcHRpb25zKVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gc3Vic3RyaW5nXFxuICAgIH0pXFxuICAgIC5qb2luKCcnKTtcXG5cXG4gIHJldHVybiByZXN1bHRcXG59XFxuXFxuZnVuY3Rpb24gY2xlYW5Fc2NhcGVkU3RyaW5nKGlucHV0KSB7XFxuICByZXR1cm4gaW5wdXQubWF0Y2goZXNjYXBlZFN0cmluZ1JlZ0V4cClbMV0ucmVwbGFjZShkb3VibGVRdW90ZVJlZ0V4cCwgXFxcIidcXFwiKVxcbn1cXG5cXG4vKipcXG4gKiBAbmFtZSBpc0FmdGVyXFxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXFxuICogQHN1bW1hcnkgSXMgdGhlIGZpcnN0IGRhdGUgYWZ0ZXIgdGhlIHNlY29uZCBvbmU/XFxuICpcXG4gKiBAZGVzY3JpcHRpb25cXG4gKiBJcyB0aGUgZmlyc3QgZGF0ZSBhZnRlciB0aGUgc2Vjb25kIG9uZT9cXG4gKlxcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdGhhdCBzaG91bGQgYmUgYWZ0ZXIgdGhlIG90aGVyIG9uZSB0byByZXR1cm4gdHJ1ZVxcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlVG9Db21wYXJlIC0gdGhlIGRhdGUgdG8gY29tcGFyZSB3aXRoXFxuICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gLSB0aGUgb2JqZWN0IHdpdGggb3B0aW9ucy4gU2VlIFtPcHRpb25zXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL09wdGlvbnN9XFxuICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHBhc3NlZCB0byBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0aGUgZmlyc3QgZGF0ZSBpcyBhZnRlciB0aGUgc2Vjb25kIGRhdGVcXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXFxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0c2AgbXVzdCBiZSAwLCAxIG9yIDJcXG4gKlxcbiAqIEBleGFtcGxlXFxuICogLy8gSXMgMTAgSnVseSAxOTg5IGFmdGVyIDExIEZlYnJ1YXJ5IDE5ODc/XFxuICogdmFyIHJlc3VsdCA9IGlzQWZ0ZXIobmV3IERhdGUoMTk4OSwgNiwgMTApLCBuZXcgRGF0ZSgxOTg3LCAxLCAxMSkpXFxuICogLy89PiB0cnVlXFxuICovXFxuZnVuY3Rpb24gaXNBZnRlciAoZGlydHlEYXRlLCBkaXJ0eURhdGVUb0NvbXBhcmUsIGRpcnR5T3B0aW9ucykge1xcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpXFxuICB9XFxuXFxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XFxuICB2YXIgZGF0ZVRvQ29tcGFyZSA9IHRvRGF0ZShkaXJ0eURhdGVUb0NvbXBhcmUsIGRpcnR5T3B0aW9ucyk7XFxuICByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgPiBkYXRlVG9Db21wYXJlLmdldFRpbWUoKVxcbn1cXG5cXG4vKipcXG4gKiBAbmFtZSBpc0JlZm9yZVxcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xcbiAqIEBzdW1tYXJ5IElzIHRoZSBmaXJzdCBkYXRlIGJlZm9yZSB0aGUgc2Vjb25kIG9uZT9cXG4gKlxcbiAqIEBkZXNjcmlwdGlvblxcbiAqIElzIHRoZSBmaXJzdCBkYXRlIGJlZm9yZSB0aGUgc2Vjb25kIG9uZT9cXG4gKlxcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdGhhdCBzaG91bGQgYmUgYmVmb3JlIHRoZSBvdGhlciBvbmUgdG8gcmV0dXJuIHRydWVcXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZVRvQ29tcGFyZSAtIHRoZSBkYXRlIHRvIGNvbXBhcmUgd2l0aFxcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIC0gdGhlIG9iamVjdCB3aXRoIG9wdGlvbnMuIFNlZSBbT3B0aW9uc117QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9PcHRpb25zfVxcbiAqIEBwYXJhbSB7MHwxfDJ9IFtvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHM9Ml0gLSBwYXNzZWQgdG8gYHRvRGF0ZWAuIFNlZSBbdG9EYXRlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3RvRGF0ZX1cXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdGhlIGZpcnN0IGRhdGUgaXMgYmVmb3JlIHRoZSBzZWNvbmQgZGF0ZVxcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxcbiAqXFxuICogQGV4YW1wbGVcXG4gKiAvLyBJcyAxMCBKdWx5IDE5ODkgYmVmb3JlIDExIEZlYnJ1YXJ5IDE5ODc/XFxuICogdmFyIHJlc3VsdCA9IGlzQmVmb3JlKG5ldyBEYXRlKDE5ODksIDYsIDEwKSwgbmV3IERhdGUoMTk4NywgMSwgMTEpKVxcbiAqIC8vPT4gZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc0JlZm9yZSAoZGlydHlEYXRlLCBkaXJ0eURhdGVUb0NvbXBhcmUsIGRpcnR5T3B0aW9ucykge1xcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpXFxuICB9XFxuXFxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XFxuICB2YXIgZGF0ZVRvQ29tcGFyZSA9IHRvRGF0ZShkaXJ0eURhdGVUb0NvbXBhcmUsIGRpcnR5T3B0aW9ucyk7XFxuICByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgPCBkYXRlVG9Db21wYXJlLmdldFRpbWUoKVxcbn1cXG5cXG4vKipcXG4gKiBAbmFtZSBpc0RhdGVcXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcXG4gKiBAc3VtbWFyeSBJcyB0aGUgZ2l2ZW4gdmFsdWUgYSBkYXRlP1xcbiAqXFxuICogQGRlc2NyaXB0aW9uXFxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiBEYXRlLiBUaGUgZnVuY3Rpb24gd29ya3MgZm9yIGRhdGVzIHRyYW5zZmVycmVkIGFjcm9zcyBpZnJhbWVzLlxcbiAqXFxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBjaGVja1xcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIC0gdGhlIG9iamVjdCB3aXRoIG9wdGlvbnMuIFVudXNlZDsgcHJlc2VudCBmb3IgRlAgc3VibW9kdWxlIGNvbXBhdGliaWxpdHkgc2FrZS4gU2VlIFtPcHRpb25zXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL09wdGlvbnN9XFxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgZGF0ZVxcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMSBhcmd1bWVudHMgcmVxdWlyZWRcXG4gKlxcbiAqIEBleGFtcGxlXFxuICogLy8gRm9yIGEgdmFsaWQgZGF0ZTpcXG4gKiB2YXIgcmVzdWx0ID0gaXNEYXRlKG5ldyBEYXRlKCkpXFxuICogLy89PiB0cnVlXFxuICpcXG4gKiBAZXhhbXBsZVxcbiAqIC8vIEZvciBhbiBpbnZhbGlkIGRhdGU6XFxuICogdmFyIHJlc3VsdCA9IGlzRGF0ZShuZXcgRGF0ZShOYU4pKVxcbiAqIC8vPT4gdHJ1ZVxcbiAqXFxuICogQGV4YW1wbGVcXG4gKiAvLyBGb3Igc29tZSB2YWx1ZTpcXG4gKiB2YXIgcmVzdWx0ID0gaXNEYXRlKCcyMDE0LTAyLTMxJylcXG4gKiAvLz0+IGZhbHNlXFxuICpcXG4gKiBAZXhhbXBsZVxcbiAqIC8vIEZvciBhbiBvYmplY3Q6XFxuICogdmFyIHJlc3VsdCA9IGlzRGF0ZSh7fSlcXG4gKiAvLz0+IGZhbHNlXFxuICovXFxuXFxuLyoqXFxuICogQG5hbWUgaXNFcXVhbFxcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xcbiAqIEBzdW1tYXJ5IEFyZSB0aGUgZ2l2ZW4gZGF0ZXMgZXF1YWw/XFxuICpcXG4gKiBAZGVzY3JpcHRpb25cXG4gKiBBcmUgdGhlIGdpdmVuIGRhdGVzIGVxdWFsP1xcbiAqXFxuICogQHBhcmFtIHtEYXRlfFN0cmluZ3xOdW1iZXJ9IGRhdGVMZWZ0IC0gdGhlIGZpcnN0IGRhdGUgdG8gY29tcGFyZVxcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlUmlnaHQgLSB0aGUgc2Vjb25kIGRhdGUgdG8gY29tcGFyZVxcbiAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIC0gdGhlIG9iamVjdCB3aXRoIG9wdGlvbnMuIFNlZSBbT3B0aW9uc117QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9PcHRpb25zfVxcbiAqIEBwYXJhbSB7MHwxfDJ9IFtvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHM9Ml0gLSBwYXNzZWQgdG8gYHRvRGF0ZWAuIFNlZSBbdG9EYXRlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3RvRGF0ZX1cXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdGhlIGRhdGVzIGFyZSBlcXVhbFxcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxcbiAqXFxuICogQGV4YW1wbGVcXG4gKiAvLyBBcmUgMiBKdWx5IDIwMTQgMDY6MzA6NDUuMDAwIGFuZCAyIEp1bHkgMjAxNCAwNjozMDo0NS41MDAgZXF1YWw/XFxuICogdmFyIHJlc3VsdCA9IGlzRXF1YWwoXFxuICogICBuZXcgRGF0ZSgyMDE0LCA2LCAyLCA2LCAzMCwgNDUsIDApXFxuICogICBuZXcgRGF0ZSgyMDE0LCA2LCAyLCA2LCAzMCwgNDUsIDUwMClcXG4gKiApXFxuICogLy89PiBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzRXF1YWwkMSAoZGlydHlMZWZ0RGF0ZSwgZGlydHlSaWdodERhdGUsIGRpcnR5T3B0aW9ucykge1xcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpXFxuICB9XFxuXFxuICB2YXIgZGF0ZUxlZnQgPSB0b0RhdGUoZGlydHlMZWZ0RGF0ZSwgZGlydHlPcHRpb25zKTtcXG4gIHZhciBkYXRlUmlnaHQgPSB0b0RhdGUoZGlydHlSaWdodERhdGUsIGRpcnR5T3B0aW9ucyk7XFxuICByZXR1cm4gZGF0ZUxlZnQuZ2V0VGltZSgpID09PSBkYXRlUmlnaHQuZ2V0VGltZSgpXFxufVxcblxcbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxcbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcXG5mdW5jdGlvbiBzZXRVVENEYXkgKGRpcnR5RGF0ZSwgZGlydHlEYXksIGRpcnR5T3B0aW9ucykge1xcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpXFxuICB9XFxuXFxuICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fTtcXG4gIHZhciBsb2NhbGUgPSBvcHRpb25zLmxvY2FsZTtcXG4gIHZhciBsb2NhbGVXZWVrU3RhcnRzT24gPSBsb2NhbGUgJiYgbG9jYWxlLm9wdGlvbnMgJiYgbG9jYWxlLm9wdGlvbnMud2Vla1N0YXJ0c09uO1xcbiAgdmFyIGRlZmF1bHRXZWVrU3RhcnRzT24gPSBsb2NhbGVXZWVrU3RhcnRzT24gPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIobG9jYWxlV2Vla1N0YXJ0c09uKTtcXG4gIHZhciB3ZWVrU3RhcnRzT24gPSBvcHRpb25zLndlZWtTdGFydHNPbiA9PSBudWxsID8gZGVmYXVsdFdlZWtTdGFydHNPbiA6IHRvSW50ZWdlcihvcHRpb25zLndlZWtTdGFydHNPbik7XFxuXFxuICAvLyBUZXN0IGlmIHdlZWtTdGFydHNPbiBpcyBiZXR3ZWVuIDAgYW5kIDYgX2FuZF8gaXMgbm90IE5hTlxcbiAgaWYgKCEod2Vla1N0YXJ0c09uID49IDAgJiYgd2Vla1N0YXJ0c09uIDw9IDYpKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd3ZWVrU3RhcnRzT24gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYgaW5jbHVzaXZlbHknKVxcbiAgfVxcblxcbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBkaXJ0eU9wdGlvbnMpO1xcbiAgdmFyIGRheSA9IHRvSW50ZWdlcihkaXJ0eURheSk7XFxuXFxuICB2YXIgY3VycmVudERheSA9IGRhdGUuZ2V0VVRDRGF5KCk7XFxuXFxuICB2YXIgcmVtYWluZGVyID0gZGF5ICUgNztcXG4gIHZhciBkYXlJbmRleCA9IChyZW1haW5kZXIgKyA3KSAlIDc7XFxuXFxuICB2YXIgZGlmZiA9IChkYXlJbmRleCA8IHdlZWtTdGFydHNPbiA/IDcgOiAwKSArIGRheSAtIGN1cnJlbnREYXk7XFxuXFxuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBkaWZmKTtcXG4gIHJldHVybiBkYXRlXFxufVxcblxcbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxcbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcXG5mdW5jdGlvbiBzZXRVVENXZWVrIChkaXJ0eURhdGUsIGRpcnR5V2VlaywgZGlydHlPcHRpb25zKSB7XFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50JylcXG4gIH1cXG5cXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKTtcXG4gIHZhciB3ZWVrID0gdG9JbnRlZ2VyKGRpcnR5V2Vlayk7XFxuICB2YXIgZGlmZiA9IGdldFVUQ1dlZWsoZGF0ZSwgZGlydHlPcHRpb25zKSAtIHdlZWs7XFxuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSBkaWZmICogNyk7XFxuICByZXR1cm4gZGF0ZVxcbn1cXG5cXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgYSBwYXJ0IG9mIHB1YmxpYyBBUEkgd2hlbiBVVEMgZnVuY3Rpb24gd2lsbCBiZSBpbXBsZW1lbnRlZC5cXG4vLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzc2XFxuZnVuY3Rpb24gc2V0VVRDSVNPRGF5IChkaXJ0eURhdGUsIGRpcnR5RGF5LCBkaXJ0eU9wdGlvbnMpIHtcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKVxcbiAgfVxcblxcbiAgdmFyIGRheSA9IHRvSW50ZWdlcihkaXJ0eURheSk7XFxuXFxuICBpZiAoZGF5ICUgNyA9PT0gMCkge1xcbiAgICBkYXkgPSBkYXkgLSA3O1xcbiAgfVxcblxcbiAgdmFyIHdlZWtTdGFydHNPbiA9IDE7XFxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucyk7XFxuICB2YXIgY3VycmVudERheSA9IGRhdGUuZ2V0VVRDRGF5KCk7XFxuXFxuICB2YXIgcmVtYWluZGVyID0gZGF5ICUgNztcXG4gIHZhciBkYXlJbmRleCA9IChyZW1haW5kZXIgKyA3KSAlIDc7XFxuXFxuICB2YXIgZGlmZiA9IChkYXlJbmRleCA8IHdlZWtTdGFydHNPbiA/IDcgOiAwKSArIGRheSAtIGN1cnJlbnREYXk7XFxuXFxuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBkaWZmKTtcXG4gIHJldHVybiBkYXRlXFxufVxcblxcbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBhIHBhcnQgb2YgcHVibGljIEFQSSB3aGVuIFVUQyBmdW5jdGlvbiB3aWxsIGJlIGltcGxlbWVudGVkLlxcbi8vIFNlZSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2lzc3Vlcy8zNzZcXG5mdW5jdGlvbiBzZXRVVENJU09XZWVrIChkaXJ0eURhdGUsIGRpcnR5SVNPV2VlaywgZGlydHlPcHRpb25zKSB7XFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50JylcXG4gIH1cXG5cXG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSwgZGlydHlPcHRpb25zKTtcXG4gIHZhciBpc29XZWVrID0gdG9JbnRlZ2VyKGRpcnR5SVNPV2Vlayk7XFxuICB2YXIgZGlmZiA9IGdldFVUQ0lTT1dlZWsoZGF0ZSwgZGlydHlPcHRpb25zKSAtIGlzb1dlZWs7XFxuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSBkaWZmICogNyk7XFxuICByZXR1cm4gZGF0ZVxcbn1cXG5cXG52YXIgTUlMTElTRUNPTkRTX0lOX0hPVVIkMSA9IDM2MDAwMDA7XFxudmFyIE1JTExJU0VDT05EU19JTl9NSU5VVEUkMiA9IDYwMDAwO1xcbnZhciBNSUxMSVNFQ09ORFNfSU5fU0VDT05EID0gMTAwMDtcXG5cXG52YXIgbnVtZXJpY1BhdHRlcm5zID0ge1xcbiAgbW9udGg6IC9eKDFbMC0yXXwwP1xcXFxkKS8sIC8vIDAgdG8gMTJcXG4gIGRhdGU6IC9eKDNbMC0xXXxbMC0yXT9cXFxcZCkvLCAvLyAwIHRvIDMxXFxuICBkYXlPZlllYXI6IC9eKDM2WzAtNl18M1swLTVdXFxcXGR8WzAtMl0/XFxcXGQ/XFxcXGQpLywgLy8gMCB0byAzNjZcXG4gIHdlZWs6IC9eKDVbMC0zXXxbMC00XT9cXFxcZCkvLCAvLyAwIHRvIDUzXFxuICBob3VyMjNoOiAvXigyWzAtM118WzAtMV0/XFxcXGQpLywgLy8gMCB0byAyM1xcbiAgaG91cjI0aDogL14oMlswLTRdfFswLTFdP1xcXFxkKS8sIC8vIDAgdG8gMjRcXG4gIGhvdXIxMWg6IC9eKDFbMC0xXXwwP1xcXFxkKS8sIC8vIDAgdG8gMTFcXG4gIGhvdXIxMmg6IC9eKDFbMC0yXXwwP1xcXFxkKS8sIC8vIDAgdG8gMTJcXG4gIG1pbnV0ZTogL15bMC01XT9cXFxcZC8sIC8vIDAgdG8gNTlcXG4gIHNlY29uZDogL15bMC01XT9cXFxcZC8sIC8vIDAgdG8gNTlcXG5cXG4gIHNpbmdsZURpZ2l0OiAvXlxcXFxkLywgLy8gMCB0byA5XFxuICB0d29EaWdpdHM6IC9eXFxcXGR7MSwyfS8sIC8vIDAgdG8gOTlcXG4gIHRocmVlRGlnaXRzOiAvXlxcXFxkezEsM30vLCAvLyAwIHRvIDk5OVxcbiAgZm91ckRpZ2l0czogL15cXFxcZHsxLDR9LywgLy8gMCB0byA5OTk5XFxuXFxuICBhbnlEaWdpdHNTaWduZWQ6IC9eLT9cXFxcZCsvLFxcbiAgc2luZ2xlRGlnaXRTaWduZWQ6IC9eLT9cXFxcZC8sIC8vIDAgdG8gOSwgLTAgdG8gLTlcXG4gIHR3b0RpZ2l0c1NpZ25lZDogL14tP1xcXFxkezEsMn0vLCAvLyAwIHRvIDk5LCAtMCB0byAtOTlcXG4gIHRocmVlRGlnaXRzU2lnbmVkOiAvXi0/XFxcXGR7MSwzfS8sIC8vIDAgdG8gOTk5LCAtMCB0byAtOTk5XFxuICBmb3VyRGlnaXRzU2lnbmVkOiAvXi0/XFxcXGR7MSw0fS8gLy8gMCB0byA5OTk5LCAtMCB0byAtOTk5OVxcbn07XFxuXFxudmFyIHRpbWV6b25lUGF0dGVybnMgPSB7XFxuICBiYXNpY09wdGlvbmFsTWludXRlczogL14oWystXSkoXFxcXGR7Mn0pKFxcXFxkezJ9KT98Wi8sXFxuICBiYXNpYzogL14oWystXSkoXFxcXGR7Mn0pKFxcXFxkezJ9KXxaLyxcXG4gIGJhc2ljT3B0aW9uYWxTZWNvbmRzOiAvXihbKy1dKShcXFxcZHsyfSkoXFxcXGR7Mn0pKChcXFxcZHsyfSkpP3xaLyxcXG4gIGV4dGVuZGVkOiAvXihbKy1dKShcXFxcZHsyfSk6KFxcXFxkezJ9KXxaLyxcXG4gIGV4dGVuZGVkT3B0aW9uYWxTZWNvbmRzOiAvXihbKy1dKShcXFxcZHsyfSk6KFxcXFxkezJ9KSg6KFxcXFxkezJ9KSk/fFovXFxufTtcXG5cXG5mdW5jdGlvbiBwYXJzZU51bWVyaWNQYXR0ZXJuIChwYXR0ZXJuLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spIHtcXG4gIHZhciBtYXRjaFJlc3VsdCA9IHN0cmluZy5tYXRjaChwYXR0ZXJuKTtcXG5cXG4gIGlmICghbWF0Y2hSZXN1bHQpIHtcXG4gICAgcmV0dXJuIG51bGxcXG4gIH1cXG5cXG4gIHZhciB2YWx1ZSA9IHBhcnNlSW50KG1hdGNoUmVzdWx0WzBdLCAxMCk7XFxuXFxuICByZXR1cm4ge1xcbiAgICB2YWx1ZTogdmFsdWVDYWxsYmFjayA/IHZhbHVlQ2FsbGJhY2sodmFsdWUpIDogdmFsdWUsXFxuICAgIHJlc3Q6IHN0cmluZy5zbGljZShtYXRjaFJlc3VsdFswXS5sZW5ndGgpXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHBhcnNlVGltZXpvbmVQYXR0ZXJuIChwYXR0ZXJuLCBzdHJpbmcpIHtcXG4gIHZhciBtYXRjaFJlc3VsdCA9IHN0cmluZy5tYXRjaChwYXR0ZXJuKTtcXG5cXG4gIGlmICghbWF0Y2hSZXN1bHQpIHtcXG4gICAgcmV0dXJuIG51bGxcXG4gIH1cXG5cXG4gIC8vIElucHV0IGlzICdaJ1xcbiAgaWYgKG1hdGNoUmVzdWx0WzBdID09PSAnWicpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICB2YWx1ZTogMCxcXG4gICAgICByZXN0OiBzdHJpbmcuc2xpY2UoMSlcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIHNpZ24gPSBtYXRjaFJlc3VsdFsxXSA9PT0gJysnID8gMSA6IC0xO1xcbiAgdmFyIGhvdXJzID0gbWF0Y2hSZXN1bHRbMl0gPyBwYXJzZUludChtYXRjaFJlc3VsdFsyXSwgMTApIDogMDtcXG4gIHZhciBtaW51dGVzID0gbWF0Y2hSZXN1bHRbM10gPyBwYXJzZUludChtYXRjaFJlc3VsdFszXSwgMTApIDogMDtcXG4gIHZhciBzZWNvbmRzID0gbWF0Y2hSZXN1bHRbNV0gPyBwYXJzZUludChtYXRjaFJlc3VsdFs1XSwgMTApIDogMDtcXG5cXG4gIHJldHVybiB7XFxuICAgIHZhbHVlOiBzaWduICogKFxcbiAgICAgIGhvdXJzICogTUlMTElTRUNPTkRTX0lOX0hPVVIkMSArXFxuICAgICAgICBtaW51dGVzICogTUlMTElTRUNPTkRTX0lOX01JTlVURSQyICtcXG4gICAgICAgIHNlY29uZHMgKiBNSUxMSVNFQ09ORFNfSU5fU0VDT05EXFxuICAgICksXFxuICAgIHJlc3Q6IHN0cmluZy5zbGljZShtYXRjaFJlc3VsdFswXS5sZW5ndGgpXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHBhcnNlQW55RGlnaXRzU2lnbmVkIChzdHJpbmcsIHZhbHVlQ2FsbGJhY2spIHtcXG4gIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5hbnlEaWdpdHNTaWduZWQsIHN0cmluZywgdmFsdWVDYWxsYmFjaylcXG59XFxuXFxuZnVuY3Rpb24gcGFyc2VORGlnaXRzIChuLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spIHtcXG4gIHN3aXRjaCAobikge1xcbiAgICBjYXNlIDE6XFxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLnNpbmdsZURpZ2l0LCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spXFxuICAgIGNhc2UgMjpcXG4gICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMudHdvRGlnaXRzLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spXFxuICAgIGNhc2UgMzpcXG4gICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMudGhyZWVEaWdpdHMsIHN0cmluZywgdmFsdWVDYWxsYmFjaylcXG4gICAgY2FzZSA0OlxcbiAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5mb3VyRGlnaXRzLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spXFxuICAgIGRlZmF1bHQ6XFxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obmV3IFJlZ0V4cCgnXlxcXFxcXFxcZHsxLCcgKyBuICsgJ30nKSwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBwYXJzZU5EaWdpdHNTaWduZWQgKG4sIHN0cmluZywgdmFsdWVDYWxsYmFjaykge1xcbiAgc3dpdGNoIChuKSB7XFxuICAgIGNhc2UgMTpcXG4gICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMuc2luZ2xlRGlnaXRTaWduZWQsIHN0cmluZywgdmFsdWVDYWxsYmFjaylcXG4gICAgY2FzZSAyOlxcbiAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy50d29EaWdpdHNTaWduZWQsIHN0cmluZywgdmFsdWVDYWxsYmFjaylcXG4gICAgY2FzZSAzOlxcbiAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy50aHJlZURpZ2l0c1NpZ25lZCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKVxcbiAgICBjYXNlIDQ6XFxuICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLmZvdXJEaWdpdHNTaWduZWQsIHN0cmluZywgdmFsdWVDYWxsYmFjaylcXG4gICAgZGVmYXVsdDpcXG4gICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihuZXcgUmVnRXhwKCdeLT9cXFxcXFxcXGR7MSwnICsgbiArICd9JyksIHN0cmluZywgdmFsdWVDYWxsYmFjaylcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZGF5UGVyaW9kRW51bVRvSG91cnMgKGVudW1WYWx1ZSkge1xcbiAgc3dpdGNoIChlbnVtVmFsdWUpIHtcXG4gICAgY2FzZSAnbW9ybmluZyc6XFxuICAgICAgcmV0dXJuIDRcXG4gICAgY2FzZSAnZXZlbmluZyc6XFxuICAgICAgcmV0dXJuIDE3XFxuICAgIGNhc2UgJ3BtJzpcXG4gICAgY2FzZSAnbm9vbic6XFxuICAgIGNhc2UgJ2FmdGVybm9vbic6XFxuICAgICAgcmV0dXJuIDEyXFxuICAgIGNhc2UgJ2FtJzpcXG4gICAgY2FzZSAnbWlkbmlnaHQnOlxcbiAgICBjYXNlICduaWdodCc6XFxuICAgIGRlZmF1bHQ6XFxuICAgICAgcmV0dXJuIDBcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gbm9ybWFsaXplVHdvRGlnaXRZZWFyICh0d29EaWdpdFllYXIsIGN1cnJlbnRZZWFyKSB7XFxuICB2YXIgaXNDb21tb25FcmEgPSBjdXJyZW50WWVhciA+IDA7XFxuICAvLyBBYnNvbHV0ZSBudW1iZXIgb2YgdGhlIGN1cnJlbnQgeWVhcjpcXG4gIC8vIDEgLT4gMSBBQ1xcbiAgLy8gMCAtPiAxIEJDXFxuICAvLyAtMSAtPiAyIEJDXFxuICB2YXIgYWJzQ3VycmVudFllYXIgPSBpc0NvbW1vbkVyYSA/IGN1cnJlbnRZZWFyIDogMSAtIGN1cnJlbnRZZWFyO1xcblxcbiAgdmFyIHJlc3VsdDtcXG4gIGlmIChhYnNDdXJyZW50WWVhciA8PSA1MCkge1xcbiAgICByZXN1bHQgPSB0d29EaWdpdFllYXIgfHwgMTAwO1xcbiAgfSBlbHNlIHtcXG4gICAgdmFyIHJhbmdlRW5kID0gYWJzQ3VycmVudFllYXIgKyA1MDtcXG4gICAgdmFyIHJhbmdlRW5kQ2VudHVyeSA9IE1hdGguZmxvb3IocmFuZ2VFbmQgLyAxMDApICogMTAwO1xcbiAgICB2YXIgaXNQcmV2aW91c0NlbnR1cnkgPSB0d29EaWdpdFllYXIgPj0gcmFuZ2VFbmQgJSAxMDA7XFxuICAgIHJlc3VsdCA9IHR3b0RpZ2l0WWVhciArIHJhbmdlRW5kQ2VudHVyeSAtIChpc1ByZXZpb3VzQ2VudHVyeSA/IDEwMCA6IDApO1xcbiAgfVxcblxcbiAgcmV0dXJuIGlzQ29tbW9uRXJhID8gcmVzdWx0IDogMSAtIHJlc3VsdFxcbn1cXG5cXG52YXIgREFZU19JTl9NT05USCQxID0gWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xcbnZhciBEQVlTX0lOX01PTlRIX0xFQVBfWUVBUiQxID0gWzMxLCAyOSwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xcblxcbi8vIFVzZXIgZm9yIHZhbGlkYXRpb25cXG5mdW5jdGlvbiBpc0xlYXBZZWFySW5kZXgkMSAoeWVhcikge1xcbiAgcmV0dXJuIHllYXIgJSA0MDAgPT09IDAgfHwgKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApXFxufVxcblxcbi8qXFxuICogfCAgICAgfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBVbml0ICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxcbiAqIHwtLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcXG4gKiB8ICBhICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICB8ICBBKiB8IE1pbGxpc2Vjb25kcyBpbiBkYXkgICAgICAgICAgICB8XFxuICogfCAgYiAgfCBBTSwgUE0sIG5vb24sIG1pZG5pZ2h0ICAgICAgICAgfCAgQiAgfCBGbGV4aWJsZSBkYXkgcGVyaW9kICAgICAgICAgICAgfFxcbiAqIHwgIGMgIHwgU3RhbmQtYWxvbmUgbG9jYWwgZGF5IG9mIHdlZWsgIHwgIEMqIHwgTG9jYWxpemVkIGhvdXIgdy8gZGF5IHBlcmlvZCAgIHxcXG4gKiB8ICBkICB8IERheSBvZiBtb250aCAgICAgICAgICAgICAgICAgICB8ICBEICB8IERheSBvZiB5ZWFyICAgICAgICAgICAgICAgICAgICB8XFxuICogfCAgZSAgfCBMb2NhbCBkYXkgb2Ygd2VlayAgICAgICAgICAgICAgfCAgRSAgfCBEYXkgb2Ygd2VlayAgICAgICAgICAgICAgICAgICAgfFxcbiAqIHwgIGYgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIEYqIHwgRGF5IG9mIHdlZWsgaW4gbW9udGggICAgICAgICAgIHxcXG4gKiB8ICBnKiB8IE1vZGlmaWVkIEp1bGlhbiBkYXkgICAgICAgICAgICB8ICBHICB8IEVyYSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XFxuICogfCAgaCAgfCBIb3VyIFsxLTEyXSAgICAgICAgICAgICAgICAgICAgfCAgSCAgfCBIb3VyIFswLTIzXSAgICAgICAgICAgICAgICAgICAgfFxcbiAqIHwgIGkhIHwgSVNPIGRheSBvZiB3ZWVrICAgICAgICAgICAgICAgIHwgIEkhIHwgSVNPIHdlZWsgb2YgeWVhciAgICAgICAgICAgICAgIHxcXG4gKiB8ICBqKiB8IExvY2FsaXplZCBob3VyIHcvIGRheSBwZXJpb2QgICB8ICBKKiB8IExvY2FsaXplZCBob3VyIHcvbyBkYXkgcGVyaW9kICB8XFxuICogfCAgayAgfCBIb3VyIFsxLTI0XSAgICAgICAgICAgICAgICAgICAgfCAgSyAgfCBIb3VyIFswLTExXSAgICAgICAgICAgICAgICAgICAgfFxcbiAqIHwgIGwqIHwgKGRlcHJlY2F0ZWQpICAgICAgICAgICAgICAgICAgIHwgIEwgIHwgU3RhbmQtYWxvbmUgbW9udGggICAgICAgICAgICAgIHxcXG4gKiB8ICBtICB8IE1pbnV0ZSAgICAgICAgICAgICAgICAgICAgICAgICB8ICBNICB8IE1vbnRoICAgICAgICAgICAgICAgICAgICAgICAgICB8XFxuICogfCAgbiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgTiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxcbiAqIHwgIG8hIHwgT3JkaW5hbCBudW1iZXIgbW9kaWZpZXIgICAgICAgIHwgIE8qIHwgVGltZXpvbmUgKEdNVCkgICAgICAgICAgICAgICAgIHxcXG4gKiB8ICBwICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBQICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XFxuICogfCAgcSAgfCBTdGFuZC1hbG9uZSBxdWFydGVyICAgICAgICAgICAgfCAgUSAgfCBRdWFydGVyICAgICAgICAgICAgICAgICAgICAgICAgfFxcbiAqIHwgIHIqIHwgUmVsYXRlZCBHcmVnb3JpYW4geWVhciAgICAgICAgIHwgIFIhIHwgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICAgIHxcXG4gKiB8ICBzICB8IFNlY29uZCAgICAgICAgICAgICAgICAgICAgICAgICB8ICBTICB8IEZyYWN0aW9uIG9mIHNlY29uZCAgICAgICAgICAgICB8XFxuICogfCAgdCEgfCBTZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICAgICAgfCAgVCEgfCBNaWxsaXNlY29uZHMgdGltZXN0YW1wICAgICAgICAgfFxcbiAqIHwgIHUgIHwgRXh0ZW5kZWQgeWVhciAgICAgICAgICAgICAgICAgIHwgIFUqIHwgQ3ljbGljIHllYXIgICAgICAgICAgICAgICAgICAgIHxcXG4gKiB8ICB2KiB8IFRpbWV6b25lIChnZW5lcmljIG5vbi1sb2NhdC4pICB8ICBWKiB8IFRpbWV6b25lIChsb2NhdGlvbikgICAgICAgICAgICB8XFxuICogfCAgdyAgfCBMb2NhbCB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgfCAgVyogfCBXZWVrIG9mIG1vbnRoICAgICAgICAgICAgICAgICAgfFxcbiAqIHwgIHggIHwgVGltZXpvbmUgKElTTy04NjAxIHcvbyBaKSAgICAgIHwgIFggIHwgVGltZXpvbmUgKElTTy04NjAxKSAgICAgICAgICAgIHxcXG4gKiB8ICB5ICB8IFllYXIgKGFicykgICAgICAgICAgICAgICAgICAgICB8ICBZICB8IExvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIgICAgICB8XFxuICogfCAgeiogfCBUaW1lem9uZSAoc3BlY2lmaWMgbm9uLWxvY2F0LikgfCAgWiogfCBUaW1lem9uZSAoYWxpYXNlcykgICAgICAgICAgICAgfFxcbiAqXFxuICogTGV0dGVycyBtYXJrZWQgYnkgKiBhcmUgbm90IGltcGxlbWVudGVkIGJ1dCByZXNlcnZlZCBieSBVbmljb2RlIHN0YW5kYXJkLlxcbiAqXFxuICogTGV0dGVycyBtYXJrZWQgYnkgISBhcmUgbm9uLXN0YW5kYXJkLCBidXQgaW1wbGVtZW50ZWQgYnkgZGF0ZS1mbnM6XFxuICogLSBgb2AgbW9kaWZpZXMgdGhlIHByZXZpb3VzIHRva2VuIHRvIHR1cm4gaXQgaW50byBhbiBvcmRpbmFsIChzZWUgYHBhcnNlYCBkb2NzKVxcbiAqIC0gYGlgIGlzIElTTyBkYXkgb2Ygd2Vlay4gRm9yIGBpYCBhbmQgYGlpYCBpcyByZXR1cm5zIG51bWVyaWMgSVNPIHdlZWsgZGF5cyxcXG4gKiAgIGkuZS4gNyBmb3IgU3VuZGF5LCAxIGZvciBNb25kYXksIGV0Yy5cXG4gKiAtIGBJYCBpcyBJU08gd2VlayBvZiB5ZWFyLCBhcyBvcHBvc2VkIHRvIGB3YCB3aGljaCBpcyBsb2NhbCB3ZWVrIG9mIHllYXIuXFxuICogLSBgUmAgaXMgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIsIGFzIG9wcG9zZWQgdG8gYFlgIHdoaWNoIGlzIGxvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIuXFxuICogICBgUmAgaXMgc3VwcG9zZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBJYCBhbmQgYGlgXFxuICogICBmb3IgdW5pdmVyc2FsIElTTyB3ZWVrLW51bWJlcmluZyBkYXRlLCB3aGVyZWFzXFxuICogICBgWWAgaXMgc3VwcG9zZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGB3YCBhbmQgYGVgXFxuICogICBmb3Igd2Vlay1udW1iZXJpbmcgZGF0ZSBzcGVjaWZpYyB0byB0aGUgbG9jYWxlLlxcbiAqL1xcbnZhciBwYXJzZXJzID0ge1xcbiAgLy8gRXJhXFxuICBHOiB7XFxuICAgIHByaW9yaXR5OiAxNDAsXFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIG9wdGlvbnMpIHtcXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XFxuICAgICAgICAvLyBBRCwgQkNcXG4gICAgICAgIGNhc2UgJ0cnOlxcbiAgICAgICAgY2FzZSAnR0cnOlxcbiAgICAgICAgY2FzZSAnR0dHJzpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmVyYShzdHJpbmcsIHt3aWR0aDogJ2FiYnJldmlhdGVkJ30pIHx8XFxuICAgICAgICAgICAgbWF0Y2guZXJhKHN0cmluZywge3dpZHRoOiAnbmFycm93J30pXFxuICAgICAgICAvLyBBLCBCXFxuICAgICAgICBjYXNlICdHR0dHRyc6XFxuICAgICAgICAgIHJldHVybiBtYXRjaC5lcmEoc3RyaW5nLCB7d2lkdGg6ICduYXJyb3cnfSlcXG4gICAgICAgIC8vIEFubm8gRG9taW5pLCBCZWZvcmUgQ2hyaXN0XFxuICAgICAgICBjYXNlICdHR0dHJzpcXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIHJldHVybiBtYXRjaC5lcmEoc3RyaW5nLCB7d2lkdGg6ICd3aWRlJ30pIHx8XFxuICAgICAgICAgICAgbWF0Y2guZXJhKHN0cmluZywge3dpZHRoOiAnYWJicmV2aWF0ZWQnfSkgfHxcXG4gICAgICAgICAgICBtYXRjaC5lcmEoc3RyaW5nLCB7d2lkdGg6ICduYXJyb3cnfSlcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgLy8gU2V0cyB5ZWFyIDEwIEJDIGlmIEJDLCBvciAxMCBBQyBpZiBBQ1xcbiAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIodmFsdWUgPT09IDEgPyAxMCA6IC05LCAwLCAxKTtcXG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xcbiAgICAgIHJldHVybiBkYXRlXFxuICAgIH1cXG4gIH0sXFxuXFxuICAvLyBZZWFyXFxuICB5OiB7XFxuICAgIC8vIEZyb20gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS0zMS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9Gb3JtYXRfUGF0dGVybnNcXG4gICAgLy8gfCBZZWFyICAgICB8ICAgICB5IHwgeXkgfCAgIHl5eSB8ICB5eXl5IHwgeXl5eXkgfFxcbiAgICAvLyB8LS0tLS0tLS0tLXwtLS0tLS0tfC0tLS18LS0tLS0tLXwtLS0tLS0tfC0tLS0tLS18XFxuICAgIC8vIHwgQUQgMSAgICAgfCAgICAgMSB8IDAxIHwgICAwMDEgfCAgMDAwMSB8IDAwMDAxIHxcXG4gICAgLy8gfCBBRCAxMiAgICB8ICAgIDEyIHwgMTIgfCAgIDAxMiB8ICAwMDEyIHwgMDAwMTIgfFxcbiAgICAvLyB8IEFEIDEyMyAgIHwgICAxMjMgfCAyMyB8ICAgMTIzIHwgIDAxMjMgfCAwMDEyMyB8XFxuICAgIC8vIHwgQUQgMTIzNCAgfCAgMTIzNCB8IDM0IHwgIDEyMzQgfCAgMTIzNCB8IDAxMjM0IHxcXG4gICAgLy8gfCBBRCAxMjM0NSB8IDEyMzQ1IHwgNDUgfCAxMjM0NSB8IDEyMzQ1IHwgMTIzNDUgfFxcblxcbiAgICBwcmlvcml0eTogMTMwLFxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBvcHRpb25zKSB7XFxuICAgICAgdmFyIHZhbHVlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoeWVhcikge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgeWVhcjogeWVhcixcXG4gICAgICAgICAgaXNUd29EaWdpdFllYXI6IHRva2VuID09PSAneXknXFxuICAgICAgICB9XFxuICAgICAgfTtcXG5cXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XFxuICAgICAgICBjYXNlICd5JzpcXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyg0LCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spXFxuICAgICAgICBjYXNlICd5byc6XFxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge3VuaXQ6ICd5ZWFyJywgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja30pXFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChkYXRlLCB2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgIHJldHVybiB2YWx1ZS5pc1R3b0RpZ2l0WWVhciB8fCB2YWx1ZS55ZWFyID4gMFxcbiAgICB9LFxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCB2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgIHZhciBjdXJyZW50WWVhciA9IGdldFVUQ1dlZWtZZWFyKGRhdGUsIG9wdGlvbnMpO1xcblxcbiAgICAgIGlmICh2YWx1ZS5pc1R3b0RpZ2l0WWVhcikge1xcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRUd29EaWdpdFllYXIgPSBub3JtYWxpemVUd29EaWdpdFllYXIodmFsdWUueWVhciwgY3VycmVudFllYXIpO1xcbiAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcihub3JtYWxpemVkVHdvRGlnaXRZZWFyLCAwLCAxKTtcXG4gICAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XFxuICAgICAgICByZXR1cm4gZGF0ZVxcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgeWVhciA9IGN1cnJlbnRZZWFyID4gMCA/IHZhbHVlLnllYXIgOiAxIC0gdmFsdWUueWVhcjtcXG4gICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIDEpO1xcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XFxuICAgICAgcmV0dXJuIGRhdGVcXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8vIExvY2FsIHdlZWstbnVtYmVyaW5nIHllYXJcXG4gIFk6IHtcXG4gICAgcHJpb3JpdHk6IDEzMCxcXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgb3B0aW9ucykge1xcbiAgICAgIHZhciB2YWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKHllYXIpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIHllYXI6IHllYXIsXFxuICAgICAgICAgIGlzVHdvRGlnaXRZZWFyOiB0b2tlbiA9PT0gJ1lZJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgc3dpdGNoICh0b2tlbikge1xcbiAgICAgICAgY2FzZSAnWSc6XFxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHMoNCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKVxcbiAgICAgICAgY2FzZSAnWW8nOlxcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHt1bml0OiAneWVhcicsIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2t9KVxcbiAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZywgdmFsdWVDYWxsYmFjaylcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgICByZXR1cm4gdmFsdWUuaXNUd29EaWdpdFllYXIgfHwgdmFsdWUueWVhciA+IDBcXG4gICAgfSxcXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgICB2YXIgY3VycmVudFllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XFxuXFxuICAgICAgaWYgKHZhbHVlLmlzVHdvRGlnaXRZZWFyKSB7XFxuICAgICAgICB2YXIgbm9ybWFsaXplZFR3b0RpZ2l0WWVhciA9IG5vcm1hbGl6ZVR3b0RpZ2l0WWVhcih2YWx1ZS55ZWFyLCBjdXJyZW50WWVhcik7XFxuICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKG5vcm1hbGl6ZWRUd29EaWdpdFllYXIsIDAsIG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlKTtcXG4gICAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XFxuICAgICAgICByZXR1cm4gc3RhcnRPZlVUQ1dlZWsoZGF0ZSwgb3B0aW9ucylcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHllYXIgPSBjdXJyZW50WWVhciA+IDAgPyB2YWx1ZS55ZWFyIDogMSAtIHZhbHVlLnllYXI7XFxuICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyLCAwLCBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XFxuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcXG4gICAgICByZXR1cm4gc3RhcnRPZlVUQ1dlZWsoZGF0ZSwgb3B0aW9ucylcXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8vIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyXFxuICBSOiB7XFxuICAgIHByaW9yaXR5OiAxMzAsXFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIG9wdGlvbnMpIHtcXG4gICAgICBpZiAodG9rZW4gPT09ICdSJykge1xcbiAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0c1NpZ25lZCg0LCBzdHJpbmcpXFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBwYXJzZU5EaWdpdHNTaWduZWQodG9rZW4ubGVuZ3RoLCBzdHJpbmcpXFxuICAgIH0sXFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgdmFyIGZpcnN0V2Vla09mWWVhciA9IG5ldyBEYXRlKDApO1xcbiAgICAgIGZpcnN0V2Vla09mWWVhci5zZXRVVENGdWxsWWVhcih2YWx1ZSwgMCwgNCk7XFxuICAgICAgZmlyc3RXZWVrT2ZZZWFyLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xcbiAgICAgIHJldHVybiBzdGFydE9mVVRDSVNPV2VlayhmaXJzdFdlZWtPZlllYXIpXFxuICAgIH1cXG4gIH0sXFxuXFxuICAvLyBFeHRlbmRlZCB5ZWFyXFxuICB1OiB7XFxuICAgIHByaW9yaXR5OiAxMzAsXFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIG9wdGlvbnMpIHtcXG4gICAgICBpZiAodG9rZW4gPT09ICd1Jykge1xcbiAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0c1NpZ25lZCg0LCBzdHJpbmcpXFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBwYXJzZU5EaWdpdHNTaWduZWQodG9rZW4ubGVuZ3RoLCBzdHJpbmcpXFxuICAgIH0sXFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih2YWx1ZSwgMCwgMSk7XFxuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcXG4gICAgICByZXR1cm4gZGF0ZVxcbiAgICB9XFxuICB9LFxcblxcbiAgLy8gUXVhcnRlclxcbiAgUToge1xcbiAgICBwcmlvcml0eTogMTIwLFxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBvcHRpb25zKSB7XFxuICAgICAgc3dpdGNoICh0b2tlbikge1xcbiAgICAgICAgLy8gMSwgMiwgMywgNFxcbiAgICAgICAgY2FzZSAnUSc6XFxuICAgICAgICBjYXNlICdRUSc6IC8vIDAxLCAwMiwgMDMsIDA0XFxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpXFxuICAgICAgICAvLyAxc3QsIDJuZCwgM3JkLCA0dGhcXG4gICAgICAgIGNhc2UgJ1FvJzpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7dW5pdDogJ3F1YXJ0ZXInfSlcXG4gICAgICAgIC8vIFExLCBRMiwgUTMsIFE0XFxuICAgICAgICBjYXNlICdRUVEnOlxcbiAgICAgICAgICByZXR1cm4gbWF0Y2gucXVhcnRlcihzdHJpbmcsIHt3aWR0aDogJ2FiYnJldmlhdGVkJywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSkgfHxcXG4gICAgICAgICAgICBtYXRjaC5xdWFydGVyKHN0cmluZywge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgICAgIC8vIDEsIDIsIDMsIDQgKG5hcnJvdyBxdWFydGVyOyBjb3VsZCBiZSBub3QgbnVtZXJpY2FsKVxcbiAgICAgICAgY2FzZSAnUVFRUVEnOlxcbiAgICAgICAgICByZXR1cm4gbWF0Y2gucXVhcnRlcihzdHJpbmcsIHt3aWR0aDogJ25hcnJvdycsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pXFxuICAgICAgICAvLyAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLlxcbiAgICAgICAgY2FzZSAnUVFRUSc6XFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICByZXR1cm4gbWF0Y2gucXVhcnRlcihzdHJpbmcsIHt3aWR0aDogJ3dpZGUnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KSB8fFxcbiAgICAgICAgICAgIG1hdGNoLnF1YXJ0ZXIoc3RyaW5nLCB7d2lkdGg6ICdhYmJyZXZpYXRlZCcsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pIHx8XFxuICAgICAgICAgICAgbWF0Y2gucXVhcnRlcihzdHJpbmcsIHt3aWR0aDogJ25hcnJvdycsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKGRhdGUsIHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgcmV0dXJuIHZhbHVlID49IDEgJiYgdmFsdWUgPD0gNFxcbiAgICB9LFxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCB2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgIGRhdGUuc2V0VVRDTW9udGgoKHZhbHVlIC0gMSkgKiAzLCAxKTtcXG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xcbiAgICAgIHJldHVybiBkYXRlXFxuICAgIH1cXG4gIH0sXFxuXFxuICAvLyBTdGFuZC1hbG9uZSBxdWFydGVyXFxuICBxOiB7XFxuICAgIHByaW9yaXR5OiAxMjAsXFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIG9wdGlvbnMpIHtcXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XFxuICAgICAgICAvLyAxLCAyLCAzLCA0XFxuICAgICAgICBjYXNlICdxJzpcXG4gICAgICAgIGNhc2UgJ3FxJzogLy8gMDEsIDAyLCAwMywgMDRcXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZylcXG4gICAgICAgIC8vIDFzdCwgMm5kLCAzcmQsIDR0aFxcbiAgICAgICAgY2FzZSAncW8nOlxcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHt1bml0OiAncXVhcnRlcid9KVxcbiAgICAgICAgLy8gUTEsIFEyLCBRMywgUTRcXG4gICAgICAgIGNhc2UgJ3FxcSc6XFxuICAgICAgICAgIHJldHVybiBtYXRjaC5xdWFydGVyKHN0cmluZywge3dpZHRoOiAnYWJicmV2aWF0ZWQnLCBjb250ZXh0OiAnc3RhbmRhbG9uZSd9KSB8fFxcbiAgICAgICAgICAgIG1hdGNoLnF1YXJ0ZXIoc3RyaW5nLCB7d2lkdGg6ICduYXJyb3cnLCBjb250ZXh0OiAnc3RhbmRhbG9uZSd9KVxcbiAgICAgICAgLy8gMSwgMiwgMywgNCAobmFycm93IHF1YXJ0ZXI7IGNvdWxkIGJlIG5vdCBudW1lcmljYWwpXFxuICAgICAgICBjYXNlICdxcXFxcSc6XFxuICAgICAgICAgIHJldHVybiBtYXRjaC5xdWFydGVyKHN0cmluZywge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ3N0YW5kYWxvbmUnfSlcXG4gICAgICAgIC8vIDFzdCBxdWFydGVyLCAybmQgcXVhcnRlciwgLi4uXFxuICAgICAgICBjYXNlICdxcXFxJzpcXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIHJldHVybiBtYXRjaC5xdWFydGVyKHN0cmluZywge3dpZHRoOiAnd2lkZScsIGNvbnRleHQ6ICdzdGFuZGFsb25lJ30pIHx8XFxuICAgICAgICAgICAgbWF0Y2gucXVhcnRlcihzdHJpbmcsIHt3aWR0aDogJ2FiYnJldmlhdGVkJywgY29udGV4dDogJ3N0YW5kYWxvbmUnfSkgfHxcXG4gICAgICAgICAgICBtYXRjaC5xdWFydGVyKHN0cmluZywge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ3N0YW5kYWxvbmUnfSlcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSA0XFxuICAgIH0sXFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgZGF0ZS5zZXRVVENNb250aCgodmFsdWUgLSAxKSAqIDMsIDEpO1xcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XFxuICAgICAgcmV0dXJuIGRhdGVcXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8vIE1vbnRoXFxuICBNOiB7XFxuICAgIHByaW9yaXR5OiAxMTAsXFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIG9wdGlvbnMpIHtcXG4gICAgICB2YXIgdmFsdWVDYWxsYmFjayA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIHZhbHVlIC0gMVxcbiAgICAgIH07XFxuXFxuICAgICAgc3dpdGNoICh0b2tlbikge1xcbiAgICAgICAgLy8gMSwgMiwgLi4uLCAxMlxcbiAgICAgICAgY2FzZSAnTSc6XFxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5tb250aCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKVxcbiAgICAgICAgLy8gMDEsIDAyLCAuLi4sIDEyXFxuICAgICAgICBjYXNlICdNTSc6XFxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHMoMiwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKVxcbiAgICAgICAgLy8gMXN0LCAybmQsIC4uLiwgMTJ0aFxcbiAgICAgICAgY2FzZSAnTW8nOlxcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHt1bml0OiAnbW9udGgnLCB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrfSlcXG4gICAgICAgIC8vIEphbiwgRmViLCAuLi4sIERlY1xcbiAgICAgICAgY2FzZSAnTU1NJzpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm1vbnRoKHN0cmluZywge3dpZHRoOiAnYWJicmV2aWF0ZWQnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KSB8fFxcbiAgICAgICAgICAgIG1hdGNoLm1vbnRoKHN0cmluZywge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgICAgIC8vIEosIEYsIC4uLiwgRFxcbiAgICAgICAgY2FzZSAnTU1NTU0nOlxcbiAgICAgICAgICByZXR1cm4gbWF0Y2gubW9udGgoc3RyaW5nLCB7d2lkdGg6ICduYXJyb3cnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KVxcbiAgICAgICAgLy8gSmFudWFyeSwgRmVicnVhcnksIC4uLiwgRGVjZW1iZXJcXG4gICAgICAgIGNhc2UgJ01NTU0nOlxcbiAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm1vbnRoKHN0cmluZywge3dpZHRoOiAnd2lkZScsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pIHx8XFxuICAgICAgICAgICAgbWF0Y2gubW9udGgoc3RyaW5nLCB7d2lkdGg6ICdhYmJyZXZpYXRlZCcsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pIHx8XFxuICAgICAgICAgICAgbWF0Y2gubW9udGgoc3RyaW5nLCB7d2lkdGg6ICduYXJyb3cnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChkYXRlLCB2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDExXFxuICAgIH0sXFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgZGF0ZS5zZXRVVENNb250aCh2YWx1ZSwgMSk7XFxuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcXG4gICAgICByZXR1cm4gZGF0ZVxcbiAgICB9XFxuICB9LFxcblxcbiAgLy8gU3RhbmQtYWxvbmUgbW9udGhcXG4gIEw6IHtcXG4gICAgcHJpb3JpdHk6IDExMCxcXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgb3B0aW9ucykge1xcbiAgICAgIHZhciB2YWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICByZXR1cm4gdmFsdWUgLSAxXFxuICAgICAgfTtcXG5cXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XFxuICAgICAgICAvLyAxLCAyLCAuLi4sIDEyXFxuICAgICAgICBjYXNlICdMJzpcXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLm1vbnRoLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spXFxuICAgICAgICAvLyAwMSwgMDIsIC4uLiwgMTJcXG4gICAgICAgIGNhc2UgJ0xMJzpcXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cygyLCBzdHJpbmcsIHZhbHVlQ2FsbGJhY2spXFxuICAgICAgICAvLyAxc3QsIDJuZCwgLi4uLCAxMnRoXFxuICAgICAgICBjYXNlICdMbyc6XFxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge3VuaXQ6ICdtb250aCcsIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2t9KVxcbiAgICAgICAgLy8gSmFuLCBGZWIsIC4uLiwgRGVjXFxuICAgICAgICBjYXNlICdMTEwnOlxcbiAgICAgICAgICByZXR1cm4gbWF0Y2gubW9udGgoc3RyaW5nLCB7d2lkdGg6ICdhYmJyZXZpYXRlZCcsIGNvbnRleHQ6ICdzdGFuZGFsb25lJ30pIHx8XFxuICAgICAgICAgICAgbWF0Y2gubW9udGgoc3RyaW5nLCB7d2lkdGg6ICduYXJyb3cnLCBjb250ZXh0OiAnc3RhbmRhbG9uZSd9KVxcbiAgICAgICAgLy8gSiwgRiwgLi4uLCBEXFxuICAgICAgICBjYXNlICdMTExMTCc6XFxuICAgICAgICAgIHJldHVybiBtYXRjaC5tb250aChzdHJpbmcsIHt3aWR0aDogJ25hcnJvdycsIGNvbnRleHQ6ICdzdGFuZGFsb25lJ30pXFxuICAgICAgICAvLyBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlclxcbiAgICAgICAgY2FzZSAnTExMTCc6XFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICByZXR1cm4gbWF0Y2gubW9udGgoc3RyaW5nLCB7d2lkdGg6ICd3aWRlJywgY29udGV4dDogJ3N0YW5kYWxvbmUnfSkgfHxcXG4gICAgICAgICAgICBtYXRjaC5tb250aChzdHJpbmcsIHt3aWR0aDogJ2FiYnJldmlhdGVkJywgY29udGV4dDogJ3N0YW5kYWxvbmUnfSkgfHxcXG4gICAgICAgICAgICBtYXRjaC5tb250aChzdHJpbmcsIHt3aWR0aDogJ25hcnJvdycsIGNvbnRleHQ6ICdzdGFuZGFsb25lJ30pXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKGRhdGUsIHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMTFcXG4gICAgfSxcXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgICBkYXRlLnNldFVUQ01vbnRoKHZhbHVlLCAxKTtcXG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xcbiAgICAgIHJldHVybiBkYXRlXFxuICAgIH1cXG4gIH0sXFxuXFxuICAvLyBMb2NhbCB3ZWVrIG9mIHllYXJcXG4gIHc6IHtcXG4gICAgcHJpb3JpdHk6IDEwMCxcXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgb3B0aW9ucykge1xcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcXG4gICAgICAgIGNhc2UgJ3cnOlxcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMud2Vlaywgc3RyaW5nKVxcbiAgICAgICAgY2FzZSAnd28nOlxcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHt1bml0OiAnd2Vlayd9KVxcbiAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZylcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSA1M1xcbiAgICB9LFxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCB2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgIHJldHVybiBzdGFydE9mVVRDV2VlayhzZXRVVENXZWVrKGRhdGUsIHZhbHVlLCBvcHRpb25zKSwgb3B0aW9ucylcXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8vIElTTyB3ZWVrIG9mIHllYXJcXG4gIEk6IHtcXG4gICAgcHJpb3JpdHk6IDEwMCxcXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgb3B0aW9ucykge1xcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcXG4gICAgICAgIGNhc2UgJ0knOlxcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMud2Vlaywgc3RyaW5nKVxcbiAgICAgICAgY2FzZSAnSW8nOlxcbiAgICAgICAgICByZXR1cm4gbWF0Y2gub3JkaW5hbE51bWJlcihzdHJpbmcsIHt1bml0OiAnd2Vlayd9KVxcbiAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZylcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSA1M1xcbiAgICB9LFxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCB2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgIHJldHVybiBzdGFydE9mVVRDSVNPV2VlayhzZXRVVENJU09XZWVrKGRhdGUsIHZhbHVlLCBvcHRpb25zKSwgb3B0aW9ucylcXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8vIERheSBvZiB0aGUgbW9udGhcXG4gIGQ6IHtcXG4gICAgcHJpb3JpdHk6IDkwLFxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBvcHRpb25zKSB7XFxuICAgICAgc3dpdGNoICh0b2tlbikge1xcbiAgICAgICAgY2FzZSAnZCc6XFxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5kYXRlLCBzdHJpbmcpXFxuICAgICAgICBjYXNlICdkbyc6XFxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge3VuaXQ6ICdkYXRlJ30pXFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nKVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChkYXRlLCB2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgIHZhciB5ZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xcbiAgICAgIHZhciBpc0xlYXBZZWFyID0gaXNMZWFwWWVhckluZGV4JDEoeWVhcik7XFxuICAgICAgdmFyIG1vbnRoID0gZGF0ZS5nZXRVVENNb250aCgpO1xcbiAgICAgIGlmIChpc0xlYXBZZWFyKSB7XFxuICAgICAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSBEQVlTX0lOX01PTlRIX0xFQVBfWUVBUiQxW21vbnRoXVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gdmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSBEQVlTX0lOX01PTlRIJDFbbW9udGhdXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCB2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgIGRhdGUuc2V0VVRDRGF0ZSh2YWx1ZSk7XFxuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcXG4gICAgICByZXR1cm4gZGF0ZVxcbiAgICB9XFxuICB9LFxcblxcbiAgLy8gRGF5IG9mIHllYXJcXG4gIEQ6IHtcXG4gICAgcHJpb3JpdHk6IDkwLFxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBvcHRpb25zKSB7XFxuICAgICAgc3dpdGNoICh0b2tlbikge1xcbiAgICAgICAgY2FzZSAnRCc6XFxuICAgICAgICBjYXNlICdERCc6XFxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5kYXlPZlllYXIsIHN0cmluZylcXG4gICAgICAgIGNhc2UgJ0RvJzpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7dW5pdDogJ2RhdGUnfSlcXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKGRhdGUsIHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgdmFyIHllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XFxuICAgICAgdmFyIGlzTGVhcFllYXIgPSBpc0xlYXBZZWFySW5kZXgkMSh5ZWFyKTtcXG4gICAgICBpZiAoaXNMZWFwWWVhcikge1xcbiAgICAgICAgcmV0dXJuIHZhbHVlID49IDEgJiYgdmFsdWUgPD0gMzY2XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDM2NVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgICBkYXRlLnNldFVUQ01vbnRoKDAsIHZhbHVlKTtcXG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xcbiAgICAgIHJldHVybiBkYXRlXFxuICAgIH1cXG4gIH0sXFxuXFxuICAvLyBEYXkgb2Ygd2Vla1xcbiAgRToge1xcbiAgICBwcmlvcml0eTogOTAsXFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIG9wdGlvbnMpIHtcXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XFxuICAgICAgICAvLyBUdWVcXG4gICAgICAgIGNhc2UgJ0UnOlxcbiAgICAgICAgY2FzZSAnRUUnOlxcbiAgICAgICAgY2FzZSAnRUVFJzpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHt3aWR0aDogJ2FiYnJldmlhdGVkJywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSkgfHxcXG4gICAgICAgICAgICBtYXRjaC5kYXkoc3RyaW5nLCB7d2lkdGg6ICdzaG9ydCcsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pIHx8XFxuICAgICAgICAgICAgbWF0Y2guZGF5KHN0cmluZywge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgICAgIC8vIFRcXG4gICAgICAgIGNhc2UgJ0VFRUVFJzpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHt3aWR0aDogJ25hcnJvdycsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pXFxuICAgICAgICAvLyBUdVxcbiAgICAgICAgY2FzZSAnRUVFRUVFJzpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHt3aWR0aDogJ3Nob3J0JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSkgfHxcXG4gICAgICAgICAgbWF0Y2guZGF5KHN0cmluZywge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgICAgIC8vIFR1ZXNkYXlcXG4gICAgICAgIGNhc2UgJ0VFRUUnOlxcbiAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHt3aWR0aDogJ3dpZGUnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KSB8fFxcbiAgICAgICAgICAgIG1hdGNoLmRheShzdHJpbmcsIHt3aWR0aDogJ2FiYnJldmlhdGVkJywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSkgfHxcXG4gICAgICAgICAgICBtYXRjaC5kYXkoc3RyaW5nLCB7d2lkdGg6ICdzaG9ydCcsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pIHx8XFxuICAgICAgICAgICAgbWF0Y2guZGF5KHN0cmluZywge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgICByZXR1cm4gdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSA2XFxuICAgIH0sXFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgZGF0ZSA9IHNldFVUQ0RheShkYXRlLCB2YWx1ZSwgb3B0aW9ucyk7XFxuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcXG4gICAgICByZXR1cm4gZGF0ZVxcbiAgICB9XFxuICB9LFxcblxcbiAgLy8gTG9jYWwgZGF5IG9mIHdlZWtcXG4gIGU6IHtcXG4gICAgcHJpb3JpdHk6IDkwLFxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBvcHRpb25zKSB7XFxuICAgICAgdmFyIHZhbHVlQ2FsbGJhY2sgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgIHZhciB3aG9sZVdlZWtEYXlzID0gTWF0aC5mbG9vcigodmFsdWUgLSAxKSAvIDcpICogNztcXG4gICAgICAgIHJldHVybiAodmFsdWUgKyBvcHRpb25zLndlZWtTdGFydHNPbiArIDYpICUgNyArIHdob2xlV2Vla0RheXNcXG4gICAgICB9O1xcblxcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcXG4gICAgICAgIC8vIDNcXG4gICAgICAgIGNhc2UgJ2UnOlxcbiAgICAgICAgY2FzZSAnZWUnOiAvLyAwM1xcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKVxcbiAgICAgICAgLy8gM3JkXFxuICAgICAgICBjYXNlICdlbyc6XFxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge3VuaXQ6ICdkYXknLCB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrfSlcXG4gICAgICAgIC8vIFR1ZVxcbiAgICAgICAgY2FzZSAnZWVlJzpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHt3aWR0aDogJ2FiYnJldmlhdGVkJywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSkgfHxcXG4gICAgICAgICAgICBtYXRjaC5kYXkoc3RyaW5nLCB7d2lkdGg6ICdzaG9ydCcsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pIHx8XFxuICAgICAgICAgICAgbWF0Y2guZGF5KHN0cmluZywge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgICAgIC8vIFRcXG4gICAgICAgIGNhc2UgJ2VlZWVlJzpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHt3aWR0aDogJ25hcnJvdycsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pXFxuICAgICAgICAvLyBUdVxcbiAgICAgICAgY2FzZSAnZWVlZWVlJzpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHt3aWR0aDogJ3Nob3J0JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSkgfHxcXG4gICAgICAgICAgbWF0Y2guZGF5KHN0cmluZywge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgICAgIC8vIFR1ZXNkYXlcXG4gICAgICAgIGNhc2UgJ2VlZWUnOlxcbiAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHt3aWR0aDogJ3dpZGUnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KSB8fFxcbiAgICAgICAgICAgIG1hdGNoLmRheShzdHJpbmcsIHt3aWR0aDogJ2FiYnJldmlhdGVkJywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSkgfHxcXG4gICAgICAgICAgICBtYXRjaC5kYXkoc3RyaW5nLCB7d2lkdGg6ICdzaG9ydCcsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pIHx8XFxuICAgICAgICAgICAgbWF0Y2guZGF5KHN0cmluZywge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgICByZXR1cm4gdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSA2XFxuICAgIH0sXFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgZGF0ZSA9IHNldFVUQ0RheShkYXRlLCB2YWx1ZSwgb3B0aW9ucyk7XFxuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcXG4gICAgICByZXR1cm4gZGF0ZVxcbiAgICB9XFxuICB9LFxcblxcbiAgLy8gU3RhbmQtYWxvbmUgbG9jYWwgZGF5IG9mIHdlZWtcXG4gIGM6IHtcXG4gICAgcHJpb3JpdHk6IDkwLFxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBvcHRpb25zKSB7XFxuICAgICAgdmFyIHZhbHVlQ2FsbGJhY2sgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgIHZhciB3aG9sZVdlZWtEYXlzID0gTWF0aC5mbG9vcigodmFsdWUgLSAxKSAvIDcpICogNztcXG4gICAgICAgIHJldHVybiAodmFsdWUgKyBvcHRpb25zLndlZWtTdGFydHNPbiArIDYpICUgNyArIHdob2xlV2Vla0RheXNcXG4gICAgICB9O1xcblxcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcXG4gICAgICAgIC8vIDNcXG4gICAgICAgIGNhc2UgJ2MnOlxcbiAgICAgICAgY2FzZSAnY2MnOiAvLyAwM1xcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nLCB2YWx1ZUNhbGxiYWNrKVxcbiAgICAgICAgLy8gM3JkXFxuICAgICAgICBjYXNlICdjbyc6XFxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge3VuaXQ6ICdkYXknLCB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrfSlcXG4gICAgICAgIC8vIFR1ZVxcbiAgICAgICAgY2FzZSAnY2NjJzpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHt3aWR0aDogJ2FiYnJldmlhdGVkJywgY29udGV4dDogJ3N0YW5kYWxvbmUnfSkgfHxcXG4gICAgICAgICAgICBtYXRjaC5kYXkoc3RyaW5nLCB7d2lkdGg6ICdzaG9ydCcsIGNvbnRleHQ6ICdzdGFuZGFsb25lJ30pIHx8XFxuICAgICAgICAgICAgbWF0Y2guZGF5KHN0cmluZywge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ3N0YW5kYWxvbmUnfSlcXG4gICAgICAgIC8vIFRcXG4gICAgICAgIGNhc2UgJ2NjY2NjJzpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHt3aWR0aDogJ25hcnJvdycsIGNvbnRleHQ6ICdzdGFuZGFsb25lJ30pXFxuICAgICAgICAvLyBUdVxcbiAgICAgICAgY2FzZSAnY2NjY2NjJzpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHt3aWR0aDogJ3Nob3J0JywgY29udGV4dDogJ3N0YW5kYWxvbmUnfSkgfHxcXG4gICAgICAgICAgbWF0Y2guZGF5KHN0cmluZywge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ3N0YW5kYWxvbmUnfSlcXG4gICAgICAgIC8vIFR1ZXNkYXlcXG4gICAgICAgIGNhc2UgJ2NjY2MnOlxcbiAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheShzdHJpbmcsIHt3aWR0aDogJ3dpZGUnLCBjb250ZXh0OiAnc3RhbmRhbG9uZSd9KSB8fFxcbiAgICAgICAgICAgIG1hdGNoLmRheShzdHJpbmcsIHt3aWR0aDogJ2FiYnJldmlhdGVkJywgY29udGV4dDogJ3N0YW5kYWxvbmUnfSkgfHxcXG4gICAgICAgICAgICBtYXRjaC5kYXkoc3RyaW5nLCB7d2lkdGg6ICdzaG9ydCcsIGNvbnRleHQ6ICdzdGFuZGFsb25lJ30pIHx8XFxuICAgICAgICAgICAgbWF0Y2guZGF5KHN0cmluZywge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ3N0YW5kYWxvbmUnfSlcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgICByZXR1cm4gdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSA2XFxuICAgIH0sXFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgZGF0ZSA9IHNldFVUQ0RheShkYXRlLCB2YWx1ZSwgb3B0aW9ucyk7XFxuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcXG4gICAgICByZXR1cm4gZGF0ZVxcbiAgICB9XFxuICB9LFxcblxcbiAgLy8gSVNPIGRheSBvZiB3ZWVrXFxuICBpOiB7XFxuICAgIHByaW9yaXR5OiA5MCxcXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgb3B0aW9ucykge1xcbiAgICAgIHZhciB2YWx1ZUNhbGxiYWNrID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcXG4gICAgICAgICAgcmV0dXJuIDdcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB2YWx1ZVxcbiAgICAgIH07XFxuXFxuICAgICAgc3dpdGNoICh0b2tlbikge1xcbiAgICAgICAgLy8gMlxcbiAgICAgICAgY2FzZSAnaSc6XFxuICAgICAgICBjYXNlICdpaSc6IC8vIDAyXFxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpXFxuICAgICAgICAvLyAybmRcXG4gICAgICAgIGNhc2UgJ2lvJzpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7dW5pdDogJ2RheSd9KVxcbiAgICAgICAgLy8gVHVlXFxuICAgICAgICBjYXNlICdpaWknOlxcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge3dpZHRoOiAnYWJicmV2aWF0ZWQnLCBjb250ZXh0OiAnZm9ybWF0dGluZycsIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2t9KSB8fFxcbiAgICAgICAgICAgIG1hdGNoLmRheShzdHJpbmcsIHt3aWR0aDogJ3Nob3J0JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnLCB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrfSkgfHxcXG4gICAgICAgICAgICBtYXRjaC5kYXkoc3RyaW5nLCB7d2lkdGg6ICduYXJyb3cnLCBjb250ZXh0OiAnZm9ybWF0dGluZycsIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2t9KVxcbiAgICAgICAgLy8gVFxcbiAgICAgICAgY2FzZSAnaWlpaWknOlxcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnLCB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrfSlcXG4gICAgICAgIC8vIFR1XFxuICAgICAgICBjYXNlICdpaWlpaWknOlxcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge3dpZHRoOiAnc2hvcnQnLCBjb250ZXh0OiAnZm9ybWF0dGluZycsIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2t9KSB8fFxcbiAgICAgICAgICBtYXRjaC5kYXkoc3RyaW5nLCB7d2lkdGg6ICduYXJyb3cnLCBjb250ZXh0OiAnZm9ybWF0dGluZycsIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2t9KVxcbiAgICAgICAgLy8gVHVlc2RheVxcbiAgICAgICAgY2FzZSAnaWlpaSc6XFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5KHN0cmluZywge3dpZHRoOiAnd2lkZScsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJywgdmFsdWVDYWxsYmFjazogdmFsdWVDYWxsYmFja30pIHx8XFxuICAgICAgICAgICAgbWF0Y2guZGF5KHN0cmluZywge3dpZHRoOiAnYWJicmV2aWF0ZWQnLCBjb250ZXh0OiAnZm9ybWF0dGluZycsIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2t9KSB8fFxcbiAgICAgICAgICAgIG1hdGNoLmRheShzdHJpbmcsIHt3aWR0aDogJ3Nob3J0JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnLCB2YWx1ZUNhbGxiYWNrOiB2YWx1ZUNhbGxiYWNrfSkgfHxcXG4gICAgICAgICAgICBtYXRjaC5kYXkoc3RyaW5nLCB7d2lkdGg6ICduYXJyb3cnLCBjb250ZXh0OiAnZm9ybWF0dGluZycsIHZhbHVlQ2FsbGJhY2s6IHZhbHVlQ2FsbGJhY2t9KVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChkYXRlLCB2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDdcXG4gICAgfSxcXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgICBkYXRlID0gc2V0VVRDSVNPRGF5KGRhdGUsIHZhbHVlLCBvcHRpb25zKTtcXG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xcbiAgICAgIHJldHVybiBkYXRlXFxuICAgIH1cXG4gIH0sXFxuXFxuICAvLyBBTSBvciBQTVxcbiAgYToge1xcbiAgICBwcmlvcml0eTogODAsXFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIG9wdGlvbnMpIHtcXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XFxuICAgICAgICBjYXNlICdhJzpcXG4gICAgICAgIGNhc2UgJ2FhJzpcXG4gICAgICAgIGNhc2UgJ2FhYSc6XFxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7d2lkdGg6ICdhYmJyZXZpYXRlZCcsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pIHx8XFxuICAgICAgICAgICAgbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgICAgIGNhc2UgJ2FhYWFhJzpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHt3aWR0aDogJ25hcnJvdycsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pXFxuICAgICAgICBjYXNlICdhYWFhJzpcXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7d2lkdGg6ICd3aWRlJywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSkgfHxcXG4gICAgICAgICAgICBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7d2lkdGg6ICdhYmJyZXZpYXRlZCcsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pIHx8XFxuICAgICAgICAgICAgbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgZGF0ZS5zZXRVVENIb3VycyhkYXlQZXJpb2RFbnVtVG9Ib3Vycyh2YWx1ZSksIDAsIDAsIDApO1xcbiAgICAgIHJldHVybiBkYXRlXFxuICAgIH1cXG4gIH0sXFxuXFxuICAvLyBBTSwgUE0sIG1pZG5pZ2h0XFxuICBiOiB7XFxuICAgIHByaW9yaXR5OiA4MCxcXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgb3B0aW9ucykge1xcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcXG4gICAgICAgIGNhc2UgJ2InOlxcbiAgICAgICAgY2FzZSAnYmInOlxcbiAgICAgICAgY2FzZSAnYmJiJzpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHt3aWR0aDogJ2FiYnJldmlhdGVkJywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSkgfHxcXG4gICAgICAgICAgICBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7d2lkdGg6ICduYXJyb3cnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KVxcbiAgICAgICAgY2FzZSAnYmJiYmInOlxcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge3dpZHRoOiAnbmFycm93JywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSlcXG4gICAgICAgIGNhc2UgJ2JiYmInOlxcbiAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHt3aWR0aDogJ3dpZGUnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KSB8fFxcbiAgICAgICAgICAgIG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHt3aWR0aDogJ2FiYnJldmlhdGVkJywgY29udGV4dDogJ2Zvcm1hdHRpbmcnfSkgfHxcXG4gICAgICAgICAgICBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7d2lkdGg6ICduYXJyb3cnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKGRheVBlcmlvZEVudW1Ub0hvdXJzKHZhbHVlKSwgMCwgMCwgMCk7XFxuICAgICAgcmV0dXJuIGRhdGVcXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8vIGluIHRoZSBtb3JuaW5nLCBpbiB0aGUgYWZ0ZXJub29uLCBpbiB0aGUgZXZlbmluZywgYXQgbmlnaHRcXG4gIEI6IHtcXG4gICAgcHJpb3JpdHk6IDgwLFxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBvcHRpb25zKSB7XFxuICAgICAgc3dpdGNoICh0b2tlbikge1xcbiAgICAgICAgY2FzZSAnQic6XFxuICAgICAgICBjYXNlICdCQic6XFxuICAgICAgICBjYXNlICdCQkInOlxcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge3dpZHRoOiAnYWJicmV2aWF0ZWQnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KSB8fFxcbiAgICAgICAgICAgIG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHt3aWR0aDogJ25hcnJvdycsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pXFxuICAgICAgICBjYXNlICdCQkJCQic6XFxuICAgICAgICAgIHJldHVybiBtYXRjaC5kYXlQZXJpb2Qoc3RyaW5nLCB7d2lkdGg6ICduYXJyb3cnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KVxcbiAgICAgICAgY2FzZSAnQkJCQic6XFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICByZXR1cm4gbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge3dpZHRoOiAnd2lkZScsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pIHx8XFxuICAgICAgICAgICAgbWF0Y2guZGF5UGVyaW9kKHN0cmluZywge3dpZHRoOiAnYWJicmV2aWF0ZWQnLCBjb250ZXh0OiAnZm9ybWF0dGluZyd9KSB8fFxcbiAgICAgICAgICAgIG1hdGNoLmRheVBlcmlvZChzdHJpbmcsIHt3aWR0aDogJ25hcnJvdycsIGNvbnRleHQ6ICdmb3JtYXR0aW5nJ30pXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCB2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoZGF5UGVyaW9kRW51bVRvSG91cnModmFsdWUpLCAwLCAwLCAwKTtcXG4gICAgICByZXR1cm4gZGF0ZVxcbiAgICB9XFxuICB9LFxcblxcbiAgLy8gSG91ciBbMS0xMl1cXG4gIGg6IHtcXG4gICAgcHJpb3JpdHk6IDcwLFxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBvcHRpb25zKSB7XFxuICAgICAgc3dpdGNoICh0b2tlbikge1xcbiAgICAgICAgY2FzZSAnaCc6XFxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5ob3VyMTJoLCBzdHJpbmcpXFxuICAgICAgICBjYXNlICdobyc6XFxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge3VuaXQ6ICdob3VyJ30pXFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nKVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChkYXRlLCB2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAxICYmIHZhbHVlIDw9IDEyXFxuICAgIH0sXFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgdmFyIGlzUE0gPSBkYXRlLmdldFVUQ0hvdXJzKCkgPj0gMTI7XFxuICAgICAgaWYgKGlzUE0gJiYgdmFsdWUgPCAxMikge1xcbiAgICAgICAgZGF0ZS5zZXRVVENIb3Vycyh2YWx1ZSArIDEyLCAwLCAwLCAwKTtcXG4gICAgICB9IGVsc2UgaWYgKCFpc1BNICYmIHZhbHVlID09PSAxMikge1xcbiAgICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZGF0ZS5zZXRVVENIb3Vycyh2YWx1ZSwgMCwgMCwgMCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBkYXRlXFxuICAgIH1cXG4gIH0sXFxuXFxuICAvLyBIb3VyIFswLTIzXVxcbiAgSDoge1xcbiAgICBwcmlvcml0eTogNzAsXFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIG9wdGlvbnMpIHtcXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XFxuICAgICAgICBjYXNlICdIJzpcXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLmhvdXIyM2gsIHN0cmluZylcXG4gICAgICAgIGNhc2UgJ0hvJzpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7dW5pdDogJ2hvdXInfSlcXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKGRhdGUsIHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMjNcXG4gICAgfSxcXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKHZhbHVlLCAwLCAwLCAwKTtcXG4gICAgICByZXR1cm4gZGF0ZVxcbiAgICB9XFxuICB9LFxcblxcbiAgLy8gSG91ciBbMC0xMV1cXG4gIEs6IHtcXG4gICAgcHJpb3JpdHk6IDcwLFxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBvcHRpb25zKSB7XFxuICAgICAgc3dpdGNoICh0b2tlbikge1xcbiAgICAgICAgY2FzZSAnSyc6XFxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5ob3VyMTFoLCBzdHJpbmcpXFxuICAgICAgICBjYXNlICdLbyc6XFxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge3VuaXQ6ICdob3VyJ30pXFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICByZXR1cm4gcGFyc2VORGlnaXRzKHRva2VuLmxlbmd0aCwgc3RyaW5nKVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChkYXRlLCB2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgIHJldHVybiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDExXFxuICAgIH0sXFxuICAgIHNldDogZnVuY3Rpb24gKGRhdGUsIHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgdmFyIGlzUE0gPSBkYXRlLmdldFVUQ0hvdXJzKCkgPj0gMTI7XFxuICAgICAgaWYgKGlzUE0gJiYgdmFsdWUgPCAxMikge1xcbiAgICAgICAgZGF0ZS5zZXRVVENIb3Vycyh2YWx1ZSArIDEyLCAwLCAwLCAwKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZGF0ZS5zZXRVVENIb3Vycyh2YWx1ZSwgMCwgMCwgMCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBkYXRlXFxuICAgIH1cXG4gIH0sXFxuXFxuICAvLyBIb3VyIFsxLTI0XVxcbiAgazoge1xcbiAgICBwcmlvcml0eTogNzAsXFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIG9wdGlvbnMpIHtcXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XFxuICAgICAgICBjYXNlICdrJzpcXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpY1BhdHRlcm4obnVtZXJpY1BhdHRlcm5zLmhvdXIyNGgsIHN0cmluZylcXG4gICAgICAgIGNhc2UgJ2tvJzpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7dW5pdDogJ2hvdXInfSlcXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKGRhdGUsIHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgcmV0dXJuIHZhbHVlID49IDEgJiYgdmFsdWUgPD0gMjRcXG4gICAgfSxcXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgICB2YXIgaG91cnMgPSB2YWx1ZSA8PSAyNCA/IHZhbHVlICUgMjQgOiB2YWx1ZTtcXG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKGhvdXJzLCAwLCAwLCAwKTtcXG4gICAgICByZXR1cm4gZGF0ZVxcbiAgICB9XFxuICB9LFxcblxcbiAgLy8gTWludXRlXFxuICBtOiB7XFxuICAgIHByaW9yaXR5OiA2MCxcXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcsIHRva2VuLCBtYXRjaCwgb3B0aW9ucykge1xcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcXG4gICAgICAgIGNhc2UgJ20nOlxcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljUGF0dGVybihudW1lcmljUGF0dGVybnMubWludXRlLCBzdHJpbmcpXFxuICAgICAgICBjYXNlICdtbyc6XFxuICAgICAgICAgIHJldHVybiBtYXRjaC5vcmRpbmFsTnVtYmVyKHN0cmluZywge3VuaXQ6ICdtaW51dGUnfSlcXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIHJldHVybiBwYXJzZU5EaWdpdHModG9rZW4ubGVuZ3RoLCBzdHJpbmcpXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKGRhdGUsIHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgcmV0dXJuIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gNTlcXG4gICAgfSxcXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgICBkYXRlLnNldFVUQ01pbnV0ZXModmFsdWUsIDAsIDApO1xcbiAgICAgIHJldHVybiBkYXRlXFxuICAgIH1cXG4gIH0sXFxuXFxuICAvLyBTZWNvbmRcXG4gIHM6IHtcXG4gICAgcHJpb3JpdHk6IDUwLFxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBvcHRpb25zKSB7XFxuICAgICAgc3dpdGNoICh0b2tlbikge1xcbiAgICAgICAgY2FzZSAncyc6XFxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWNQYXR0ZXJuKG51bWVyaWNQYXR0ZXJucy5zZWNvbmQsIHN0cmluZylcXG4gICAgICAgIGNhc2UgJ3NvJzpcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoLm9yZGluYWxOdW1iZXIoc3RyaW5nLCB7dW5pdDogJ3NlY29uZCd9KVxcbiAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZylcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgICByZXR1cm4gdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSA1OVxcbiAgICB9LFxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCB2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgIGRhdGUuc2V0VVRDU2Vjb25kcyh2YWx1ZSwgMCk7XFxuICAgICAgcmV0dXJuIGRhdGVcXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8vIEZyYWN0aW9uIG9mIHNlY29uZFxcbiAgUzoge1xcbiAgICBwcmlvcml0eTogNDAsXFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIG9wdGlvbnMpIHtcXG4gICAgICB2YXIgdmFsdWVDYWxsYmFjayA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodmFsdWUgKiBNYXRoLnBvdygxMCwgLXRva2VuLmxlbmd0aCArIDMpKVxcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHBhcnNlTkRpZ2l0cyh0b2tlbi5sZW5ndGgsIHN0cmluZywgdmFsdWVDYWxsYmFjaylcXG4gICAgfSxcXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgICBkYXRlLnNldFVUQ01pbGxpc2Vjb25kcyh2YWx1ZSk7XFxuICAgICAgcmV0dXJuIGRhdGVcXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8vIFRpbWV6b25lIChJU08tODYwMS4gKzAwOjAwIGlzIGAnWidgKVxcbiAgWDoge1xcbiAgICBwcmlvcml0eTogMjAsXFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIG9wdGlvbnMpIHtcXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XFxuICAgICAgICBjYXNlICdYJzpcXG4gICAgICAgICAgcmV0dXJuIHBhcnNlVGltZXpvbmVQYXR0ZXJuKHRpbWV6b25lUGF0dGVybnMuYmFzaWNPcHRpb25hbE1pbnV0ZXMsIHN0cmluZylcXG4gICAgICAgIGNhc2UgJ1hYJzpcXG4gICAgICAgICAgcmV0dXJuIHBhcnNlVGltZXpvbmVQYXR0ZXJuKHRpbWV6b25lUGF0dGVybnMuYmFzaWMsIHN0cmluZylcXG4gICAgICAgIGNhc2UgJ1hYWFgnOlxcbiAgICAgICAgICByZXR1cm4gcGFyc2VUaW1lem9uZVBhdHRlcm4odGltZXpvbmVQYXR0ZXJucy5iYXNpY09wdGlvbmFsU2Vjb25kcywgc3RyaW5nKVxcbiAgICAgICAgY2FzZSAnWFhYWFgnOlxcbiAgICAgICAgICByZXR1cm4gcGFyc2VUaW1lem9uZVBhdHRlcm4odGltZXpvbmVQYXR0ZXJucy5leHRlbmRlZE9wdGlvbmFsU2Vjb25kcywgc3RyaW5nKVxcbiAgICAgICAgY2FzZSAnWFhYJzpcXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIHJldHVybiBwYXJzZVRpbWV6b25lUGF0dGVybih0aW1lem9uZVBhdHRlcm5zLmV4dGVuZGVkLCBzdHJpbmcpXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCB2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSAtIHZhbHVlKVxcbiAgICB9XFxuICB9LFxcblxcbiAgLy8gVGltZXpvbmUgKElTTy04NjAxKVxcbiAgeDoge1xcbiAgICBwcmlvcml0eTogMjAsXFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIG9wdGlvbnMpIHtcXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XFxuICAgICAgICBjYXNlICd4JzpcXG4gICAgICAgICAgcmV0dXJuIHBhcnNlVGltZXpvbmVQYXR0ZXJuKHRpbWV6b25lUGF0dGVybnMuYmFzaWNPcHRpb25hbE1pbnV0ZXMsIHN0cmluZylcXG4gICAgICAgIGNhc2UgJ3h4JzpcXG4gICAgICAgICAgcmV0dXJuIHBhcnNlVGltZXpvbmVQYXR0ZXJuKHRpbWV6b25lUGF0dGVybnMuYmFzaWMsIHN0cmluZylcXG4gICAgICAgIGNhc2UgJ3h4eHgnOlxcbiAgICAgICAgICByZXR1cm4gcGFyc2VUaW1lem9uZVBhdHRlcm4odGltZXpvbmVQYXR0ZXJucy5iYXNpY09wdGlvbmFsU2Vjb25kcywgc3RyaW5nKVxcbiAgICAgICAgY2FzZSAneHh4eHgnOlxcbiAgICAgICAgICByZXR1cm4gcGFyc2VUaW1lem9uZVBhdHRlcm4odGltZXpvbmVQYXR0ZXJucy5leHRlbmRlZE9wdGlvbmFsU2Vjb25kcywgc3RyaW5nKVxcbiAgICAgICAgY2FzZSAneHh4JzpcXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIHJldHVybiBwYXJzZVRpbWV6b25lUGF0dGVybih0aW1lem9uZVBhdHRlcm5zLmV4dGVuZGVkLCBzdHJpbmcpXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCB2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSAtIHZhbHVlKVxcbiAgICB9XFxuICB9LFxcblxcbiAgLy8gU2Vjb25kcyB0aW1lc3RhbXBcXG4gIHQ6IHtcXG4gICAgcHJpb3JpdHk6IDEwLFxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHN0cmluZywgdG9rZW4sIG1hdGNoLCBvcHRpb25zKSB7XFxuICAgICAgcmV0dXJuIHBhcnNlQW55RGlnaXRzU2lnbmVkKHN0cmluZylcXG4gICAgfSxcXG4gICAgc2V0OiBmdW5jdGlvbiAoZGF0ZSwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUgKiAxMDAwKVxcbiAgICB9XFxuICB9LFxcblxcbiAgLy8gTWlsbGlzZWNvbmRzIHRpbWVzdGFtcFxcbiAgVDoge1xcbiAgICBwcmlvcml0eTogMTAsXFxuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nLCB0b2tlbiwgbWF0Y2gsIG9wdGlvbnMpIHtcXG4gICAgICByZXR1cm4gcGFyc2VBbnlEaWdpdHNTaWduZWQoc3RyaW5nKVxcbiAgICB9LFxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlLCB2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSlcXG4gICAgfVxcbiAgfVxcbn07XFxuXFxudmFyIFRJTUVaT05FX1VOSVRfUFJJT1JJVFkgPSAyMDtcXG5cXG4vLyBUaGlzIFJlZ0V4cCBjb25zaXN0cyBvZiB0aHJlZSBwYXJ0cyBzZXBhcmF0ZWQgYnkgYHxgOlxcbi8vIC0gW3lZUXFNTHdJZERlY2loSEtrbXNdbyBtYXRjaGVzIGFueSBhdmFpbGFibGUgb3JkaW5hbCBudW1iZXIgdG9rZW5cXG4vLyAgIChvbmUgb2YgdGhlIGNlcnRhaW4gbGV0dGVycyBmb2xsb3dlZCBieSBgb2ApXFxuLy8gLSAoXFxcXHcpXFxcXDEqIG1hdGNoZXMgYW55IHNlcXVlbmNlcyBvZiB0aGUgc2FtZSBsZXR0ZXJcXG4vLyAtICcnIG1hdGNoZXMgdHdvIHF1b3RlIGNoYXJhY3RlcnMgaW4gYSByb3dcXG4vLyAtICcoJyd8W14nXSkrKCd8JCkgbWF0Y2hlcyBhbnl0aGluZyBzdXJyb3VuZGVkIGJ5IHR3byBxdW90ZSBjaGFyYWN0ZXJzICgnKSxcXG4vLyAgIGV4Y2VwdCBhIHNpbmdsZSBxdW90ZSBzeW1ib2wsIHdoaWNoIGVuZHMgdGhlIHNlcXVlbmNlLlxcbi8vICAgVHdvIHF1b3RlIGNoYXJhY3RlcnMgZG8gbm90IGVuZCB0aGUgc2VxdWVuY2UuXFxuLy8gICBJZiB0aGVyZSBpcyBubyBtYXRjaGluZyBzaW5nbGUgcXVvdGVcXG4vLyAgIHRoZW4gdGhlIHNlcXVlbmNlIHdpbGwgY29udGludWUgdW50aWwgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLlxcbi8vIC0gLiBtYXRjaGVzIGFueSBzaW5nbGUgY2hhcmFjdGVyIHVubWF0Y2hlZCBieSBwcmV2aW91cyBwYXJ0cyBvZiB0aGUgUmVnRXhwc1xcbnZhciBmb3JtYXR0aW5nVG9rZW5zUmVnRXhwJDEgPSAvW3lZUXFNTHdJZERlY2loSEtrbXNdb3woXFxcXHcpXFxcXDEqfCcnfCcoJyd8W14nXSkrKCd8JCl8Li9nO1xcblxcbnZhciBlc2NhcGVkU3RyaW5nUmVnRXhwJDEgPSAvXicoLio/KSc/JC87XFxudmFyIGRvdWJsZVF1b3RlUmVnRXhwJDEgPSAvJycvZztcXG5cXG52YXIgbm90V2hpdGVzcGFjZVJlZ0V4cCA9IC9cXFxcUy87XFxuXFxuLyoqXFxuICogQG5hbWUgcGFyc2VcXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcXG4gKiBAc3VtbWFyeSBQYXJzZSB0aGUgZGF0ZS5cXG4gKlxcbiAqIEBkZXNjcmlwdGlvblxcbiAqIFJldHVybiB0aGUgZGF0ZSBwYXJzZWQgZnJvbSBzdHJpbmcgdXNpbmcgdGhlIGdpdmVuIGZvcm1hdCBzdHJpbmcuXFxuICpcXG4gKiA+IOKaoO+4jyBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBgZm9ybWF0YCB0b2tlbnMgZGlmZmVyIGZyb20gTW9tZW50LmpzIGFuZCBvdGhlciBsaWJyYXJpZXMuXFxuICogPiBTZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXFxuICpcXG4gKiBUaGUgY2hhcmFjdGVycyBpbiB0aGUgZm9ybWF0IHN0cmluZyB3cmFwcGVkIGJldHdlZW4gdHdvIHNpbmdsZSBxdW90ZXMgY2hhcmFjdGVycyAoJykgYXJlIGVzY2FwZWQuXFxuICogVHdvIHNpbmdsZSBxdW90ZXMgaW4gYSByb3csIHdoZXRoZXIgaW5zaWRlIG9yIG91dHNpZGUgYSBxdW90ZWQgc2VxdWVuY2UsIHJlcHJlc2VudCBhICdyZWFsJyBzaW5nbGUgcXVvdGUuXFxuICpcXG4gKiBGb3JtYXQgb2YgdGhlIGZvcm1hdCBzdHJpbmcgaXMgYmFzZWQgb24gVW5pY29kZSBUZWNobmljYWwgU3RhbmRhcmQgIzM1OlxcbiAqIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9GaWVsZF9TeW1ib2xfVGFibGVcXG4gKiB3aXRoIGEgZmV3IGFkZGl0aW9ucyAoc2VlIG5vdGUgNSBiZWxvdyB0aGUgdGFibGUpLlxcbiAqXFxuICogQWNjZXB0ZWQgZm9ybWF0IHN0cmluZyBwYXR0ZXJuczpcXG4gKiB8IFVuaXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFByaW9yfCBQYXR0ZXJuIHwgUmVzdWx0IGV4YW1wbGVzICAgICAgICAgICAgICAgICAgIHwgTm90ZXMgfFxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS18XFxuICogfCBFcmEgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMTQwIHwgRy4uR0dHICB8IEFELCBCQyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBHR0dHICAgIHwgQW5ubyBEb21pbmksIEJlZm9yZSBDaHJpc3QgICAgICAgIHwgMiAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEdHR0dHICAgfCBBLCBCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCBDYWxlbmRhciB5ZWFyICAgICAgICAgICAgICAgICAgIHwgMTMwIHwgeSAgICAgICB8IDQ0LCAxLCAxOTAwLCAyMDE3LCA5OTk5ICAgICAgICAgICB8IDQgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB5byAgICAgIHwgNDR0aCwgMXN0LCAxOTAwdGgsIDk5OTk5OTl0aCAgICAgIHwgNCw1ICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHl5ICAgICAgfCA0NCwgMDEsIDAwLCAxNyAgICAgICAgICAgICAgICAgICAgfCA0ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgeXl5ICAgICB8IDA0NCwgMDAxLCAxMjMsIDk5OSAgICAgICAgICAgICAgICB8IDQgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB5eXl5ICAgIHwgMDA0NCwgMDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgIHwgNCAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHl5eXl5ICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAyLDQgICB8XFxuICogfCBMb2NhbCB3ZWVrLW51bWJlcmluZyB5ZWFyICAgICAgIHwgMTMwIHwgWSAgICAgICB8IDQ0LCAxLCAxOTAwLCAyMDE3LCA5MDAwICAgICAgICAgICB8IDQgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBZbyAgICAgIHwgNDR0aCwgMXN0LCAxOTAwdGgsIDk5OTk5OTl0aCAgICAgIHwgNCw1ICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFlZICAgICAgfCA0NCwgMDEsIDAwLCAxNyAgICAgICAgICAgICAgICAgICAgfCA0LDYgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWVlZICAgICB8IDA0NCwgMDAxLCAxMjMsIDk5OSAgICAgICAgICAgICAgICB8IDQgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBZWVlZICAgIHwgMDA0NCwgMDAwMSwgMTkwMCwgMjAxNyAgICAgICAgICAgIHwgNCw2ICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFlZWVlZICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAyLDQgICB8XFxuICogfCBJU08gd2Vlay1udW1iZXJpbmcgeWVhciAgICAgICAgIHwgMTMwIHwgUiAgICAgICB8IC00MywgMSwgMTkwMCwgMjAxNywgOTk5OSwgLTk5OTkgICB8IDQsNSAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBSUiAgICAgIHwgLTQzLCAwMSwgMDAsIDE3ICAgICAgICAgICAgICAgICAgIHwgNCw1ICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFJSUiAgICAgfCAtMDQzLCAwMDEsIDEyMywgOTk5LCAtOTk5ICAgICAgICAgfCA0LDUgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUlJSUiAgICB8IC0wMDQzLCAwMDAxLCAyMDE3LCA5OTk5LCAtOTk5OSAgICB8IDQsNSAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBSUlJSUiAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMiw0LDUgfFxcbiAqIHwgRXh0ZW5kZWQgeWVhciAgICAgICAgICAgICAgICAgICB8IDEzMCB8IHUgICAgICAgfCAtNDMsIDEsIDE5MDAsIDIwMTcsIDk5OTksIC05OTkgICAgfCA0ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgdXUgICAgICB8IC00MywgMDEsIDk5LCAtOTkgICAgICAgICAgICAgICAgICB8IDQgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB1dXUgICAgIHwgLTA0MywgMDAxLCAxMjMsIDk5OSwgLTk5OSAgICAgICAgIHwgNCAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHV1dXUgICAgfCAtMDA0MywgMDAwMSwgMjAxNywgOTk5OSwgLTk5OTkgICAgfCA0ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgdXV1dXUgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDIsNCAgIHxcXG4gKiB8IFF1YXJ0ZXIgKGZvcm1hdHRpbmcpICAgICAgICAgICAgfCAxMjAgfCBRICAgICAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFFvICAgICAgfCAxc3QsIDJuZCwgM3JkLCA0dGggICAgICAgICAgICAgICAgfCA1ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUVEgICAgICB8IDAxLCAwMiwgMDMsIDA0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBRUVEgICAgIHwgUTEsIFEyLCBRMywgUTQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFFRUVEgICAgfCAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLiAgICAgfCAyICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgUVFRUVEgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8IDQgICAgIHxcXG4gKiB8IFF1YXJ0ZXIgKHN0YW5kLWFsb25lKSAgICAgICAgICAgfCAxMjAgfCBxICAgICAgIHwgMSwgMiwgMywgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHFvICAgICAgfCAxc3QsIDJuZCwgM3JkLCA0dGggICAgICAgICAgICAgICAgfCA1ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgcXEgICAgICB8IDAxLCAwMiwgMDMsIDA0ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBxcXEgICAgIHwgUTEsIFEyLCBRMywgUTQgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHFxcXEgICAgfCAxc3QgcXVhcnRlciwgMm5kIHF1YXJ0ZXIsIC4uLiAgICAgfCAyICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgcXFxcXEgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgICB8IDMgICAgIHxcXG4gKiB8IE1vbnRoIChmb3JtYXR0aW5nKSAgICAgICAgICAgICAgfCAxMTAgfCBNICAgICAgIHwgMSwgMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IE1vICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMnRoICAgICAgICAgICAgICAgfCA1ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTU0gICAgICB8IDAxLCAwMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBNTU0gICAgIHwgSmFuLCBGZWIsIC4uLiwgRGVjICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IE1NTU0gICAgfCBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlciAgfCAyICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTU1NTU0gICB8IEosIEYsIC4uLiwgRCAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8IE1vbnRoIChzdGFuZC1hbG9uZSkgICAgICAgICAgICAgfCAxMTAgfCBMICAgICAgIHwgMSwgMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IExvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMnRoICAgICAgICAgICAgICAgfCA1ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTEwgICAgICB8IDAxLCAwMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBMTEwgICAgIHwgSmFuLCBGZWIsIC4uLiwgRGVjICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IExMTEwgICAgfCBKYW51YXJ5LCBGZWJydWFyeSwgLi4uLCBEZWNlbWJlciAgfCAyICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgTExMTEwgICB8IEosIEYsIC4uLiwgRCAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8IExvY2FsIHdlZWsgb2YgeWVhciAgICAgICAgICAgICAgfCAxMDAgfCB3ICAgICAgIHwgMSwgMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHdvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA1M3RoICAgICAgICAgICAgICAgfCA1ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgd3cgICAgICB8IDAxLCAwMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8IElTTyB3ZWVrIG9mIHllYXIgICAgICAgICAgICAgICAgfCAxMDAgfCBJICAgICAgIHwgMSwgMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IElvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA1M3RoICAgICAgICAgICAgICAgfCA1ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgSUkgICAgICB8IDAxLCAwMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgICB8IDUgICAgIHxcXG4gKiB8IERheSBvZiBtb250aCAgICAgICAgICAgICAgICAgICAgfCAgOTAgfCBkICAgICAgIHwgMSwgMiwgLi4uLCAzMSAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGRvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAzMXN0ICAgICAgICAgICAgICAgfCA1ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgZGQgICAgICB8IDAxLCAwMiwgLi4uLCAzMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8IERheSBvZiB5ZWFyICAgICAgICAgICAgICAgICAgICAgfCAgOTAgfCBEICAgICAgIHwgMSwgMiwgLi4uLCAzNjUsIDM2NiAgICAgICAgICAgICAgIHwgNiAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IERvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAzNjV0aCwgMzY2dGggICAgICAgfCA1ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgREQgICAgICB8IDAxLCAwMiwgLi4uLCAzNjUsIDM2NiAgICAgICAgICAgICB8IDYgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBEREQgICAgIHwgMDAxLCAwMDIsIC4uLiwgMzY1LCAzNjYgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEREREQgICAgfCAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAyICAgICB8XFxuICogfCBEYXkgb2Ygd2VlayAoZm9ybWF0dGluZykgICAgICAgIHwgIDkwIHwgRS4uRUVFICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3UgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBFRUVFICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEVFRUVFICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgRUVFRUVFICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU3UsIFNhICAgICAgICB8ICAgICAgIHxcXG4gKiB8IElTTyBkYXkgb2Ygd2VlayAoZm9ybWF0dGluZykgICAgfCAgOTAgfCBpICAgICAgIHwgMSwgMiwgMywgLi4uLCA3ICAgICAgICAgICAgICAgICAgIHwgNSAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGlvICAgICAgfCAxc3QsIDJuZCwgLi4uLCA3dGggICAgICAgICAgICAgICAgfCA1ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgaWkgICAgICB8IDAxLCAwMiwgLi4uLCAwNyAgICAgICAgICAgICAgICAgICB8IDUgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBpaWkgICAgIHwgTW9uLCBUdWUsIFdlZCwgLi4uLCBTdSAgICAgICAgICAgIHwgNSAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGlpaWkgICAgfCBNb25kYXksIFR1ZXNkYXksIC4uLiwgU3VuZGF5ICAgICAgfCAyLDUgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgaWlpaWkgICB8IE0sIFQsIFcsIFQsIEYsIFMsIFMgICAgICAgICAgICAgICB8IDUgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBpaWlpaWkgIHwgTW8sIFR1LCBXZSwgVGgsIEZyLCBTdSwgU2EgICAgICAgIHwgNSAgICAgfFxcbiAqIHwgTG9jYWwgZGF5IG9mIHdlZWsgKGZvcm1hdHRpbmcpICB8ICA5MCB8IGUgICAgICAgfCAyLCAzLCA0LCAuLi4sIDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgZW8gICAgICB8IDJuZCwgM3JkLCAuLi4sIDFzdCAgICAgICAgICAgICAgICB8IDUgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBlZSAgICAgIHwgMDIsIDAzLCAuLi4sIDAxICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGVlZSAgICAgfCBNb24sIFR1ZSwgV2VkLCAuLi4sIFN1ICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgZWVlZSAgICB8IE1vbmRheSwgVHVlc2RheSwgLi4uLCBTdW5kYXkgICAgICB8IDIgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBlZWVlZSAgIHwgTSwgVCwgVywgVCwgRiwgUywgUyAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGVlZWVlZSAgfCBNbywgVHUsIFdlLCBUaCwgRnIsIFN1LCBTYSAgICAgICAgfCAgICAgICB8XFxuICogfCBMb2NhbCBkYXkgb2Ygd2VlayAoc3RhbmQtYWxvbmUpIHwgIDkwIHwgYyAgICAgICB8IDIsIDMsIDQsIC4uLiwgMSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBjbyAgICAgIHwgMm5kLCAzcmQsIC4uLiwgMXN0ICAgICAgICAgICAgICAgIHwgNSAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGNjICAgICAgfCAwMiwgMDMsIC4uLiwgMDEgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgY2NjICAgICB8IE1vbiwgVHVlLCBXZWQsIC4uLiwgU3UgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBjY2NjICAgIHwgTW9uZGF5LCBUdWVzZGF5LCAuLi4sIFN1bmRheSAgICAgIHwgMiAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGNjY2NjICAgfCBNLCBULCBXLCBULCBGLCBTLCBTICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgY2NjY2NjICB8IE1vLCBUdSwgV2UsIFRoLCBGciwgU3UsIFNhICAgICAgICB8ICAgICAgIHxcXG4gKiB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgODAgfCBhLi5hYWEgIHwgQU0sIFBNICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGFhYWEgICAgfCBhLm0uLCBwLm0uICAgICAgICAgICAgICAgICAgICAgICAgfCAyICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgYWFhYWEgICB8IGEsIHAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8IEFNLCBQTSwgbm9vbiwgbWlkbmlnaHQgICAgICAgICAgfCAgODAgfCBiLi5iYmIgIHwgQU0sIFBNLCBub29uLCBtaWRuaWdodCAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGJiYmIgICAgfCBhLm0uLCBwLm0uLCBub29uLCBtaWRuaWdodCAgICAgICAgfCAyICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgYmJiYmIgICB8IGEsIHAsIG4sIG1pICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8IEZsZXhpYmxlIGRheSBwZXJpb2QgICAgICAgICAgICAgfCAgODAgfCBCLi5CQkIgIHwgYXQgbmlnaHQsIGluIHRoZSBtb3JuaW5nLCAuLi4gICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEJCQkIgICAgfCBhdCBuaWdodCwgaW4gdGhlIG1vcm5pbmcsIC4uLiAgICAgfCAyICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgQkJCQkIgICB8IGF0IG5pZ2h0LCBpbiB0aGUgbW9ybmluZywgLi4uICAgICB8ICAgICAgIHxcXG4gKiB8IEhvdXIgWzEtMTJdICAgICAgICAgICAgICAgICAgICAgfCAgNzAgfCBoICAgICAgIHwgMSwgMiwgLi4uLCAxMSwgMTIgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGhvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMXRoLCAxMnRoICAgICAgICAgfCA1ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgaGggICAgICB8IDAxLCAwMiwgLi4uLCAxMSwgMTIgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8IEhvdXIgWzAtMjNdICAgICAgICAgICAgICAgICAgICAgfCAgNzAgfCBIICAgICAgIHwgMCwgMSwgMiwgLi4uLCAyMyAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEhvICAgICAgfCAwdGgsIDFzdCwgMm5kLCAuLi4sIDIzcmQgICAgICAgICAgfCA1ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgSEggICAgICB8IDAwLCAwMSwgMDIsIC4uLiwgMjMgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8IEhvdXIgWzAtMTFdICAgICAgICAgICAgICAgICAgICAgfCAgNzAgfCBLICAgICAgIHwgMSwgMiwgLi4uLCAxMSwgMCAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IEtvICAgICAgfCAxc3QsIDJuZCwgLi4uLCAxMXRoLCAwdGggICAgICAgICAgfCA1ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgS0sgICAgICB8IDEsIDIsIC4uLiwgMTEsIDAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8IEhvdXIgWzEtMjRdICAgICAgICAgICAgICAgICAgICAgfCAgNzAgfCBrICAgICAgIHwgMjQsIDEsIDIsIC4uLiwgMjMgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IGtvICAgICAgfCAyNHRoLCAxc3QsIDJuZCwgLi4uLCAyM3JkICAgICAgICAgfCA1ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwga2sgICAgICB8IDI0LCAwMSwgMDIsIC4uLiwgMjMgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8IE1pbnV0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgNjAgfCBtICAgICAgIHwgMCwgMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IG1vICAgICAgfCAwdGgsIDFzdCwgLi4uLCA1OXRoICAgICAgICAgICAgICAgfCA1ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgbW0gICAgICB8IDAwLCAwMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8IFNlY29uZCAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgNTAgfCBzICAgICAgIHwgMCwgMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHNvICAgICAgfCAwdGgsIDFzdCwgLi4uLCA1OXRoICAgICAgICAgICAgICAgfCA1ICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgc3MgICAgICB8IDAwLCAwMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8IEZyYWN0aW9uIG9mIHNlY29uZCAgICAgICAgICAgICAgfCAgNDAgfCBTICAgICAgIHwgMCwgMSwgLi4uLCA5ICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFNTICAgICAgfCAwMCwgMDEsIC4uLiwgOTkgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgU1NTICAgICB8IDAwMCwgMDAwMSwgLi4uLCA5OTkgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBTU1NTICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMiAgICAgfFxcbiAqIHwgVGltZXpvbmUgKElTTy04NjAxIHcvIFopICAgICAgICB8ICAyMCB8IFggICAgICAgfCAtMDgsICswNTMwLCBaICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWFggICAgICB8IC0wODAwLCArMDUzMCwgWiAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCBYWFggICAgIHwgLTA4OjAwLCArMDU6MzAsIFogICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IFhYWFggICAgfCAtMDgwMCwgKzA1MzAsIFosICsxMjM0NTYgICAgICAgICAgfCAyICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgWFhYWFggICB8IC0wODowMCwgKzA1OjMwLCBaLCArMTI6MzQ6NTYgICAgICB8ICAgICAgIHxcXG4gKiB8IFRpbWV6b25lIChJU08tODYwMSB3L28gWikgICAgICAgfCAgMjAgfCB4ICAgICAgIHwgLTA4LCArMDUzMCwgKzAwICAgICAgICAgICAgICAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHh4ICAgICAgfCAtMDgwMCwgKzA1MzAsICswMDAwICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgeHh4ICAgICB8IC0wODowMCwgKzA1OjMwLCArMDA6MDAgICAgICAgICAgICB8IDIgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB4eHh4ICAgIHwgLTA4MDAsICswNTMwLCArMDAwMCwgKzEyMzQ1NiAgICAgIHwgICAgICAgfFxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8IHh4eHh4ICAgfCAtMDg6MDAsICswNTozMCwgKzAwOjAwLCArMTI6MzQ6NTYgfCAgICAgICB8XFxuICogfCBTZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICAgICAgIHwgIDEwIHwgdCAgICAgICB8IDUxMjk2OTUyMCAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHxcXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCB0dCAgICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgMiAgICAgfFxcbiAqIHwgTWlsbGlzZWNvbmRzIHRpbWVzdGFtcCAgICAgICAgICB8ICAxMCB8IFQgICAgICAgfCA1MTI5Njk1MjA5MDAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8XFxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgVFQgICAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IDIgICAgIHxcXG4gKiBOb3RlczpcXG4gKiAxLiBcXFwiRm9ybWF0dGluZ1xcXCIgdW5pdHMgKGUuZy4gZm9ybWF0dGluZyBxdWFydGVyKSBpbiB0aGUgZGVmYXVsdCBlbi1VUyBsb2NhbGVcXG4gKiAgICBhcmUgdGhlIHNhbWUgYXMgXFxcInN0YW5kLWFsb25lXFxcIiB1bml0cywgYnV0IGFyZSBkaWZmZXJlbnQgaW4gc29tZSBsYW5ndWFnZXMuXFxuICogICAgXFxcIkZvcm1hdHRpbmdcXFwiIHVuaXRzIGFyZSBkZWNsaW5lZCBhY2NvcmRpbmcgdG8gdGhlIHJ1bGVzIG9mIHRoZSBsYW5ndWFnZVxcbiAqICAgIGluIHRoZSBjb250ZXh0IG9mIGEgZGF0ZS4gXFxcIlN0YW5kLWFsb25lXFxcIiB1bml0cyBhcmUgYWx3YXlzIG5vbWluYXRpdmUgc2luZ3VsYXIuXFxuICogICAgSW4gYGZvcm1hdGAgZnVuY3Rpb24sIHRoZXkgd2lsbCBwcm9kdWNlIGRpZmZlcmVudCByZXN1bHQ6XFxuICpcXG4gKiAgICBgZm9ybWF0KG5ldyBEYXRlKDIwMTcsIDEwLCA2KSwgJ2RvIExMTEwnLCB7bG9jYWxlOiBjc30pIC8vPT4gJzYuIGxpc3RvcGFkJ2BcXG4gKlxcbiAqICAgIGBmb3JtYXQobmV3IERhdGUoMjAxNywgMTAsIDYpLCAnZG8gTU1NTScsIHtsb2NhbGU6IGNzfSkgLy89PiAnNi4gbGlzdG9wYWR1J2BcXG4gKlxcbiAqICAgIGBwYXJzZWAgd2lsbCB0cnkgdG8gbWF0Y2ggYm90aCBmb3JtYXR0aW5nIGFuZCBzdGFuZC1hbG9uZSB1bml0cyBpbnRlcmNoYW5nYWJseS5cXG4gKlxcbiAqIDIuIEFueSBzZXF1ZW5jZSBvZiB0aGUgaWRlbnRpY2FsIGxldHRlcnMgaXMgYSBwYXR0ZXJuLCB1bmxlc3MgaXQgaXMgZXNjYXBlZCBieVxcbiAqICAgIHRoZSBzaW5nbGUgcXVvdGUgY2hhcmFjdGVycyAoc2VlIGJlbG93KS5cXG4gKiAgICBJZiB0aGUgc2VxdWVuY2UgaXMgbG9uZ2VyIHRoYW4gbGlzdGVkIGluIHRhYmxlOlxcbiAqICAgIC0gZm9yIG51bWVyaWNhbCB1bml0cyAoYHl5eXl5eXl5YCkgYHBhcnNlYCB3aWxsIHRyeSB0byBtYXRjaCBhIG51bWJlclxcbiAqICAgICAgYXMgd2lkZSBhcyB0aGUgc2VxdWVuY2VcXG4gKiAgICAtIGZvciB0ZXh0IHVuaXRzIChgTU1NTU1NTU1gKSBgcGFyc2VgIHdpbGwgdHJ5IHRvIG1hdGNoIHRoZSB3aWRlc3QgdmFyaWF0aW9uIG9mIHRoZSB1bml0LlxcbiAqICAgICAgVGhlc2UgdmFyaWF0aW9ucyBhcmUgbWFya2VkIHdpdGggXFxcIjJcXFwiIGluIHRoZSBsYXN0IGNvbHVtbiBvZiB0aGUgdGFibGUuXFxuICpcXG4gKiAzLiBgUVFRUVFgIGFuZCBgcXFxcXFgIGNvdWxkIGJlIG5vdCBzdHJpY3RseSBudW1lcmljYWwgaW4gc29tZSBsb2NhbGVzLlxcbiAqICAgIFRoZXNlIHRva2VucyByZXByZXNlbnQgdGhlIHNob3J0ZXN0IGZvcm0gb2YgdGhlIHF1YXJ0ZXIuXFxuICpcXG4gKiA0LiBUaGUgbWFpbiBkaWZmZXJlbmNlIGJldHdlZW4gYHlgIGFuZCBgdWAgcGF0dGVybnMgYXJlIEIuQy4geWVhcnM6XFxuICpcXG4gKiAgICB8IFllYXIgfCBgeWAgfCBgdWAgfFxcbiAqICAgIHwtLS0tLS18LS0tLS18LS0tLS18XFxuICogICAgfCBBQyAxIHwgICAxIHwgICAxIHxcXG4gKiAgICB8IEJDIDEgfCAgIDEgfCAgIDAgfFxcbiAqICAgIHwgQkMgMiB8ICAgMiB8ICAtMSB8XFxuICpcXG4gKiAgICBBbHNvIGB5eWAgd2lsbCB0cnkgdG8gZ3Vlc3MgdGhlIGNlbnR1cnkgb2YgdHdvIGRpZ2l0IHllYXIgYnkgcHJveGltaXR5IHdpdGggYGJhc2VEYXRlYDpcXG4gKlxcbiAqICAgIGBwYXJzZSgnNTAnLCAneXknLCBuZXcgRGF0ZSgyMDE4LCAwLCAxKSkgLy89PiBTYXQgSmFuIDAxIDIwNTAgMDA6MDA6MDBgXFxuICpcXG4gKiAgICBgcGFyc2UoJzc1JywgJ3l5JywgbmV3IERhdGUoMjAxOCwgMCwgMSkpIC8vPT4gV2VkIEphbiAwMSAxOTc1IDAwOjAwOjAwYFxcbiAqXFxuICogICAgd2hpbGUgYHV1YCB3aWxsIGp1c3QgYXNzaWduIHRoZSB5ZWFyIGFzIGlzOlxcbiAqXFxuICogICAgYHBhcnNlKCc1MCcsICd1dScsIG5ldyBEYXRlKDIwMTgsIDAsIDEpKSAvLz0+IFNhdCBKYW4gMDEgMDA1MCAwMDowMDowMGBcXG4gKlxcbiAqICAgIGBwYXJzZSgnNzUnLCAndXUnLCBuZXcgRGF0ZSgyMDE4LCAwLCAxKSkgLy89PiBUdWUgSmFuIDAxIDAwNzUgMDA6MDA6MDBgXFxuICpcXG4gKiAgICBUaGUgc2FtZSBkaWZmZXJlbmNlIGlzIHRydWUgZm9yIGxvY2FsIGFuZCBJU08gd2Vlay1udW1iZXJpbmcgeWVhcnMgKGBZYCBhbmQgYFJgKSxcXG4gKiAgICBleGNlcHQgbG9jYWwgd2Vlay1udW1iZXJpbmcgeWVhcnMgYXJlIGRlcGVuZGVudCBvbiBgb3B0aW9ucy53ZWVrU3RhcnRzT25gXFxuICogICAgYW5kIGBvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZWAgKGNvbXBhcmUgW3NldElTT1dlZWtZZWFyXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL3NldElTT1dlZWtZZWFyfVxcbiAqICAgIGFuZCBbc2V0V2Vla1llYXJde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3Mvc2V0V2Vla1llYXJ9KS5cXG4gKlxcbiAqIDUuIFRoZXNlIHBhdHRlcm5zIGFyZSBub3QgaW4gdGhlIFVuaWNvZGUgVGVjaG5pY2FsIFN0YW5kYXJkICMzNTpcXG4gKiAgICAtIGBpYDogSVNPIGRheSBvZiB3ZWVrXFxuICogICAgLSBgSWA6IElTTyB3ZWVrIG9mIHllYXJcXG4gKiAgICAtIGBSYDogSVNPIHdlZWstbnVtYmVyaW5nIHllYXJcXG4gKiAgICAtIGBvYDogb3JkaW5hbCBudW1iZXIgbW9kaWZpZXJcXG4gKlxcbiAqIDYuIFRoZXNlIHRva2VucyBhcmUgb2Z0ZW4gY29uZnVzZWQgd2l0aCBvdGhlcnMuIFNlZTogaHR0cHM6Ly9naXQuaW8vZnhDeXJcXG4gKlxcbiAqIFZhbHVlcyB3aWxsIGJlIGFzc2lnbmVkIHRvIHRoZSBkYXRlIGluIHRoZSBkZXNjZW5kaW5nIG9yZGVyIG9mIGl0cyB1bml0J3MgcHJpb3JpdHkuXFxuICogVW5pdHMgb2YgYW4gZXF1YWwgcHJpb3JpdHkgb3ZlcndyaXRlIGVhY2ggb3RoZXIgaW4gdGhlIG9yZGVyIG9mIGFwcGVhcmFuY2UuXFxuICpcXG4gKiBJZiBubyB2YWx1ZXMgb2YgaGlnaGVyIHByaW9yaXR5IGFyZSBwYXJzZWQgKGUuZy4gd2hlbiBwYXJzaW5nIHN0cmluZyAnSmFudWFyeSAxc3QnIHdpdGhvdXQgYSB5ZWFyKSxcXG4gKiB0aGUgdmFsdWVzIHdpbGwgYmUgdGFrZW4gZnJvbSAzcmQgYXJndW1lbnQgYGJhc2VEYXRlYCB3aGljaCB3b3JrcyBhcyBhIGNvbnRleHQgb2YgcGFyc2luZy5cXG4gKlxcbiAqIGBiYXNlRGF0ZWAgbXVzdCBiZSBwYXNzZWQgZm9yIGNvcnJlY3Qgd29yayBvZiB0aGUgZnVuY3Rpb24uXFxuICogSWYgeW91J3JlIG5vdCBzdXJlIHdoaWNoIGBiYXNlRGF0ZWAgdG8gc3VwcGx5LCBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgRGF0ZTpcXG4gKiBgcGFyc2UoJzAyLzExLzIwMTQnLCAnTU0vZGQveXl5eScsIG5ldyBEYXRlKCkpYFxcbiAqIEluIHRoaXMgY2FzZSBwYXJzaW5nIHdpbGwgYmUgZG9uZSBpbiB0aGUgY29udGV4dCBvZiB0aGUgY3VycmVudCBkYXRlLlxcbiAqIElmIGBiYXNlRGF0ZWAgaXMgYEludmFsaWQgRGF0ZWAgb3IgYSB2YWx1ZSBub3QgY29udmVydGlibGUgdG8gdmFsaWQgYERhdGVgLFxcbiAqIHRoZW4gYEludmFsaWQgRGF0ZWAgd2lsbCBiZSByZXR1cm5lZC5cXG4gKlxcbiAqIFRoZSByZXN1bHQgbWF5IHZhcnkgYnkgbG9jYWxlLlxcbiAqXFxuICogSWYgYGZvcm1hdFN0cmluZ2AgbWF0Y2hlcyB3aXRoIGBkYXRlU3RyaW5nYCBidXQgZG9lcyBub3QgcHJvdmlkZXMgdG9rZW5zLCBgYmFzZURhdGVgIHdpbGwgYmUgcmV0dXJuZWQuXFxuICpcXG4gKiBJZiBwYXJzaW5nIGZhaWxlZCwgYEludmFsaWQgRGF0ZWAgd2lsbCBiZSByZXR1cm5lZC5cXG4gKiBJbnZhbGlkIERhdGUgaXMgYSBEYXRlLCB3aG9zZSB0aW1lIHZhbHVlIGlzIE5hTi5cXG4gKiBUaW1lIHZhbHVlIG9mIERhdGU6IGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuOS4xLjFcXG4gKlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRlU3RyaW5nIC0gdGhlIHN0cmluZyB0byBwYXJzZVxcbiAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXRTdHJpbmcgLSB0aGUgc3RyaW5nIG9mIHRva2Vuc1xcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBiYXNlRGF0ZSAtIGRlZmluZXMgdmFsdWVzIG1pc3NpbmcgZnJvbSB0aGUgcGFyc2VkIGRhdGVTdHJpbmdcXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zLiBTZWUgW09wdGlvbnNde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvT3B0aW9uc31cXG4gKiBAcGFyYW0gezB8MXwyfSBbb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzPTJdIC0gcGFzc2VkIHRvIGB0b0RhdGVgLiBTZWUgW3RvRGF0ZV17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy90b0RhdGV9XFxuICogQHBhcmFtIHtMb2NhbGV9IFtvcHRpb25zLmxvY2FsZT1kZWZhdWx0TG9jYWxlXSAtIHRoZSBsb2NhbGUgb2JqZWN0LiBTZWUgW0xvY2FsZV17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9Mb2NhbGV9XFxuICogQHBhcmFtIHswfDF8MnwzfDR8NXw2fSBbb3B0aW9ucy53ZWVrU3RhcnRzT249MF0gLSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayAoMCAtIFN1bmRheSlcXG4gKiBAcGFyYW0gezF8MnwzfDR8NXw2fDd9IFtvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZT0xXSAtIHRoZSBkYXkgb2YgSmFudWFyeSwgd2hpY2ggaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyXFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hd2FyZU9mVW5pY29kZVRva2Vucz1mYWxzZV0gLSBpZiB0cnVlLCBhbGxvd3MgdXNhZ2Ugb2YgVW5pY29kZSB0b2tlbnMgY2F1c2VzIGNvbmZ1c2lvbjpcXG4gKiAgIC0gU29tZSBvZiB0aGUgZGF5IG9mIHllYXIgdG9rZW5zIChgRGAsIGBERGApIHRoYXQgYXJlIGNvbmZ1c2VkIHdpdGggdGhlIGRheSBvZiBtb250aCB0b2tlbnMgKGBkYCwgYGRkYCkuXFxuICogICAtIFNvbWUgb2YgdGhlIGxvY2FsIHdlZWstbnVtYmVyaW5nIHllYXIgdG9rZW5zIChgWVlgLCBgWVlZWWApIHRoYXQgYXJlIGNvbmZ1c2VkIHdpdGggdGhlIGNhbGVuZGFyIHllYXIgdG9rZW5zIChgeXlgLCBgeXl5eWApLlxcbiAqICAgU2VlOiBodHRwczovL2dpdC5pby9meEN5clxcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgcGFyc2VkIGRhdGVcXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDMgYXJndW1lbnRzIHJlcXVpcmVkXFxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0c2AgbXVzdCBiZSAwLCAxIG9yIDJcXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy53ZWVrU3RhcnRzT25gIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA2XFxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlYCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgN1xcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmxvY2FsZWAgbXVzdCBjb250YWluIGBtYXRjaGAgcHJvcGVydHlcXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hd2FyZU9mVW5pY29kZVRva2Vuc2AgbXVzdCBiZSBzZXQgdG8gYHRydWVgIHRvIHVzZSBgWFhgIHRva2VuOyBzZWU6IGh0dHBzOi8vZ2l0LmlvL2Z4Q3lyXFxuICpcXG4gKiBAZXhhbXBsZVxcbiAqIC8vIFBhcnNlIDExIEZlYnJ1YXJ5IDIwMTQgZnJvbSBtaWRkbGUtZW5kaWFuIGZvcm1hdDpcXG4gKiB2YXIgcmVzdWx0ID0gcGFyc2UoXFxuICogICAnMDIvMTEvMjAxNCcsXFxuICogICAnTU0vZGQveXl5eScsXFxuICogICBuZXcgRGF0ZSgpXFxuICogKVxcbiAqIC8vPT4gVHVlIEZlYiAxMSAyMDE0IDAwOjAwOjAwXFxuICpcXG4gKiBAZXhhbXBsZVxcbiAqIC8vIFBhcnNlIDI4dGggb2YgRmVicnVhcnkgaW4gRXNwZXJhbnRvIGxvY2FsZSBpbiB0aGUgY29udGV4dCBvZiAyMDEwIHllYXI6XFxuICogaW1wb3J0IGVvIGZyb20gJ2RhdGUtZm5zL2xvY2FsZS9lbydcXG4gKiB2YXIgcmVzdWx0ID0gcGFyc2UoXFxuICogICAnMjgtYSBkZSBmZWJydWFybycsXFxuICogICBcXFwiZG8gJ2RlJyBNTU1NXFxcIixcXG4gKiAgIG5ldyBEYXRlKDIwMTAsIDAsIDEpLFxcbiAqICAge2xvY2FsZTogZW99XFxuICogKVxcbiAqIC8vPT4gU3VuIEZlYiAyOCAyMDEwIDAwOjAwOjAwXFxuICovXFxuZnVuY3Rpb24gcGFyc2UoXFxuICBkaXJ0eURhdGVTdHJpbmcsXFxuICBkaXJ0eUZvcm1hdFN0cmluZyxcXG4gIGRpcnR5QmFzZURhdGUsXFxuICBkaXJ0eU9wdGlvbnNcXG4pIHtcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcbiAgICAgICczIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnXFxuICAgIClcXG4gIH1cXG5cXG4gIHZhciBkYXRlU3RyaW5nID0gU3RyaW5nKGRpcnR5RGF0ZVN0cmluZyk7XFxuICB2YXIgZm9ybWF0U3RyaW5nID0gU3RyaW5nKGRpcnR5Rm9ybWF0U3RyaW5nKTtcXG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9O1xcblxcbiAgdmFyIGxvY2FsZSA9IG9wdGlvbnMubG9jYWxlIHx8IGxvY2FsZSQxO1xcblxcbiAgaWYgKCFsb2NhbGUubWF0Y2gpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2xvY2FsZSBtdXN0IGNvbnRhaW4gbWF0Y2ggcHJvcGVydHknKVxcbiAgfVxcblxcbiAgdmFyIGxvY2FsZUZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9XFxuICAgIGxvY2FsZS5vcHRpb25zICYmIGxvY2FsZS5vcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZTtcXG4gIHZhciBkZWZhdWx0Rmlyc3RXZWVrQ29udGFpbnNEYXRlID1cXG4gICAgbG9jYWxlRmlyc3RXZWVrQ29udGFpbnNEYXRlID09IG51bGxcXG4gICAgICA/IDFcXG4gICAgICA6IHRvSW50ZWdlcihsb2NhbGVGaXJzdFdlZWtDb250YWluc0RhdGUpO1xcbiAgdmFyIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9XFxuICAgIG9wdGlvbnMuZmlyc3RXZWVrQ29udGFpbnNEYXRlID09IG51bGxcXG4gICAgICA/IGRlZmF1bHRGaXJzdFdlZWtDb250YWluc0RhdGVcXG4gICAgICA6IHRvSW50ZWdlcihvcHRpb25zLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSk7XFxuXFxuICAvLyBUZXN0IGlmIHdlZWtTdGFydHNPbiBpcyBiZXR3ZWVuIDEgYW5kIDcgX2FuZF8gaXMgbm90IE5hTlxcbiAgaWYgKCEoZmlyc3RXZWVrQ29udGFpbnNEYXRlID49IDEgJiYgZmlyc3RXZWVrQ29udGFpbnNEYXRlIDw9IDcpKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxcbiAgICAgICdmaXJzdFdlZWtDb250YWluc0RhdGUgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDcgaW5jbHVzaXZlbHknXFxuICAgIClcXG4gIH1cXG5cXG4gIHZhciBsb2NhbGVXZWVrU3RhcnRzT24gPSBsb2NhbGUub3B0aW9ucyAmJiBsb2NhbGUub3B0aW9ucy53ZWVrU3RhcnRzT247XFxuICB2YXIgZGVmYXVsdFdlZWtTdGFydHNPbiA9XFxuICAgIGxvY2FsZVdlZWtTdGFydHNPbiA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihsb2NhbGVXZWVrU3RhcnRzT24pO1xcbiAgdmFyIHdlZWtTdGFydHNPbiA9XFxuICAgIG9wdGlvbnMud2Vla1N0YXJ0c09uID09IG51bGxcXG4gICAgICA/IGRlZmF1bHRXZWVrU3RhcnRzT25cXG4gICAgICA6IHRvSW50ZWdlcihvcHRpb25zLndlZWtTdGFydHNPbik7XFxuXFxuICAvLyBUZXN0IGlmIHdlZWtTdGFydHNPbiBpcyBiZXR3ZWVuIDAgYW5kIDYgX2FuZF8gaXMgbm90IE5hTlxcbiAgaWYgKCEod2Vla1N0YXJ0c09uID49IDAgJiYgd2Vla1N0YXJ0c09uIDw9IDYpKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd3ZWVrU3RhcnRzT24gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYgaW5jbHVzaXZlbHknKVxcbiAgfVxcblxcbiAgaWYgKGZvcm1hdFN0cmluZyA9PT0gJycpIHtcXG4gICAgaWYgKGRhdGVTdHJpbmcgPT09ICcnKSB7XFxuICAgICAgcmV0dXJuIHRvRGF0ZShkaXJ0eUJhc2VEYXRlLCBvcHRpb25zKVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBzdWJGbk9wdGlvbnMgPSB7XFxuICAgIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZTogZmlyc3RXZWVrQ29udGFpbnNEYXRlLFxcbiAgICB3ZWVrU3RhcnRzT246IHdlZWtTdGFydHNPbixcXG4gICAgbG9jYWxlOiBsb2NhbGVcXG4gIH07XFxuXFxuICAvLyBJZiB0aW1lem9uZSBpc24ndCBzcGVjaWZpZWQsIGl0IHdpbGwgYmUgc2V0IHRvIHRoZSBzeXN0ZW0gdGltZXpvbmVcXG4gIHZhciBzZXR0ZXJzID0gW1xcbiAgICB7XFxuICAgICAgcHJpb3JpdHk6IFRJTUVaT05FX1VOSVRfUFJJT1JJVFksXFxuICAgICAgc2V0OiBkYXRlVG9TeXN0ZW1UaW1lem9uZSxcXG4gICAgICBpbmRleDogMFxcbiAgICB9XFxuICBdO1xcblxcbiAgdmFyIGk7XFxuXFxuICB2YXIgdG9rZW5zID0gZm9ybWF0U3RyaW5nLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnNSZWdFeHAkMSk7XFxuXFxuICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcXG5cXG4gICAgaWYgKCFvcHRpb25zLmF3YXJlT2ZVbmljb2RlVG9rZW5zICYmIGlzUHJvdGVjdGVkVG9rZW4odG9rZW4pKSB7XFxuICAgICAgdGhyb3dQcm90ZWN0ZWRFcnJvcih0b2tlbik7XFxuICAgIH1cXG5cXG4gICAgdmFyIGZpcnN0Q2hhcmFjdGVyID0gdG9rZW5bMF07XFxuICAgIHZhciBwYXJzZXIgPSBwYXJzZXJzW2ZpcnN0Q2hhcmFjdGVyXTtcXG4gICAgaWYgKHBhcnNlcikge1xcbiAgICAgIHZhciBwYXJzZVJlc3VsdCA9IHBhcnNlci5wYXJzZShcXG4gICAgICAgIGRhdGVTdHJpbmcsXFxuICAgICAgICB0b2tlbixcXG4gICAgICAgIGxvY2FsZS5tYXRjaCxcXG4gICAgICAgIHN1YkZuT3B0aW9uc1xcbiAgICAgICk7XFxuXFxuICAgICAgaWYgKCFwYXJzZVJlc3VsdCkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcXG4gICAgICB9XFxuXFxuICAgICAgc2V0dGVycy5wdXNoKHtcXG4gICAgICAgIHByaW9yaXR5OiBwYXJzZXIucHJpb3JpdHksXFxuICAgICAgICBzZXQ6IHBhcnNlci5zZXQsXFxuICAgICAgICB2YWxpZGF0ZTogcGFyc2VyLnZhbGlkYXRlLFxcbiAgICAgICAgdmFsdWU6IHBhcnNlUmVzdWx0LnZhbHVlLFxcbiAgICAgICAgaW5kZXg6IHNldHRlcnMubGVuZ3RoXFxuICAgICAgfSk7XFxuXFxuICAgICAgZGF0ZVN0cmluZyA9IHBhcnNlUmVzdWx0LnJlc3Q7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gUmVwbGFjZSB0d28gc2luZ2xlIHF1b3RlIGNoYXJhY3RlcnMgd2l0aCBvbmUgc2luZ2xlIHF1b3RlIGNoYXJhY3RlclxcbiAgICAgIGlmICh0b2tlbiA9PT0gXFxcIicnXFxcIikge1xcbiAgICAgICAgdG9rZW4gPSBcXFwiJ1xcXCI7XFxuICAgICAgfSBlbHNlIGlmIChmaXJzdENoYXJhY3RlciA9PT0gXFxcIidcXFwiKSB7XFxuICAgICAgICB0b2tlbiA9IGNsZWFuRXNjYXBlZFN0cmluZyQxKHRva2VuKTtcXG4gICAgICB9XFxuXFxuICAgICAgLy8gQ3V0IHRva2VuIGZyb20gc3RyaW5nLCBvciwgaWYgc3RyaW5nIGRvZXNuJ3QgbWF0Y2ggdGhlIHRva2VuLCByZXR1cm4gSW52YWxpZCBEYXRlXFxuICAgICAgaWYgKGRhdGVTdHJpbmcuaW5kZXhPZih0b2tlbikgPT09IDApIHtcXG4gICAgICAgIGRhdGVTdHJpbmcgPSBkYXRlU3RyaW5nLnNsaWNlKHRva2VuLmxlbmd0aCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICAvLyBDaGVjayBpZiB0aGUgcmVtYWluaW5nIGlucHV0IGNvbnRhaW5zIHNvbWV0aGluZyBvdGhlciB0aGFuIHdoaXRlc3BhY2VcXG4gIGlmIChkYXRlU3RyaW5nLmxlbmd0aCA+IDAgJiYgbm90V2hpdGVzcGFjZVJlZ0V4cC50ZXN0KGRhdGVTdHJpbmcpKSB7XFxuICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXFxuICB9XFxuXFxuICB2YXIgdW5pcXVlUHJpb3JpdHlTZXR0ZXJzID0gc2V0dGVyc1xcbiAgICAubWFwKGZ1bmN0aW9uKHNldHRlcikge1xcbiAgICAgIHJldHVybiBzZXR0ZXIucHJpb3JpdHlcXG4gICAgfSlcXG4gICAgLnNvcnQoZnVuY3Rpb24oYSwgYikge1xcbiAgICAgIHJldHVybiBiIC0gYVxcbiAgICB9KVxcbiAgICAuZmlsdGVyKGZ1bmN0aW9uKHByaW9yaXR5LCBpbmRleCwgYXJyYXkpIHtcXG4gICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihwcmlvcml0eSkgPT09IGluZGV4XFxuICAgIH0pXFxuICAgIC5tYXAoZnVuY3Rpb24ocHJpb3JpdHkpIHtcXG4gICAgICByZXR1cm4gc2V0dGVyc1xcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbihzZXR0ZXIpIHtcXG4gICAgICAgICAgcmV0dXJuIHNldHRlci5wcmlvcml0eSA9PT0gcHJpb3JpdHlcXG4gICAgICAgIH0pXFxuICAgICAgICAucmV2ZXJzZSgpXFxuICAgIH0pXFxuICAgIC5tYXAoZnVuY3Rpb24oc2V0dGVyQXJyYXkpIHtcXG4gICAgICByZXR1cm4gc2V0dGVyQXJyYXlbMF1cXG4gICAgfSk7XFxuXFxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eUJhc2VEYXRlLCBvcHRpb25zKTtcXG5cXG4gIGlmIChpc05hTihkYXRlKSkge1xcbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxcbiAgfVxcblxcbiAgLy8gQ29udmVydCB0aGUgZGF0ZSBpbiBzeXN0ZW0gdGltZXpvbmUgdG8gdGhlIHNhbWUgZGF0ZSBpbiBVVEMrMDA6MDAgdGltZXpvbmUuXFxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB3aGVuIFVUQyBmdW5jdGlvbnMgd2lsbCBiZSBpbXBsZW1lbnRlZCwgbG9jYWxlcyB3aWxsIGJlIGNvbXBhdGlibGUgd2l0aCB0aGVtLlxcbiAgLy8gU2VlIGFuIGlzc3VlIGFib3V0IFVUQyBmdW5jdGlvbnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9pc3N1ZXMvMzdcXG4gIHZhciB1dGNEYXRlID0gc3ViTWlsbGlzZWNvbmRzKGRhdGUsIGdldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMoZGF0ZSkpO1xcblxcbiAgZm9yIChpID0gMDsgaSA8IHVuaXF1ZVByaW9yaXR5U2V0dGVycy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgc2V0dGVyID0gdW5pcXVlUHJpb3JpdHlTZXR0ZXJzW2ldO1xcblxcbiAgICBpZiAoXFxuICAgICAgc2V0dGVyLnZhbGlkYXRlICYmXFxuICAgICAgIXNldHRlci52YWxpZGF0ZSh1dGNEYXRlLCBzZXR0ZXIudmFsdWUsIHN1YkZuT3B0aW9ucylcXG4gICAgKSB7XFxuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcXG4gICAgfVxcblxcbiAgICB1dGNEYXRlID0gc2V0dGVyLnNldCh1dGNEYXRlLCBzZXR0ZXIudmFsdWUsIHN1YkZuT3B0aW9ucyk7XFxuICB9XFxuXFxuICByZXR1cm4gdXRjRGF0ZVxcbn1cXG5cXG5mdW5jdGlvbiBkYXRlVG9TeXN0ZW1UaW1lem9uZShkYXRlKSB7XFxuICB2YXIgY29udmVydGVkRGF0ZSA9IG5ldyBEYXRlKDApO1xcbiAgY29udmVydGVkRGF0ZS5zZXRGdWxsWWVhcihcXG4gICAgZGF0ZS5nZXRVVENGdWxsWWVhcigpLFxcbiAgICBkYXRlLmdldFVUQ01vbnRoKCksXFxuICAgIGRhdGUuZ2V0VVRDRGF0ZSgpXFxuICApO1xcbiAgY29udmVydGVkRGF0ZS5zZXRIb3VycyhcXG4gICAgZGF0ZS5nZXRVVENIb3VycygpLFxcbiAgICBkYXRlLmdldFVUQ01pbnV0ZXMoKSxcXG4gICAgZGF0ZS5nZXRVVENTZWNvbmRzKCksXFxuICAgIGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKClcXG4gICk7XFxuICByZXR1cm4gY29udmVydGVkRGF0ZVxcbn1cXG5cXG5mdW5jdGlvbiBjbGVhbkVzY2FwZWRTdHJpbmckMShpbnB1dCkge1xcbiAgcmV0dXJuIGlucHV0Lm1hdGNoKGVzY2FwZWRTdHJpbmdSZWdFeHAkMSlbMV0ucmVwbGFjZShkb3VibGVRdW90ZVJlZ0V4cCQxLCBcXFwiJ1xcXCIpXFxufVxcblxcbi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYXV0b21hdGljYWxseSBieSBgc2NyaXB0cy9idWlsZC9pbmRpY2VzLmpzYC4gUGxlYXNlLCBkb24ndCBjaGFuZ2UgaXQuXFxuXFxuLy8gXFxuXFxuLyoqXFxuICogQ3VzdG9tIHBhcnNlIGJlaGF2aW9yIG9uIHRvcCBvZiBkYXRlLWZucyBwYXJzZSBmdW5jdGlvbi5cXG4gKi9cXG5mdW5jdGlvbiBwYXJzZURhdGUkMSAoZGF0ZSwgZm9ybWF0JDEpIHtcXG4gIGlmICh0eXBlb2YgZGF0ZSAhPT0gJ3N0cmluZycpIHtcXG4gICAgcmV0dXJuIGlzVmFsaWQoZGF0ZSkgPyBkYXRlIDogbnVsbDtcXG4gIH1cXG5cXG4gIHZhciBwYXJzZWQgPSBwYXJzZShkYXRlLCBmb3JtYXQkMSwgbmV3IERhdGUoKSk7XFxuXFxuICAvLyBpZiBkYXRlIGlzIG5vdCB2YWxpZCBvciB0aGUgZm9ybWF0dGVkIG91dHB1dCBhZnRlciBwYXJzaW5nIGRvZXMgbm90IG1hdGNoXFxuICAvLyB0aGUgc3RyaW5nIHZhbHVlIHBhc3NlZCBpbiAoYXZvaWRzIG92ZXJmbG93cylcXG4gIGlmICghaXNWYWxpZChwYXJzZWQpIHx8IGZvcm1hdChwYXJzZWQsIGZvcm1hdCQxKSAhPT0gZGF0ZSkge1xcbiAgICByZXR1cm4gbnVsbDtcXG4gIH1cXG5cXG4gIHJldHVybiBwYXJzZWQ7XFxufVxcblxcbnZhciBhZnRlclZhbGlkYXRvciA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmKSB7XFxuICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XFxuICB2YXIgdGFyZ2V0VmFsdWUgPSByZWYudGFyZ2V0VmFsdWU7XFxuICB2YXIgaW5jbHVzaW9uID0gcmVmLmluY2x1c2lvbjsgaWYgKCBpbmNsdXNpb24gPT09IHZvaWQgMCApIGluY2x1c2lvbiA9IGZhbHNlO1xcbiAgdmFyIGZvcm1hdCA9IHJlZi5mb3JtYXQ7XFxuXFxuICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgZm9ybWF0ID0gaW5jbHVzaW9uO1xcbiAgICBpbmNsdXNpb24gPSBmYWxzZTtcXG4gIH1cXG5cXG4gIHZhbHVlID0gcGFyc2VEYXRlJDEodmFsdWUsIGZvcm1hdCk7XFxuICB0YXJnZXRWYWx1ZSA9IHBhcnNlRGF0ZSQxKHRhcmdldFZhbHVlLCBmb3JtYXQpO1xcblxcbiAgLy8gaWYgZWl0aGVyIGlzIG5vdCB2YWxpZC5cXG4gIGlmICghdmFsdWUgfHwgIXRhcmdldFZhbHVlKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIHJldHVybiBpc0FmdGVyKHZhbHVlLCB0YXJnZXRWYWx1ZSkgfHwgKGluY2x1c2lvbiAmJiBpc0VxdWFsJDEodmFsdWUsIHRhcmdldFZhbHVlKSk7XFxufTtcXG5cXG52YXIgb3B0aW9ucyA9IHtcXG4gIGhhc1RhcmdldDogdHJ1ZSxcXG4gIGlzRGF0ZTogdHJ1ZVxcbn07XFxuXFxuLy8gcmVxdWlyZWQgdG8gY29udmVydCBmcm9tIGEgbGlzdCBvZiBhcnJheSB2YWx1ZXMgdG8gYW4gb2JqZWN0LlxcbnZhciBwYXJhbU5hbWVzID0gWyd0YXJnZXRWYWx1ZScsICdpbmNsdXNpb24nLCAnZm9ybWF0J107XFxuXFxudmFyIGFmdGVyID0ge1xcbiAgdmFsaWRhdGU6IGFmdGVyVmFsaWRhdG9yLFxcbiAgb3B0aW9uczogb3B0aW9ucyxcXG4gIHBhcmFtTmFtZXM6IHBhcmFtTmFtZXNcXG59O1xcblxcbi8qKlxcbiAqIFNvbWUgQWxwaGEgUmVnZXggaGVscGVycy5cXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2hyaXNvL3ZhbGlkYXRvci5qcy9ibG9iL21hc3Rlci9zcmMvbGliL2FscGhhLmpzXFxuICovXFxuXFxudmFyIGFscGhhID0ge1xcbiAgZW46IC9eW0EtWl0qJC9pLFxcbiAgY3M6IC9eW0EtWsOBxIzEjsOJxJrDjcWHw5PFmMWgxaTDmsWuw53FvV0qJC9pLFxcbiAgZGE6IC9eW0EtWsOGw5jDhV0qJC9pLFxcbiAgZGU6IC9eW0EtWsOEw5bDnMOfXSokL2ksXFxuICBlczogL15bQS1aw4HDicONw5HDk8Oaw5xdKiQvaSxcXG4gIGZyOiAvXltBLVrDgMOCw4bDh8OJw4jDisOLw4/DjsOUxZLDmcObw5zFuF0qJC9pLFxcbiAgaXQ6IC9eW0EtWlxcXFx4QzAtXFxcXHhGRl0qJC9pLFxcbiAgbHQ6IC9eW0EtWsSExIzEmMSWxK7FoMWyxarFvV0qJC9pLFxcbiAgbmw6IC9eW0EtWsOJw4vDj8OTw5bDnF0qJC9pLFxcbiAgaHU6IC9eW0EtWsOBw4nDjcOTw5bFkMOaw5zFsF0qJC9pLFxcbiAgcGw6IC9eW0EtWsSExIbEmMWaxYHFg8OTxbvFuV0qJC9pLFxcbiAgcHQ6IC9eW0EtWsODw4HDgMOCw4fDicOKw43DlcOTw5TDmsOcXSokL2ksXFxuICBydTogL15b0JAt0K/QgV0qJC9pLFxcbiAgc2s6IC9eW0EtWsOBw4TEjMSOw4nDjcS5xL3Fh8OTxZTFoMWkw5rDncW9XSokL2ksXFxuICBzcjogL15bQS1axIzEhsW9xaDEkF0qJC9pLFxcbiAgc3Y6IC9eW0EtWsOFw4TDll0qJC9pLFxcbiAgdHI6IC9eW0EtWsOHxJ7EsMSxw5bFnsOcXSokL2ksXFxuICB1azogL15b0JAt0KnQrNCu0K/QhNCG0IfSkF0qJC9pLFxcbiAgYXI6IC9eW9ih2KLYo9ik2KXYptin2KjYqdiq2KvYrNit2K7Yr9iw2LHYstiz2LTYtdi22LfYuNi52LrZgdmC2YPZhNmF2YbZh9mI2YnZitmL2YzZjdmO2Y/ZkNmR2ZLZsF0qJC8sXFxuICBhejogL15bQS1aw4fGj8SexLDEscOWxZ7DnF0qJC9pXFxufTtcXG5cXG52YXIgYWxwaGFTcGFjZXMgPSB7XFxuICBlbjogL15bQS1aXFxcXHNdKiQvaSxcXG4gIGNzOiAvXltBLVrDgcSMxI7DicSaw43Fh8OTxZjFoMWkw5rFrsOdxb1cXFxcc10qJC9pLFxcbiAgZGE6IC9eW0EtWsOGw5jDhVxcXFxzXSokL2ksXFxuICBkZTogL15bQS1aw4TDlsOcw59cXFxcc10qJC9pLFxcbiAgZXM6IC9eW0EtWsOBw4nDjcORw5PDmsOcXFxcXHNdKiQvaSxcXG4gIGZyOiAvXltBLVrDgMOCw4bDh8OJw4jDisOLw4/DjsOUxZLDmcObw5zFuFxcXFxzXSokL2ksXFxuICBpdDogL15bQS1aXFxcXHhDMC1cXFxceEZGXFxcXHNdKiQvaSxcXG4gIGx0OiAvXltBLVrEhMSMxJjElsSuxaDFssWqxb1cXFxcc10qJC9pLFxcbiAgbmw6IC9eW0EtWsOJw4vDj8OTw5bDnFxcXFxzXSokL2ksXFxuICBodTogL15bQS1aw4HDicONw5PDlsWQw5rDnMWwXFxcXHNdKiQvaSxcXG4gIHBsOiAvXltBLVrEhMSGxJjFmsWBxYPDk8W7xblcXFxcc10qJC9pLFxcbiAgcHQ6IC9eW0EtWsODw4HDgMOCw4fDicOKw43DlcOTw5TDmsOcXFxcXHNdKiQvaSxcXG4gIHJ1OiAvXlvQkC3Qr9CBXFxcXHNdKiQvaSxcXG4gIHNrOiAvXltBLVrDgcOExIzEjsOJw43EucS9xYfDk8WUxaDFpMOaw53FvVxcXFxzXSokL2ksXFxuICBzcjogL15bQS1axIzEhsW9xaDEkFxcXFxzXSokL2ksXFxuICBzdjogL15bQS1aw4XDhMOWXFxcXHNdKiQvaSxcXG4gIHRyOiAvXltBLVrDh8SexLDEscOWxZ7DnFxcXFxzXSokL2ksXFxuICB1azogL15b0JAt0KnQrNCu0K/QhNCG0IfSkFxcXFxzXSokL2ksXFxuICBhcjogL15b2KHYotij2KTYpdim2KfYqNip2KrYq9is2K3Yrtiv2LDYsdiy2LPYtNi12LbYt9i42LnYutmB2YLZg9mE2YXZhtmH2YjZidmK2YvZjNmN2Y7Zj9mQ2ZHZktmwXFxcXHNdKiQvLFxcbiAgYXo6IC9eW0EtWsOHxo/EnsSwxLHDlsWew5xcXFxcc10qJC9pXFxufTtcXG5cXG52YXIgYWxwaGFudW1lcmljID0ge1xcbiAgZW46IC9eWzAtOUEtWl0qJC9pLFxcbiAgY3M6IC9eWzAtOUEtWsOBxIzEjsOJxJrDjcWHw5PFmMWgxaTDmsWuw53FvV0qJC9pLFxcbiAgZGE6IC9eWzAtOUEtWsOGw5jDhV0kL2ksXFxuICBkZTogL15bMC05QS1aw4TDlsOcw59dKiQvaSxcXG4gIGVzOiAvXlswLTlBLVrDgcOJw43DkcOTw5rDnF0qJC9pLFxcbiAgZnI6IC9eWzAtOUEtWsOAw4LDhsOHw4nDiMOKw4vDj8OOw5TFksOZw5vDnMW4XSokL2ksXFxuICBpdDogL15bMC05QS1aXFxcXHhDMC1cXFxceEZGXSokL2ksXFxuICBsdDogL15bMC05QS1axITEjMSYxJbErsWgxbLFqsW9XSokL2ksXFxuICBodTogL15bMC05QS1aw4HDicONw5PDlsWQw5rDnMWwXSokL2ksXFxuICBubDogL15bMC05QS1aw4nDi8OPw5PDlsOcXSokL2ksXFxuICBwbDogL15bMC05QS1axITEhsSYxZrFgcWDw5PFu8W5XSokL2ksXFxuICBwdDogL15bMC05QS1aw4PDgcOAw4LDh8OJw4rDjcOVw5PDlMOaw5xdKiQvaSxcXG4gIHJ1OiAvXlswLTnQkC3Qr9CBXSokL2ksXFxuICBzazogL15bMC05QS1aw4HDhMSMxI7DicONxLnEvcWHw5PFlMWgxaTDmsOdxb1dKiQvaSxcXG4gIHNyOiAvXlswLTlBLVrEjMSGxb3FoMSQXSokL2ksXFxuICBzdjogL15bMC05QS1aw4XDhMOWXSokL2ksXFxuICB0cjogL15bMC05QS1aw4fEnsSwxLHDlsWew5xdKiQvaSxcXG4gIHVrOiAvXlswLTnQkC3QqdCs0K7Qr9CE0IbQh9KQXSokL2ksXFxuICBhcjogL15b2aDZodmi2aPZpNml2abZp9mo2akwLTnYodii2KPYpNil2KbYp9io2KnYqtir2KzYrdiu2K/YsNix2LLYs9i02LXYtti32LjYudi62YHZgtmD2YTZhdmG2YfZiNmJ2YrZi9mM2Y3ZjtmP2ZDZkdmS2bBdKiQvLFxcbiAgYXo6IC9eWzAtOUEtWsOHxo/EnsSwxLHDlsWew5xdKiQvaVxcbn07XFxuXFxudmFyIGFscGhhRGFzaCA9IHtcXG4gIGVuOiAvXlswLTlBLVpfLV0qJC9pLFxcbiAgY3M6IC9eWzAtOUEtWsOBxIzEjsOJxJrDjcWHw5PFmMWgxaTDmsWuw53FvV8tXSokL2ksXFxuICBkYTogL15bMC05QS1aw4bDmMOFXy1dKiQvaSxcXG4gIGRlOiAvXlswLTlBLVrDhMOWw5zDn18tXSokL2ksXFxuICBlczogL15bMC05QS1aw4HDicONw5HDk8Oaw5xfLV0qJC9pLFxcbiAgZnI6IC9eWzAtOUEtWsOAw4LDhsOHw4nDiMOKw4vDj8OOw5TFksOZw5vDnMW4Xy1dKiQvaSxcXG4gIGl0OiAvXlswLTlBLVpcXFxceEMwLVxcXFx4RkZfLV0qJC9pLFxcbiAgbHQ6IC9eWzAtOUEtWsSExIzEmMSWxK7FoMWyxarFvV8tXSokL2ksXFxuICBubDogL15bMC05QS1aw4nDi8OPw5PDlsOcXy1dKiQvaSxcXG4gIGh1OiAvXlswLTlBLVrDgcOJw43Dk8OWxZDDmsOcxbBfLV0qJC9pLFxcbiAgcGw6IC9eWzAtOUEtWsSExIbEmMWaxYHFg8OTxbvFuV8tXSokL2ksXFxuICBwdDogL15bMC05QS1aw4PDgcOAw4LDh8OJw4rDjcOVw5PDlMOaw5xfLV0qJC9pLFxcbiAgcnU6IC9eWzAtOdCQLdCv0IFfLV0qJC9pLFxcbiAgc2s6IC9eWzAtOUEtWsOBw4TEjMSOw4nDjcS5xL3Fh8OTxZTFoMWkw5rDncW9Xy1dKiQvaSxcXG4gIHNyOiAvXlswLTlBLVrEjMSGxb3FoMSQXy1dKiQvaSxcXG4gIHN2OiAvXlswLTlBLVrDhcOEw5ZfLV0qJC9pLFxcbiAgdHI6IC9eWzAtOUEtWsOHxJ7EsMSxw5bFnsOcXy1dKiQvaSxcXG4gIHVrOiAvXlswLTnQkC3QqdCs0K7Qr9CE0IbQh9KQXy1dKiQvaSxcXG4gIGFyOiAvXlvZoNmh2aLZo9mk2aXZptmn2ajZqTAtOdih2KLYo9ik2KXYptin2KjYqdiq2KvYrNit2K7Yr9iw2LHYstiz2LTYtdi22LfYuNi52LrZgdmC2YPZhNmF2YbZh9mI2YnZitmL2YzZjdmO2Y/ZkNmR2ZLZsF8tXSokLyxcXG4gIGF6OiAvXlswLTlBLVrDh8aPxJ7EsMSxw5bFnsOcXy1dKiQvaVxcbn07XFxuXFxudmFyIHZhbGlkYXRlID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcXG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcXG4gIHZhciBsb2NhbGUgPSByZWYubG9jYWxlO1xcblxcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XFxuICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSh2YWwsIFtsb2NhbGVdKTsgfSk7XFxuICB9XFxuXFxuICAvLyBNYXRjaCBhdCBsZWFzdCBvbmUgbG9jYWxlLlxcbiAgaWYgKCEgbG9jYWxlKSB7XFxuICAgIHJldHVybiBPYmplY3Qua2V5cyhhbHBoYSkuc29tZShmdW5jdGlvbiAobG9jKSB7IHJldHVybiBhbHBoYVtsb2NdLnRlc3QodmFsdWUpOyB9KTtcXG4gIH1cXG5cXG4gIHJldHVybiAoYWxwaGFbbG9jYWxlXSB8fCBhbHBoYS5lbikudGVzdCh2YWx1ZSk7XFxufTtcXG5cXG52YXIgcGFyYW1OYW1lcyQxID0gWydsb2NhbGUnXTtcXG5cXG52YXIgYWxwaGEkMSA9IHtcXG4gIHZhbGlkYXRlOiB2YWxpZGF0ZSxcXG4gIHBhcmFtTmFtZXM6IHBhcmFtTmFtZXMkMVxcbn07XFxuXFxudmFyIHZhbGlkYXRlJDEgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xcbiAgdmFyIGxvY2FsZSA9IHJlZi5sb2NhbGU7XFxuXFxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcXG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbGlkYXRlJDEodmFsLCBbbG9jYWxlXSk7IH0pO1xcbiAgfVxcblxcbiAgLy8gTWF0Y2ggYXQgbGVhc3Qgb25lIGxvY2FsZS5cXG4gIGlmICghIGxvY2FsZSkge1xcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYWxwaGFEYXNoKS5zb21lKGZ1bmN0aW9uIChsb2MpIHsgcmV0dXJuIGFscGhhRGFzaFtsb2NdLnRlc3QodmFsdWUpOyB9KTtcXG4gIH1cXG5cXG4gIHJldHVybiAoYWxwaGFEYXNoW2xvY2FsZV0gfHwgYWxwaGFEYXNoLmVuKS50ZXN0KHZhbHVlKTtcXG59O1xcblxcbnZhciBwYXJhbU5hbWVzJDIgPSBbJ2xvY2FsZSddO1xcblxcbnZhciBhbHBoYV9kYXNoID0ge1xcbiAgdmFsaWRhdGU6IHZhbGlkYXRlJDEsXFxuICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzJDJcXG59O1xcblxcbnZhciB2YWxpZGF0ZSQyID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcXG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcXG4gIHZhciBsb2NhbGUgPSByZWYubG9jYWxlO1xcblxcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XFxuICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSQyKHZhbCwgW2xvY2FsZV0pOyB9KTtcXG4gIH1cXG5cXG4gIC8vIE1hdGNoIGF0IGxlYXN0IG9uZSBsb2NhbGUuXFxuICBpZiAoISBsb2NhbGUpIHtcXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGFscGhhbnVtZXJpYykuc29tZShmdW5jdGlvbiAobG9jKSB7IHJldHVybiBhbHBoYW51bWVyaWNbbG9jXS50ZXN0KHZhbHVlKTsgfSk7XFxuICB9XFxuXFxuICByZXR1cm4gKGFscGhhbnVtZXJpY1tsb2NhbGVdIHx8IGFscGhhbnVtZXJpYy5lbikudGVzdCh2YWx1ZSk7XFxufTtcXG5cXG52YXIgcGFyYW1OYW1lcyQzID0gWydsb2NhbGUnXTtcXG5cXG52YXIgYWxwaGFfbnVtID0ge1xcbiAgdmFsaWRhdGU6IHZhbGlkYXRlJDIsXFxuICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzJDNcXG59O1xcblxcbnZhciB2YWxpZGF0ZSQzID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcXG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcXG4gIHZhciBsb2NhbGUgPSByZWYubG9jYWxlO1xcblxcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XFxuICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSQzKHZhbCwgW2xvY2FsZV0pOyB9KTtcXG4gIH1cXG5cXG4gIC8vIE1hdGNoIGF0IGxlYXN0IG9uZSBsb2NhbGUuXFxuICBpZiAoISBsb2NhbGUpIHtcXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGFscGhhU3BhY2VzKS5zb21lKGZ1bmN0aW9uIChsb2MpIHsgcmV0dXJuIGFscGhhU3BhY2VzW2xvY10udGVzdCh2YWx1ZSk7IH0pO1xcbiAgfVxcblxcbiAgcmV0dXJuIChhbHBoYVNwYWNlc1tsb2NhbGVdIHx8IGFscGhhU3BhY2VzLmVuKS50ZXN0KHZhbHVlKTtcXG59O1xcblxcbnZhciBwYXJhbU5hbWVzJDQgPSBbJ2xvY2FsZSddO1xcblxcbnZhciBhbHBoYV9zcGFjZXMgPSB7XFxuICB2YWxpZGF0ZTogdmFsaWRhdGUkMyxcXG4gIHBhcmFtTmFtZXM6IHBhcmFtTmFtZXMkNFxcbn07XFxuXFxudmFyIHZhbGlkYXRlJDQgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xcbiAgdmFyIHRhcmdldFZhbHVlID0gcmVmLnRhcmdldFZhbHVlO1xcbiAgdmFyIGluY2x1c2lvbiA9IHJlZi5pbmNsdXNpb247IGlmICggaW5jbHVzaW9uID09PSB2b2lkIDAgKSBpbmNsdXNpb24gPSBmYWxzZTtcXG4gIHZhciBmb3JtYXQgPSByZWYuZm9ybWF0O1xcblxcbiAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgIGZvcm1hdCA9IGluY2x1c2lvbjtcXG4gICAgaW5jbHVzaW9uID0gZmFsc2U7XFxuICB9XFxuXFxuICB2YWx1ZSA9IHBhcnNlRGF0ZSQxKHZhbHVlLCBmb3JtYXQpO1xcbiAgdGFyZ2V0VmFsdWUgPSBwYXJzZURhdGUkMSh0YXJnZXRWYWx1ZSwgZm9ybWF0KTtcXG5cXG4gIC8vIGlmIGVpdGhlciBpcyBub3QgdmFsaWQuXFxuICBpZiAoIXZhbHVlIHx8ICF0YXJnZXRWYWx1ZSkge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICByZXR1cm4gaXNCZWZvcmUodmFsdWUsIHRhcmdldFZhbHVlKSB8fCAoaW5jbHVzaW9uICYmIGlzRXF1YWwkMSh2YWx1ZSwgdGFyZ2V0VmFsdWUpKTtcXG59O1xcblxcbnZhciBvcHRpb25zJDEgPSB7XFxuICBoYXNUYXJnZXQ6IHRydWUsXFxuICBpc0RhdGU6IHRydWVcXG59O1xcblxcbnZhciBwYXJhbU5hbWVzJDUgPSBbJ3RhcmdldFZhbHVlJywgJ2luY2x1c2lvbicsICdmb3JtYXQnXTtcXG5cXG52YXIgYmVmb3JlID0ge1xcbiAgdmFsaWRhdGU6IHZhbGlkYXRlJDQsXFxuICBvcHRpb25zOiBvcHRpb25zJDEsXFxuICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzJDVcXG59O1xcblxcbnZhciB2YWxpZGF0ZSQ1ID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcXG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcXG4gIHZhciBtaW4gPSByZWYubWluO1xcbiAgdmFyIG1heCA9IHJlZi5tYXg7XFxuXFxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcXG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbGlkYXRlJDUodmFsLCB7IG1pbjogbWluLCBtYXg6IG1heCB9KTsgfSk7XFxuICB9XFxuXFxuICByZXR1cm4gTnVtYmVyKG1pbikgPD0gdmFsdWUgJiYgTnVtYmVyKG1heCkgPj0gdmFsdWU7XFxufTtcXG5cXG52YXIgcGFyYW1OYW1lcyQ2ID0gWydtaW4nLCAnbWF4J107XFxuXFxudmFyIGJldHdlZW4gPSB7XFxuICB2YWxpZGF0ZTogdmFsaWRhdGUkNSxcXG4gIHBhcmFtTmFtZXM6IHBhcmFtTmFtZXMkNlxcbn07XFxuXFxudmFyIHZhbGlkYXRlJDYgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xcbiAgdmFyIHRhcmdldFZhbHVlID0gcmVmLnRhcmdldFZhbHVlO1xcblxcbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSkgPT09IFN0cmluZyh0YXJnZXRWYWx1ZSk7XFxufTtcXG52YXIgb3B0aW9ucyQyID0ge1xcbiAgaGFzVGFyZ2V0OiB0cnVlXFxufTtcXG5cXG52YXIgcGFyYW1OYW1lcyQ3ID0gWyd0YXJnZXRWYWx1ZSddO1xcblxcbnZhciBjb25maXJtZWQgPSB7XFxuICB2YWxpZGF0ZTogdmFsaWRhdGUkNixcXG4gIG9wdGlvbnM6IG9wdGlvbnMkMixcXG4gIHBhcmFtTmFtZXM6IHBhcmFtTmFtZXMkN1xcbn07XFxuXFxuZnVuY3Rpb24gdW53cmFwRXhwb3J0cyAoeCkge1xcblxcdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcXG5cXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XFxufVxcblxcbnZhciBhc3NlcnRTdHJpbmdfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gYXNzZXJ0U3RyaW5nO1xcbmZ1bmN0aW9uIGFzc2VydFN0cmluZyhpbnB1dCkge1xcbiAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCBpbnB1dCBpbnN0YW5jZW9mIFN0cmluZztcXG5cXG4gIGlmICghaXNTdHJpbmcpIHtcXG4gICAgdmFyIGludmFsaWRUeXBlID0gdm9pZCAwO1xcbiAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcXG4gICAgICBpbnZhbGlkVHlwZSA9ICdudWxsJztcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpbnZhbGlkVHlwZSA9IHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoaW5wdXQpO1xcbiAgICAgIGlmIChpbnZhbGlkVHlwZSA9PT0gJ29iamVjdCcgJiYgaW5wdXQuY29uc3RydWN0b3IgJiYgaW5wdXQuY29uc3RydWN0b3IuaGFzT3duUHJvcGVydHkoJ25hbWUnKSkge1xcbiAgICAgICAgaW52YWxpZFR5cGUgPSBpbnB1dC5jb25zdHJ1Y3Rvci5uYW1lO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpbnZhbGlkVHlwZSA9ICdhICcgKyBpbnZhbGlkVHlwZTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgc3RyaW5nIGJ1dCByZWNlaXZlZCAnICsgaW52YWxpZFR5cGUgKyAnLicpO1xcbiAgfVxcbn1cXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcXG59KTtcXG5cXG51bndyYXBFeHBvcnRzKGFzc2VydFN0cmluZ18xKTtcXG5cXG52YXIgaXNDcmVkaXRDYXJkXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5leHBvcnRzLmRlZmF1bHQgPSBpc0NyZWRpdENhcmQ7XFxuXFxuXFxuXFxudmFyIF9hc3NlcnRTdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NlcnRTdHJpbmdfMSk7XFxuXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXFxudmFyIGNyZWRpdENhcmQgPSAvXig/OjRbMC05XXsxMn0oPzpbMC05XXszfSk/fDVbMS01XVswLTldezE0fXwoMjIyWzEtOV18MjJbMy05XVswLTldfDJbMy02XVswLTldezJ9fDI3WzAxXVswLTldfDI3MjApWzAtOV17MTJ9fDYoPzowMTF8NVswLTldWzAtOV0pWzAtOV17MTJ9fDNbNDddWzAtOV17MTN9fDMoPzowWzAtNV18WzY4XVswLTldKVswLTldezExfXwoPzoyMTMxfDE4MDB8MzVcXFxcZHszfSlcXFxcZHsxMX18NlsyN11bMC05XXsxNH0pJC87XFxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXFxuXFxuZnVuY3Rpb24gaXNDcmVkaXRDYXJkKHN0cikge1xcbiAgKDAsIF9hc3NlcnRTdHJpbmcyLmRlZmF1bHQpKHN0cik7XFxuICB2YXIgc2FuaXRpemVkID0gc3RyLnJlcGxhY2UoL1stIF0rL2csICcnKTtcXG4gIGlmICghY3JlZGl0Q2FyZC50ZXN0KHNhbml0aXplZCkpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcbiAgdmFyIHN1bSA9IDA7XFxuICB2YXIgZGlnaXQgPSB2b2lkIDA7XFxuICB2YXIgdG1wTnVtID0gdm9pZCAwO1xcbiAgdmFyIHNob3VsZERvdWJsZSA9IHZvaWQgMDtcXG4gIGZvciAodmFyIGkgPSBzYW5pdGl6ZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG4gICAgZGlnaXQgPSBzYW5pdGl6ZWQuc3Vic3RyaW5nKGksIGkgKyAxKTtcXG4gICAgdG1wTnVtID0gcGFyc2VJbnQoZGlnaXQsIDEwKTtcXG4gICAgaWYgKHNob3VsZERvdWJsZSkge1xcbiAgICAgIHRtcE51bSAqPSAyO1xcbiAgICAgIGlmICh0bXBOdW0gPj0gMTApIHtcXG4gICAgICAgIHN1bSArPSB0bXBOdW0gJSAxMCArIDE7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHN1bSArPSB0bXBOdW07XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN1bSArPSB0bXBOdW07XFxuICAgIH1cXG4gICAgc2hvdWxkRG91YmxlID0gIXNob3VsZERvdWJsZTtcXG4gIH1cXG4gIHJldHVybiAhIShzdW0gJSAxMCA9PT0gMCA/IHNhbml0aXplZCA6IGZhbHNlKTtcXG59XFxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XFxufSk7XFxuXFxudmFyIGlzQ3JlZGl0Q2FyZCA9IHVud3JhcEV4cG9ydHMoaXNDcmVkaXRDYXJkXzEpO1xcblxcbnZhciB2YWxpZGF0ZSQ3ID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBpc0NyZWRpdENhcmQoU3RyaW5nKHZhbHVlKSk7IH07XFxuXFxudmFyIGNyZWRpdF9jYXJkID0ge1xcbiAgdmFsaWRhdGU6IHZhbGlkYXRlJDdcXG59O1xcblxcbnZhciB2YWxpZGF0ZSQ4ID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcXG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcXG4gIHZhciBtaW4gPSByZWYubWluO1xcbiAgdmFyIG1heCA9IHJlZi5tYXg7XFxuICB2YXIgaW5jbHVzaXZpdHkgPSByZWYuaW5jbHVzaXZpdHk7IGlmICggaW5jbHVzaXZpdHkgPT09IHZvaWQgMCApIGluY2x1c2l2aXR5ID0gJygpJztcXG4gIHZhciBmb3JtYXQgPSByZWYuZm9ybWF0O1xcblxcbiAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgIGZvcm1hdCA9IGluY2x1c2l2aXR5O1xcbiAgICBpbmNsdXNpdml0eSA9ICcoKSc7XFxuICB9XFxuXFxuICB2YXIgbWluRGF0ZSA9IHBhcnNlRGF0ZSQxKFN0cmluZyhtaW4pLCBmb3JtYXQpO1xcbiAgdmFyIG1heERhdGUgPSBwYXJzZURhdGUkMShTdHJpbmcobWF4KSwgZm9ybWF0KTtcXG4gIHZhciBkYXRlVmFsID0gcGFyc2VEYXRlJDEoU3RyaW5nKHZhbHVlKSwgZm9ybWF0KTtcXG5cXG4gIGlmICghbWluRGF0ZSB8fCAhbWF4RGF0ZSB8fCAhZGF0ZVZhbCkge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICBpZiAoaW5jbHVzaXZpdHkgPT09ICcoKScpIHtcXG4gICAgcmV0dXJuIGlzQWZ0ZXIoZGF0ZVZhbCwgbWluRGF0ZSkgJiYgaXNCZWZvcmUoZGF0ZVZhbCwgbWF4RGF0ZSk7XFxuICB9XFxuXFxuICBpZiAoaW5jbHVzaXZpdHkgPT09ICcoXScpIHtcXG4gICAgcmV0dXJuIGlzQWZ0ZXIoZGF0ZVZhbCwgbWluRGF0ZSkgJiYgKGlzRXF1YWwkMShkYXRlVmFsLCBtYXhEYXRlKSB8fCBpc0JlZm9yZShkYXRlVmFsLCBtYXhEYXRlKSk7XFxuICB9XFxuXFxuICBpZiAoaW5jbHVzaXZpdHkgPT09ICdbKScpIHtcXG4gICAgcmV0dXJuIGlzQmVmb3JlKGRhdGVWYWwsIG1heERhdGUpICYmIChpc0VxdWFsJDEoZGF0ZVZhbCwgbWluRGF0ZSkgfHwgaXNBZnRlcihkYXRlVmFsLCBtaW5EYXRlKSk7XFxuICB9XFxuXFxuICByZXR1cm4gaXNFcXVhbCQxKGRhdGVWYWwsIG1heERhdGUpIHx8IGlzRXF1YWwkMShkYXRlVmFsLCBtaW5EYXRlKSB8fFxcbiAgICAoaXNCZWZvcmUoZGF0ZVZhbCwgbWF4RGF0ZSkgJiYgaXNBZnRlcihkYXRlVmFsLCBtaW5EYXRlKSk7XFxufTtcXG5cXG52YXIgb3B0aW9ucyQzID0ge1xcbiAgaXNEYXRlOiB0cnVlXFxufTtcXG5cXG52YXIgcGFyYW1OYW1lcyQ4ID0gWydtaW4nLCAnbWF4JywgJ2luY2x1c2l2aXR5JywgJ2Zvcm1hdCddO1xcblxcbnZhciBkYXRlX2JldHdlZW4gPSB7XFxuICB2YWxpZGF0ZTogdmFsaWRhdGUkOCxcXG4gIG9wdGlvbnM6IG9wdGlvbnMkMyxcXG4gIHBhcmFtTmFtZXM6IHBhcmFtTmFtZXMkOFxcbn07XFxuXFxudmFyIHZhbGlkYXRlJDkgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xcbiAgdmFyIGZvcm1hdCA9IHJlZi5mb3JtYXQ7XFxuXFxuICByZXR1cm4gISFwYXJzZURhdGUkMSh2YWx1ZSwgZm9ybWF0KTtcXG59O1xcblxcbnZhciBvcHRpb25zJDQgPSB7XFxuICBpc0RhdGU6IHRydWVcXG59O1xcblxcbnZhciBwYXJhbU5hbWVzJDkgPSBbJ2Zvcm1hdCddO1xcblxcbnZhciBkYXRlX2Zvcm1hdCA9IHtcXG4gIHZhbGlkYXRlOiB2YWxpZGF0ZSQ5LFxcbiAgb3B0aW9uczogb3B0aW9ucyQ0LFxcbiAgcGFyYW1OYW1lczogcGFyYW1OYW1lcyQ5XFxufTtcXG5cXG52YXIgdmFsaWRhdGUkYSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmKSB7XFxuICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XFxuICB2YXIgZGVjaW1hbHMgPSByZWYuZGVjaW1hbHM7IGlmICggZGVjaW1hbHMgPT09IHZvaWQgMCApIGRlY2ltYWxzID0gJyonO1xcbiAgdmFyIHNlcGFyYXRvciA9IHJlZi5zZXBhcmF0b3I7IGlmICggc2VwYXJhdG9yID09PSB2b2lkIDAgKSBzZXBhcmF0b3IgPSAnLic7XFxuXFxuICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSAnJykge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcXG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbGlkYXRlJGEodmFsLCB7IGRlY2ltYWxzOiBkZWNpbWFscywgc2VwYXJhdG9yOiBzZXBhcmF0b3IgfSk7IH0pO1xcbiAgfVxcblxcbiAgLy8gaWYgaXMgMC5cXG4gIGlmIChOdW1iZXIoZGVjaW1hbHMpID09PSAwKSB7XFxuICAgIHJldHVybiAvXi0/XFxcXGQqJC8udGVzdCh2YWx1ZSk7XFxuICB9XFxuXFxuICB2YXIgcmVnZXhQYXJ0ID0gZGVjaW1hbHMgPT09ICcqJyA/ICcrJyA6IChcXFwiezEsXFxcIiArIGRlY2ltYWxzICsgXFxcIn1cXFwiKTtcXG4gIHZhciByZWdleCA9IG5ldyBSZWdFeHAoKFxcXCJeWy0rXT9cXFxcXFxcXGQqKFxcXFxcXFxcXFxcIiArIHNlcGFyYXRvciArIFxcXCJcXFxcXFxcXGRcXFwiICsgcmVnZXhQYXJ0ICsgXFxcIik/KFtlRV17MX1bLV0/XFxcXFxcXFxkKyk/JFxcXCIpKTtcXG5cXG4gIGlmICghIHJlZ2V4LnRlc3QodmFsdWUpKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIHZhciBwYXJzZWRWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xcblxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXFxuICByZXR1cm4gcGFyc2VkVmFsdWUgPT09IHBhcnNlZFZhbHVlO1xcbn07XFxuXFxudmFyIHBhcmFtTmFtZXMkYSA9IFsnZGVjaW1hbHMnLCAnc2VwYXJhdG9yJ107XFxuXFxudmFyIGRlY2ltYWwgPSB7XFxuICB2YWxpZGF0ZTogdmFsaWRhdGUkYSxcXG4gIHBhcmFtTmFtZXM6IHBhcmFtTmFtZXMkYVxcbn07XFxuXFxudmFyIHZhbGlkYXRlJGIgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xcbiAgdmFyIGxlbmd0aCA9IHJlZlswXTtcXG5cXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xcbiAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkYih2YWwsIFtsZW5ndGhdKTsgfSk7XFxuICB9XFxuICB2YXIgc3RyVmFsID0gU3RyaW5nKHZhbHVlKTtcXG5cXG4gIHJldHVybiAvXlswLTldKiQvLnRlc3Qoc3RyVmFsKSAmJiBzdHJWYWwubGVuZ3RoID09PSBOdW1iZXIobGVuZ3RoKTtcXG59O1xcblxcbnZhciBkaWdpdHMgPSB7XFxuICB2YWxpZGF0ZTogdmFsaWRhdGUkYlxcbn07XFxuXFxudmFyIGltYWdlUmVnZXggPSAvXFxcXC4oanBnfHN2Z3xqcGVnfHBuZ3xibXB8Z2lmKSQvaTtcXG5cXG52YXIgdmFsaWRhdGVJbWFnZSA9IGZ1bmN0aW9uIChmaWxlLCB3aWR0aCwgaGVpZ2h0KSB7XFxuICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XFxuICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xcbiAgICBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSh7IHZhbGlkOiBmYWxzZSB9KTsgfTtcXG4gICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSh7XFxuICAgICAgdmFsaWQ6IGltYWdlLndpZHRoID09PSBOdW1iZXIod2lkdGgpICYmIGltYWdlLmhlaWdodCA9PT0gTnVtYmVyKGhlaWdodClcXG4gICAgfSk7IH07XFxuXFxuICAgIGltYWdlLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7XFxuICB9KTtcXG59O1xcblxcbnZhciB2YWxpZGF0ZSRjID0gZnVuY3Rpb24gKGZpbGVzLCByZWYpIHtcXG4gIHZhciB3aWR0aCA9IHJlZlswXTtcXG4gIHZhciBoZWlnaHQgPSByZWZbMV07XFxuXFxuICB2YXIgaW1hZ2VzID0gZW5zdXJlQXJyYXkoZmlsZXMpLmZpbHRlcihmdW5jdGlvbiAoZmlsZSkgeyByZXR1cm4gaW1hZ2VSZWdleC50ZXN0KGZpbGUubmFtZSk7IH0pO1xcbiAgaWYgKGltYWdlcy5sZW5ndGggPT09IDApIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcbiAgcmV0dXJuIFByb21pc2UuYWxsKGltYWdlcy5tYXAoZnVuY3Rpb24gKGltYWdlKSB7IHJldHVybiB2YWxpZGF0ZUltYWdlKGltYWdlLCB3aWR0aCwgaGVpZ2h0KTsgfSkpO1xcbn07XFxuXFxudmFyIGRpbWVuc2lvbnMgPSB7XFxuICB2YWxpZGF0ZTogdmFsaWRhdGUkY1xcbn07XFxuXFxudmFyIG1lcmdlXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5leHBvcnRzLmRlZmF1bHQgPSBtZXJnZTtcXG5mdW5jdGlvbiBtZXJnZSgpIHtcXG4gIHZhciBvYmogPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcbiAgdmFyIGRlZmF1bHRzID0gYXJndW1lbnRzWzFdO1xcblxcbiAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XFxuICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgb2JqW2tleV0gPSBkZWZhdWx0c1trZXldO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gb2JqO1xcbn1cXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcXG59KTtcXG5cXG51bndyYXBFeHBvcnRzKG1lcmdlXzEpO1xcblxcbnZhciBpc0J5dGVMZW5ndGhfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gaXNCeXRlTGVuZ3RoO1xcblxcblxcblxcbnZhciBfYXNzZXJ0U3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoYXNzZXJ0U3RyaW5nXzEpO1xcblxcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFxuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLXJlc3QtcGFyYW1zICovXFxuZnVuY3Rpb24gaXNCeXRlTGVuZ3RoKHN0ciwgb3B0aW9ucykge1xcbiAgKDAsIF9hc3NlcnRTdHJpbmcyLmRlZmF1bHQpKHN0cik7XFxuICB2YXIgbWluID0gdm9pZCAwO1xcbiAgdmFyIG1heCA9IHZvaWQgMDtcXG4gIGlmICgodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9wdGlvbnMpKSA9PT0gJ29iamVjdCcpIHtcXG4gICAgbWluID0gb3B0aW9ucy5taW4gfHwgMDtcXG4gICAgbWF4ID0gb3B0aW9ucy5tYXg7XFxuICB9IGVsc2Uge1xcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogaXNCeXRlTGVuZ3RoKHN0ciwgbWluIFssIG1heF0pXFxuICAgIG1pbiA9IGFyZ3VtZW50c1sxXTtcXG4gICAgbWF4ID0gYXJndW1lbnRzWzJdO1xcbiAgfVxcbiAgdmFyIGxlbiA9IGVuY29kZVVSSShzdHIpLnNwbGl0KC8lLi58Li8pLmxlbmd0aCAtIDE7XFxuICByZXR1cm4gbGVuID49IG1pbiAmJiAodHlwZW9mIG1heCA9PT0gJ3VuZGVmaW5lZCcgfHwgbGVuIDw9IG1heCk7XFxufVxcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xcbn0pO1xcblxcbnVud3JhcEV4cG9ydHMoaXNCeXRlTGVuZ3RoXzEpO1xcblxcbnZhciBpc0ZRRE5fMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbmV4cG9ydHMuZGVmYXVsdCA9IGlzRlFETjtcXG5cXG5cXG5cXG52YXIgX2Fzc2VydFN0cmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcXG5cXG5cXG5cXG52YXIgX21lcmdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQobWVyZ2VfMSk7XFxuXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXG52YXIgZGVmYXVsdF9mcWRuX29wdGlvbnMgPSB7XFxuICByZXF1aXJlX3RsZDogdHJ1ZSxcXG4gIGFsbG93X3VuZGVyc2NvcmVzOiBmYWxzZSxcXG4gIGFsbG93X3RyYWlsaW5nX2RvdDogZmFsc2VcXG59O1xcblxcbmZ1bmN0aW9uIGlzRlFETihzdHIsIG9wdGlvbnMpIHtcXG4gICgwLCBfYXNzZXJ0U3RyaW5nMi5kZWZhdWx0KShzdHIpO1xcbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UyLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfZnFkbl9vcHRpb25zKTtcXG5cXG4gIC8qIFJlbW92ZSB0aGUgb3B0aW9uYWwgdHJhaWxpbmcgZG90IGJlZm9yZSBjaGVja2luZyB2YWxpZGl0eSAqL1xcbiAgaWYgKG9wdGlvbnMuYWxsb3dfdHJhaWxpbmdfZG90ICYmIHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICcuJykge1xcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcXG4gIH1cXG4gIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnLicpO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xcbiAgICBpZiAocGFydHNbaV0ubGVuZ3RoID4gNjMpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gIH1cXG4gIGlmIChvcHRpb25zLnJlcXVpcmVfdGxkKSB7XFxuICAgIHZhciB0bGQgPSBwYXJ0cy5wb3AoKTtcXG4gICAgaWYgKCFwYXJ0cy5sZW5ndGggfHwgIS9eKFthLXpcXFxcdTAwYTEtXFxcXHVmZmZmXXsyLH18eG5bYS16MC05LV17Mix9KSQvaS50ZXN0KHRsZCkpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgLy8gZGlzYWxsb3cgc3BhY2VzXFxuICAgIGlmICgvW1xcXFxzXFxcXHUyMDAyLVxcXFx1MjAwQlxcXFx1MjAyRlxcXFx1MjA1RlxcXFx1MzAwMFxcXFx1RkVGRlxcXFx1REI0MFxcXFx1REMyMF0vLnRlc3QodGxkKSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgfVxcbiAgZm9yICh2YXIgcGFydCwgX2kgPSAwOyBfaSA8IHBhcnRzLmxlbmd0aDsgX2krKykge1xcbiAgICBwYXJ0ID0gcGFydHNbX2ldO1xcbiAgICBpZiAob3B0aW9ucy5hbGxvd191bmRlcnNjb3Jlcykge1xcbiAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UoL18vZywgJycpO1xcbiAgICB9XFxuICAgIGlmICghL15bYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOS1dKyQvaS50ZXN0KHBhcnQpKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIC8vIGRpc2FsbG93IGZ1bGwtd2lkdGggY2hhcnNcXG4gICAgaWYgKC9bXFxcXHVmZjAxLVxcXFx1ZmY1ZV0vLnRlc3QocGFydCkpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgaWYgKHBhcnRbMF0gPT09ICctJyB8fCBwYXJ0W3BhcnQubGVuZ3RoIC0gMV0gPT09ICctJykge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHRydWU7XFxufVxcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xcbn0pO1xcblxcbnZhciBpc0ZRRE4gPSB1bndyYXBFeHBvcnRzKGlzRlFETl8xKTtcXG5cXG52YXIgaXNJUF8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuZXhwb3J0cy5kZWZhdWx0ID0gaXNJUDtcXG5cXG5cXG5cXG52YXIgX2Fzc2VydFN0cmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcXG5cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxcblxcbnZhciBpcHY0TWF5YmUgPSAvXihcXFxcZHsxLDN9KVxcXFwuKFxcXFxkezEsM30pXFxcXC4oXFxcXGR7MSwzfSlcXFxcLihcXFxcZHsxLDN9KSQvO1xcbnZhciBpcHY2QmxvY2sgPSAvXlswLTlBLUZdezEsNH0kL2k7XFxuXFxuZnVuY3Rpb24gaXNJUChzdHIpIHtcXG4gIHZhciB2ZXJzaW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcXG5cXG4gICgwLCBfYXNzZXJ0U3RyaW5nMi5kZWZhdWx0KShzdHIpO1xcbiAgdmVyc2lvbiA9IFN0cmluZyh2ZXJzaW9uKTtcXG4gIGlmICghdmVyc2lvbikge1xcbiAgICByZXR1cm4gaXNJUChzdHIsIDQpIHx8IGlzSVAoc3RyLCA2KTtcXG4gIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gJzQnKSB7XFxuICAgIGlmICghaXB2NE1heWJlLnRlc3Qoc3RyKSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJy4nKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgcmV0dXJuIGEgLSBiO1xcbiAgICB9KTtcXG4gICAgcmV0dXJuIHBhcnRzWzNdIDw9IDI1NTtcXG4gIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gJzYnKSB7XFxuICAgIHZhciBibG9ja3MgPSBzdHIuc3BsaXQoJzonKTtcXG4gICAgdmFyIGZvdW5kT21pc3Npb25CbG9jayA9IGZhbHNlOyAvLyBtYXJrZXIgdG8gaW5kaWNhdGUgOjpcXG5cXG4gICAgLy8gQXQgbGVhc3Qgc29tZSBPUyBhY2NlcHQgdGhlIGxhc3QgMzIgYml0cyBvZiBhbiBJUHY2IGFkZHJlc3NcXG4gICAgLy8gKGkuZS4gMiBvZiB0aGUgYmxvY2tzKSBpbiBJUHY0IG5vdGF0aW9uLCBhbmQgUkZDIDM0OTMgc2F5c1xcbiAgICAvLyB0aGF0ICc6OmZmZmY6YS5iLmMuZCcgaXMgdmFsaWQgZm9yIElQdjQtbWFwcGVkIElQdjYgYWRkcmVzc2VzLFxcbiAgICAvLyBhbmQgJzo6YS5iLmMuZCcgaXMgZGVwcmVjYXRlZCwgYnV0IGFsc28gdmFsaWQuXFxuICAgIHZhciBmb3VuZElQdjRUcmFuc2l0aW9uQmxvY2sgPSBpc0lQKGJsb2Nrc1tibG9ja3MubGVuZ3RoIC0gMV0sIDQpO1xcbiAgICB2YXIgZXhwZWN0ZWROdW1iZXJPZkJsb2NrcyA9IGZvdW5kSVB2NFRyYW5zaXRpb25CbG9jayA/IDcgOiA4O1xcblxcbiAgICBpZiAoYmxvY2tzLmxlbmd0aCA+IGV4cGVjdGVkTnVtYmVyT2ZCbG9ja3MpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgLy8gaW5pdGlhbCBvciBmaW5hbCA6OlxcbiAgICBpZiAoc3RyID09PSAnOjonKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0gZWxzZSBpZiAoc3RyLnN1YnN0cigwLCAyKSA9PT0gJzo6Jykge1xcbiAgICAgIGJsb2Nrcy5zaGlmdCgpO1xcbiAgICAgIGJsb2Nrcy5zaGlmdCgpO1xcbiAgICAgIGZvdW5kT21pc3Npb25CbG9jayA9IHRydWU7XFxuICAgIH0gZWxzZSBpZiAoc3RyLnN1YnN0cihzdHIubGVuZ3RoIC0gMikgPT09ICc6OicpIHtcXG4gICAgICBibG9ja3MucG9wKCk7XFxuICAgICAgYmxvY2tzLnBvcCgpO1xcbiAgICAgIGZvdW5kT21pc3Npb25CbG9jayA9IHRydWU7XFxuICAgIH1cXG5cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja3MubGVuZ3RoOyArK2kpIHtcXG4gICAgICAvLyB0ZXN0IGZvciBhIDo6IHdoaWNoIGNhbiBub3QgYmUgYXQgdGhlIHN0cmluZyBzdGFydC9lbmRcXG4gICAgICAvLyBzaW5jZSB0aG9zZSBjYXNlcyBoYXZlIGJlZW4gaGFuZGxlZCBhYm92ZVxcbiAgICAgIGlmIChibG9ja3NbaV0gPT09ICcnICYmIGkgPiAwICYmIGkgPCBibG9ja3MubGVuZ3RoIC0gMSkge1xcbiAgICAgICAgaWYgKGZvdW5kT21pc3Npb25CbG9jaykge1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG11bHRpcGxlIDo6IGluIGFkZHJlc3NcXG4gICAgICAgIH1cXG4gICAgICAgIGZvdW5kT21pc3Npb25CbG9jayA9IHRydWU7XFxuICAgICAgfSBlbHNlIGlmIChmb3VuZElQdjRUcmFuc2l0aW9uQmxvY2sgJiYgaSA9PT0gYmxvY2tzLmxlbmd0aCAtIDEpIDsgZWxzZSBpZiAoIWlwdjZCbG9jay50ZXN0KGJsb2Nrc1tpXSkpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKGZvdW5kT21pc3Npb25CbG9jaykge1xcbiAgICAgIHJldHVybiBibG9ja3MubGVuZ3RoID49IDE7XFxuICAgIH1cXG4gICAgcmV0dXJuIGJsb2Nrcy5sZW5ndGggPT09IGV4cGVjdGVkTnVtYmVyT2ZCbG9ja3M7XFxuICB9XFxuICByZXR1cm4gZmFsc2U7XFxufVxcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xcbn0pO1xcblxcbnZhciBpc0lQID0gdW53cmFwRXhwb3J0cyhpc0lQXzEpO1xcblxcbnZhciBpc0VtYWlsXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5leHBvcnRzLmRlZmF1bHQgPSBpc0VtYWlsO1xcblxcblxcblxcbnZhciBfYXNzZXJ0U3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoYXNzZXJ0U3RyaW5nXzEpO1xcblxcblxcblxcbnZhciBfbWVyZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChtZXJnZV8xKTtcXG5cXG5cXG5cXG52YXIgX2lzQnl0ZUxlbmd0aDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGlzQnl0ZUxlbmd0aF8xKTtcXG5cXG5cXG5cXG52YXIgX2lzRlFETjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGlzRlFETl8xKTtcXG5cXG5cXG5cXG52YXIgX2lzSVAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChpc0lQXzEpO1xcblxcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFxudmFyIGRlZmF1bHRfZW1haWxfb3B0aW9ucyA9IHtcXG4gIGFsbG93X2Rpc3BsYXlfbmFtZTogZmFsc2UsXFxuICByZXF1aXJlX2Rpc3BsYXlfbmFtZTogZmFsc2UsXFxuICBhbGxvd191dGY4X2xvY2FsX3BhcnQ6IHRydWUsXFxuICByZXF1aXJlX3RsZDogdHJ1ZVxcbn07XFxuXFxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xcbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cXG52YXIgZGlzcGxheU5hbWUgPSAvXlthLXpcXFxcZCEjXFxcXCQlJidcXFxcKlxcXFwrXFxcXC1cXFxcLz1cXFxcP1xcXFxeX2B7XFxcXHx9flxcXFwuXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXStbYS16XFxcXGQhI1xcXFwkJSYnXFxcXCpcXFxcK1xcXFwtXFxcXC89XFxcXD9cXFxcXl9ge1xcXFx8fX5cXFxcLFxcXFwuXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXFxcXHNdKjwoLispPiQvaTtcXG52YXIgZW1haWxVc2VyUGFydCA9IC9eW2EtelxcXFxkISNcXFxcJCUmJ1xcXFwqXFxcXCtcXFxcLVxcXFwvPVxcXFw/XFxcXF5fYHtcXFxcfH1+XSskL2k7XFxudmFyIGdtYWlsVXNlclBhcnQgPSAvXlthLXpcXFxcZF0rJC87XFxudmFyIHF1b3RlZEVtYWlsVXNlciA9IC9eKFtcXFxcc1xcXFx4MDEtXFxcXHgwOFxcXFx4MGJcXFxceDBjXFxcXHgwZS1cXFxceDFmXFxcXHg3ZlxcXFx4MjFcXFxceDIzLVxcXFx4NWJcXFxceDVkLVxcXFx4N2VdfChcXFxcXFxcXFtcXFxceDAxLVxcXFx4MDlcXFxceDBiXFxcXHgwY1xcXFx4MGQtXFxcXHg3Zl0pKSokL2k7XFxudmFyIGVtYWlsVXNlclV0ZjhQYXJ0ID0gL15bYS16XFxcXGQhI1xcXFwkJSYnXFxcXCpcXFxcK1xcXFwtXFxcXC89XFxcXD9cXFxcXl9ge1xcXFx8fX5cXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKyQvaTtcXG52YXIgcXVvdGVkRW1haWxVc2VyVXRmOCA9IC9eKFtcXFxcc1xcXFx4MDEtXFxcXHgwOFxcXFx4MGJcXFxceDBjXFxcXHgwZS1cXFxceDFmXFxcXHg3ZlxcXFx4MjFcXFxceDIzLVxcXFx4NWJcXFxceDVkLVxcXFx4N2VcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdfChcXFxcXFxcXFtcXFxceDAxLVxcXFx4MDlcXFxceDBiXFxcXHgwY1xcXFx4MGQtXFxcXHg3ZlxcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKSokL2k7XFxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXFxuLyogZXNsaW50LWVuYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXFxuXFxuZnVuY3Rpb24gaXNFbWFpbChzdHIsIG9wdGlvbnMpIHtcXG4gICgwLCBfYXNzZXJ0U3RyaW5nMi5kZWZhdWx0KShzdHIpO1xcbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UyLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfZW1haWxfb3B0aW9ucyk7XFxuXFxuICBpZiAob3B0aW9ucy5yZXF1aXJlX2Rpc3BsYXlfbmFtZSB8fCBvcHRpb25zLmFsbG93X2Rpc3BsYXlfbmFtZSkge1xcbiAgICB2YXIgZGlzcGxheV9lbWFpbCA9IHN0ci5tYXRjaChkaXNwbGF5TmFtZSk7XFxuICAgIGlmIChkaXNwbGF5X2VtYWlsKSB7XFxuICAgICAgc3RyID0gZGlzcGxheV9lbWFpbFsxXTtcXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnJlcXVpcmVfZGlzcGxheV9uYW1lKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJ0AnKTtcXG4gIHZhciBkb21haW4gPSBwYXJ0cy5wb3AoKTtcXG4gIHZhciB1c2VyID0gcGFydHMuam9pbignQCcpO1xcblxcbiAgdmFyIGxvd2VyX2RvbWFpbiA9IGRvbWFpbi50b0xvd2VyQ2FzZSgpO1xcblxcbiAgaWYgKG9wdGlvbnMuZG9tYWluX3NwZWNpZmljX3ZhbGlkYXRpb24gJiYgKGxvd2VyX2RvbWFpbiA9PT0gJ2dtYWlsLmNvbScgfHwgbG93ZXJfZG9tYWluID09PSAnZ29vZ2xlbWFpbC5jb20nKSkge1xcbiAgICAvKlxcbiAgICAgIFByZXZpb3VzbHkgd2UgcmVtb3ZlZCBkb3RzIGZvciBnbWFpbCBhZGRyZXNzZXMgYmVmb3JlIHZhbGlkYXRpbmcuXFxuICAgICAgVGhpcyB3YXMgcmVtb3ZlZCBiZWNhdXNlIGl0IGFsbG93cyBgbXVsdGlwbGUuLmRvdHNAZ21haWwuY29tYFxcbiAgICAgIHRvIGJlIHJlcG9ydGVkIGFzIHZhbGlkLCBidXQgaXQgaXMgbm90LlxcbiAgICAgIEdtYWlsIG9ubHkgbm9ybWFsaXplcyBzaW5nbGUgZG90cywgcmVtb3ZpbmcgdGhlbSBmcm9tIGhlcmUgaXMgcG9pbnRsZXNzLFxcbiAgICAgIHNob3VsZCBiZSBkb25lIGluIG5vcm1hbGl6ZUVtYWlsXFxuICAgICovXFxuICAgIHVzZXIgPSB1c2VyLnRvTG93ZXJDYXNlKCk7XFxuXFxuICAgIC8vIFJlbW92aW5nIHN1Yi1hZGRyZXNzIGZyb20gdXNlcm5hbWUgYmVmb3JlIGdtYWlsIHZhbGlkYXRpb25cXG4gICAgdmFyIHVzZXJuYW1lID0gdXNlci5zcGxpdCgnKycpWzBdO1xcblxcbiAgICAvLyBEb3RzIGFyZSBub3QgaW5jbHVkZWQgaW4gZ21haWwgbGVuZ3RoIHJlc3RyaWN0aW9uXFxuICAgIGlmICghKDAsIF9pc0J5dGVMZW5ndGgyLmRlZmF1bHQpKHVzZXJuYW1lLnJlcGxhY2UoJy4nLCAnJyksIHsgbWluOiA2LCBtYXg6IDMwIH0pKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIHZhciBfdXNlcl9wYXJ0cyA9IHVzZXJuYW1lLnNwbGl0KCcuJyk7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3VzZXJfcGFydHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICBpZiAoIWdtYWlsVXNlclBhcnQudGVzdChfdXNlcl9wYXJ0c1tpXSkpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGlmICghKDAsIF9pc0J5dGVMZW5ndGgyLmRlZmF1bHQpKHVzZXIsIHsgbWF4OiA2NCB9KSB8fCAhKDAsIF9pc0J5dGVMZW5ndGgyLmRlZmF1bHQpKGRvbWFpbiwgeyBtYXg6IDI1NCB9KSkge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICBpZiAoISgwLCBfaXNGUUROMi5kZWZhdWx0KShkb21haW4sIHsgcmVxdWlyZV90bGQ6IG9wdGlvbnMucmVxdWlyZV90bGQgfSkpIHtcXG4gICAgaWYgKCFvcHRpb25zLmFsbG93X2lwX2RvbWFpbikge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICBpZiAoISgwLCBfaXNJUDIuZGVmYXVsdCkoZG9tYWluKSkge1xcbiAgICAgIGlmICghZG9tYWluLnN0YXJ0c1dpdGgoJ1snKSB8fCAhZG9tYWluLmVuZHNXaXRoKCddJykpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIG5vQnJhY2tldGRvbWFpbiA9IGRvbWFpbi5zdWJzdHIoMSwgZG9tYWluLmxlbmd0aCAtIDIpO1xcblxcbiAgICAgIGlmIChub0JyYWNrZXRkb21haW4ubGVuZ3RoID09PSAwIHx8ICEoMCwgX2lzSVAyLmRlZmF1bHQpKG5vQnJhY2tldGRvbWFpbikpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGlmICh1c2VyWzBdID09PSAnXFxcIicpIHtcXG4gICAgdXNlciA9IHVzZXIuc2xpY2UoMSwgdXNlci5sZW5ndGggLSAxKTtcXG4gICAgcmV0dXJuIG9wdGlvbnMuYWxsb3dfdXRmOF9sb2NhbF9wYXJ0ID8gcXVvdGVkRW1haWxVc2VyVXRmOC50ZXN0KHVzZXIpIDogcXVvdGVkRW1haWxVc2VyLnRlc3QodXNlcik7XFxuICB9XFxuXFxuICB2YXIgcGF0dGVybiA9IG9wdGlvbnMuYWxsb3dfdXRmOF9sb2NhbF9wYXJ0ID8gZW1haWxVc2VyVXRmOFBhcnQgOiBlbWFpbFVzZXJQYXJ0O1xcblxcbiAgdmFyIHVzZXJfcGFydHMgPSB1c2VyLnNwbGl0KCcuJyk7XFxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdXNlcl9wYXJ0cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgaWYgKCFwYXR0ZXJuLnRlc3QodXNlcl9wYXJ0c1tfaV0pKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gdHJ1ZTtcXG59XFxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XFxufSk7XFxuXFxudmFyIGlzRW1haWwgPSB1bndyYXBFeHBvcnRzKGlzRW1haWxfMSk7XFxuXFxuZnVuY3Rpb24gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgKG9iaiwgZXhjbHVkZSkgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGsgaW4gb2JqKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaykgJiYgZXhjbHVkZS5pbmRleE9mKGspID09PSAtMSkgdGFyZ2V0W2tdID0gb2JqW2tdOyByZXR1cm4gdGFyZ2V0OyB9XFxuXFxudmFyIHZhbGlkYXRlJGQgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xcbiAgdmFyIG11bHRpcGxlID0gcmVmLm11bHRpcGxlOyBpZiAoIG11bHRpcGxlID09PSB2b2lkIDAgKSBtdWx0aXBsZSA9IGZhbHNlO1xcbiAgdmFyIHJlc3QgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyggcmVmLCBbXFxcIm11bHRpcGxlXFxcIl0gKTtcXG4gIHZhciBvcHRpb25zID0gcmVzdDtcXG5cXG4gIGlmIChtdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcXG4gICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChlbWFpbFN0cikgeyByZXR1cm4gZW1haWxTdHIudHJpbSgpOyB9KTtcXG4gIH1cXG5cXG4gIHZhciB2YWxpZGF0b3JPcHRpb25zID0gYXNzaWduKHt9LCBvcHRpb25zKTtcXG5cXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xcbiAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gaXNFbWFpbChTdHJpbmcodmFsKSwgdmFsaWRhdG9yT3B0aW9ucyk7IH0pO1xcbiAgfVxcblxcbiAgcmV0dXJuIGlzRW1haWwoU3RyaW5nKHZhbHVlKSwgdmFsaWRhdG9yT3B0aW9ucyk7XFxufTtcXG5cXG52YXIgZW1haWwgPSB7XFxuICB2YWxpZGF0ZTogdmFsaWRhdGUkZFxcbn07XFxuXFxudmFyIHZhbGlkYXRlJGUgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xcbiAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkZSh2YWwsIG9wdGlvbnMpOyB9KTtcXG4gIH1cXG5cXG4gIHJldHVybiB0b0FycmF5KG9wdGlvbnMpLnNvbWUoZnVuY3Rpb24gKGl0ZW0pIHtcXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXFxuICAgIHJldHVybiBpdGVtID09IHZhbHVlO1xcbiAgfSk7XFxufTtcXG5cXG52YXIgaW5jbHVkZWQgPSB7XFxuICB2YWxpZGF0ZTogdmFsaWRhdGUkZVxcbn07XFxuXFxudmFyIHZhbGlkYXRlJGYgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xcbiAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcXG5cXG4gIHJldHVybiAhdmFsaWRhdGUkZS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xcbn07XFxuXFxudmFyIGV4Y2x1ZGVkID0ge1xcbiAgdmFsaWRhdGU6IHZhbGlkYXRlJGZcXG59O1xcblxcbnZhciB2YWxpZGF0ZSRnID0gZnVuY3Rpb24gKGZpbGVzLCBleHRlbnNpb25zKSB7XFxuICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKChcXFwiLihcXFwiICsgKGV4dGVuc2lvbnMuam9pbignfCcpKSArIFxcXCIpJFxcXCIpLCAnaScpO1xcbiAgcmV0dXJuIGVuc3VyZUFycmF5KGZpbGVzKS5ldmVyeShmdW5jdGlvbiAoZmlsZSkgeyByZXR1cm4gcmVnZXgudGVzdChmaWxlLm5hbWUpOyB9KTtcXG59O1xcblxcbnZhciBleHQgPSB7XFxuICB2YWxpZGF0ZTogdmFsaWRhdGUkZ1xcbn07XFxuXFxudmFyIHZhbGlkYXRlJGggPSBmdW5jdGlvbiAoZmlsZXMpIHsgcmV0dXJuIChBcnJheS5pc0FycmF5KGZpbGVzKSA/IGZpbGVzIDogW2ZpbGVzXSkuZXZlcnkoZnVuY3Rpb24gKGZpbGUpIHsgcmV0dXJuIC9cXFxcLihqcGd8c3ZnfGpwZWd8cG5nfGJtcHxnaWYpJC9pLnRlc3QoZmlsZS5uYW1lKTsgfSk7IH07XFxuXFxudmFyIGltYWdlID0ge1xcbiAgdmFsaWRhdGU6IHZhbGlkYXRlJGhcXG59O1xcblxcbnZhciB2YWxpZGF0ZSRpID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcXG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIC9eLT9bMC05XSskLy50ZXN0KFN0cmluZyh2YWwpKTsgfSk7XFxuICB9XFxuXFxuICByZXR1cm4gL14tP1swLTldKyQvLnRlc3QoU3RyaW5nKHZhbHVlKSk7XFxufTtcXG5cXG52YXIgaW50ZWdlciA9IHtcXG4gIHZhbGlkYXRlOiB2YWxpZGF0ZSRpXFxufTtcXG5cXG52YXIgdmFsaWRhdGUkaiA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmKSB7XFxuICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XFxuICB2YXIgdmVyc2lvbiA9IHJlZi52ZXJzaW9uOyBpZiAoIHZlcnNpb24gPT09IHZvaWQgMCApIHZlcnNpb24gPSA0O1xcblxcbiAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSkge1xcbiAgICB2YWx1ZSA9ICcnO1xcbiAgfVxcblxcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XFxuICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiBpc0lQKHZhbCwgdmVyc2lvbik7IH0pO1xcbiAgfVxcblxcbiAgcmV0dXJuIGlzSVAodmFsdWUsIHZlcnNpb24pO1xcbn07XFxuXFxudmFyIHBhcmFtTmFtZXMkYiA9IFsndmVyc2lvbiddO1xcblxcbnZhciBpcCA9IHtcXG4gIHZhbGlkYXRlOiB2YWxpZGF0ZSRqLFxcbiAgcGFyYW1OYW1lczogcGFyYW1OYW1lcyRiXFxufTtcXG5cXG52YXIgdmFsaWRhdGUkayA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSkge1xcbiAgICB2YWx1ZSA9ICcnO1xcbiAgfVxcblxcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XFxuICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiAoaXNJUCh2YWwsICcnKSB8fCBpc0ZRRE4odmFsKSk7IH0pO1xcbiAgfVxcblxcbiAgcmV0dXJuIGlzSVAodmFsdWUsICcnKSB8fCBpc0ZRRE4odmFsdWUpO1xcbn07XFxuXFxudmFyIGlwX29yX2ZxZG4gPSB7XFxuICB2YWxpZGF0ZTogdmFsaWRhdGUka1xcbn07XFxuXFxudmFyIHZhbGlkYXRlJGwgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IFtdO1xcbiAgdmFyIG90aGVyID0gcmVmWzBdO1xcblxcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlcjtcXG59O1xcblxcbnZhciBpcyA9IHtcXG4gIHZhbGlkYXRlOiB2YWxpZGF0ZSRsXFxufTtcXG5cXG52YXIgdmFsaWRhdGUkbSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmKSB7XFxuICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0gW107XFxuICB2YXIgb3RoZXIgPSByZWZbMF07XFxuXFxuICByZXR1cm4gdmFsdWUgIT09IG90aGVyO1xcbn07XFxuXFxudmFyIGlzX25vdCA9IHtcXG4gIHZhbGlkYXRlOiB2YWxpZGF0ZSRtXFxufTtcXG5cXG4vKipcXG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gdmFsdWVcXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXFxuICogQHBhcmFtIHtOdW1iZXJ9IG1heFxcbiAqL1xcbnZhciBjb21wYXJlID0gZnVuY3Rpb24gKHZhbHVlLCBsZW5ndGgsIG1heCkge1xcbiAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPT09IGxlbmd0aDtcXG4gIH1cXG5cXG4gIC8vIGNhc3QgdG8gbnVtYmVyLlxcbiAgbWF4ID0gTnVtYmVyKG1heCk7XFxuXFxuICByZXR1cm4gdmFsdWUubGVuZ3RoID49IGxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggPD0gbWF4O1xcbn07XFxuXFxudmFyIHZhbGlkYXRlJG4gPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xcbiAgdmFyIGxlbmd0aCA9IHJlZlswXTtcXG4gIHZhciBtYXggPSByZWZbMV07IGlmICggbWF4ID09PSB2b2lkIDAgKSBtYXggPSB1bmRlZmluZWQ7XFxuXFxuICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpO1xcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcXG4gICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xcbiAgfVxcblxcbiAgaWYgKCF2YWx1ZS5sZW5ndGgpIHtcXG4gICAgdmFsdWUgPSB0b0FycmF5KHZhbHVlKTtcXG4gIH1cXG5cXG4gIHJldHVybiBjb21wYXJlKHZhbHVlLCBsZW5ndGgsIG1heCk7XFxufTtcXG5cXG52YXIgbGVuZ3RoID0ge1xcbiAgdmFsaWRhdGU6IHZhbGlkYXRlJG5cXG59O1xcblxcbnZhciB2YWxpZGF0ZSRvID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcXG4gIHZhciBsZW5ndGggPSByZWZbMF07XFxuXFxuICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpKSB7XFxuICAgIHJldHVybiBsZW5ndGggPj0gMDtcXG4gIH1cXG5cXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xcbiAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkbyh2YWwsIFtsZW5ndGhdKTsgfSk7XFxuICB9XFxuXFxuICByZXR1cm4gU3RyaW5nKHZhbHVlKS5sZW5ndGggPD0gbGVuZ3RoO1xcbn07XFxuXFxudmFyIG1heCA9IHtcXG4gIHZhbGlkYXRlOiB2YWxpZGF0ZSRvXFxufTtcXG5cXG52YXIgdmFsaWRhdGUkcCA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmKSB7XFxuICB2YXIgbWF4ID0gcmVmWzBdO1xcblxcbiAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJycpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XFxuICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPiAwICYmIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbGlkYXRlJHAodmFsLCBbbWF4XSk7IH0pO1xcbiAgfVxcblxcbiAgcmV0dXJuIE51bWJlcih2YWx1ZSkgPD0gbWF4O1xcbn07XFxuXFxudmFyIG1heF92YWx1ZSA9IHtcXG4gIHZhbGlkYXRlOiB2YWxpZGF0ZSRwXFxufTtcXG5cXG52YXIgdmFsaWRhdGUkcSA9IGZ1bmN0aW9uIChmaWxlcywgbWltZXMpIHtcXG4gIHZhciByZWdleCA9IG5ldyBSZWdFeHAoKChtaW1lcy5qb2luKCd8JykucmVwbGFjZSgnKicsICcuKycpKSArIFxcXCIkXFxcIiksICdpJyk7XFxuICByZXR1cm4gZW5zdXJlQXJyYXkoZmlsZXMpLmV2ZXJ5KGZ1bmN0aW9uIChmaWxlKSB7IHJldHVybiByZWdleC50ZXN0KGZpbGUudHlwZSk7IH0pO1xcbn07XFxuXFxudmFyIG1pbWVzID0ge1xcbiAgdmFsaWRhdGU6IHZhbGlkYXRlJHFcXG59O1xcblxcbnZhciB2YWxpZGF0ZSRyID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcXG4gIHZhciBsZW5ndGggPSByZWZbMF07XFxuXFxuICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xcbiAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkcih2YWwsIFtsZW5ndGhdKTsgfSk7XFxuICB9XFxuXFxuICByZXR1cm4gU3RyaW5nKHZhbHVlKS5sZW5ndGggPj0gbGVuZ3RoO1xcbn07XFxuXFxudmFyIG1pbiA9IHtcXG4gIHZhbGlkYXRlOiB2YWxpZGF0ZSRyXFxufTtcXG5cXG52YXIgdmFsaWRhdGUkcyA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVmKSB7XFxuICB2YXIgbWluID0gcmVmWzBdO1xcblxcbiAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJycpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XFxuICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPiAwICYmIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbGlkYXRlJHModmFsLCBbbWluXSk7IH0pO1xcbiAgfVxcblxcbiAgcmV0dXJuIE51bWJlcih2YWx1ZSkgPj0gbWluO1xcbn07XFxuXFxudmFyIG1pbl92YWx1ZSA9IHtcXG4gIHZhbGlkYXRlOiB2YWxpZGF0ZSRzXFxufTtcXG5cXG52YXIgYXIgPSAvXlvZoNmh2aLZo9mk2aXZptmn2ajZqV0rJC87XFxudmFyIGVuID0gL15bMC05XSskLztcXG5cXG52YXIgdmFsaWRhdGUkdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgdmFyIHRlc3RWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcXG4gICAgdmFyIHN0clZhbHVlID0gU3RyaW5nKHZhbCk7XFxuXFxuICAgIHJldHVybiBlbi50ZXN0KHN0clZhbHVlKSB8fCBhci50ZXN0KHN0clZhbHVlKTtcXG4gIH07XFxuXFxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcXG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KHRlc3RWYWx1ZSk7XFxuICB9XFxuXFxuICByZXR1cm4gdGVzdFZhbHVlKHZhbHVlKTtcXG59O1xcblxcbnZhciBudW1lcmljID0ge1xcbiAgdmFsaWRhdGU6IHZhbGlkYXRlJHRcXG59O1xcblxcbnZhciB2YWxpZGF0ZSR1ID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcXG4gIHZhciBleHByZXNzaW9uID0gcmVmLmV4cHJlc3Npb247XFxuXFxuICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdzdHJpbmcnKSB7XFxuICAgIGV4cHJlc3Npb24gPSBuZXcgUmVnRXhwKGV4cHJlc3Npb24pO1xcbiAgfVxcblxcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XFxuICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSR1KHZhbCwgeyBleHByZXNzaW9uOiBleHByZXNzaW9uIH0pOyB9KTtcXG4gIH1cXG5cXG4gIHJldHVybiBleHByZXNzaW9uLnRlc3QoU3RyaW5nKHZhbHVlKSk7XFxufTtcXG5cXG52YXIgcGFyYW1OYW1lcyRjID0gWydleHByZXNzaW9uJ107XFxuXFxudmFyIHJlZ2V4ID0ge1xcbiAgdmFsaWRhdGU6IHZhbGlkYXRlJHUsXFxuICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzJGNcXG59O1xcblxcbnZhciB2YWxpZGF0ZSR2ID0gZnVuY3Rpb24gKHZhbHVlLCByZWYpIHtcXG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSBbXTtcXG4gIHZhciBpbnZhbGlkYXRlRmFsc2UgPSByZWZbMF07IGlmICggaW52YWxpZGF0ZUZhbHNlID09PSB2b2lkIDAgKSBpbnZhbGlkYXRlRmFsc2UgPSBmYWxzZTtcXG5cXG4gIGlmIChpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkgfHwgaXNFbXB0eUFycmF5KHZhbHVlKSkge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICAvLyBpbmNhc2UgYSBmaWVsZCBjb25zaWRlcnMgYGZhbHNlYCBhcyBhbiBlbXB0eSB2YWx1ZSBsaWtlIGNoZWNrYm94ZXMuXFxuICBpZiAodmFsdWUgPT09IGZhbHNlICYmIGludmFsaWRhdGVGYWxzZSkge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICByZXR1cm4gISFTdHJpbmcodmFsdWUpLnRyaW0oKS5sZW5ndGg7XFxufTtcXG5cXG52YXIgcmVxdWlyZWQgPSB7XFxuICB2YWxpZGF0ZTogdmFsaWRhdGUkdlxcbn07XFxuXFxudmFyIHZhbGlkYXRlJHcgPSBmdW5jdGlvbiAodmFsdWUsIHJlZikge1xcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IFtdO1xcbiAgdmFyIG90aGVyRmllbGRWYWwgPSByZWZbMF07XFxuICB2YXIgcG9zc2libGVWYWxzID0gcmVmLnNsaWNlKDEpO1xcblxcbiAgdmFyIHJlcXVpcmVkID0gcG9zc2libGVWYWxzLmluY2x1ZGVzKFN0cmluZyhvdGhlckZpZWxkVmFsKS50cmltKCkpO1xcblxcbiAgaWYgKCFyZXF1aXJlZCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIHZhbGlkOiB0cnVlLFxcbiAgICAgIGRhdGE6IHtcXG4gICAgICAgIHJlcXVpcmVkOiByZXF1aXJlZFxcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHZhciBpbnZhbGlkID0gKGlzRW1wdHlBcnJheSh2YWx1ZSkgfHwgW2ZhbHNlLCBudWxsLCB1bmRlZmluZWRdLmluY2x1ZGVzKHZhbHVlKSk7XFxuXFxuICBpbnZhbGlkID0gaW52YWxpZCB8fCAhU3RyaW5nKHZhbHVlKS50cmltKCkubGVuZ3RoO1xcblxcbiAgcmV0dXJuIHtcXG4gICAgdmFsaWQ6ICFpbnZhbGlkLFxcbiAgICBkYXRhOiB7XFxuICAgICAgcmVxdWlyZWQ6IHJlcXVpcmVkXFxuICAgIH1cXG4gIH07XFxufTtcXG5cXG52YXIgb3B0aW9ucyQ1ID0ge1xcbiAgaGFzVGFyZ2V0OiB0cnVlLFxcbiAgY29tcHV0ZXNSZXF1aXJlZDogdHJ1ZVxcbn07XFxuXFxudmFyIHJlcXVpcmVkX2lmID0ge1xcbiAgdmFsaWRhdGU6IHZhbGlkYXRlJHcsXFxuICBvcHRpb25zOiBvcHRpb25zJDVcXG59O1xcblxcbnZhciB2YWxpZGF0ZSR4ID0gZnVuY3Rpb24gKGZpbGVzLCByZWYpIHtcXG4gIHZhciBzaXplID0gcmVmWzBdO1xcblxcbiAgaWYgKGlzTmFOKHNpemUpKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG4gIHZhciBuU2l6ZSA9IE51bWJlcihzaXplKSAqIDEwMjQ7XFxuICByZXR1cm4gZW5zdXJlQXJyYXkoZmlsZXMpLmV2ZXJ5KGZ1bmN0aW9uIChmaWxlKSB7IHJldHVybiBmaWxlLnNpemUgPD0gblNpemU7IH0pO1xcbn07XFxuXFxudmFyIHNpemUgPSB7XFxuICB2YWxpZGF0ZTogdmFsaWRhdGUkeFxcbn07XFxuXFxudmFyIGlzVVJMXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5leHBvcnRzLmRlZmF1bHQgPSBpc1VSTDtcXG5cXG5cXG5cXG52YXIgX2Fzc2VydFN0cmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGFzc2VydFN0cmluZ18xKTtcXG5cXG5cXG5cXG52YXIgX2lzRlFETjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGlzRlFETl8xKTtcXG5cXG5cXG5cXG52YXIgX2lzSVAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChpc0lQXzEpO1xcblxcblxcblxcbnZhciBfbWVyZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChtZXJnZV8xKTtcXG5cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxcblxcbnZhciBkZWZhdWx0X3VybF9vcHRpb25zID0ge1xcbiAgcHJvdG9jb2xzOiBbJ2h0dHAnLCAnaHR0cHMnLCAnZnRwJ10sXFxuICByZXF1aXJlX3RsZDogdHJ1ZSxcXG4gIHJlcXVpcmVfcHJvdG9jb2w6IGZhbHNlLFxcbiAgcmVxdWlyZV9ob3N0OiB0cnVlLFxcbiAgcmVxdWlyZV92YWxpZF9wcm90b2NvbDogdHJ1ZSxcXG4gIGFsbG93X3VuZGVyc2NvcmVzOiBmYWxzZSxcXG4gIGFsbG93X3RyYWlsaW5nX2RvdDogZmFsc2UsXFxuICBhbGxvd19wcm90b2NvbF9yZWxhdGl2ZV91cmxzOiBmYWxzZVxcbn07XFxuXFxudmFyIHdyYXBwZWRfaXB2NiA9IC9eXFxcXFsoW15cXFxcXV0rKVxcXFxdKD86OihbMC05XSspKT8kLztcXG5cXG5mdW5jdGlvbiBpc1JlZ0V4cChvYmopIHtcXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XFxufVxcblxcbmZ1bmN0aW9uIGNoZWNrSG9zdChob3N0LCBtYXRjaGVzKSB7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIG1hdGNoID0gbWF0Y2hlc1tpXTtcXG4gICAgaWYgKGhvc3QgPT09IG1hdGNoIHx8IGlzUmVnRXhwKG1hdGNoKSAmJiBtYXRjaC50ZXN0KGhvc3QpKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBmYWxzZTtcXG59XFxuXFxuZnVuY3Rpb24gaXNVUkwodXJsLCBvcHRpb25zKSB7XFxuICAoMCwgX2Fzc2VydFN0cmluZzIuZGVmYXVsdCkodXJsKTtcXG4gIGlmICghdXJsIHx8IHVybC5sZW5ndGggPj0gMjA4MyB8fCAvW1xcXFxzPD5dLy50ZXN0KHVybCkpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcbiAgaWYgKHVybC5pbmRleE9mKCdtYWlsdG86JykgPT09IDApIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UyLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfdXJsX29wdGlvbnMpO1xcbiAgdmFyIHByb3RvY29sID0gdm9pZCAwLFxcbiAgICAgIGF1dGggPSB2b2lkIDAsXFxuICAgICAgaG9zdCA9IHZvaWQgMCxcXG4gICAgICBob3N0bmFtZSA9IHZvaWQgMCxcXG4gICAgICBwb3J0ID0gdm9pZCAwLFxcbiAgICAgIHBvcnRfc3RyID0gdm9pZCAwLFxcbiAgICAgIHNwbGl0ID0gdm9pZCAwLFxcbiAgICAgIGlwdjYgPSB2b2lkIDA7XFxuXFxuICBzcGxpdCA9IHVybC5zcGxpdCgnIycpO1xcbiAgdXJsID0gc3BsaXQuc2hpZnQoKTtcXG5cXG4gIHNwbGl0ID0gdXJsLnNwbGl0KCc/Jyk7XFxuICB1cmwgPSBzcGxpdC5zaGlmdCgpO1xcblxcbiAgc3BsaXQgPSB1cmwuc3BsaXQoJzovLycpO1xcbiAgaWYgKHNwbGl0Lmxlbmd0aCA+IDEpIHtcXG4gICAgcHJvdG9jb2wgPSBzcGxpdC5zaGlmdCgpLnRvTG93ZXJDYXNlKCk7XFxuICAgIGlmIChvcHRpb25zLnJlcXVpcmVfdmFsaWRfcHJvdG9jb2wgJiYgb3B0aW9ucy5wcm90b2NvbHMuaW5kZXhPZihwcm90b2NvbCkgPT09IC0xKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICB9IGVsc2UgaWYgKG9wdGlvbnMucmVxdWlyZV9wcm90b2NvbCkge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9IGVsc2UgaWYgKHVybC5zdWJzdHIoMCwgMikgPT09ICcvLycpIHtcXG4gICAgaWYgKCFvcHRpb25zLmFsbG93X3Byb3RvY29sX3JlbGF0aXZlX3VybHMpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgc3BsaXRbMF0gPSB1cmwuc3Vic3RyKDIpO1xcbiAgfVxcbiAgdXJsID0gc3BsaXQuam9pbignOi8vJyk7XFxuXFxuICBpZiAodXJsID09PSAnJykge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICBzcGxpdCA9IHVybC5zcGxpdCgnLycpO1xcbiAgdXJsID0gc3BsaXQuc2hpZnQoKTtcXG5cXG4gIGlmICh1cmwgPT09ICcnICYmICFvcHRpb25zLnJlcXVpcmVfaG9zdCkge1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH1cXG5cXG4gIHNwbGl0ID0gdXJsLnNwbGl0KCdAJyk7XFxuICBpZiAoc3BsaXQubGVuZ3RoID4gMSkge1xcbiAgICBhdXRoID0gc3BsaXQuc2hpZnQoKTtcXG4gICAgaWYgKGF1dGguaW5kZXhPZignOicpID49IDAgJiYgYXV0aC5zcGxpdCgnOicpLmxlbmd0aCA+IDIpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gIH1cXG4gIGhvc3RuYW1lID0gc3BsaXQuam9pbignQCcpO1xcblxcbiAgcG9ydF9zdHIgPSBudWxsO1xcbiAgaXB2NiA9IG51bGw7XFxuICB2YXIgaXB2Nl9tYXRjaCA9IGhvc3RuYW1lLm1hdGNoKHdyYXBwZWRfaXB2Nik7XFxuICBpZiAoaXB2Nl9tYXRjaCkge1xcbiAgICBob3N0ID0gJyc7XFxuICAgIGlwdjYgPSBpcHY2X21hdGNoWzFdO1xcbiAgICBwb3J0X3N0ciA9IGlwdjZfbWF0Y2hbMl0gfHwgbnVsbDtcXG4gIH0gZWxzZSB7XFxuICAgIHNwbGl0ID0gaG9zdG5hbWUuc3BsaXQoJzonKTtcXG4gICAgaG9zdCA9IHNwbGl0LnNoaWZ0KCk7XFxuICAgIGlmIChzcGxpdC5sZW5ndGgpIHtcXG4gICAgICBwb3J0X3N0ciA9IHNwbGl0LmpvaW4oJzonKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKHBvcnRfc3RyICE9PSBudWxsKSB7XFxuICAgIHBvcnQgPSBwYXJzZUludChwb3J0X3N0ciwgMTApO1xcbiAgICBpZiAoIS9eWzAtOV0rJC8udGVzdChwb3J0X3N0cikgfHwgcG9ydCA8PSAwIHx8IHBvcnQgPiA2NTUzNSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKCEoMCwgX2lzSVAyLmRlZmF1bHQpKGhvc3QpICYmICEoMCwgX2lzRlFETjIuZGVmYXVsdCkoaG9zdCwgb3B0aW9ucykgJiYgKCFpcHY2IHx8ICEoMCwgX2lzSVAyLmRlZmF1bHQpKGlwdjYsIDYpKSkge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICBob3N0ID0gaG9zdCB8fCBpcHY2O1xcblxcbiAgaWYgKG9wdGlvbnMuaG9zdF93aGl0ZWxpc3QgJiYgIWNoZWNrSG9zdChob3N0LCBvcHRpb25zLmhvc3Rfd2hpdGVsaXN0KSkge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuICBpZiAob3B0aW9ucy5ob3N0X2JsYWNrbGlzdCAmJiBjaGVja0hvc3QoaG9zdCwgb3B0aW9ucy5ob3N0X2JsYWNrbGlzdCkpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRydWU7XFxufVxcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xcbn0pO1xcblxcbnZhciBpc1VSTCA9IHVud3JhcEV4cG9ydHMoaXNVUkxfMSk7XFxuXFxudmFyIHZhbGlkYXRlJHkgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcXG4gIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xcblxcbiAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSkge1xcbiAgICB2YWx1ZSA9ICcnO1xcbiAgfVxcblxcbiAgdmFyIHZhbGlkYXRvck9wdGlvbnMgPSBhc3NpZ24oe30sIG9wdGlvbnMpO1xcblxcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XFxuICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiBpc1VSTCh2YWwsIHZhbGlkYXRvck9wdGlvbnMpOyB9KTtcXG4gIH1cXG5cXG4gIHJldHVybiBpc1VSTCh2YWx1ZSwgdmFsaWRhdG9yT3B0aW9ucyk7XFxufTtcXG5cXG52YXIgdXJsID0ge1xcbiAgdmFsaWRhdGU6IHZhbGlkYXRlJHlcXG59O1xcblxcbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xcblxcbnZhciBSdWxlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcXG4gIGFmdGVyOiBhZnRlcixcXG4gIGFscGhhX2Rhc2g6IGFscGhhX2Rhc2gsXFxuICBhbHBoYV9udW06IGFscGhhX251bSxcXG4gIGFscGhhX3NwYWNlczogYWxwaGFfc3BhY2VzLFxcbiAgYWxwaGE6IGFscGhhJDEsXFxuICBiZWZvcmU6IGJlZm9yZSxcXG4gIGJldHdlZW46IGJldHdlZW4sXFxuICBjb25maXJtZWQ6IGNvbmZpcm1lZCxcXG4gIGNyZWRpdF9jYXJkOiBjcmVkaXRfY2FyZCxcXG4gIGRhdGVfYmV0d2VlbjogZGF0ZV9iZXR3ZWVuLFxcbiAgZGF0ZV9mb3JtYXQ6IGRhdGVfZm9ybWF0LFxcbiAgZGVjaW1hbDogZGVjaW1hbCxcXG4gIGRpZ2l0czogZGlnaXRzLFxcbiAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcXG4gIGVtYWlsOiBlbWFpbCxcXG4gIGV4dDogZXh0LFxcbiAgaW1hZ2U6IGltYWdlLFxcbiAgaW5jbHVkZWQ6IGluY2x1ZGVkLFxcbiAgaW50ZWdlcjogaW50ZWdlcixcXG4gIGxlbmd0aDogbGVuZ3RoLFxcbiAgaXA6IGlwLFxcbiAgaXBfb3JfZnFkbjogaXBfb3JfZnFkbixcXG4gIGlzX25vdDogaXNfbm90LFxcbiAgaXM6IGlzLFxcbiAgbWF4OiBtYXgsXFxuICBtYXhfdmFsdWU6IG1heF92YWx1ZSxcXG4gIG1pbWVzOiBtaW1lcyxcXG4gIG1pbjogbWluLFxcbiAgbWluX3ZhbHVlOiBtaW5fdmFsdWUsXFxuICBleGNsdWRlZDogZXhjbHVkZWQsXFxuICBudW1lcmljOiBudW1lcmljLFxcbiAgcmVnZXg6IHJlZ2V4LFxcbiAgcmVxdWlyZWQ6IHJlcXVpcmVkLFxcbiAgcmVxdWlyZWRfaWY6IHJlcXVpcmVkX2lmLFxcbiAgc2l6ZTogc2l6ZSxcXG4gIHVybDogdXJsXFxufSk7XFxuXFxuLy8gXFxuXFxudmFyIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChmaWVsZHMpIHtcXG4gIGlmIChBcnJheS5pc0FycmF5KGZpZWxkcykpIHtcXG4gICAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcXG4gICAgICBpZiAoaW5jbHVkZXMoY3VyciwgJy4nKSkge1xcbiAgICAgICAgcHJldltjdXJyLnNwbGl0KCcuJylbMV1dID0gY3VycjtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcHJldltjdXJyXSA9IGN1cnI7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBwcmV2O1xcbiAgICB9LCB7fSk7XFxuICB9XFxuXFxuICByZXR1cm4gZmllbGRzO1xcbn07XFxuXFxuLy8gQ29tYmluZXMgdHdvIGZsYWdzIHVzaW5nIGVpdGhlciBBTkQgb3IgT1IgZGVwZW5kaW5nIG9uIHRoZSBmbGFnIHR5cGUuXFxudmFyIGNvbWJpbmUgPSBmdW5jdGlvbiAobGhzLCByaHMpIHtcXG4gIHZhciBtYXBwZXIgPSB7XFxuICAgIHByaXN0aW5lOiBmdW5jdGlvbiAobGhzLCByaHMpIHsgcmV0dXJuIGxocyAmJiByaHM7IH0sXFxuICAgIGRpcnR5OiBmdW5jdGlvbiAobGhzLCByaHMpIHsgcmV0dXJuIGxocyB8fCByaHM7IH0sXFxuICAgIHRvdWNoZWQ6IGZ1bmN0aW9uIChsaHMsIHJocykgeyByZXR1cm4gbGhzIHx8IHJoczsgfSxcXG4gICAgdW50b3VjaGVkOiBmdW5jdGlvbiAobGhzLCByaHMpIHsgcmV0dXJuIGxocyAmJiByaHM7IH0sXFxuICAgIHZhbGlkOiBmdW5jdGlvbiAobGhzLCByaHMpIHsgcmV0dXJuIGxocyAmJiByaHM7IH0sXFxuICAgIGludmFsaWQ6IGZ1bmN0aW9uIChsaHMsIHJocykgeyByZXR1cm4gbGhzIHx8IHJoczsgfSxcXG4gICAgcGVuZGluZzogZnVuY3Rpb24gKGxocywgcmhzKSB7IHJldHVybiBsaHMgfHwgcmhzOyB9LFxcbiAgICByZXF1aXJlZDogZnVuY3Rpb24gKGxocywgcmhzKSB7IHJldHVybiBsaHMgfHwgcmhzOyB9LFxcbiAgICB2YWxpZGF0ZWQ6IGZ1bmN0aW9uIChsaHMsIHJocykgeyByZXR1cm4gbGhzICYmIHJoczsgfVxcbiAgfTtcXG5cXG4gIHJldHVybiBPYmplY3Qua2V5cyhtYXBwZXIpLnJlZHVjZShmdW5jdGlvbiAoZmxhZ3MsIGZsYWcpIHtcXG4gICAgZmxhZ3NbZmxhZ10gPSBtYXBwZXJbZmxhZ10obGhzW2ZsYWddLCByaHNbZmxhZ10pO1xcblxcbiAgICByZXR1cm4gZmxhZ3M7XFxuICB9LCB7fSk7XFxufTtcXG5cXG52YXIgbWFwU2NvcGUgPSBmdW5jdGlvbiAoc2NvcGUsIGRlZXApIHtcXG4gIGlmICggZGVlcCA9PT0gdm9pZCAwICkgZGVlcCA9IHRydWU7XFxuXFxuICByZXR1cm4gT2JqZWN0LmtleXMoc2NvcGUpLnJlZHVjZShmdW5jdGlvbiAoZmxhZ3MsIGZpZWxkKSB7XFxuICAgIGlmICghZmxhZ3MpIHtcXG4gICAgICBmbGFncyA9IGFzc2lnbih7fSwgc2NvcGVbZmllbGRdKTtcXG4gICAgICByZXR1cm4gZmxhZ3M7XFxuICAgIH1cXG5cXG4gICAgLy8gc2NvcGUuXFxuICAgIHZhciBpc1Njb3BlID0gZmllbGQuaW5kZXhPZignJCcpID09PSAwO1xcbiAgICBpZiAoZGVlcCAmJiBpc1Njb3BlKSB7XFxuICAgICAgcmV0dXJuIGNvbWJpbmUobWFwU2NvcGUoc2NvcGVbZmllbGRdKSwgZmxhZ3MpO1xcbiAgICB9IGVsc2UgaWYgKCFkZWVwICYmIGlzU2NvcGUpIHtcXG4gICAgICByZXR1cm4gZmxhZ3M7XFxuICAgIH1cXG5cXG4gICAgZmxhZ3MgPSBjb21iaW5lKGZsYWdzLCBzY29wZVtmaWVsZF0pO1xcblxcbiAgICByZXR1cm4gZmxhZ3M7XFxuICB9LCBudWxsKTtcXG59O1xcblxcbi8qKlxcbiAqIE1hcHMgZmllbGRzIHRvIGNvbXB1dGVkIGZ1bmN0aW9ucy5cXG4gKi9cXG52YXIgbWFwRmllbGRzID0gZnVuY3Rpb24gKGZpZWxkcykge1xcbiAgaWYgKCFmaWVsZHMpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gbWFwU2NvcGUodGhpcy4kdmFsaWRhdG9yLmZsYWdzKTtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIHZhciBub3JtYWxpemVkID0gbm9ybWFsaXplKGZpZWxkcyk7XFxuICByZXR1cm4gT2JqZWN0LmtleXMobm9ybWFsaXplZCkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XFxuICAgIHZhciBmaWVsZCA9IG5vcm1hbGl6ZWRbY3Vycl07XFxuICAgIHByZXZbY3Vycl0gPSBmdW5jdGlvbiBtYXBwZWRGaWVsZCAoKSB7XFxuICAgICAgLy8gaWYgZmllbGQgZXhpc3RzXFxuICAgICAgaWYgKHRoaXMuJHZhbGlkYXRvci5mbGFnc1tmaWVsZF0pIHtcXG4gICAgICAgIHJldHVybiB0aGlzLiR2YWxpZGF0b3IuZmxhZ3NbZmllbGRdO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBzY29wZWxlc3MgZmllbGRzIHdlcmUgc2VsZWN0ZWQuXFxuICAgICAgaWYgKG5vcm1hbGl6ZWRbY3Vycl0gPT09ICcqJykge1xcbiAgICAgICAgcmV0dXJuIG1hcFNjb3BlKHRoaXMuJHZhbGlkYXRvci5mbGFncywgZmFsc2UpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBpZiBpdCBoYXMgYSBzY29wZSBkZWZpbmVkXFxuICAgICAgdmFyIGluZGV4ID0gZmllbGQuaW5kZXhPZignLicpO1xcbiAgICAgIGlmIChpbmRleCA8PSAwKSB7XFxuICAgICAgICByZXR1cm4ge307XFxuICAgICAgfVxcblxcbiAgICAgIHZhciByZWYgPSBmaWVsZC5zcGxpdCgnLicpO1xcbiAgICAgIHZhciBzY29wZSA9IHJlZlswXTtcXG4gICAgICB2YXIgbmFtZSA9IHJlZi5zbGljZSgxKTtcXG5cXG4gICAgICBzY29wZSA9IHRoaXMuJHZhbGlkYXRvci5mbGFnc1soXFxcIiRcXFwiICsgc2NvcGUpXTtcXG4gICAgICBuYW1lID0gbmFtZS5qb2luKCcuJyk7XFxuXFxuICAgICAgLy8gYW4gZW50aXJlIHNjb3BlIHdhcyBzZWxlY3RlZDogc2NvcGUuKlxcbiAgICAgIGlmIChuYW1lID09PSAnKicgJiYgc2NvcGUpIHtcXG4gICAgICAgIHJldHVybiBtYXBTY29wZShzY29wZSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChzY29wZSAmJiBzY29wZVtuYW1lXSkge1xcbiAgICAgICAgcmV0dXJuIHNjb3BlW25hbWVdO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4ge307XFxuICAgIH07XFxuXFxuICAgIHJldHVybiBwcmV2O1xcbiAgfSwge30pO1xcbn07XFxuXFxudmFyICR2YWxpZGF0b3IgPSBudWxsO1xcblxcbnZhciBQUk9WSURFUl9DT1VOVEVSID0gMDtcXG5cXG52YXIgVmFsaWRhdGlvblByb3ZpZGVyID0ge1xcbiAgJF9fdmVlSW5qZWN0OiBmYWxzZSxcXG4gIGluamVjdDoge1xcbiAgICAkX3ZlZU9ic2VydmVyOiB7XFxuICAgICAgZnJvbTogJyRfdmVlT2JzZXJ2ZXInLFxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIGRlZmF1bHQkMSAoKSB7XFxuICAgICAgICBpZiAoIXRoaXMuJHZub2RlLmNvbnRleHQuJF92ZWVPYnNlcnZlcikge1xcbiAgICAgICAgICB0aGlzLiR2bm9kZS5jb250ZXh0LiRfdmVlT2JzZXJ2ZXIgPSBjcmVhdGVPYnNlcnZlcigpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRoaXMuJHZub2RlLmNvbnRleHQuJF92ZWVPYnNlcnZlcjtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sXFxuICBwcm9wczoge1xcbiAgICB2aWQ6IHtcXG4gICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIFBST1ZJREVSX0NPVU5URVIrKztcXG5cXG4gICAgICAgIHJldHVybiAoXFxcIl92ZWVfXFxcIiArIFBST1ZJREVSX0NPVU5URVIpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgbmFtZToge1xcbiAgICAgIHR5cGU6IFN0cmluZyxcXG4gICAgICBkZWZhdWx0OiBudWxsXFxuICAgIH0sXFxuICAgIG1vZGU6IHtcXG4gICAgICB0eXBlOiBbU3RyaW5nLCBGdW5jdGlvbl0sXFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIGdldENvbmZpZygpLm1vZGU7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBldmVudHM6IHtcXG4gICAgICB0eXBlOiBBcnJheSxcXG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cXG4gICAgICAgIGlmICh0cnVlKSB7XFxuICAgICAgICAgIHdhcm4oJ2V2ZW50cyBwcm9wIGFuZCBjb25maWcgd2lsbCBiZSBkZXByZWNhdGVkIGluIGZ1dHVyZSB2ZXJzaW9uIHBsZWFzZSB1c2UgdGhlIGludGVyYWN0aW9uIG1vZGVzIGluc3RlYWQnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH0sXFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGV2ZW50cyA9IGdldENvbmZpZygpLmV2ZW50cztcXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnRzID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLnNwbGl0KCd8Jyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gZXZlbnRzO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgcnVsZXM6IHtcXG4gICAgICB0eXBlOiBbT2JqZWN0LCBTdHJpbmddLFxcbiAgICAgIGRlZmF1bHQ6IG51bGxcXG4gICAgfSxcXG4gICAgaW1tZWRpYXRlOiB7XFxuICAgICAgdHlwZTogQm9vbGVhbixcXG4gICAgICBkZWZhdWx0OiBmYWxzZVxcbiAgICB9LFxcbiAgICBwZXJzaXN0OiB7XFxuICAgICAgdHlwZTogQm9vbGVhbixcXG4gICAgICBkZWZhdWx0OiBmYWxzZVxcbiAgICB9LFxcbiAgICBiYWlsczoge1xcbiAgICAgIHR5cGU6IEJvb2xlYW4sXFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0Q29uZmlnKCkuZmFzdEV4aXQ7IH1cXG4gICAgfSxcXG4gICAgZGVib3VuY2U6IHtcXG4gICAgICB0eXBlOiBOdW1iZXIsXFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0Q29uZmlnKCkuZGVsYXkgfHwgMDsgfVxcbiAgICB9LFxcbiAgICB0YWc6IHtcXG4gICAgICB0eXBlOiBTdHJpbmcsXFxuICAgICAgZGVmYXVsdDogJ3NwYW4nXFxuICAgIH0sXFxuICAgIHNsaW06IHtcXG4gICAgICB0eXBlOiBCb29sZWFuLFxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXFxuICAgIH1cXG4gIH0sXFxuICB3YXRjaDoge1xcbiAgICBydWxlczoge1xcbiAgICAgIGRlZXA6IHRydWUsXFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlciAodmFsLCBvbGRWYWwpIHtcXG4gICAgICAgIHRoaXMuX25lZWRzVmFsaWRhdGlvbiA9ICFpc0VxdWFsKHZhbCwgb2xkVmFsKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sXFxuICBkYXRhOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xcbiAgICBtZXNzYWdlczogW10sXFxuICAgIHZhbHVlOiB1bmRlZmluZWQsXFxuICAgIGluaXRpYWxpemVkOiBmYWxzZSxcXG4gICAgaW5pdGlhbFZhbHVlOiB1bmRlZmluZWQsXFxuICAgIGZsYWdzOiBjcmVhdGVGbGFncygpLFxcbiAgICBmYWlsZWRSdWxlczoge30sXFxuICAgIGZvcmNlUmVxdWlyZWQ6IGZhbHNlLFxcbiAgICBpc0RlYWN0aXZhdGVkOiBmYWxzZSxcXG4gICAgaWQ6IG51bGxcXG4gIH0pOyB9LFxcbiAgY29tcHV0ZWQ6IHtcXG4gICAgaXNWYWxpZDogZnVuY3Rpb24gaXNWYWxpZCAoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MudmFsaWQ7XFxuICAgIH0sXFxuICAgIGZpZWxkRGVwczogZnVuY3Rpb24gZmllbGREZXBzICgpIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICB2YXIgcnVsZXMgPSBub3JtYWxpemVSdWxlcyh0aGlzLnJ1bGVzKTtcXG5cXG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMocnVsZXMpLmZpbHRlcihSdWxlQ29udGFpbmVyLmlzVGFyZ2V0UnVsZSkubWFwKGZ1bmN0aW9uIChydWxlKSB7XFxuICAgICAgICB2YXIgZGVwTmFtZSA9IHJ1bGVzW3J1bGVdWzBdO1xcbiAgICAgICAgd2F0Y2hDcm9zc0ZpZWxkRGVwKHRoaXMkMSwgZGVwTmFtZSk7XFxuXFxuICAgICAgICByZXR1cm4gZGVwTmFtZTtcXG4gICAgICB9KTtcXG4gICAgfSxcXG4gICAgbm9ybWFsaXplZEV2ZW50czogZnVuY3Rpb24gbm9ybWFsaXplZEV2ZW50cyAoKSB7XFxuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgICAgdmFyIHJlZiA9IGNvbXB1dGVNb2RlU2V0dGluZyh0aGlzKTtcXG4gICAgICB2YXIgb24gPSByZWYub247XFxuXFxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZUV2ZW50cyhvbiB8fCB0aGlzLmV2ZW50cyB8fCBbXSkubWFwKGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBpZiAoZSA9PT0gJ2lucHV0Jykge1xcbiAgICAgICAgICByZXR1cm4gdGhpcyQxLl9pbnB1dEV2ZW50TmFtZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBlO1xcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBpc1JlcXVpcmVkOiBmdW5jdGlvbiBpc1JlcXVpcmVkICgpIHtcXG4gICAgICB2YXIgcnVsZXMgPSBub3JtYWxpemVSdWxlcyh0aGlzLnJ1bGVzKTtcXG4gICAgICB2YXIgZm9yY2VSZXF1aXJlZCA9IHRoaXMuZm9yY2VSZXF1aXJlZDtcXG5cXG4gICAgICB2YXIgaXNSZXF1aXJlZCA9IHJ1bGVzLnJlcXVpcmVkIHx8IGZvcmNlUmVxdWlyZWQ7XFxuICAgICAgdGhpcy5mbGFncy5yZXF1aXJlZCA9IGlzUmVxdWlyZWQ7XFxuXFxuICAgICAgcmV0dXJuIGlzUmVxdWlyZWQ7XFxuICAgIH0sXFxuICAgIGNsYXNzZXM6IGZ1bmN0aW9uIGNsYXNzZXMgKCkge1xcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICAgIHZhciBuYW1lcyA9IGdldENvbmZpZygpLmNsYXNzTmFtZXM7XFxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZmxhZ3MpLnJlZHVjZShmdW5jdGlvbiAoY2xhc3NlcywgZmxhZykge1xcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IChuYW1lcyAmJiBuYW1lc1tmbGFnXSkgfHwgZmxhZztcXG4gICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh0aGlzJDEuZmxhZ3NbZmxhZ10pKSB7XFxuICAgICAgICAgIHJldHVybiBjbGFzc2VzO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xcbiAgICAgICAgICBjbGFzc2VzW2NsYXNzTmFtZV0gPSB0aGlzJDEuZmxhZ3NbZmxhZ107XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gY2xhc3NlcztcXG4gICAgICB9LCB7fSk7XFxuICAgIH1cXG4gIH0sXFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgdGhpcy5yZWdpc3RlckZpZWxkKCk7XFxuICAgIHZhciBjdHggPSBjcmVhdGVWYWxpZGF0aW9uQ3R4KHRoaXMpO1xcblxcbiAgICAvLyBHcmFjZWZ1bGx5IGhhbmRsZSBub24tZXhpc3RlbnQgc2NvcGVkIHNsb3RzLlxcbiAgICB2YXIgc2xvdCA9IHRoaXMuJHNjb3BlZFNsb3RzLmRlZmF1bHQ7XFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXFxuICAgIGlmICghaXNDYWxsYWJsZShzbG90KSkge1xcbiAgICAgIGlmICh0cnVlKSB7XFxuICAgICAgICB3YXJuKCdWYWxpZGF0aW9uUHJvdmlkZXIgZXhwZWN0cyBhIHNjb3BlZCBzbG90LiBEaWQgeW91IGZvcmdldCB0byBhZGQgXFxcInYtc2xvdFxcXCIgdG8geW91ciBzbG90PycpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gaCh0aGlzLnRhZywgdGhpcy4kc2xvdHMuZGVmYXVsdCk7XFxuICAgIH1cXG5cXG4gICAgdmFyIG5vZGVzID0gc2xvdChjdHgpO1xcbiAgICAvLyBIYW5kbGUgc2luZ2xlLXJvb3Qgc2xvdC5cXG4gICAgZXh0cmFjdFZOb2Rlcyhub2RlcykuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHtcXG4gICAgICBhZGRMaXN0ZW5lcnMuY2FsbCh0aGlzJDEsIGlucHV0KTtcXG4gICAgfSk7XFxuXFxuICAgIHJldHVybiB0aGlzLnNsaW0gPyBjcmVhdGVSZW5kZXJsZXNzKGgsIG5vZGVzKSA6IGgodGhpcy50YWcsIG5vZGVzKTtcXG4gIH0sXFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95ICgpIHtcXG4gICAgLy8gY2xlYW51cCByZWZlcmVuY2UuXFxuICAgIHRoaXMuJF92ZWVPYnNlcnZlci51bnN1YnNjcmliZSh0aGlzKTtcXG4gIH0sXFxuICBhY3RpdmF0ZWQ6IGZ1bmN0aW9uIGFjdGl2YXRlZCAoKSB7XFxuICAgIHRoaXMuJF92ZWVPYnNlcnZlci5zdWJzY3JpYmUodGhpcyk7XFxuICAgIHRoaXMuaXNEZWFjdGl2YXRlZCA9IGZhbHNlO1xcbiAgfSxcXG4gIGRlYWN0aXZhdGVkOiBmdW5jdGlvbiBkZWFjdGl2YXRlZCAoKSB7XFxuICAgIHRoaXMuJF92ZWVPYnNlcnZlci51bnN1YnNjcmliZSh0aGlzKTtcXG4gICAgdGhpcy5pc0RlYWN0aXZhdGVkID0gdHJ1ZTtcXG4gIH0sXFxuICBtZXRob2RzOiB7XFxuICAgIHNldEZsYWdzOiBmdW5jdGlvbiBzZXRGbGFncyAoZmxhZ3MpIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICBPYmplY3Qua2V5cyhmbGFncykuZm9yRWFjaChmdW5jdGlvbiAoZmxhZykge1xcbiAgICAgICAgdGhpcyQxLmZsYWdzW2ZsYWddID0gZmxhZ3NbZmxhZ107XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIHN5bmNWYWx1ZTogZnVuY3Rpb24gc3luY1ZhbHVlIChlKSB7XFxuICAgICAgdmFyIHZhbHVlID0gbm9ybWFsaXplVmFsdWUkMShlKTtcXG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XFxuICAgICAgdGhpcy5mbGFncy5jaGFuZ2VkID0gdGhpcy5pbml0aWFsVmFsdWUgIT09IHZhbHVlO1xcbiAgICB9LFxcbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQgKCkge1xcbiAgICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcXG4gICAgICB0aGlzLl9wZW5kaW5nVmFsaWRhdGlvbiA9IG51bGw7XFxuICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSB0aGlzLnZhbHVlO1xcbiAgICAgIHZhciBmbGFncyA9IGNyZWF0ZUZsYWdzKCk7XFxuICAgICAgdGhpcy5zZXRGbGFncyhmbGFncyk7XFxuICAgIH0sXFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZSAoKSB7XFxuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcXG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xcblxcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIHRoaXMuc3luY1ZhbHVlKGFyZ3NbMF0pO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVNpbGVudCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xcbiAgICAgICAgdGhpcyQxLmFwcGx5UmVzdWx0KHJlc3VsdCk7XFxuXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICB2YWxpZGF0ZVNpbGVudDogZnVuY3Rpb24gdmFsaWRhdGVTaWxlbnQgKCkge1xcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuc2V0RmxhZ3MoeyBwZW5kaW5nOiB0cnVlIH0pO1xcblxcbiAgICAgIHJldHVybiAkdmFsaWRhdG9yLnZlcmlmeSh0aGlzLnZhbHVlLCB0aGlzLnJ1bGVzLCB7XFxuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXFxuICAgICAgICB2YWx1ZXM6IGNyZWF0ZVZhbHVlc0xvb2t1cCh0aGlzKSxcXG4gICAgICAgIGJhaWxzOiB0aGlzLmJhaWxzXFxuICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XFxuICAgICAgICB0aGlzJDEuc2V0RmxhZ3MoeyBwZW5kaW5nOiBmYWxzZSB9KTtcXG4gICAgICAgIGlmICghdGhpcyQxLmlzUmVxdWlyZWQpIHtcXG4gICAgICAgICAgdGhpcyQxLnNldEZsYWdzKHsgdmFsaWQ6IHJlc3VsdC52YWxpZCwgaW52YWxpZDogIXJlc3VsdC52YWxpZCB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIGFwcGx5UmVzdWx0OiBmdW5jdGlvbiBhcHBseVJlc3VsdCAocmVmKSB7XFxuICAgICAgdmFyIGVycm9ycyA9IHJlZi5lcnJvcnM7XFxuICAgICAgdmFyIGZhaWxlZFJ1bGVzID0gcmVmLmZhaWxlZFJ1bGVzO1xcblxcbiAgICAgIHRoaXMubWVzc2FnZXMgPSBlcnJvcnM7XFxuICAgICAgdGhpcy5mYWlsZWRSdWxlcyA9IGFzc2lnbih7fSwgZmFpbGVkUnVsZXMpO1xcbiAgICAgIHRoaXMuc2V0RmxhZ3Moe1xcbiAgICAgICAgdmFsaWQ6ICFlcnJvcnMubGVuZ3RoLFxcbiAgICAgICAgY2hhbmdlZDogdGhpcy52YWx1ZSAhPT0gdGhpcy5pbml0aWFsVmFsdWUsXFxuICAgICAgICBpbnZhbGlkOiAhIWVycm9ycy5sZW5ndGgsXFxuICAgICAgICB2YWxpZGF0ZWQ6IHRydWVcXG4gICAgICB9KTtcXG4gICAgfSxcXG4gICAgcmVnaXN0ZXJGaWVsZDogZnVuY3Rpb24gcmVnaXN0ZXJGaWVsZCAoKSB7XFxuICAgICAgaWYgKCEkdmFsaWRhdG9yKSB7XFxuICAgICAgICAkdmFsaWRhdG9yID0gZ2V0VmFsaWRhdG9yKCkgfHwgbmV3IFZhbGlkYXRvcihudWxsLCB7IGZhc3RFeGl0OiBnZXRDb25maWcoKS5mYXN0RXhpdCB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgdXBkYXRlUmVuZGVyaW5nQ29udGV4dFJlZnModGhpcyk7XFxuICAgIH1cXG4gIH1cXG59O1xcblxcbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRpb25DdHggKGN0eCkge1xcbiAgcmV0dXJuIHtcXG4gICAgZXJyb3JzOiBjdHgubWVzc2FnZXMsXFxuICAgIGZsYWdzOiBjdHguZmxhZ3MsXFxuICAgIGNsYXNzZXM6IGN0eC5jbGFzc2VzLFxcbiAgICB2YWxpZDogY3R4LmlzVmFsaWQsXFxuICAgIGZhaWxlZFJ1bGVzOiBjdHguZmFpbGVkUnVsZXMsXFxuICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjdHgucmVzZXQoKTsgfSxcXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xcbiAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XFxuXFxuICAgICAgcmV0dXJuIGN0eC52YWxpZGF0ZS5hcHBseShjdHgsIGFyZ3MpO1xcbiAgfSxcXG4gICAgYXJpYToge1xcbiAgICAgICdhcmlhLWludmFsaWQnOiBjdHguZmxhZ3MuaW52YWxpZCA/ICd0cnVlJyA6ICdmYWxzZScsXFxuICAgICAgJ2FyaWEtcmVxdWlyZWQnOiBjdHguaXNSZXF1aXJlZCA/ICd0cnVlJyA6ICdmYWxzZSdcXG4gICAgfVxcbiAgfTtcXG59XFxuXFxuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUkMSAodmFsdWUpIHtcXG4gIGlmIChpc0V2ZW50KHZhbHVlKSkge1xcbiAgICByZXR1cm4gdmFsdWUudGFyZ2V0LnR5cGUgPT09ICdmaWxlJyA/IHRvQXJyYXkodmFsdWUudGFyZ2V0LmZpbGVzKSA6IHZhbHVlLnRhcmdldC52YWx1ZTtcXG4gIH1cXG5cXG4gIHJldHVybiB2YWx1ZTtcXG59XFxuXFxuLyoqXFxuICogRGV0ZXJtaW5lcyBpZiBhIHByb3ZpZGVyIG5lZWRzIHRvIHJ1biB2YWxpZGF0aW9uLlxcbiAqL1xcbmZ1bmN0aW9uIHNob3VsZFZhbGlkYXRlIChjdHgsIG1vZGVsKSB7XFxuICAvLyB3aGVuIGFuIGltbWVkaWF0ZS9pbml0aWFsIHZhbGlkYXRpb24gaXMgbmVlZGVkIGFuZCB3YXNuJ3QgZG9uZSBiZWZvcmUuXFxuICBpZiAoIWN0eC5faWdub3JlSW1tZWRpYXRlICYmIGN0eC5pbW1lZGlhdGUpIHtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuXFxuICAvLyB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIGZvciB3aGF0ZXZlciByZWFzb24uXFxuICBpZiAoY3R4LnZhbHVlICE9PSBtb2RlbC52YWx1ZSkge1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH1cXG5cXG4gIC8vIHdoZW4gaXQgbmVlZHMgdmFsaWRhdGlvbiBkdWUgdG8gcHJvcHMvY3Jvc3MtZmllbGRzIGNoYW5nZXMuXFxuICBpZiAoY3R4Ll9uZWVkc1ZhbGlkYXRpb24pIHtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuXFxuICAvLyB3aGVuIHRoZSBpbml0aWFsIHZhbHVlIGlzIHVuZGVmaW5lZCBhbmQgdGhlIGZpZWxkIHdhc24ndCByZW5kZXJlZCB5ZXQuXFxuICBpZiAoIWN0eC5pbml0aWFsaXplZCAmJiBtb2RlbC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcblxcbiAgcmV0dXJuIGZhbHNlO1xcbn1cXG5cXG5mdW5jdGlvbiBjb21wdXRlTW9kZVNldHRpbmcgKGN0eCkge1xcbiAgdmFyIGNvbXB1dGUgPSBpc0NhbGxhYmxlKGN0eC5tb2RlKSA/IGN0eC5tb2RlIDogbW9kZXNbY3R4Lm1vZGVdO1xcblxcbiAgcmV0dXJuIGNvbXB1dGUoe1xcbiAgICBlcnJvcnM6IGN0eC5tZXNzYWdlcyxcXG4gICAgdmFsdWU6IGN0eC52YWx1ZSxcXG4gICAgZmxhZ3M6IGN0eC5mbGFnc1xcbiAgfSk7XFxufVxcblxcbmZ1bmN0aW9uIG9uUmVuZGVyVXBkYXRlIChtb2RlbCkge1xcbiAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XFxuICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gbW9kZWwudmFsdWU7XFxuICB9XFxuXFxuICB2YXIgdmFsaWRhdGVOb3cgPSBzaG91bGRWYWxpZGF0ZSh0aGlzLCBtb2RlbCk7XFxuICB0aGlzLl9uZWVkc1ZhbGlkYXRpb24gPSBmYWxzZTtcXG4gIHRoaXMudmFsdWUgPSBtb2RlbC52YWx1ZTtcXG4gIHRoaXMuX2lnbm9yZUltbWVkaWF0ZSA9IHRydWU7XFxuXFxuICBpZiAoIXZhbGlkYXRlTm93KSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIHRoaXMudmFsaWRhdGVTaWxlbnQoKS50aGVuKHRoaXMuaW1tZWRpYXRlIHx8IHRoaXMuZmxhZ3MudmFsaWRhdGVkID8gdGhpcy5hcHBseVJlc3VsdCA6IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9KTtcXG59XFxuXFxuLy8gQ3JlYXRlcyB0aGUgY29tbW9uIGhhbmRsZXJzIGZvciBhIHZhbGlkYXRhYmxlIGNvbnRleHQuXFxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uSGFuZGxlcnMgKGN0eCkge1xcbiAgdmFyIG9uSW5wdXQgPSBmdW5jdGlvbiAoZSkge1xcbiAgICBjdHguc3luY1ZhbHVlKGUpOyAvLyB0cmFjayBhbmQga2VlcCB0aGUgdmFsdWUgdXBkYXRlZC5cXG4gICAgY3R4LnNldEZsYWdzKHsgZGlydHk6IHRydWUsIHByaXN0aW5lOiBmYWxzZSB9KTtcXG4gIH07XFxuXFxuICAvLyBCbHVyIGV2ZW50IGxpc3RlbmVyLlxcbiAgdmFyIG9uQmx1ciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgY3R4LnNldEZsYWdzKHsgdG91Y2hlZDogdHJ1ZSwgdW50b3VjaGVkOiBmYWxzZSB9KTtcXG4gIH07XFxuXFxuICB2YXIgb25WYWxpZGF0ZSA9IGN0eC4kdmVlSGFuZGxlcjtcXG4gIHZhciBtb2RlID0gY29tcHV0ZU1vZGVTZXR0aW5nKGN0eCk7XFxuXFxuICAvLyBIYW5kbGUgZGVib3VuY2UgY2hhbmdlcy5cXG4gIGlmICghb25WYWxpZGF0ZSB8fCBjdHguJHZlZURlYm91bmNlICE9PSBjdHguZGVib3VuY2UpIHtcXG4gICAgb25WYWxpZGF0ZSA9IGRlYm91bmNlKFxcbiAgICAgIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGN0eC4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgcGVuZGluZ1Byb21pc2UgPSBjdHgudmFsaWRhdGVTaWxlbnQoKTtcXG4gICAgICAgICAgLy8gYXZvaWRzIHJhY2UgY29uZGl0aW9ucyBiZXR3ZWVuIHN1Y2Nlc3NpdmUgdmFsaWRhdGlvbnMuXFxuICAgICAgICAgIGN0eC5fcGVuZGluZ1ZhbGlkYXRpb24gPSBwZW5kaW5nUHJvbWlzZTtcXG4gICAgICAgICAgcGVuZGluZ1Byb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XFxuICAgICAgICAgICAgaWYgKHBlbmRpbmdQcm9taXNlID09PSBjdHguX3BlbmRpbmdWYWxpZGF0aW9uKSB7XFxuICAgICAgICAgICAgICBjdHguYXBwbHlSZXN1bHQocmVzdWx0KTtcXG4gICAgICAgICAgICAgIGN0eC5fcGVuZGluZ1ZhbGlkYXRpb24gPSBudWxsO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9KTtcXG4gICAgICB9LFxcbiAgICAgIG1vZGUuZGVib3VuY2UgfHwgY3R4LmRlYm91bmNlXFxuICAgICk7XFxuXFxuICAgIC8vIENhY2hlIHRoZSBoYW5kbGVyIHNvIHdlIGRvbid0IGNyZWF0ZSBpdCBlYWNoIHRpbWUuXFxuICAgIGN0eC4kdmVlSGFuZGxlciA9IG9uVmFsaWRhdGU7XFxuICAgIC8vIGNhY2hlIHRoZSBkZWJvdW5jZSB2YWx1ZSBzbyB3ZSBkZXRlY3QgaWYgaXQgd2FzIGNoYW5nZWQuXFxuICAgIGN0eC4kdmVlRGVib3VuY2UgPSBjdHguZGVib3VuY2U7XFxuICB9XFxuXFxuICByZXR1cm4geyBvbklucHV0OiBvbklucHV0LCBvbkJsdXI6IG9uQmx1ciwgb25WYWxpZGF0ZTogb25WYWxpZGF0ZSB9O1xcbn1cXG5cXG4vLyBBZGRzIGFsbCBwbHVnaW4gbGlzdGVuZXJzIHRvIHRoZSB2bm9kZS5cXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcnMgKG5vZGUpIHtcXG4gIHZhciBtb2RlbCA9IGZpbmRNb2RlbChub2RlKTtcXG4gIC8vIGNhY2hlIHRoZSBpbnB1dCBldmVudE5hbWUuXFxuICB0aGlzLl9pbnB1dEV2ZW50TmFtZSA9IHRoaXMuX2lucHV0RXZlbnROYW1lIHx8IGdldElucHV0RXZlbnROYW1lKG5vZGUsIG1vZGVsKTtcXG5cXG4gIG9uUmVuZGVyVXBkYXRlLmNhbGwodGhpcywgbW9kZWwpO1xcblxcbiAgdmFyIHJlZiA9IGNyZWF0ZUNvbW1vbkhhbmRsZXJzKHRoaXMpO1xcbiAgdmFyIG9uSW5wdXQgPSByZWYub25JbnB1dDtcXG4gIHZhciBvbkJsdXIgPSByZWYub25CbHVyO1xcbiAgdmFyIG9uVmFsaWRhdGUgPSByZWYub25WYWxpZGF0ZTtcXG4gIGFkZFZOb2RlTGlzdGVuZXIobm9kZSwgdGhpcy5faW5wdXRFdmVudE5hbWUsIG9uSW5wdXQpO1xcbiAgYWRkVk5vZGVMaXN0ZW5lcihub2RlLCAnYmx1cicsIG9uQmx1cik7XFxuXFxuICAvLyBhZGQgdGhlIHZhbGlkYXRpb24gbGlzdGVuZXJzLlxcbiAgdGhpcy5ub3JtYWxpemVkRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2dCkge1xcbiAgICBhZGRWTm9kZUxpc3RlbmVyKG5vZGUsIGV2dCwgb25WYWxpZGF0ZSk7XFxuICB9KTtcXG5cXG4gIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xcbn1cXG5cXG5mdW5jdGlvbiBjcmVhdGVWYWx1ZXNMb29rdXAgKGN0eCkge1xcbiAgdmFyIHByb3ZpZGVycyA9IGN0eC4kX3ZlZU9ic2VydmVyLnJlZnM7XFxuXFxuICByZXR1cm4gY3R4LmZpZWxkRGVwcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZGVwTmFtZSkge1xcbiAgICBpZiAoIXByb3ZpZGVyc1tkZXBOYW1lXSkge1xcbiAgICAgIHJldHVybiBhY2M7XFxuICAgIH1cXG5cXG4gICAgYWNjW2RlcE5hbWVdID0gcHJvdmlkZXJzW2RlcE5hbWVdLnZhbHVlO1xcblxcbiAgICByZXR1cm4gYWNjO1xcbiAgfSwge30pO1xcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVSZW5kZXJpbmdDb250ZXh0UmVmcyAoY3R4KSB7XFxuICAvLyBJRHMgc2hvdWxkIG5vdCBiZSBudWxsYWJsZS5cXG4gIGlmIChpc051bGxPclVuZGVmaW5lZChjdHguaWQpICYmIGN0eC5pZCA9PT0gY3R4LnZpZCkge1xcbiAgICBjdHguaWQgPSBQUk9WSURFUl9DT1VOVEVSO1xcbiAgICBQUk9WSURFUl9DT1VOVEVSKys7XFxuICB9XFxuXFxuICB2YXIgaWQgPSBjdHguaWQ7XFxuICB2YXIgdmlkID0gY3R4LnZpZDtcXG4gIC8vIE5vdGhpbmcgaGFzIGNoYW5nZWQuXFxuICBpZiAoY3R4LmlzRGVhY3RpdmF0ZWQgfHwgKGlkID09PSB2aWQgJiYgY3R4LiRfdmVlT2JzZXJ2ZXIucmVmc1tpZF0pKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIC8vIHZpZCB3YXMgY2hhbmdlZC5cXG4gIGlmIChpZCAhPT0gdmlkICYmIGN0eC4kX3ZlZU9ic2VydmVyLnJlZnNbaWRdID09PSBjdHgpIHtcXG4gICAgY3R4LiRfdmVlT2JzZXJ2ZXIudW5zdWJzY3JpYmUoY3R4KTtcXG4gIH1cXG5cXG4gIGN0eC4kX3ZlZU9ic2VydmVyLnN1YnNjcmliZShjdHgpO1xcbiAgY3R4LmlkID0gdmlkO1xcbn1cXG5cXG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlciAoKSB7XFxuICByZXR1cm4ge1xcbiAgICByZWZzOiB7fSxcXG4gICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUgKGN0eCkge1xcbiAgICAgIHRoaXMucmVmc1tjdHgudmlkXSA9IGN0eDtcXG4gICAgfSxcXG4gICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIHVuc3Vic2NyaWJlIChjdHgpIHtcXG4gICAgICBkZWxldGUgdGhpcy5yZWZzW2N0eC52aWRdO1xcbiAgICB9XFxuICB9O1xcbn1cXG5cXG5mdW5jdGlvbiB3YXRjaENyb3NzRmllbGREZXAgKGN0eCwgZGVwTmFtZSwgd2l0aEhvb2tzKSB7XFxuICBpZiAoIHdpdGhIb29rcyA9PT0gdm9pZCAwICkgd2l0aEhvb2tzID0gdHJ1ZTtcXG5cXG4gIHZhciBwcm92aWRlcnMgPSBjdHguJF92ZWVPYnNlcnZlci5yZWZzO1xcbiAgaWYgKCFjdHguX3ZlZVdhdGNoZXJzKSB7XFxuICAgIGN0eC5fdmVlV2F0Y2hlcnMgPSB7fTtcXG4gIH1cXG5cXG4gIGlmICghcHJvdmlkZXJzW2RlcE5hbWVdICYmIHdpdGhIb29rcykge1xcbiAgICByZXR1cm4gY3R4LiRvbmNlKCdob29rOm1vdW50ZWQnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgd2F0Y2hDcm9zc0ZpZWxkRGVwKGN0eCwgZGVwTmFtZSwgZmFsc2UpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIGlmICghaXNDYWxsYWJsZShjdHguX3ZlZVdhdGNoZXJzW2RlcE5hbWVdKSAmJiBwcm92aWRlcnNbZGVwTmFtZV0pIHtcXG4gICAgY3R4Ll92ZWVXYXRjaGVyc1tkZXBOYW1lXSA9IHByb3ZpZGVyc1tkZXBOYW1lXS4kd2F0Y2goJ3ZhbHVlJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIGlmIChjdHguZmxhZ3MudmFsaWRhdGVkKSB7XFxuICAgICAgICBjdHguX25lZWRzVmFsaWRhdGlvbiA9IHRydWU7XFxuICAgICAgICBjdHgudmFsaWRhdGUoKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfVxcbn1cXG5cXG52YXIgZmxhZ01lcmdpbmdTdHJhdGVneSA9IHtcXG4gIHByaXN0aW5lOiAnZXZlcnknLFxcbiAgZGlydHk6ICdzb21lJyxcXG4gIHRvdWNoZWQ6ICdzb21lJyxcXG4gIHVudG91Y2hlZDogJ2V2ZXJ5JyxcXG4gIHZhbGlkOiAnZXZlcnknLFxcbiAgaW52YWxpZDogJ3NvbWUnLFxcbiAgcGVuZGluZzogJ3NvbWUnLFxcbiAgdmFsaWRhdGVkOiAnZXZlcnknXFxufTtcXG5cXG5mdW5jdGlvbiBtZXJnZUZsYWdzIChsaHMsIHJocywgc3RyYXRlZ3kpIHtcXG4gIHZhciBzdHJhdE5hbWUgPSBmbGFnTWVyZ2luZ1N0cmF0ZWd5W3N0cmF0ZWd5XTtcXG5cXG4gIHJldHVybiBbbGhzLCByaHNdW3N0cmF0TmFtZV0oZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGY7IH0pO1xcbn1cXG5cXG52YXIgT0JTRVJWRVJfQ09VTlRFUiA9IDA7XFxuXFxudmFyIFZhbGlkYXRpb25PYnNlcnZlciA9IHtcXG4gIG5hbWU6ICdWYWxpZGF0aW9uT2JzZXJ2ZXInLFxcbiAgcHJvdmlkZTogZnVuY3Rpb24gcHJvdmlkZSAoKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgJF92ZWVPYnNlcnZlcjogdGhpc1xcbiAgICB9O1xcbiAgfSxcXG4gIGluamVjdDoge1xcbiAgICAkX3ZlZU9ic2VydmVyOiB7XFxuICAgICAgZnJvbTogJyRfdmVlT2JzZXJ2ZXInLFxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIGRlZmF1bHQkMSAoKSB7XFxuICAgICAgICBpZiAoIXRoaXMuJHZub2RlLmNvbnRleHQuJF92ZWVPYnNlcnZlcikge1xcbiAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0aGlzLiR2bm9kZS5jb250ZXh0LiRfdmVlT2JzZXJ2ZXI7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LFxcbiAgcHJvcHM6IHtcXG4gICAgdGFnOiB7XFxuICAgICAgdHlwZTogU3RyaW5nLFxcbiAgICAgIGRlZmF1bHQ6ICdzcGFuJ1xcbiAgICB9LFxcbiAgICBzbGltOiB7XFxuICAgICAgdHlwZTogQm9vbGVhbixcXG4gICAgICBkZWZhdWx0OiBmYWxzZVxcbiAgICB9XFxuICB9LFxcbiAgZGF0YTogZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcXG4gICAgdmlkOiAoXFxcIm9ic19cXFwiICsgKE9CU0VSVkVSX0NPVU5URVIrKykpLFxcbiAgICByZWZzOiB7fSxcXG4gICAgb2JzZXJ2ZXJzOiBbXSxcXG4gICAgcGVyc2lzdGVkU3RvcmU6IHt9XFxuICB9KTsgfSxcXG4gIGNvbXB1dGVkOiB7XFxuICAgIGN0eDogZnVuY3Rpb24gY3R4ICgpIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICB2YXIgY3R4ID0ge1xcbiAgICAgICAgZXJyb3JzOiB7fSxcXG4gICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoYXJnKSB7XFxuICAgICAgICAgIHZhciBwcm9taXNlID0gdGhpcyQxLnZhbGlkYXRlKGFyZyk7XFxuXFxuICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgdGhlbjogZnVuY3Rpb24gdGhlbiAodGhlbmFibGUpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcXG4gICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MgJiYgaXNDYWxsYWJsZSh0aGVuYWJsZSkpIHtcXG4gICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoZW5hYmxlKCkpO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3VjY2Vzcyk7XFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH07XFxuICAgICAgICB9LFxcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5yZXNldCgpOyB9XFxuICAgICAgfTtcXG5cXG4gICAgICByZXR1cm4gdmFsdWVzKHRoaXMucmVmcykuY29uY2F0KCBPYmplY3Qua2V5cyh0aGlzLnBlcnNpc3RlZFN0b3JlKS5tYXAoZnVuY3Rpb24gKGtleSkge1xcbiAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIHZpZDoga2V5LFxcbiAgICAgICAgICAgIGZsYWdzOiB0aGlzJDEucGVyc2lzdGVkU3RvcmVba2V5XS5mbGFncyxcXG4gICAgICAgICAgICBtZXNzYWdlczogdGhpcyQxLnBlcnNpc3RlZFN0b3JlW2tleV0uZXJyb3JzXFxuICAgICAgICAgIH07XFxuICAgICAgICB9KSxcXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzICkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHByb3ZpZGVyKSB7XFxuICAgICAgICBPYmplY3Qua2V5cyhmbGFnTWVyZ2luZ1N0cmF0ZWd5KS5mb3JFYWNoKGZ1bmN0aW9uIChmbGFnKSB7XFxuICAgICAgICAgIHZhciBmbGFncyA9IHByb3ZpZGVyLmZsYWdzIHx8IHByb3ZpZGVyLmN0eDtcXG4gICAgICAgICAgaWYgKCEoZmxhZyBpbiBhY2MpKSB7XFxuICAgICAgICAgICAgYWNjW2ZsYWddID0gZmxhZ3NbZmxhZ107XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGFjY1tmbGFnXSA9IG1lcmdlRmxhZ3MoYWNjW2ZsYWddLCBmbGFnc1tmbGFnXSwgZmxhZyk7XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGFjYy5lcnJvcnNbcHJvdmlkZXIudmlkXSA9IHByb3ZpZGVyLm1lc3NhZ2VzIHx8IHZhbHVlcyhwcm92aWRlci5jdHguZXJyb3JzKS5yZWR1Y2UoZnVuY3Rpb24gKGVycnMsIG9ic0Vycm9ycykge1xcbiAgICAgICAgICByZXR1cm4gZXJycy5jb25jYXQob2JzRXJyb3JzKTtcXG4gICAgICAgIH0sIFtdKTtcXG5cXG4gICAgICAgIHJldHVybiBhY2M7XFxuICAgICAgfSwgY3R4KTtcXG4gICAgfVxcbiAgfSxcXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xcbiAgICBpZiAodGhpcy4kX3ZlZU9ic2VydmVyKSB7XFxuICAgICAgdGhpcy4kX3ZlZU9ic2VydmVyLnN1YnNjcmliZSh0aGlzLCAnb2JzZXJ2ZXInKTtcXG4gICAgfVxcbiAgfSxcXG4gIGFjdGl2YXRlZDogZnVuY3Rpb24gYWN0aXZhdGVkICgpIHtcXG4gICAgaWYgKHRoaXMuJF92ZWVPYnNlcnZlcikge1xcbiAgICAgIHRoaXMuJF92ZWVPYnNlcnZlci5zdWJzY3JpYmUodGhpcywgJ29ic2VydmVyJyk7XFxuICAgIH1cXG4gIH0sXFxuICBkZWFjdGl2YXRlZDogZnVuY3Rpb24gZGVhY3RpdmF0ZWQgKCkge1xcbiAgICBpZiAodGhpcy4kX3ZlZU9ic2VydmVyKSB7XFxuICAgICAgdGhpcy4kX3ZlZU9ic2VydmVyLnVuc3Vic2NyaWJlKHRoaXMsICdvYnNlcnZlcicpO1xcbiAgICB9XFxuICB9LFxcbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSAoKSB7XFxuICAgIGlmICh0aGlzLiRfdmVlT2JzZXJ2ZXIpIHtcXG4gICAgICB0aGlzLiRfdmVlT2JzZXJ2ZXIudW5zdWJzY3JpYmUodGhpcywgJ29ic2VydmVyJyk7XFxuICAgIH1cXG4gIH0sXFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xcbiAgICB2YXIgc2xvdHMgPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IHRoaXMuJHNjb3BlZFNsb3RzLmRlZmF1bHQgfHwgW107XFxuICAgIGlmIChpc0NhbGxhYmxlKHNsb3RzKSkge1xcbiAgICAgIHNsb3RzID0gc2xvdHModGhpcy5jdHgpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB0aGlzLnNsaW0gPyBjcmVhdGVSZW5kZXJsZXNzKGgsIHNsb3RzKSA6IGgodGhpcy50YWcsIHsgb246IHRoaXMuJGxpc3RlbmVycywgYXR0cnM6IHRoaXMuJGF0dHJzIH0sIHNsb3RzKTtcXG4gIH0sXFxuICBtZXRob2RzOiB7XFxuICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlIChzdWJzY3JpYmVyLCBraW5kKSB7XFxuICAgICAgdmFyIG9iajtcXG5cXG4gICAgICBpZiAoIGtpbmQgPT09IHZvaWQgMCApIGtpbmQgPSAncHJvdmlkZXInO1xcbiAgICAgIGlmIChraW5kID09PSAnb2JzZXJ2ZXInKSB7XFxuICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKHN1YnNjcmliZXIpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLnJlZnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnJlZnMsICggb2JqID0ge30sIG9ialtzdWJzY3JpYmVyLnZpZF0gPSBzdWJzY3JpYmVyLCBvYmogKSk7XFxuICAgICAgaWYgKHN1YnNjcmliZXIucGVyc2lzdCAmJiB0aGlzLnBlcnNpc3RlZFN0b3JlW3N1YnNjcmliZXIudmlkXSkge1xcbiAgICAgICAgdGhpcy5yZXN0b3JlUHJvdmlkZXJTdGF0ZShzdWJzY3JpYmVyKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiB1bnN1YnNjcmliZSAocmVmLCBraW5kKSB7XFxuICAgICAgdmFyIHZpZCA9IHJlZi52aWQ7XFxuICAgICAgaWYgKCBraW5kID09PSB2b2lkIDAgKSBraW5kID0gJ3Byb3ZpZGVyJztcXG5cXG4gICAgICBpZiAoa2luZCA9PT0gJ3Byb3ZpZGVyJykge1xcbiAgICAgICAgdGhpcy5yZW1vdmVQcm92aWRlcih2aWQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgaWR4ID0gZmluZEluZGV4KHRoaXMub2JzZXJ2ZXJzLCBmdW5jdGlvbiAobykgeyByZXR1cm4gby52aWQgPT09IHZpZDsgfSk7XFxuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLnNwbGljZShpZHgsIDEpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlIChyZWYpIHtcXG4gICAgICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0geyBzaWxlbnQ6IGZhbHNlIH07XFxuICAgICAgdmFyIHNpbGVudCA9IHJlZi5zaWxlbnQ7XFxuXFxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHZhbHVlcyh0aGlzLnJlZnMpLm1hcChmdW5jdGlvbiAocmVmKSB7IHJldHVybiByZWZbc2lsZW50ID8gJ3ZhbGlkYXRlU2lsZW50JyA6ICd2YWxpZGF0ZSddKCkudGhlbihmdW5jdGlvbiAocikgeyByZXR1cm4gci52YWxpZDsgfSk7IH0pLmNvbmNhdCggdGhpcy5vYnNlcnZlcnMubWFwKGZ1bmN0aW9uIChvYnMpIHsgcmV0dXJuIG9icy52YWxpZGF0ZSh7IHNpbGVudDogc2lsZW50IH0pOyB9KVxcbiAgICAgICkpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHsgcmV0dXJuIHJlc3VsdHMuZXZlcnkoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHI7IH0pOyB9KTtcXG4gICAgfSxcXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0ICgpIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnBlcnNpc3RlZFN0b3JlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgICAgIHRoaXMkMS4kZGVsZXRlKHRoaXMkMS5wZXJzaXN0ZWRTdG9yZSwga2V5KTtcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gdmFsdWVzKHRoaXMucmVmcykuY29uY2F0KCB0aGlzLm9ic2VydmVycykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7IHJldHVybiByZWYucmVzZXQoKTsgfSk7XFxuICAgIH0sXFxuICAgIHJlc3RvcmVQcm92aWRlclN0YXRlOiBmdW5jdGlvbiByZXN0b3JlUHJvdmlkZXJTdGF0ZSAocHJvdmlkZXIpIHtcXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnBlcnNpc3RlZFN0b3JlW3Byb3ZpZGVyLnZpZF07XFxuICAgICAgcHJvdmlkZXIuc2V0RmxhZ3Moc3RhdGUuZmxhZ3MpO1xcbiAgICAgIHByb3ZpZGVyLmFwcGx5UmVzdWx0KHN0YXRlKTtcXG4gICAgICB0aGlzLiRkZWxldGUodGhpcy5wZXJzaXN0ZWRTdG9yZSwgcHJvdmlkZXIudmlkKTtcXG4gICAgfSxcXG4gICAgcmVtb3ZlUHJvdmlkZXI6IGZ1bmN0aW9uIHJlbW92ZVByb3ZpZGVyICh2aWQpIHtcXG4gICAgICB2YXIgb2JqO1xcblxcbiAgICAgIHZhciBwcm92aWRlciA9IHRoaXMucmVmc1t2aWRdO1xcbiAgICAgIC8vIHNhdmUgaXQgZm9yIHRoZSBuZXh0IHRpbWUuXFxuICAgICAgaWYgKHByb3ZpZGVyICYmIHByb3ZpZGVyLnBlcnNpc3QpIHtcXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXFxuICAgICAgICBpZiAodHJ1ZSkge1xcbiAgICAgICAgICBpZiAodmlkLmluZGV4T2YoJ192ZWVfJykgPT09IDApIHtcXG4gICAgICAgICAgICB3YXJuKCdQbGVhc2UgcHJvdmlkZSBhIGB2aWRgIHByb3Agd2hlbiB1c2luZyBgcGVyc2lzdGAsIHRoZXJlIG1pZ2h0IGJlIHVuZXhwZWN0ZWQgaXNzdWVzIG90aGVyd2lzZS4nKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5wZXJzaXN0ZWRTdG9yZSA9IGFzc2lnbih7fSwgdGhpcy5wZXJzaXN0ZWRTdG9yZSwgKCBvYmogPSB7fSwgb2JqW3ZpZF0gPSB7XFxuICAgICAgICAgICAgZmxhZ3M6IHByb3ZpZGVyLmZsYWdzLFxcbiAgICAgICAgICAgIGVycm9yczogcHJvdmlkZXIubWVzc2FnZXMsXFxuICAgICAgICAgICAgZmFpbGVkUnVsZXM6IHByb3ZpZGVyLmZhaWxlZFJ1bGVzXFxuICAgICAgICAgIH0sIG9iaiApKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy4kZGVsZXRlKHRoaXMucmVmcywgdmlkKTtcXG4gICAgfSxcXG4gIH1cXG59O1xcblxcbmZ1bmN0aW9uIHdpdGhWYWxpZGF0aW9uIChjb21wb25lbnQsIGN0eFRvUHJvcHMpIHtcXG4gIGlmICggY3R4VG9Qcm9wcyA9PT0gdm9pZCAwICkgY3R4VG9Qcm9wcyA9IG51bGw7XFxuXFxuICB2YXIgb3B0aW9ucyA9IGlzQ2FsbGFibGUoY29tcG9uZW50KSA/IGNvbXBvbmVudC5vcHRpb25zIDogY29tcG9uZW50O1xcbiAgb3B0aW9ucy4kX192ZWVJbmplY3QgPSBmYWxzZTtcXG4gIHZhciBob2MgPSB7XFxuICAgIG5hbWU6ICgob3B0aW9ucy5uYW1lIHx8ICdBbm9ueW1vdXNIb2MnKSArIFxcXCJXaXRoVmFsaWRhdGlvblxcXCIpLFxcbiAgICBwcm9wczogYXNzaWduKHt9LCBWYWxpZGF0aW9uUHJvdmlkZXIucHJvcHMpLFxcbiAgICBkYXRhOiBWYWxpZGF0aW9uUHJvdmlkZXIuZGF0YSxcXG4gICAgY29tcHV0ZWQ6IGFzc2lnbih7fSwgVmFsaWRhdGlvblByb3ZpZGVyLmNvbXB1dGVkKSxcXG4gICAgbWV0aG9kczogYXNzaWduKHt9LCBWYWxpZGF0aW9uUHJvdmlkZXIubWV0aG9kcyksXFxuICAgICRfX3ZlZUluamVjdDogZmFsc2UsXFxuICAgIGJlZm9yZURlc3Ryb3k6IFZhbGlkYXRpb25Qcm92aWRlci5iZWZvcmVEZXN0cm95LFxcbiAgICBpbmplY3Q6IFZhbGlkYXRpb25Qcm92aWRlci5pbmplY3RcXG4gIH07XFxuXFxuICAvLyBEZWZhdWx0IGN0eCBjb252ZXJ0cyBjdHggcHJvcHMgdG8gY29tcG9uZW50IHByb3BzLlxcbiAgaWYgKCFjdHhUb1Byb3BzKSB7XFxuICAgIGN0eFRvUHJvcHMgPSBmdW5jdGlvbiAoY3R4KSB7IHJldHVybiBjdHg7IH07XFxuICB9XFxuXFxuICB2YXIgZXZlbnROYW1lID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JztcXG5cXG4gIGhvYy5yZW5kZXIgPSBmdW5jdGlvbiAoaCkge1xcbiAgICB2YXIgb2JqO1xcblxcbiAgICB0aGlzLnJlZ2lzdGVyRmllbGQoKTtcXG4gICAgdmFyIHZjdHggPSBjcmVhdGVWYWxpZGF0aW9uQ3R4KHRoaXMpO1xcbiAgICB2YXIgbGlzdGVuZXJzID0gYXNzaWduKHt9LCB0aGlzLiRsaXN0ZW5lcnMpO1xcblxcbiAgICB2YXIgbW9kZWwgPSBmaW5kTW9kZWwodGhpcy4kdm5vZGUpO1xcbiAgICB0aGlzLl9pbnB1dEV2ZW50TmFtZSA9IHRoaXMuX2lucHV0RXZlbnROYW1lIHx8IGdldElucHV0RXZlbnROYW1lKHRoaXMuJHZub2RlLCBtb2RlbCk7XFxuICAgIG9uUmVuZGVyVXBkYXRlLmNhbGwodGhpcywgbW9kZWwpO1xcblxcbiAgICB2YXIgcmVmID0gY3JlYXRlQ29tbW9uSGFuZGxlcnModGhpcyk7XFxuICAgIHZhciBvbklucHV0ID0gcmVmLm9uSW5wdXQ7XFxuICAgIHZhciBvbkJsdXIgPSByZWYub25CbHVyO1xcbiAgICB2YXIgb25WYWxpZGF0ZSA9IHJlZi5vblZhbGlkYXRlO1xcblxcbiAgICBtZXJnZVZOb2RlTGlzdGVuZXJzKGxpc3RlbmVycywgZXZlbnROYW1lLCBvbklucHV0KTtcXG4gICAgbWVyZ2VWTm9kZUxpc3RlbmVycyhsaXN0ZW5lcnMsICdibHVyJywgb25CbHVyKTtcXG4gICAgdGhpcy5ub3JtYWxpemVkRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2dCwgaWR4KSB7XFxuICAgICAgbWVyZ2VWTm9kZUxpc3RlbmVycyhsaXN0ZW5lcnMsIGV2dCwgb25WYWxpZGF0ZSk7XFxuICAgIH0pO1xcblxcbiAgICAvLyBQcm9wcyBhcmUgYW55IGF0dHJzIG5vdCBhc3NvY2lhdGVkIHdpdGggVmFsaWRhdGlvblByb3ZpZGVyIFBsdXMgdGhlIG1vZGVsIHByb3AuXFxuICAgIC8vIFdBUk5JTkc6IEFjY2lkZW50YWwgcHJvcCBvdmVyd3JpdGUgd2lsbCBwcm9iYWJseSBoYXBwZW4uXFxuICAgIHZhciByZWYkMSA9IGZpbmRNb2RlbENvbmZpZyh0aGlzLiR2bm9kZSkgfHwgeyBwcm9wOiAndmFsdWUnIH07XFxuICAgIHZhciBwcm9wID0gcmVmJDEucHJvcDtcXG4gICAgdmFyIHByb3BzID0gYXNzaWduKHt9LCB0aGlzLiRhdHRycywgKCBvYmogPSB7fSwgb2JqW3Byb3BdID0gbW9kZWwudmFsdWUsIG9iaiApLCBjdHhUb1Byb3BzKHZjdHgpKTtcXG5cXG4gICAgcmV0dXJuIGgob3B0aW9ucywge1xcbiAgICAgIGF0dHJzOiB0aGlzLiRhdHRycyxcXG4gICAgICBwcm9wczogcHJvcHMsXFxuICAgICAgb246IGxpc3RlbmVyc1xcbiAgICB9LCBub3JtYWxpemVTbG90cyh0aGlzLiRzbG90cywgdGhpcy4kdm5vZGUuY29udGV4dCkpO1xcbiAgfTtcXG5cXG4gIHJldHVybiBob2M7XFxufVxcblxcbnZhciB2ZXJzaW9uID0gJzIuMi4xMic7XFxuXFxuT2JqZWN0LmtleXMoUnVsZXMpLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcXG4gIFZhbGlkYXRvci5leHRlbmQocnVsZSwgUnVsZXNbcnVsZV0udmFsaWRhdGUsIGFzc2lnbih7fSwgUnVsZXNbcnVsZV0ub3B0aW9ucywgeyBwYXJhbU5hbWVzOiBSdWxlc1tydWxlXS5wYXJhbU5hbWVzIH0pKTtcXG59KTtcXG5cXG4vLyBNZXJnZSB0aGUgZW5nbGlzaCBtZXNzYWdlcy5cXG5WYWxpZGF0b3IubG9jYWxpemUoeyBlbjogbG9jYWxlIH0pO1xcblxcbnZhciBpbnN0YWxsID0gVmVlVmFsaWRhdGUkMS5pbnN0YWxsO1xcblxcblZlZVZhbGlkYXRlJDEudmVyc2lvbiA9IHZlcnNpb247XFxuVmVlVmFsaWRhdGUkMS5tYXBGaWVsZHMgPSBtYXBGaWVsZHM7XFxuVmVlVmFsaWRhdGUkMS5WYWxpZGF0aW9uUHJvdmlkZXIgPSBWYWxpZGF0aW9uUHJvdmlkZXI7XFxuVmVlVmFsaWRhdGUkMS5WYWxpZGF0aW9uT2JzZXJ2ZXIgPSBWYWxpZGF0aW9uT2JzZXJ2ZXI7XFxuVmVlVmFsaWRhdGUkMS53aXRoVmFsaWRhdGlvbiA9IHdpdGhWYWxpZGF0aW9uO1xcblxcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcXFwiZGVmYXVsdFxcXCJdID0gKFZlZVZhbGlkYXRlJDEpO1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92ZWUtdmFsaWRhdGUvZGlzdC92ZWUtdmFsaWRhdGUuZXNtLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/IS4vc3JjL2pzL2NvbXBvbmVudHMvTG9naW5Gb3JtLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1iMzk3YWI5ZSZcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9qcy9jb21wb25lbnRzL0xvZ2luRm9ybS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YjM5N2FiOWUmICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInJlbmRlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVuZGVyOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJzdGF0aWNSZW5kZXJGbnNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHN0YXRpY1JlbmRlckZuczsgfSk7XFxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xcbiAgdmFyIF92bSA9IHRoaXNcXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXFxuICByZXR1cm4gX2MoXFxcImRpdlxcXCIsIHsgc3RhdGljQ2xhc3M6IFxcXCJjb250ZW50IG1vZC1sb2dpblxcXCIgfSwgW1xcbiAgICBfYyhcXFwiZGl2XFxcIiwgeyBzdGF0aWNDbGFzczogXFxcImxvZ2luLXdyYXBwZXJcXFwiIH0sIFtcXG4gICAgICBfYyhcXFwiZGl2XFxcIiwgeyBzdGF0aWNDbGFzczogXFxcImxvZ2luLXdyYXBwZXJfX3RpdGxlXFxcIiB9LCBbX3ZtLl92KFxcXCJBZG1pblxcXCIpXSksXFxuICAgICAgX3ZtLl92KFxcXCIgXFxcIiksXFxuICAgICAgX2MoXFxuICAgICAgICBcXFwiZm9ybVxcXCIsXFxuICAgICAgICB7XFxuICAgICAgICAgIGF0dHJzOiB7IGFjdGlvbjogX3ZtLnJvdXRlLCBtZXRob2Q6IF92bS5tZXRob2QgfSxcXG4gICAgICAgICAgb246IHsgc3VibWl0OiBfdm0uY2hlY2tGb3JtIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBbXFxuICAgICAgICAgIF9jKFxcXCJpbnB1dFxcXCIsIHtcXG4gICAgICAgICAgICBhdHRyczogeyB0eXBlOiBcXFwiaGlkZGVuXFxcIiwgbmFtZTogXFxcIl90b2tlblxcXCIgfSxcXG4gICAgICAgICAgICBkb21Qcm9wczogeyB2YWx1ZTogX3ZtLnRva2VuIH1cXG4gICAgICAgICAgfSksXFxuICAgICAgICAgIF92bS5fdihcXFwiIFxcXCIpLFxcbiAgICAgICAgICBfdm0uX2woX3ZtLmVycm9yc0pzb25QYXJzZSwgZnVuY3Rpb24oZXJyb3IpIHtcXG4gICAgICAgICAgICByZXR1cm4gX2MoXFxuICAgICAgICAgICAgICBcXFwiZGl2XFxcIixcXG4gICAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFxcXCJsb2dpbi13cmFwcGVyLWZyb21fX2Vycm9yLWNvbnRhaW5lclxcXCIgfSxcXG4gICAgICAgICAgICAgIF92bS5fbChlcnJvciwgZnVuY3Rpb24obWVzc2FnZSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gX2MoXFxcImRpdlxcXCIsIHsgc3RhdGljQ2xhc3M6IFxcXCJsb2dpbi13cmFwcGVyLWZyb21fX2Vycm9yXFxcIiB9LCBbXFxuICAgICAgICAgICAgICAgICAgX3ZtLl92KFxcbiAgICAgICAgICAgICAgICAgICAgXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICBcXFwiICtcXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKG1lc3NhZ2UpICtcXG4gICAgICAgICAgICAgICAgICAgICAgXFxcIlxcXFxuICAgICAgICAgICAgICAgIFxcXCJcXG4gICAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgIF0pXFxuICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgIDBcXG4gICAgICAgICAgICApXFxuICAgICAgICAgIH0pLFxcbiAgICAgICAgICBfdm0uX3YoXFxcIiBcXFwiKSxcXG4gICAgICAgICAgX2MoXFxcImRpdlxcXCIsIHsgc3RhdGljQ2xhc3M6IFxcXCJsb2dpbi13cmFwcGVyX19mcm9tXFxcIiB9LCBbXFxuICAgICAgICAgICAgX2MoXFxcImRpdlxcXCIsIHsgc3RhdGljQ2xhc3M6IFxcXCJsb2dpbi13cmFwcGVyLWZyb21fX2dyb3VwXFxcIiB9LCBbXFxuICAgICAgICAgICAgICBfYyhcXFwibGFiZWxcXFwiLCB7IGF0dHJzOiB7IGZvcjogXFxcImVtYWlsXFxcIiB9IH0sIFtfdm0uX3YoXFxcItCf0L7Rh9GC0LBcXFwiKV0pLFxcbiAgICAgICAgICAgICAgX3ZtLl92KFxcXCIgXFxcIiksXFxuICAgICAgICAgICAgICBfYyhcXFwiaW5wdXRcXFwiLCB7XFxuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcXG4gICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcXFwibW9kZWxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgcmF3TmFtZTogXFxcInYtbW9kZWxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5lbWFpbCxcXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFxcXCJlbWFpbFxcXCJcXG4gICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFxcXCJ2YWxpZGF0ZVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICByYXdOYW1lOiBcXFwidi12YWxpZGF0ZVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXFxcInJlcXVpcmVkfGVtYWlsXFxcIixcXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFxcXCIncmVxdWlyZWR8ZW1haWwnXFxcIlxcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgXSxcXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcXG4gICAgICAgICAgICAgICAgICB0eXBlOiBcXFwidGV4dFxcXCIsXFxuICAgICAgICAgICAgICAgICAgaWQ6IFxcXCJlbWFpbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgbmFtZTogXFxcImVtYWlsXFxcIixcXG4gICAgICAgICAgICAgICAgICBcXFwiZGF0YS12di1hc1xcXCI6IFxcXCLQn9C+0YfRgtCwXFxcIlxcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBkb21Qcm9wczogeyB2YWx1ZTogX3ZtLmVtYWlsIH0sXFxuICAgICAgICAgICAgICAgIG9uOiB7XFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCRldmVudCkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7XFxuICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgX3ZtLmVtYWlsID0gJGV2ZW50LnRhcmdldC52YWx1ZVxcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgICBfdm0uX3YoXFxcIiBcXFwiKSxcXG4gICAgICAgICAgICAgIF9jKFxcXCJkaXZcXFwiLCB7IHN0YXRpY0NsYXNzOiBcXFwibG9naW4td3JhcHBlci1mcm9tX19lcnJvclxcXCIgfSwgW1xcbiAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5lcnJvcnMuZmlyc3QoXFxcImVtYWlsXFxcIikpKVxcbiAgICAgICAgICAgICAgXSlcXG4gICAgICAgICAgICBdKSxcXG4gICAgICAgICAgICBfdm0uX3YoXFxcIiBcXFwiKSxcXG4gICAgICAgICAgICBfYyhcXFwiZGl2XFxcIiwgeyBzdGF0aWNDbGFzczogXFxcImxvZ2luLXdyYXBwZXItZnJvbV9fZ3JvdXBcXFwiIH0sIFtcXG4gICAgICAgICAgICAgIF9jKFxcXCJsYWJlbFxcXCIsIHsgYXR0cnM6IHsgZm9yOiBcXFwicGFzc3dvcmRcXFwiIH0gfSwgW192bS5fdihcXFwi0J/QsNGA0L7Qu9GMXFxcIildKSxcXG4gICAgICAgICAgICAgIF92bS5fdihcXFwiIFxcXCIpLFxcbiAgICAgICAgICAgICAgX2MoXFxcImlucHV0XFxcIiwge1xcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbXFxuICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXFxcIm1vZGVsXFxcIixcXG4gICAgICAgICAgICAgICAgICAgIHJhd05hbWU6IFxcXCJ2LW1vZGVsXFxcIixcXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0ucGFzc3dvcmQsXFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcXFwicGFzc3dvcmRcXFwiXFxuICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcXFwidmFsaWRhdGVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgcmF3TmFtZTogXFxcInYtdmFsaWRhdGVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFxcXCJyZXF1aXJlZFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcXFwiJ3JlcXVpcmVkJ1xcXCJcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIF0sXFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7XFxuICAgICAgICAgICAgICAgICAgdHlwZTogXFxcInBhc3N3b3JkXFxcIixcXG4gICAgICAgICAgICAgICAgICBpZDogXFxcInBhc3N3b3JkXFxcIixcXG4gICAgICAgICAgICAgICAgICBuYW1lOiBcXFwicGFzc3dvcmRcXFwiLFxcbiAgICAgICAgICAgICAgICAgIFxcXCJkYXRhLXZ2LWFzXFxcIjogXFxcItCf0LDRgNC+0LvRjFxcXCJcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS5wYXNzd29yZCB9LFxcbiAgICAgICAgICAgICAgICBvbjoge1xcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbigkZXZlbnQpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmICgkZXZlbnQudGFyZ2V0LmNvbXBvc2luZykge1xcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIF92bS5wYXNzd29yZCA9ICRldmVudC50YXJnZXQudmFsdWVcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgICAgX3ZtLl92KFxcXCIgXFxcIiksXFxuICAgICAgICAgICAgICBfYyhcXFwiZGl2XFxcIiwgeyBzdGF0aWNDbGFzczogXFxcImxvZ2luLXdyYXBwZXItZnJvbV9fZXJyb3JcXFwiIH0sIFtcXG4gICAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0uZXJyb3JzLmZpcnN0KFxcXCJwYXNzd29yZFxcXCIpKSlcXG4gICAgICAgICAgICAgIF0pXFxuICAgICAgICAgICAgXSksXFxuICAgICAgICAgICAgX3ZtLl92KFxcXCIgXFxcIiksXFxuICAgICAgICAgICAgX2MoXFxuICAgICAgICAgICAgICBcXFwiYnV0dG9uXFxcIixcXG4gICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFxcXCJsb2dpbi13cmFwcGVyLWZyb21fX2J1dHRvblxcXCIsXFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFxcXCJzdWJtaXRcXFwiIH1cXG4gICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICBbX3ZtLl92KFxcXCLQktC+0LnRgtC4XFxcIildXFxuICAgICAgICAgICAgKVxcbiAgICAgICAgICBdKVxcbiAgICAgICAgXSxcXG4gICAgICAgIDJcXG4gICAgICApXFxuICAgIF0pXFxuICBdKVxcbn1cXG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9Mb2dpbkZvcm0udnVlPy4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8hLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL0ZpbGUudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTUxOTFjMThiJlwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9GaWxlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01MTkxYzE4YiYgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiByZW5kZXIsIHN0YXRpY1JlbmRlckZucyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicmVuZGVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByZW5kZXI7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInN0YXRpY1JlbmRlckZuc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc3RhdGljUmVuZGVyRm5zOyB9KTtcXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgX3ZtID0gdGhpc1xcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcXG4gIHJldHVybiBfYyhcXFwiZGl2XFxcIiwgeyBzdGF0aWNDbGFzczogXFxcImZvcm0tZ3JvdXBfX2ZpZWxkLWZpbGVfX2NvbnRhaW5lclxcXCIgfSwgW1xcbiAgICBfYyhcXG4gICAgICBcXFwiYnV0dG9uXFxcIixcXG4gICAgICB7XFxuICAgICAgICBzdGF0aWNDbGFzczogXFxcImZvcm0tZ3JvdXBfX2ZpZWxkLWZpbGVcXFwiLFxcbiAgICAgICAgYXR0cnM6IHsgdHlwZTogXFxcImJ1dHRvblxcXCIgfSxcXG4gICAgICAgIG9uOiB7IGNsaWNrOiBfdm0ub3Blbk1hbmFnZXIgfVxcbiAgICAgIH0sXFxuICAgICAgW192bS5fdihcXFwi0JLRi9Cx0YDQsNGC0YxcXFwiKV1cXG4gICAgKSxcXG4gICAgX3ZtLl92KFxcXCIgXFxcIiksXFxuICAgIF9jKFxcXCJpbWdcXFwiLCB7XFxuICAgICAgc3RhdGljQ2xhc3M6IFxcXCJmb3JtLWdyb3VwX19maWVsZC1maWxlX19pbWFnZVxcXCIsXFxuICAgICAgYXR0cnM6IHsgc3JjOiBfdm0udXJsLCBhbHQ6IF92bS5maWxlTmFtZSB9XFxuICAgIH0pLFxcbiAgICBfdm0uX3YoXFxcIiBcXFwiKSxcXG4gICAgX2MoXFxcImlucHV0XFxcIiwge1xcbiAgICAgIGRpcmVjdGl2ZXM6IFtcXG4gICAgICAgIHsgbmFtZTogXFxcIm1vZGVsXFxcIiwgcmF3TmFtZTogXFxcInYtbW9kZWxcXFwiLCB2YWx1ZTogX3ZtLnVybCwgZXhwcmVzc2lvbjogXFxcInVybFxcXCIgfVxcbiAgICAgIF0sXFxuICAgICAgYXR0cnM6IHsgdHlwZTogXFxcImhpZGRlblxcXCIsIG5hbWU6IF92bS5uYW1lIH0sXFxuICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS51cmwgfSxcXG4gICAgICBvbjoge1xcbiAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCRldmVudCkge1xcbiAgICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHtcXG4gICAgICAgICAgICByZXR1cm5cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBfdm0udXJsID0gJGV2ZW50LnRhcmdldC52YWx1ZVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSlcXG4gIF0pXFxufVxcbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxcbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vRmlsZS52dWU/Li9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnNcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPyEuL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vSW1hZ2VJdGVyYXRvci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9OWQ5MDQxMmMmXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL0ltYWdlSXRlcmF0b3IudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTlkOTA0MTJjJiAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJyZW5kZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJlbmRlcjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwic3RhdGljUmVuZGVyRm5zXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzdGF0aWNSZW5kZXJGbnM7IH0pO1xcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcXG4gIHZhciBfdm0gPSB0aGlzXFxuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcXG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxcbiAgcmV0dXJuIF9jKFxcbiAgICBcXFwiZGl2XFxcIixcXG4gICAgeyBzdGF0aWNDbGFzczogXFxcImZvcm0tZ3JvdXBfX2l0ZXJhdG9yLWltYWdlXFxcIiB9LFxcbiAgICBbXFxuICAgICAgX2MoXFxuICAgICAgICBcXFwiZGl2XFxcIixcXG4gICAgICAgIHtcXG4gICAgICAgICAgZGlyZWN0aXZlczogW1xcbiAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgIG5hbWU6IFxcXCJzaG93XFxcIixcXG4gICAgICAgICAgICAgIHJhd05hbWU6IFxcXCJ2LXNob3dcXFwiLFxcbiAgICAgICAgICAgICAgdmFsdWU6IF92bS5pbWFnZXMubGVuZ3RoID09PSAwLFxcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXFxcImltYWdlcy5sZW5ndGggPT09IDBcXFwiXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICBdXFxuICAgICAgICB9LFxcbiAgICAgICAgW192bS5fdihcXFwi0J3QtdGCINGN0LvQtdC80LXQvdGC0L7QslxcXCIpXVxcbiAgICAgICksXFxuICAgICAgX3ZtLl92KFxcXCIgXFxcIiksXFxuICAgICAgX2MoXFxuICAgICAgICBcXFwiZHJhZ2dhYmxlXFxcIixcXG4gICAgICAgIHtcXG4gICAgICAgICAgbW9kZWw6IHtcXG4gICAgICAgICAgICB2YWx1ZTogX3ZtLmltYWdlcyxcXG4gICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oJCR2KSB7XFxuICAgICAgICAgICAgICBfdm0uaW1hZ2VzID0gJCR2XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBleHByZXNzaW9uOiBcXFwiaW1hZ2VzXFxcIlxcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgW1xcbiAgICAgICAgICBfYyhcXG4gICAgICAgICAgICBcXFwidHJhbnNpdGlvbi1ncm91cFxcXCIsXFxuICAgICAgICAgICAgeyBhdHRyczogeyB0eXBlOiBcXFwidHJhbnNpdGlvblxcXCIgfSB9LFxcbiAgICAgICAgICAgIF92bS5fbChfdm0uaW1hZ2VzLCBmdW5jdGlvbihpbWFnZSwgaW5kZXgpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBfYyhcXG4gICAgICAgICAgICAgICAgXFxcImRpdlxcXCIsXFxuICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICBrZXk6IGltYWdlLmlkLFxcbiAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcXFwiZm9ybS1ncm91cF9faXRlcmF0b3ItaW1hZ2VfY29udGFpbmVyXFxcIlxcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBbXFxuICAgICAgICAgICAgICAgICAgX2MoXFxcImRpdlxcXCIsIHsgc3RhdGljQ2xhc3M6IFxcXCJmb3JtLWdyb3VwX19pdGVyYXRvci1kcmFnXFxcIiB9KSxcXG4gICAgICAgICAgICAgICAgICBfdm0uX3YoXFxcIiBcXFwiKSxcXG4gICAgICAgICAgICAgICAgICBfYyhcXFwiZmlsZVxcXCIsIHtcXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFxcXCJpbWFnZXNbXFxcIiArIGluZGV4ICsgXFxcIl1baW1hZ2VdXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogaW1hZ2UuaW1hZ2VcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgICAgICBfdm0uX3YoXFxcIiBcXFwiKSxcXG4gICAgICAgICAgICAgICAgICBfYyhcXFwiaW5wdXRcXFwiLCB7XFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbXFxuICAgICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcXFwibW9kZWxcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd05hbWU6IFxcXCJ2LW1vZGVsXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW1hZ2UubmFtZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcXFwiaW1hZ2UubmFtZVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgXSxcXG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcXFwiZm9ybS1ncm91cF9fZmllbGQgaXRlcmF0b3ItaW1hZ2UtbmFtZVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcXFwiaW1hZ2VzW1xcXCIgKyBpbmRleCArIFxcXCJdW25hbWVdXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXFxcInRleHRcXFwiXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IGltYWdlLm5hbWUgfSxcXG4gICAgICAgICAgICAgICAgICAgIG9uOiB7XFxuICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbigkZXZlbnQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uJHNldChpbWFnZSwgXFxcIm5hbWVcXFwiLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVxcbiAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgICAgICAgX3ZtLl92KFxcXCIgXFxcIiksXFxuICAgICAgICAgICAgICAgICAgX2MoXFxcImlucHV0XFxcIiwge1xcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlczogW1xcbiAgICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXFxcIm1vZGVsXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdOYW1lOiBcXFwidi1tb2RlbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGltYWdlLmlkLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFxcXCJpbWFnZS5pZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgXSxcXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFxcXCJoaWRkZW5cXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcXFwiaW1hZ2VzW1xcXCIgKyBpbmRleCArIFxcXCJdW2lkXVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICBkb21Qcm9wczogeyB2YWx1ZTogaW1hZ2UuaWQgfSxcXG4gICAgICAgICAgICAgICAgICAgIG9uOiB7XFxuICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbigkZXZlbnQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uJHNldChpbWFnZSwgXFxcImlkXFxcIiwgJGV2ZW50LnRhcmdldC52YWx1ZSlcXG4gICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgICAgICAgIF92bS5fdihcXFwiIFxcXCIpLFxcbiAgICAgICAgICAgICAgICAgIF9jKFxcbiAgICAgICAgICAgICAgICAgICAgXFxcImJ1dHRvblxcXCIsXFxuICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcXFwiZm9ybS1ncm91cF9fZmllbGQtZmlsZVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFxcXCJidXR0b25cXFwiIH0sXFxuICAgICAgICAgICAgICAgICAgICAgIG9uOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92bS5yZW1vdmVJdGVyYXRlKGluZGV4KVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgIFtfdm0uX3YoXFxcItCj0LTQsNC70LjRgtGMXFxcXG4gICAgICAgICAgICAgICAgXFxcIildXFxuICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICBdLFxcbiAgICAgICAgICAgICAgICAxXFxuICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgMFxcbiAgICAgICAgICApXFxuICAgICAgICBdLFxcbiAgICAgICAgMVxcbiAgICAgICksXFxuICAgICAgX3ZtLl92KFxcXCIgXFxcIiksXFxuICAgICAgX2MoXFxuICAgICAgICBcXFwiYnV0dG9uXFxcIixcXG4gICAgICAgIHtcXG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFxcXCJmb3JtLWdyb3VwX19maWVsZC1maWxlIGZpZWxkLWZpbGUtaXRlcmF0b3JcXFwiLFxcbiAgICAgICAgICBhdHRyczogeyB0eXBlOiBcXFwiYnV0dG9uXFxcIiB9LFxcbiAgICAgICAgICBvbjogeyBjbGljazogX3ZtLmFkZEl0ZXJhdGUgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIFtfdm0uX3YoXFxcItCU0L7QsdCw0LLQuNGC0YxcXFwiKV1cXG4gICAgICApXFxuICAgIF0sXFxuICAgIDFcXG4gIClcXG59XFxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXFxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9JbWFnZUl0ZXJhdG9yLnZ1ZT8uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9uc1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/IS4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9NdWx0aVNlbGVjdC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YTQwMWU3NTQmXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9NdWx0aVNlbGVjdC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YTQwMWU3NTQmICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJyZW5kZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJlbmRlcjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwic3RhdGljUmVuZGVyRm5zXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzdGF0aWNSZW5kZXJGbnM7IH0pO1xcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcXG4gIHZhciBfdm0gPSB0aGlzXFxuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcXG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxcbiAgcmV0dXJuIF9jKFxcbiAgICBcXFwiZGl2XFxcIixcXG4gICAgW1xcbiAgICAgIF9jKFxcXCJtdWx0aS1saXN0LXNlbGVjdFxcXCIsIHtcXG4gICAgICAgIGF0dHJzOiB7XFxuICAgICAgICAgIGxpc3Q6IF92bS5kYXRhLFxcbiAgICAgICAgICBcXFwic2VsZWN0ZWQtaXRlbXNcXFwiOiBfdm0uc2VsZWN0ZWRJdGVtcyxcXG4gICAgICAgICAgXFxcIm9wdGlvbi12YWx1ZVxcXCI6IF92bS52YWx1ZSxcXG4gICAgICAgICAgXFxcIm9wdGlvbi10ZXh0XFxcIjogX3ZtLnRleHQsXFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiBcXFwi0JLRi9Cx0LXRgNC40YLQtSDRjdC70LXQvNC10L3RgtGLXFxcIlxcbiAgICAgICAgfSxcXG4gICAgICAgIG9uOiB7IHNlbGVjdDogX3ZtLm9uU2VsZWN0IH1cXG4gICAgICB9KSxcXG4gICAgICBfdm0uX3YoXFxcIiBcXFwiKSxcXG4gICAgICBfdm0uX2woX3ZtLnNlbGVjdGVkSXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcXG4gICAgICAgIHJldHVybiBfYyhcXFwiZGl2XFxcIiwgW1xcbiAgICAgICAgICBfYyhcXFwiaW5wdXRcXFwiLCB7XFxuICAgICAgICAgICAgZGlyZWN0aXZlczogW1xcbiAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICBuYW1lOiBcXFwibW9kZWxcXFwiLFxcbiAgICAgICAgICAgICAgICByYXdOYW1lOiBcXFwidi1tb2RlbFxcXCIsXFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtW192bS52YWx1ZV0sXFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFxcXCJpdGVtW3ZhbHVlXVxcXCJcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBdLFxcbiAgICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFxcXCJoaWRkZW5cXFwiLCBuYW1lOiBfdm0ubmFtZSArIFxcXCJbXVxcXCIgfSxcXG4gICAgICAgICAgICBkb21Qcm9wczogeyB2YWx1ZTogaXRlbVtfdm0udmFsdWVdIH0sXFxuICAgICAgICAgICAgb246IHtcXG4gICAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbigkZXZlbnQpIHtcXG4gICAgICAgICAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7XFxuICAgICAgICAgICAgICAgICAgcmV0dXJuXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgX3ZtLiRzZXQoaXRlbSwgX3ZtLnZhbHVlLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSlcXG4gICAgICAgIF0pXFxuICAgICAgfSlcXG4gICAgXSxcXG4gICAgMlxcbiAgKVxcbn1cXG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL011bHRpU2VsZWN0LnZ1ZT8uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9uc1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/IS4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9TZWxlY3QudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWI1ZjU4MTZhJlwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL1NlbGVjdC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YjVmNTgxNmEmICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiByZW5kZXIsIHN0YXRpY1JlbmRlckZucyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicmVuZGVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByZW5kZXI7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInN0YXRpY1JlbmRlckZuc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc3RhdGljUmVuZGVyRm5zOyB9KTtcXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgX3ZtID0gdGhpc1xcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcXG4gIHJldHVybiBfYyhcXG4gICAgXFxcImRpdlxcXCIsXFxuICAgIFtcXG4gICAgICBfYyhcXFwibW9kZWwtbGlzdC1zZWxlY3RcXFwiLCB7XFxuICAgICAgICBhdHRyczoge1xcbiAgICAgICAgICBsaXN0OiBfdm0uZGF0YSxcXG4gICAgICAgICAgXFxcIm9wdGlvbi12YWx1ZVxcXCI6IF92bS52YWx1ZSxcXG4gICAgICAgICAgXFxcIm9wdGlvbi10ZXh0XFxcIjogX3ZtLnRleHQsXFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiBcXFwi0JLRi9Cx0LXRgNC40YLQtSDRjdC70LXQvNC10L3RglxcXCJcXG4gICAgICAgIH0sXFxuICAgICAgICBtb2RlbDoge1xcbiAgICAgICAgICB2YWx1ZTogX3ZtLm9iamVjdEl0ZW0sXFxuICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbigkJHYpIHtcXG4gICAgICAgICAgICBfdm0ub2JqZWN0SXRlbSA9ICQkdlxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBleHByZXNzaW9uOiBcXFwib2JqZWN0SXRlbVxcXCJcXG4gICAgICAgIH1cXG4gICAgICB9KSxcXG4gICAgICBfdm0uX3YoXFxcIiBcXFwiKSxcXG4gICAgICBfYyhcXFwiaW5wdXRcXFwiLCB7XFxuICAgICAgICBkaXJlY3RpdmVzOiBbXFxuICAgICAgICAgIHtcXG4gICAgICAgICAgICBuYW1lOiBcXFwibW9kZWxcXFwiLFxcbiAgICAgICAgICAgIHJhd05hbWU6IFxcXCJ2LW1vZGVsXFxcIixcXG4gICAgICAgICAgICB2YWx1ZTogX3ZtLm9iamVjdEl0ZW1bX3ZtLnZhbHVlXSxcXG4gICAgICAgICAgICBleHByZXNzaW9uOiBcXFwib2JqZWN0SXRlbVt2YWx1ZV1cXFwiXFxuICAgICAgICAgIH1cXG4gICAgICAgIF0sXFxuICAgICAgICBhdHRyczogeyB0eXBlOiBcXFwiaGlkZGVuXFxcIiwgbmFtZTogX3ZtLm5hbWUgfSxcXG4gICAgICAgIGRvbVByb3BzOiB7IHZhbHVlOiBfdm0ub2JqZWN0SXRlbVtfdm0udmFsdWVdIH0sXFxuICAgICAgICBvbjoge1xcbiAgICAgICAgICBpbnB1dDogZnVuY3Rpb24oJGV2ZW50KSB7XFxuICAgICAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7XFxuICAgICAgICAgICAgICByZXR1cm5cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgX3ZtLiRzZXQoX3ZtLm9iamVjdEl0ZW0sIF92bS52YWx1ZSwgJGV2ZW50LnRhcmdldC52YWx1ZSlcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0pXFxuICAgIF0sXFxuICAgIDFcXG4gIClcXG59XFxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXFxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9TZWxlY3QudnVlPy4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbm9ybWFsaXplQ29tcG9uZW50OyB9KTtcXG4vKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cXG5cXG4vLyBJTVBPUlRBTlQ6IERvIE5PVCB1c2UgRVMyMDE1IGZlYXR1cmVzIGluIHRoaXMgZmlsZSAoZXhjZXB0IGZvciBtb2R1bGVzKS5cXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlLlxcblxcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXFxuICBzY3JpcHRFeHBvcnRzLFxcbiAgcmVuZGVyLFxcbiAgc3RhdGljUmVuZGVyRm5zLFxcbiAgZnVuY3Rpb25hbFRlbXBsYXRlLFxcbiAgaW5qZWN0U3R5bGVzLFxcbiAgc2NvcGVJZCxcXG4gIG1vZHVsZUlkZW50aWZpZXIsIC8qIHNlcnZlciBvbmx5ICovXFxuICBzaGFkb3dNb2RlIC8qIHZ1ZS1jbGkgb25seSAqL1xcbikge1xcbiAgLy8gVnVlLmV4dGVuZCBjb25zdHJ1Y3RvciBleHBvcnQgaW50ZXJvcFxcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xcbiAgICA6IHNjcmlwdEV4cG9ydHNcXG5cXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcXG4gIGlmIChyZW5kZXIpIHtcXG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnNcXG4gICAgb3B0aW9ucy5fY29tcGlsZWQgPSB0cnVlXFxuICB9XFxuXFxuICAvLyBmdW5jdGlvbmFsIHRlbXBsYXRlXFxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XFxuICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWVcXG4gIH1cXG5cXG4gIC8vIHNjb3BlZElkXFxuICBpZiAoc2NvcGVJZCkge1xcbiAgICBvcHRpb25zLl9zY29wZUlkID0gJ2RhdGEtdi0nICsgc2NvcGVJZFxcbiAgfVxcblxcbiAgdmFyIGhvb2tcXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7IC8vIHNlcnZlciBidWlsZFxcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcXG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXFxuICAgICAgY29udGV4dCA9XFxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcXG4gICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpIC8vIGZ1bmN0aW9uYWxcXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfX1xcbiAgICAgIH1cXG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xcbiAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcXG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXFxuICAgICAgfVxcbiAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJyZW5jZVxcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XFxuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXFxuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xcbiAgICBob29rID0gc2hhZG93TW9kZVxcbiAgICAgID8gZnVuY3Rpb24gKCkgeyBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCB0aGlzLiRyb290LiRvcHRpb25zLnNoYWRvd1Jvb3QpIH1cXG4gICAgICA6IGluamVjdFN0eWxlc1xcbiAgfVxcblxcbiAgaWYgKGhvb2spIHtcXG4gICAgaWYgKG9wdGlvbnMuZnVuY3Rpb25hbCkge1xcbiAgICAgIC8vIGZvciB0ZW1wbGF0ZS1vbmx5IGhvdC1yZWxvYWQgYmVjYXVzZSBpbiB0aGF0IGNhc2UgdGhlIHJlbmRlciBmbiBkb2Vzbid0XFxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsaXplclxcbiAgICAgIG9wdGlvbnMuX2luamVjdFN0eWxlcyA9IGhvb2tcXG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb2FsIGNvbXBvbmVudCBpbiB2dWUgZmlsZVxcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXFxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcXG4gICAgICAgIGhvb2suY2FsbChjb250ZXh0KVxcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXFxuICAgICAgdmFyIGV4aXN0aW5nID0gb3B0aW9ucy5iZWZvcmVDcmVhdGVcXG4gICAgICBvcHRpb25zLmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nXFxuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcXG4gICAgICAgIDogW2hvb2tdXFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiB7XFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcXG4gIH1cXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3Z1ZS1zZWFyY2gtc2VsZWN0L3B1Ymxpc2gvdnVlLXNlYXJjaC1zZWxlY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy92dWUtc2VhcmNoLXNlbGVjdC9wdWJsaXNoL3Z1ZS1zZWFyY2gtc2VsZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XFxuXFx0aWYodHJ1ZSlcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcXG5cXHRlbHNlIHt9XFxufSkodGhpcywgZnVuY3Rpb24oKSB7XFxucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcXG4vKioqKioqLyBcXHQvLyBUaGUgbW9kdWxlIGNhY2hlXFxuLyoqKioqKi8gXFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXFxuLyoqKioqKi8gXFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0XFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXFxuLyoqKioqKi8gXFx0XFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXFxuLyoqKioqKi8gXFx0XFx0XFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHRcXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxcbi8qKioqKiovIFxcdFxcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcXG4vKioqKioqLyBcXHRcXHRcXHRleHBvcnRzOiB7fSxcXG4vKioqKioqLyBcXHRcXHRcXHRpZDogbW9kdWxlSWQsXFxuLyoqKioqKi8gXFx0XFx0XFx0bG9hZGVkOiBmYWxzZVxcbi8qKioqKiovIFxcdFxcdH07XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHRcXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cXG4vKioqKioqLyBcXHRcXHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcXG4vKioqKioqLyBcXHRcXHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXFxuLyoqKioqKi8gXFx0XFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xcbi8qKioqKiovIFxcdH1cXG4vKioqKioqL1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcXFwiLi9cXFwiO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXFxuLyoqKioqKi8gXFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XFxuLyoqKioqKi8gfSlcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qKioqKiovIChbXFxuLyogMCAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdCd1c2Ugc3RyaWN0JztcXG5cXHRcXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuXFx0ICB2YWx1ZTogdHJ1ZVxcblxcdH0pO1xcblxcdGV4cG9ydHMuTW9kZWxMaXN0U2VsZWN0ID0gZXhwb3J0cy5Nb2RlbFNlbGVjdCA9IGV4cG9ydHMuTXVsdGlMaXN0U2VsZWN0ID0gZXhwb3J0cy5MaXN0U2VsZWN0ID0gZXhwb3J0cy5NdWx0aVNlbGVjdCA9IGV4cG9ydHMuQmFzaWNTZWxlY3QgPSB1bmRlZmluZWQ7XFxuXFx0XFxuXFx0dmFyIF9CYXNpY1NlbGVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xcblxcdFxcblxcdHZhciBfQmFzaWNTZWxlY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzaWNTZWxlY3QpO1xcblxcdFxcblxcdHZhciBfTGlzdFNlbGVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTcpO1xcblxcdFxcblxcdHZhciBfTGlzdFNlbGVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MaXN0U2VsZWN0KTtcXG5cXHRcXG5cXHR2YXIgX011bHRpTGlzdFNlbGVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTkpO1xcblxcdFxcblxcdHZhciBfTXVsdGlMaXN0U2VsZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX011bHRpTGlzdFNlbGVjdCk7XFxuXFx0XFxuXFx0dmFyIF9NdWx0aVNlbGVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xcblxcdFxcblxcdHZhciBfTXVsdGlTZWxlY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTXVsdGlTZWxlY3QpO1xcblxcdFxcblxcdHZhciBfTW9kZWxTZWxlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcXG5cXHRcXG5cXHR2YXIgX01vZGVsU2VsZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vZGVsU2VsZWN0KTtcXG5cXHRcXG5cXHR2YXIgX01vZGVsTGlzdFNlbGVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTgpO1xcblxcdFxcblxcdHZhciBfTW9kZWxMaXN0U2VsZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vZGVsTGlzdFNlbGVjdCk7XFxuXFx0XFxuXFx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXHRcXG5cXHRleHBvcnRzLkJhc2ljU2VsZWN0ID0gX0Jhc2ljU2VsZWN0Mi5kZWZhdWx0O1xcblxcdGV4cG9ydHMuTXVsdGlTZWxlY3QgPSBfTXVsdGlTZWxlY3QyLmRlZmF1bHQ7XFxuXFx0ZXhwb3J0cy5MaXN0U2VsZWN0ID0gX0xpc3RTZWxlY3QyLmRlZmF1bHQ7XFxuXFx0ZXhwb3J0cy5NdWx0aUxpc3RTZWxlY3QgPSBfTXVsdGlMaXN0U2VsZWN0Mi5kZWZhdWx0O1xcblxcdGV4cG9ydHMuTW9kZWxTZWxlY3QgPSBfTW9kZWxTZWxlY3QyLmRlZmF1bHQ7XFxuXFx0ZXhwb3J0cy5Nb2RlbExpc3RTZWxlY3QgPSBfTW9kZWxMaXN0U2VsZWN0Mi5kZWZhdWx0O1xcblxcbi8qKiovIH0sXFxuLyogMSAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XFxuXFx0dmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXFxuXFx0ICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XFxuXFx0aWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcXG5cXG4vKioqLyB9LFxcbi8qIDIgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHR2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xcblxcdCAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDMgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcXG5cXHR2YXIgSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNjgpXFxuXFx0ICAsIGRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcXG5cXHQgIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogNCAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdC8qXFxyXFxuXFx0XFx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcXHJcXG5cXHRcXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXFxyXFxuXFx0Ki9cXHJcXG5cXHQvLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxcclxcblxcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XFxyXFxuXFx0XFx0dmFyIGxpc3QgPSBbXTtcXHJcXG5cXHRcXHJcXG5cXHRcXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXFxyXFxuXFx0XFx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xcclxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBbXTtcXHJcXG5cXHRcXHRcXHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xcclxcblxcdFxcdFxcdFxcdHZhciBpdGVtID0gdGhpc1tpXTtcXHJcXG5cXHRcXHRcXHRcXHRpZihpdGVtWzJdKSB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0cmVzdWx0LnB1c2goXFxcIkBtZWRpYSBcXFwiICsgaXRlbVsyXSArIFxcXCJ7XFxcIiArIGl0ZW1bMV0gKyBcXFwifVxcXCIpO1xcclxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0LmpvaW4oXFxcIlxcXCIpO1xcclxcblxcdFxcdH07XFxyXFxuXFx0XFxyXFxuXFx0XFx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcXHJcXG5cXHRcXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XFxyXFxuXFx0XFx0XFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFxcXCJzdHJpbmdcXFwiKVxcclxcblxcdFxcdFxcdFxcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFxcXCJcXFwiXV07XFxyXFxuXFx0XFx0XFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcXHJcXG5cXHRcXHRcXHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xcclxcblxcdFxcdFxcdFxcdHZhciBpZCA9IHRoaXNbaV1bMF07XFxyXFxuXFx0XFx0XFx0XFx0aWYodHlwZW9mIGlkID09PSBcXFwibnVtYmVyXFxcIilcXHJcXG5cXHRcXHRcXHRcXHRcXHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdFxcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcXHJcXG5cXHRcXHRcXHRcXHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XFxyXFxuXFx0XFx0XFx0XFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxcclxcblxcdFxcdFxcdFxcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXFxyXFxuXFx0XFx0XFx0XFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cXHJcXG5cXHRcXHRcXHRcXHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxcclxcblxcdFxcdFxcdFxcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcXFwibnVtYmVyXFxcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xcclxcblxcdFxcdFxcdFxcdFxcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcXHJcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xcclxcblxcdFxcdFxcdFxcdFxcdFxcdGl0ZW1bMl0gPSBcXFwiKFxcXCIgKyBpdGVtWzJdICsgXFxcIikgYW5kIChcXFwiICsgbWVkaWFRdWVyeSArIFxcXCIpXFxcIjtcXHJcXG5cXHRcXHRcXHRcXHRcXHR9XFxyXFxuXFx0XFx0XFx0XFx0XFx0bGlzdC5wdXNoKGl0ZW0pO1xcclxcblxcdFxcdFxcdFxcdH1cXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0fTtcXHJcXG5cXHRcXHRyZXR1cm4gbGlzdDtcXHJcXG5cXHR9O1xcclxcblxcblxcbi8qKiovIH0sXFxuLyogNSAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8qXFxuXFx0XFx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcXG5cXHRcXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXFxuXFx0Ki9cXG5cXHR2YXIgc3R5bGVzSW5Eb20gPSB7fSxcXG5cXHRcXHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcXG5cXHRcXHRcXHR2YXIgbWVtbztcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdGlmICh0eXBlb2YgbWVtbyA9PT0gXFxcInVuZGVmaW5lZFxcXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdFxcdHJldHVybiBtZW1vO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fSxcXG5cXHRcXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZXR1cm4gL21zaWUgWzYtOV1cXFxcYi8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcXG5cXHRcXHR9KSxcXG5cXHRcXHRnZXRIZWFkRWxlbWVudCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJoZWFkXFxcIilbMF07XFxuXFx0XFx0fSksXFxuXFx0XFx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXFxuXFx0XFx0c2luZ2xldG9uQ291bnRlciA9IDAsXFxuXFx0XFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcXG5cXHRcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcXG5cXHRcXHRpZihmYWxzZSkge31cXG5cXHRcXG5cXHRcXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXHRcXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cXG5cXHRcXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXFxuXFx0XFx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXFxcInVuZGVmaW5lZFxcXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xcblxcdFxcblxcdFxcdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiA8aGVhZD4uXFxuXFx0XFx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcXFwidW5kZWZpbmVkXFxcIikgb3B0aW9ucy5pbnNlcnRBdCA9IFxcXCJib3R0b21cXFwiO1xcblxcdFxcblxcdFxcdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XFxuXFx0XFx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcXG5cXHRcXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcXG5cXHRcXHRcXHR2YXIgbWF5UmVtb3ZlID0gW107XFxuXFx0XFx0XFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdFxcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xcblxcdFxcdFxcdFxcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xcblxcdFxcdFxcdFxcdGRvbVN0eWxlLnJlZnMtLTtcXG5cXHRcXHRcXHRcXHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmKG5ld0xpc3QpIHtcXG5cXHRcXHRcXHRcXHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QpO1xcblxcdFxcdFxcdFxcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcXG5cXHRcXHRcXHRcXHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XFxuXFx0XFx0XFx0XFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcXG5cXHRcXHRcXHRcXHRcXHRcXHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xcblxcdFxcdFxcdFxcdFxcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdH1cXG5cXHRcXG5cXHRmdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcXG5cXHRcXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XFxuXFx0XFx0XFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XFxuXFx0XFx0XFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XFxuXFx0XFx0XFx0aWYoZG9tU3R5bGUpIHtcXG5cXHRcXHRcXHRcXHRkb21TdHlsZS5yZWZzKys7XFxuXFx0XFx0XFx0XFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dmFyIHBhcnRzID0gW107XFxuXFx0XFx0XFx0XFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFx0XFxuXFx0ZnVuY3Rpb24gbGlzdFRvU3R5bGVzKGxpc3QpIHtcXG5cXHRcXHR2YXIgc3R5bGVzID0gW107XFxuXFx0XFx0dmFyIG5ld1N0eWxlcyA9IHt9O1xcblxcdFxcdGZvcih2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XFxuXFx0XFx0XFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xcblxcdFxcdFxcdHZhciBpZCA9IGl0ZW1bMF07XFxuXFx0XFx0XFx0dmFyIGNzcyA9IGl0ZW1bMV07XFxuXFx0XFx0XFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcXG5cXHRcXHRcXHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcXG5cXHRcXHRcXHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XFxuXFx0XFx0XFx0aWYoIW5ld1N0eWxlc1tpZF0pXFxuXFx0XFx0XFx0XFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcXG5cXHRcXHRcXHRlbHNlXFxuXFx0XFx0XFx0XFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gc3R5bGVzO1xcblxcdH1cXG5cXHRcXG5cXHRmdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KSB7XFxuXFx0XFx0dmFyIGhlYWQgPSBnZXRIZWFkRWxlbWVudCgpO1xcblxcdFxcdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xcblxcdFxcdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcXFwidG9wXFxcIikge1xcblxcdFxcdFxcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xcblxcdFxcdFxcdFxcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgaGVhZC5maXJzdENoaWxkKTtcXG5cXHRcXHRcXHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcXG5cXHRcXHRcXHRcXHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xcblxcdFxcdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXFxcImJvdHRvbVxcXCIpIHtcXG5cXHRcXHRcXHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoXFxcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlxcXCIpO1xcblxcdFxcdH1cXG5cXHR9XFxuXFx0XFxuXFx0ZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xcblxcdFxcdHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XFxuXFx0XFx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcXG5cXHRcXHRpZihpZHggPj0gMCkge1xcblxcdFxcdFxcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xcblxcdFxcdH1cXG5cXHR9XFxuXFx0XFxuXFx0ZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcXG5cXHRcXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwic3R5bGVcXFwiKTtcXG5cXHRcXHRzdHlsZUVsZW1lbnQudHlwZSA9IFxcXCJ0ZXh0L2Nzc1xcXCI7XFxuXFx0XFx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XFxuXFx0XFx0cmV0dXJuIHN0eWxlRWxlbWVudDtcXG5cXHR9XFxuXFx0XFxuXFx0ZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XFxuXFx0XFx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XFxuXFx0XFxuXFx0XFx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XFxuXFx0XFx0XFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XFxuXFx0XFx0XFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XFxuXFx0XFx0XFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xcblxcdFxcdFxcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xcblxcdFxcdFxcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xcblxcdFxcdFxcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fVxcblxcdFxcblxcdFxcdHVwZGF0ZShvYmopO1xcblxcdFxcblxcdFxcdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcXG5cXHRcXHRcXHRpZihuZXdPYmopIHtcXG5cXHRcXHRcXHRcXHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0cmVtb3ZlKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0fVxcblxcdFxcblxcdHZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0dmFyIHRleHRTdG9yZSA9IFtdO1xcblxcdFxcblxcdFxcdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XFxuXFx0XFx0XFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xcblxcdFxcdFxcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcXFxuJyk7XFxuXFx0XFx0fTtcXG5cXHR9KSgpO1xcblxcdFxcblxcdGZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcXG5cXHRcXHR2YXIgY3NzID0gcmVtb3ZlID8gXFxcIlxcXCIgOiBvYmouY3NzO1xcblxcdFxcblxcdFxcdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xcblxcdFxcdFxcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcXG5cXHRcXHRcXHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xcblxcdFxcdFxcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcXG5cXHRcXHRcXHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXHRcXG5cXHRmdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlRWxlbWVudCwgb2JqKSB7XFxuXFx0XFx0dmFyIGNzcyA9IG9iai5jc3M7XFxuXFx0XFx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xcblxcdFxcdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xcblxcdFxcblxcdFxcdGlmIChtZWRpYSkge1xcblxcdFxcdFxcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXFxcIm1lZGlhXFxcIiwgbWVkaWEpO1xcblxcdFxcdH1cXG5cXHRcXG5cXHRcXHRpZiAoc291cmNlTWFwKSB7XFxuXFx0XFx0XFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kZXZ0b29scy9kb2NzL2phdmFzY3JpcHQtZGVidWdnaW5nXFxuXFx0XFx0XFx0Ly8gdGhpcyBtYWtlcyBzb3VyY2UgbWFwcyBpbnNpZGUgc3R5bGUgdGFncyB3b3JrIHByb3Blcmx5IGluIENocm9tZVxcblxcdFxcdFxcdGNzcyArPSAnXFxcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nO1xcblxcdFxcdFxcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XFxuXFx0XFx0XFx0Y3NzICs9IFxcXCJcXFxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXFxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcXFwiICovXFxcIjtcXG5cXHRcXHR9XFxuXFx0XFxuXFx0XFx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XFxuXFx0XFx0XFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XFxuXFx0XFx0XFx0XFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFxuLyoqKi8gfSxcXG4vKiA2ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0J3VzZSBzdHJpY3QnO1xcblxcdFxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG5cXHQgIHZhbHVlOiB0cnVlXFxuXFx0fSk7XFxuXFx0ZXhwb3J0cy5vcHRpb25Bd2FyZU1peGluID0gZXhwb3J0cy5jb21tb25NaXhpbiA9IGV4cG9ydHMuYmFzZU1peGluID0gdW5kZWZpbmVkO1xcblxcdFxcblxcdHZhciBfY29tbW9uTWl4aW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KTtcXG5cXHRcXG5cXHR2YXIgX2NvbW1vbk1peGluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbW1vbk1peGluKTtcXG5cXHRcXG5cXHR2YXIgX2Jhc2VNaXhpbiA9IF9fd2VicGFja19yZXF1aXJlX18oNTMpO1xcblxcdFxcblxcdHZhciBfYmFzZU1peGluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2VNaXhpbik7XFxuXFx0XFxuXFx0dmFyIF9vcHRpb25Bd2FyZU1peGluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XFxuXFx0XFxuXFx0dmFyIF9vcHRpb25Bd2FyZU1peGluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29wdGlvbkF3YXJlTWl4aW4pO1xcblxcdFxcblxcdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFx0XFxuXFx0ZXhwb3J0cy5iYXNlTWl4aW4gPSBfYmFzZU1peGluMi5kZWZhdWx0O1xcblxcdGV4cG9ydHMuY29tbW9uTWl4aW4gPSBfY29tbW9uTWl4aW4yLmRlZmF1bHQ7XFxuXFx0ZXhwb3J0cy5vcHRpb25Bd2FyZU1peGluID0gX29wdGlvbkF3YXJlTWl4aW4yLmRlZmF1bHQ7XFxuXFxuLyoqKi8gfSxcXG4vKiA3ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Ly8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxcblxcdG1vZHVsZS5leHBvcnRzID0gIV9fd2VicGFja19yZXF1aXJlX18oMTIpKGZ1bmN0aW9uKCl7XFxuXFx0ICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xcblxcdH0pO1xcblxcbi8qKiovIH0sXFxuLyogOCAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdHZhciBkUCAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KVxcblxcdCAgLCBjcmVhdGVEZXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcXG5cXHQgIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XFxuXFx0fSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XFxuXFx0ICBvYmplY3Rba2V5XSA9IHZhbHVlO1xcblxcdCAgcmV0dXJuIG9iamVjdDtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogOSAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdHZhciBhbk9iamVjdCAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpXFxuXFx0ICAsIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNilcXG5cXHQgICwgdG9QcmltaXRpdmUgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKVxcblxcdCAgLCBkUCAgICAgICAgICAgICA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcXG5cXHRcXG5cXHRleHBvcnRzLmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XFxuXFx0ICBhbk9iamVjdChPKTtcXG5cXHQgIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcXG5cXHQgIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xcblxcdCAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcXG5cXHQgICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xcblxcdCAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxcblxcdCAgaWYoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKXRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XFxuXFx0ICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XFxuXFx0ICByZXR1cm4gTztcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMTAgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHR2YXIgc3RvcmUgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpKCd3a3MnKVxcblxcdCAgLCB1aWQgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNylcXG5cXHQgICwgU3ltYm9sICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuU3ltYm9sXFxuXFx0ICAsIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XFxuXFx0XFxuXFx0dmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcXG5cXHQgIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxcblxcdCAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xcblxcdH07XFxuXFx0XFxuXFx0JGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcXG5cXG4vKioqLyB9LFxcbi8qIDExICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFx0dmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcXG5cXHRpZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcXG5cXG4vKioqLyB9LFxcbi8qIDEyICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcXG5cXHQgIHRyeSB7XFxuXFx0ICAgIHJldHVybiAhIWV4ZWMoKTtcXG5cXHQgIH0gY2F0Y2goZSl7XFxuXFx0ICAgIHJldHVybiB0cnVlO1xcblxcdCAgfVxcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiAxMyAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxcblxcdHZhciAka2V5cyAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpXFxuXFx0ICAsIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XFxuXFx0XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pe1xcblxcdCAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMTQgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHR2YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcXG5cXHQgIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xcblxcdCAgcmV0dXJuIGl0O1xcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiAxNSAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xcblxcdCAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMTYgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xcblxcdCAgcmV0dXJuIHtcXG5cXHQgICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxcblxcdCAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXFxuXFx0ICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcXG5cXHQgICAgdmFsdWUgICAgICAgOiB2YWx1ZVxcblxcdCAgfTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMTcgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHR2YXIgaWQgPSAwXFxuXFx0ICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XFxuXFx0ICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiAxOCAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdCd1c2Ugc3RyaWN0JztcXG5cXHRcXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuXFx0ICB2YWx1ZTogdHJ1ZVxcblxcdH0pO1xcblxcdGV4cG9ydHMuZGVmYXVsdCA9IHtcXG5cXHQgIG9wZW5PcHRpb25zOiBmdW5jdGlvbiBvcGVuT3B0aW9ucyhzZWxmKSB7XFxuXFx0ICAgIHNlbGYuJHJlZnMuaW5wdXQuZm9jdXMoKTtcXG5cXHQgICAgc2VsZi5zaG93TWVudSA9IHRydWU7XFxuXFx0ICAgIHNlbGYubW91c2Vkb3duU3RhdGUgPSBmYWxzZTtcXG5cXHQgIH0sXFxuXFx0ICBibHVySW5wdXQ6IGZ1bmN0aW9uIGJsdXJJbnB1dChzZWxmKSB7XFxuXFx0ICAgIGlmICghc2VsZi5tb3VzZWRvd25TdGF0ZSkge1xcblxcdCAgICAgIHNlbGYuc2VhcmNoVGV4dCA9ICcnO1xcblxcdCAgICAgIHNlbGYuY2xvc2VPcHRpb25zKCk7XFxuXFx0ICAgIH1cXG5cXHQgIH0sXFxuXFx0ICBjbG9zZU9wdGlvbnM6IGZ1bmN0aW9uIGNsb3NlT3B0aW9ucyhzZWxmKSB7XFxuXFx0ICAgIHNlbGYuc2hvd01lbnUgPSBmYWxzZTtcXG5cXHQgIH0sXFxuXFx0ICBwcmV2SXRlbTogZnVuY3Rpb24gcHJldkl0ZW0oc2VsZikge1xcblxcdCAgICB2YXIgcHJldkluZGV4ID0gc2VsZi5wb2ludGVyIC0gMTtcXG5cXHQgICAgdmFyIHByZXZJbmRleFNjcm9sbFRvcCA9IHNlbGYuJGVsLm9mZnNldEhlaWdodCAqIHByZXZJbmRleDtcXG5cXHQgICAgaWYgKHByZXZJbmRleCA+PSAwKSB7XFxuXFx0ICAgICAgc2VsZi5wb2ludGVyID0gcHJldkluZGV4O1xcblxcdCAgICB9XFxuXFx0XFxuXFx0ICAgIHNlbGYuJHJlZnMubWVudS5zY3JvbGxUb3AgPSBwcmV2SW5kZXhTY3JvbGxUb3A7XFxuXFx0ICB9LFxcblxcdCAgbmV4dEl0ZW06IGZ1bmN0aW9uIG5leHRJdGVtKHNlbGYpIHtcXG5cXHQgICAgdmFyIG5leHRJbmRleCA9IHNlbGYucG9pbnRlciArIDE7XFxuXFx0ICAgIHZhciBuZXh0SW5kZXhTY3JvbGxUb3AgPSBzZWxmLiRlbC5vZmZzZXRIZWlnaHQgKiBuZXh0SW5kZXg7XFxuXFx0ICAgIGlmIChuZXh0SW5kZXggPD0gc2VsZi5maWx0ZXJlZE9wdGlvbnMubGVuZ3RoIC0gMSkge1xcblxcdCAgICAgIHNlbGYucG9pbnRlciA9IG5leHRJbmRleDtcXG5cXHQgICAgfVxcblxcdFxcblxcdCAgICB2YXIgY3VycmVudE1lbnVIZWlnaHQgPSBzZWxmLiRyZWZzLm1lbnUub2Zmc2V0SGVpZ2h0O1xcblxcdCAgICB2YXIgY3VycmVudFBhZ2UgPSBNYXRoLmNlaWwoKHNlbGYuJHJlZnMubWVudS5zY3JvbGxUb3AgKyBzZWxmLiRlbC5vZmZzZXRIZWlnaHQpIC8gY3VycmVudE1lbnVIZWlnaHQpO1xcblxcdCAgICB2YXIgaXRlbVBhZ2UgPSBNYXRoLmNlaWwobmV4dEluZGV4U2Nyb2xsVG9wIC8gY3VycmVudE1lbnVIZWlnaHQpO1xcblxcdFxcblxcdCAgICBpZiAoY3VycmVudFBhZ2UgIT09IGl0ZW1QYWdlKSB7XFxuXFx0ICAgICAgc2VsZi4kcmVmcy5tZW51LnNjcm9sbFRvcCA9IChpdGVtUGFnZSAtIDEpICogc2VsZi4kcmVmcy5tZW51Lm9mZnNldEhlaWdodDtcXG5cXHQgICAgfVxcblxcdCAgfSxcXG5cXHQgIGVudGVySXRlbTogZnVuY3Rpb24gZW50ZXJJdGVtKHNlbGYpIHtcXG5cXHQgICAgdmFyIGN1cnJlbnRJdGVtID0gc2VsZi5maWx0ZXJlZE9wdGlvbnNbc2VsZi5wb2ludGVyXTtcXG5cXHQgICAgaWYgKGN1cnJlbnRJdGVtKSB7XFxuXFx0ICAgICAgc2VsZi5zZWxlY3RJdGVtKGN1cnJlbnRJdGVtKTtcXG5cXHQgICAgfVxcblxcdCAgfSxcXG5cXHQgIHBvaW50ZXJTZXQ6IGZ1bmN0aW9uIHBvaW50ZXJTZXQoc2VsZiwgaW5kZXgpIHtcXG5cXHQgICAgc2VsZi5wb2ludGVyID0gaW5kZXg7XFxuXFx0ICB9LFxcblxcdCAgcG9pbnRlckFkanVzdDogZnVuY3Rpb24gcG9pbnRlckFkanVzdChzZWxmKSB7XFxuXFx0ICAgIGlmIChzZWxmLnBvaW50ZXIgPj0gc2VsZi5maWx0ZXJlZE9wdGlvbnMubGVuZ3RoIC0gMSkge1xcblxcdCAgICAgIHNlbGYucG9pbnRlciA9IHNlbGYuZmlsdGVyZWRPcHRpb25zLmxlbmd0aCA/IHNlbGYuZmlsdGVyZWRPcHRpb25zLmxlbmd0aCAtIDEgOiAwO1xcblxcdCAgICB9XFxuXFx0ICB9LFxcblxcdCAgbW91c2Vkb3duSXRlbTogZnVuY3Rpb24gbW91c2Vkb3duSXRlbShzZWxmKSB7XFxuXFx0ICAgIHNlbGYubW91c2Vkb3duU3RhdGUgPSB0cnVlO1xcblxcdCAgfVxcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiAxOSAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdG1vZHVsZS5leHBvcnRzID0geyBcXFwiZGVmYXVsdFxcXCI6IF9fd2VicGFja19yZXF1aXJlX18oNTkpLCBfX2VzTW9kdWxlOiB0cnVlIH07XFxuXFxuLyoqKi8gfSxcXG4vKiAyMCAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdC8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XFxuXFx0ICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFxcXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXFxcIiArIGl0KTtcXG5cXHQgIHJldHVybiBpdDtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMjEgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHQvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXFxuXFx0bW9kdWxlLmV4cG9ydHMgPSAoXFxuXFx0ICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xcblxcdCkuc3BsaXQoJywnKTtcXG5cXG4vKioqLyB9LFxcbi8qIDIyICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0dmFyIGdsb2JhbCAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMSlcXG5cXHQgICwgY29yZSAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSlcXG5cXHQgICwgY3R4ICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NSlcXG5cXHQgICwgaGlkZSAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KVxcblxcdCAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcXG5cXHRcXG5cXHR2YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XFxuXFx0ICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxcblxcdCAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcXG5cXHQgICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXFxuXFx0ICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxcblxcdCAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcXG5cXHQgICAgLCBJU19XUkFQICAgPSB0eXBlICYgJGV4cG9ydC5XXFxuXFx0ICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcXG5cXHQgICAgLCBleHBQcm90byAgPSBleHBvcnRzW1BST1RPVFlQRV1cXG5cXHQgICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXFxuXFx0ICAgICwga2V5LCBvd24sIG91dDtcXG5cXHQgIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xcblxcdCAgZm9yKGtleSBpbiBzb3VyY2Upe1xcblxcdCAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcXG5cXHQgICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcXG5cXHQgICAgaWYob3duICYmIGtleSBpbiBleHBvcnRzKWNvbnRpbnVlO1xcblxcdCAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxcblxcdCAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xcblxcdCAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcXG5cXHQgICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cXG5cXHQgICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcXG5cXHQgICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcXG5cXHQgICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcXG5cXHQgICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbihDKXtcXG5cXHQgICAgICB2YXIgRiA9IGZ1bmN0aW9uKGEsIGIsIGMpe1xcblxcdCAgICAgICAgaWYodGhpcyBpbnN0YW5jZW9mIEMpe1xcblxcdCAgICAgICAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7XFxuXFx0ICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEM7XFxuXFx0ICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XFxuXFx0ICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XFxuXFx0ICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xcblxcdCAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdCAgICAgIH07XFxuXFx0ICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xcblxcdCAgICAgIHJldHVybiBGO1xcblxcdCAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcXG5cXHQgICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xcblxcdCAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcXG5cXHQgICAgaWYoSVNfUFJPVE8pe1xcblxcdCAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcXG5cXHQgICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxcblxcdCAgICAgIGlmKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0paGlkZShleHBQcm90bywga2V5LCBvdXQpO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0fTtcXG5cXHQvLyB0eXBlIGJpdG1hcFxcblxcdCRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXFxuXFx0JGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcXG5cXHQkZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xcblxcdCRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cXG5cXHQkZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcXG5cXHQkZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcXG5cXHQkZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcXG5cXHQkZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXFxuXFx0bW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xcblxcbi8qKiovIH0sXFxuLyogMjMgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHRtb2R1bGUuZXhwb3J0cyA9IHt9O1xcblxcbi8qKiovIH0sXFxuLyogMjQgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHRtb2R1bGUuZXhwb3J0cyA9IHRydWU7XFxuXFxuLyoqKi8gfSxcXG4vKiAyNSAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdGV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xcblxcbi8qKiovIH0sXFxuLyogMjYgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHR2YXIgZGVmID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KS5mXFxuXFx0ICAsIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oMilcXG5cXHQgICwgVEFHID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCkoJ3RvU3RyaW5nVGFnJyk7XFxuXFx0XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcXG5cXHQgIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpZGVmKGl0LCBUQUcsIHtjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWd9KTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMjcgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHR2YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCkoJ2tleXMnKVxcblxcdCAgLCB1aWQgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XFxuXFx0ICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiAyOCAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdHZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpXFxuXFx0ICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXFxuXFx0ICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XFxuXFx0ICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMjkgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHQvLyA3LjEuNCBUb0ludGVnZXJcXG5cXHR2YXIgY2VpbCAgPSBNYXRoLmNlaWxcXG5cXHQgICwgZmxvb3IgPSBNYXRoLmZsb29yO1xcblxcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xcblxcdCAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDMwICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Ly8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXFxuXFx0dmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XFxuXFx0Ly8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2VcXG5cXHQvLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xcblxcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xcblxcdCAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gaXQ7XFxuXFx0ICB2YXIgZm4sIHZhbDtcXG5cXHQgIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcXG5cXHQgIGlmKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcXG5cXHQgIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XFxuXFx0ICB0aHJvdyBUeXBlRXJyb3IoXFxcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVxcXCIpO1xcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiAzMSAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdHZhciBnbG9iYWwgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMSlcXG5cXHQgICwgY29yZSAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKVxcblxcdCAgLCBMSUJSQVJZICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpXFxuXFx0ICAsIHdrc0V4dCAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMilcXG5cXHQgICwgZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpLmY7XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcXG5cXHQgIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XFxuXFx0ICBpZihuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKWRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHt2YWx1ZTogd2tzRXh0LmYobmFtZSl9KTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMzIgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRleHBvcnRzLmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcXG5cXG4vKioqLyB9LFxcbi8qIDMzICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcdFxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0XFxuXFx0dmFyIF9pdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xcblxcdFxcblxcdHZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xcblxcdFxcblxcdHZhciBfc3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nyk7XFxuXFx0XFxuXFx0dmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcXG5cXHRcXG5cXHR2YXIgX3R5cGVvZiA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFxcXCJzeW1ib2xcXFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07XFxuXFx0XFxuXFx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXHRcXG5cXHRleHBvcnRzLmRlZmF1bHQgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFxcXCJzeW1ib2xcXFwiID8gZnVuY3Rpb24gKG9iaikge1xcblxcdCAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKG9iaik7XFxuXFx0fSA6IGZ1bmN0aW9uIChvYmopIHtcXG5cXHQgIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihvYmopO1xcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiAzNCAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdHZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xcblxcdFxcblxcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xcblxcdCAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMzUgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHR2YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KVxcblxcdCAgLCBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuZG9jdW1lbnRcXG5cXHQgIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xcblxcdCAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcXG5cXHQgIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDM2ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0bW9kdWxlLmV4cG9ydHMgPSAhX193ZWJwYWNrX3JlcXVpcmVfXyg3KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXygxMikoZnVuY3Rpb24oKXtcXG5cXHQgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX3JlcXVpcmVfXygzNSkoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xcblxcdH0pO1xcblxcbi8qKiovIH0sXFxuLyogMzcgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQndXNlIHN0cmljdCc7XFxuXFx0dmFyIExJQlJBUlkgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNClcXG5cXHQgICwgJGV4cG9ydCAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKVxcblxcdCAgLCByZWRlZmluZSAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpXFxuXFx0ICAsIGhpZGUgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KVxcblxcdCAgLCBoYXMgICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMilcXG5cXHQgICwgSXRlcmF0b3JzICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKVxcblxcdCAgLCAkaXRlckNyZWF0ZSAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNzApXFxuXFx0ICAsIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNilcXG5cXHQgICwgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3KVxcblxcdCAgLCBJVEVSQVRPUiAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTApKCdpdGVyYXRvcicpXFxuXFx0ICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcXG5cXHQgICwgRkZfSVRFUkFUT1IgICAgPSAnQEBpdGVyYXRvcidcXG5cXHQgICwgS0VZUyAgICAgICAgICAgPSAna2V5cydcXG5cXHQgICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcXG5cXHRcXG5cXHR2YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9O1xcblxcdFxcblxcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKXtcXG5cXHQgICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcXG5cXHQgIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcXG5cXHQgICAgaWYoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pcmV0dXJuIHByb3RvW2tpbmRdO1xcblxcdCAgICBzd2l0Y2goa2luZCl7XFxuXFx0ICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xcblxcdCAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XFxuXFx0ICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcXG5cXHQgIH07XFxuXFx0ICB2YXIgVEFHICAgICAgICA9IE5BTUUgKyAnIEl0ZXJhdG9yJ1xcblxcdCAgICAsIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFU1xcblxcdCAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxcblxcdCAgICAsIHByb3RvICAgICAgPSBCYXNlLnByb3RvdHlwZVxcblxcdCAgICAsICRuYXRpdmUgICAgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF1cXG5cXHQgICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcXG5cXHQgICAgLCAkZW50cmllcyAgID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZFxcblxcdCAgICAsICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlXFxuXFx0ICAgICwgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcXG5cXHQgIC8vIEZpeCBuYXRpdmVcXG5cXHQgIGlmKCRhbnlOYXRpdmUpe1xcblxcdCAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSkpO1xcblxcdCAgICBpZihJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSl7XFxuXFx0ICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xcblxcdCAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xcblxcdCAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xcblxcdCAgICAgIGlmKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSloaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHQgIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcXG5cXHQgIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XFxuXFx0ICAgIFZBTFVFU19CVUcgPSB0cnVlO1xcblxcdCAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xcblxcdCAgfVxcblxcdCAgLy8gRGVmaW5lIGl0ZXJhdG9yXFxuXFx0ICBpZigoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSl7XFxuXFx0ICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XFxuXFx0ICB9XFxuXFx0ICAvLyBQbHVnIGZvciBsaWJyYXJ5XFxuXFx0ICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcXG5cXHQgIEl0ZXJhdG9yc1tUQUddICA9IHJldHVyblRoaXM7XFxuXFx0ICBpZihERUZBVUxUKXtcXG5cXHQgICAgbWV0aG9kcyA9IHtcXG5cXHQgICAgICB2YWx1ZXM6ICBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcXG5cXHQgICAgICBrZXlzOiAgICBJU19TRVQgICAgID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXFxuXFx0ICAgICAgZW50cmllczogJGVudHJpZXNcXG5cXHQgICAgfTtcXG5cXHQgICAgaWYoRk9SQ0VEKWZvcihrZXkgaW4gbWV0aG9kcyl7XFxuXFx0ICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XFxuXFx0ICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XFxuXFx0ICB9XFxuXFx0ICByZXR1cm4gbWV0aG9kcztcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogMzggKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcXG5cXHR2YXIgYW5PYmplY3QgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KVxcblxcdCAgLCBkUHMgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpXFxuXFx0ICAsIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSlcXG5cXHQgICwgSUVfUFJPVE8gICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KSgnSUVfUFJPVE8nKVxcblxcdCAgLCBFbXB0eSAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cXG5cXHQgICwgUFJPVE9UWVBFICAgPSAncHJvdG90eXBlJztcXG5cXHRcXG5cXHQvLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXFxuXFx0dmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbigpe1xcblxcdCAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcXG5cXHQgIHZhciBpZnJhbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KSgnaWZyYW1lJylcXG5cXHQgICAgLCBpICAgICAgPSBlbnVtQnVnS2V5cy5sZW5ndGhcXG5cXHQgICAgLCBsdCAgICAgPSAnPCdcXG5cXHQgICAgLCBndCAgICAgPSAnPidcXG5cXHQgICAgLCBpZnJhbWVEb2N1bWVudDtcXG5cXHQgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xcblxcdCAgX193ZWJwYWNrX3JlcXVpcmVfXyg2NykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcXG5cXHQgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcXG5cXHQgIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XFxuXFx0ICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XFxuXFx0ICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xcblxcdCAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xcblxcdCAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xcblxcdCAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcXG5cXHQgIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xcblxcdCAgd2hpbGUoaS0tKWRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xcblxcdCAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcXG5cXHR9O1xcblxcdFxcblxcdG1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcyl7XFxuXFx0ICB2YXIgcmVzdWx0O1xcblxcdCAgaWYoTyAhPT0gbnVsbCl7XFxuXFx0ICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcXG5cXHQgICAgcmVzdWx0ID0gbmV3IEVtcHR5O1xcblxcdCAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcXG5cXHQgICAgLy8gYWRkIFxcXCJfX3Byb3RvX19cXFwiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcXG5cXHQgICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XFxuXFx0ICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xcblxcdCAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xcblxcdH07XFxuXFxuXFxuLyoqKi8gfSxcXG4vKiAzOSAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcXG5cXHR2YXIgJGtleXMgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpXFxuXFx0ICAsIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcXG5cXHRcXG5cXHRleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pe1xcblxcdCAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiA0MCAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdGV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XFxuXFxuLyoqKi8gfSxcXG4vKiA0MSAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdHZhciBoYXMgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpXFxuXFx0ICAsIHRvSU9iamVjdCAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMylcXG5cXHQgICwgYXJyYXlJbmRleE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NCkoZmFsc2UpXFxuXFx0ICAsIElFX1BST1RPICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpKCdJRV9QUk9UTycpO1xcblxcdFxcblxcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lcyl7XFxuXFx0ICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcXG5cXHQgICAgLCBpICAgICAgPSAwXFxuXFx0ICAgICwgcmVzdWx0ID0gW11cXG5cXHQgICAgLCBrZXk7XFxuXFx0ICBmb3Ioa2V5IGluIE8paWYoa2V5ICE9IElFX1BST1RPKWhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XFxuXFx0ICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXFxuXFx0ICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XFxuXFx0ICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XFxuXFx0ICB9XFxuXFx0ICByZXR1cm4gcmVzdWx0O1xcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiA0MiAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcXG5cXG4vKioqLyB9LFxcbi8qIDQzICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Ly8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxcblxcdHZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XFxuXFx0ICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogNDQgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHR2YXIgX192dWVfZXhwb3J0c19fLCBfX3Z1ZV9vcHRpb25zX19cXG5cXHR2YXIgX192dWVfc3R5bGVzX18gPSB7fVxcblxcdFxcblxcdC8qIHN0eWxlcyAqL1xcblxcdF9fd2VicGFja19yZXF1aXJlX18oMTA2KVxcblxcdF9fd2VicGFja19yZXF1aXJlX18oMTA1KVxcblxcdFxcblxcdC8qIHNjcmlwdCAqL1xcblxcdF9fdnVlX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpXFxuXFx0XFxuXFx0LyogdGVtcGxhdGUgKi9cXG5cXHR2YXIgX192dWVfdGVtcGxhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTAxKVxcblxcdF9fdnVlX29wdGlvbnNfXyA9IF9fdnVlX2V4cG9ydHNfXyA9IF9fdnVlX2V4cG9ydHNfXyB8fCB7fVxcblxcdGlmIChcXG5cXHQgIHR5cGVvZiBfX3Z1ZV9leHBvcnRzX18uZGVmYXVsdCA9PT0gXFxcIm9iamVjdFxcXCIgfHxcXG5cXHQgIHR5cGVvZiBfX3Z1ZV9leHBvcnRzX18uZGVmYXVsdCA9PT0gXFxcImZ1bmN0aW9uXFxcIlxcblxcdCkge1xcblxcdF9fdnVlX29wdGlvbnNfXyA9IF9fdnVlX2V4cG9ydHNfXyA9IF9fdnVlX2V4cG9ydHNfXy5kZWZhdWx0XFxuXFx0fVxcblxcdGlmICh0eXBlb2YgX192dWVfb3B0aW9uc19fID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuXFx0ICBfX3Z1ZV9vcHRpb25zX18gPSBfX3Z1ZV9vcHRpb25zX18ub3B0aW9uc1xcblxcdH1cXG5cXHRcXG5cXHRfX3Z1ZV9vcHRpb25zX18ucmVuZGVyID0gX192dWVfdGVtcGxhdGVfXy5yZW5kZXJcXG5cXHRfX3Z1ZV9vcHRpb25zX18uc3RhdGljUmVuZGVyRm5zID0gX192dWVfdGVtcGxhdGVfXy5zdGF0aWNSZW5kZXJGbnNcXG5cXHRfX3Z1ZV9vcHRpb25zX18uX3Njb3BlSWQgPSBcXFwiZGF0YS12LTQwMzBkYWEyXFxcIlxcblxcdFxcblxcdG1vZHVsZS5leHBvcnRzID0gX192dWVfZXhwb3J0c19fXFxuXFxuXFxuLyoqKi8gfSxcXG4vKiA0NSAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdHZhciBfX3Z1ZV9leHBvcnRzX18sIF9fdnVlX29wdGlvbnNfX1xcblxcdHZhciBfX3Z1ZV9zdHlsZXNfXyA9IHt9XFxuXFx0XFxuXFx0Lyogc3R5bGVzICovXFxuXFx0X193ZWJwYWNrX3JlcXVpcmVfXygxMDQpXFxuXFx0X193ZWJwYWNrX3JlcXVpcmVfXygxMDMpXFxuXFx0XFxuXFx0Lyogc2NyaXB0ICovXFxuXFx0X192dWVfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MClcXG5cXHRcXG5cXHQvKiB0ZW1wbGF0ZSAqL1xcblxcdHZhciBfX3Z1ZV90ZW1wbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDApXFxuXFx0X192dWVfb3B0aW9uc19fID0gX192dWVfZXhwb3J0c19fID0gX192dWVfZXhwb3J0c19fIHx8IHt9XFxuXFx0aWYgKFxcblxcdCAgdHlwZW9mIF9fdnVlX2V4cG9ydHNfXy5kZWZhdWx0ID09PSBcXFwib2JqZWN0XFxcIiB8fFxcblxcdCAgdHlwZW9mIF9fdnVlX2V4cG9ydHNfXy5kZWZhdWx0ID09PSBcXFwiZnVuY3Rpb25cXFwiXFxuXFx0KSB7XFxuXFx0X192dWVfb3B0aW9uc19fID0gX192dWVfZXhwb3J0c19fID0gX192dWVfZXhwb3J0c19fLmRlZmF1bHRcXG5cXHR9XFxuXFx0aWYgKHR5cGVvZiBfX3Z1ZV9vcHRpb25zX18gPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXG5cXHQgIF9fdnVlX29wdGlvbnNfXyA9IF9fdnVlX29wdGlvbnNfXy5vcHRpb25zXFxuXFx0fVxcblxcdFxcblxcdF9fdnVlX29wdGlvbnNfXy5yZW5kZXIgPSBfX3Z1ZV90ZW1wbGF0ZV9fLnJlbmRlclxcblxcdF9fdnVlX29wdGlvbnNfXy5zdGF0aWNSZW5kZXJGbnMgPSBfX3Z1ZV90ZW1wbGF0ZV9fLnN0YXRpY1JlbmRlckZuc1xcblxcdF9fdnVlX29wdGlvbnNfXy5fc2NvcGVJZCA9IFxcXCJkYXRhLXYtM2EwYzdiZWFcXFwiXFxuXFx0XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9leHBvcnRzX19cXG5cXG5cXG4vKioqLyB9LFxcbi8qIDQ2ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0dmFyIF9fdnVlX2V4cG9ydHNfXywgX192dWVfb3B0aW9uc19fXFxuXFx0dmFyIF9fdnVlX3N0eWxlc19fID0ge31cXG5cXHRcXG5cXHQvKiBzdHlsZXMgKi9cXG5cXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOSlcXG5cXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOClcXG5cXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNylcXG5cXHRcXG5cXHQvKiBzY3JpcHQgKi9cXG5cXHRfX3Z1ZV9leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKVxcblxcdFxcblxcdC8qIHRlbXBsYXRlICovXFxuXFx0dmFyIF9fdnVlX3RlbXBsYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMilcXG5cXHRfX3Z1ZV9vcHRpb25zX18gPSBfX3Z1ZV9leHBvcnRzX18gPSBfX3Z1ZV9leHBvcnRzX18gfHwge31cXG5cXHRpZiAoXFxuXFx0ICB0eXBlb2YgX192dWVfZXhwb3J0c19fLmRlZmF1bHQgPT09IFxcXCJvYmplY3RcXFwiIHx8XFxuXFx0ICB0eXBlb2YgX192dWVfZXhwb3J0c19fLmRlZmF1bHQgPT09IFxcXCJmdW5jdGlvblxcXCJcXG5cXHQpIHtcXG5cXHRfX3Z1ZV9vcHRpb25zX18gPSBfX3Z1ZV9leHBvcnRzX18gPSBfX3Z1ZV9leHBvcnRzX18uZGVmYXVsdFxcblxcdH1cXG5cXHRpZiAodHlwZW9mIF9fdnVlX29wdGlvbnNfXyA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcblxcdCAgX192dWVfb3B0aW9uc19fID0gX192dWVfb3B0aW9uc19fLm9wdGlvbnNcXG5cXHR9XFxuXFx0XFxuXFx0X192dWVfb3B0aW9uc19fLnJlbmRlciA9IF9fdnVlX3RlbXBsYXRlX18ucmVuZGVyXFxuXFx0X192dWVfb3B0aW9uc19fLnN0YXRpY1JlbmRlckZucyA9IF9fdnVlX3RlbXBsYXRlX18uc3RhdGljUmVuZGVyRm5zXFxuXFx0X192dWVfb3B0aW9uc19fLl9zY29wZUlkID0gXFxcImRhdGEtdi1hM2RiZmMwY1xcXCJcXG5cXHRcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX2V4cG9ydHNfX1xcblxcblxcbi8qKiovIH0sXFxuLyogNDcgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQndXNlIHN0cmljdCc7XFxuXFx0XFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcblxcdCAgdmFsdWU6IHRydWVcXG5cXHR9KTtcXG5cXHRcXG5cXHR2YXIgX2NvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xcblxcdFxcblxcdHZhciBfY29tbW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbW1vbik7XFxuXFx0XFxuXFx0dmFyIF9taXhpbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xcblxcdFxcblxcdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFx0XFxuXFx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xcblxcdCAgbWl4aW5zOiBbX21peGlucy5iYXNlTWl4aW4sIF9taXhpbnMuY29tbW9uTWl4aW4sIF9taXhpbnMub3B0aW9uQXdhcmVNaXhpbl0sXFxuXFx0ICBwcm9wczoge1xcblxcdCAgICBzZWxlY3RlZE9wdGlvbjoge1xcblxcdCAgICAgIHR5cGU6IE9iamVjdCxcXG5cXHQgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcXG5cXHQgICAgICAgIHJldHVybiB7IHZhbHVlOiAnJywgdGV4dDogJycgfTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH0sXFxuXFx0ICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xcblxcdCAgICByZXR1cm4ge1xcblxcdCAgICAgIHNob3dNZW51OiBmYWxzZSxcXG5cXHQgICAgICBzZWFyY2hUZXh0OiAnJyxcXG5cXHQgICAgICBtb3VzZWRvd25TdGF0ZTogZmFsc2UsXFxuXFx0ICAgICAgcG9pbnRlcjogLTFcXG5cXHQgICAgfTtcXG5cXHQgIH0sXFxuXFx0XFxuXFx0ICB3YXRjaDoge1xcblxcdCAgICBzZWxlY3RlZE9wdGlvbjogZnVuY3Rpb24gc2VsZWN0ZWRPcHRpb24obmV3VmFsdWUpIHtcXG5cXHQgICAgICBpZiAobmV3VmFsdWUgJiYgbmV3VmFsdWUudmFsdWUpIHtcXG5cXHQgICAgICAgIHRoaXMucG9pbnRlciA9IHRoaXMuZmlsdGVyZWRPcHRpb25zLmZpbmRJbmRleChmdW5jdGlvbiAob3B0aW9uKSB7XFxuXFx0ICAgICAgICAgIHJldHVybiBvcHRpb24udmFsdWUgPT09IG5ld1ZhbHVlLnZhbHVlO1xcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgIHRoaXMucG9pbnRlciA9IC0xO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgfSxcXG5cXHQgIGNvbXB1dGVkOiB7XFxuXFx0ICAgIHNlYXJjaFRleHRDdXN0b21BdHRyOiBmdW5jdGlvbiBzZWFyY2hUZXh0Q3VzdG9tQXR0cigpIHtcXG5cXHQgICAgICBpZiAodGhpcy5zZWxlY3RlZE9wdGlvbiAmJiB0aGlzLnNlbGVjdGVkT3B0aW9uLnZhbHVlKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21BdHRyKHRoaXMuc2VsZWN0ZWRPcHRpb24pO1xcblxcdCAgICAgIH1cXG5cXHQgICAgICByZXR1cm4gJyc7XFxuXFx0ICAgIH0sXFxuXFx0ICAgIGlucHV0VGV4dDogZnVuY3Rpb24gaW5wdXRUZXh0KCkge1xcblxcdCAgICAgIGlmICh0aGlzLnNlYXJjaFRleHQpIHtcXG5cXHQgICAgICAgIHJldHVybiAnJztcXG5cXHQgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgdmFyIHRleHQgPSB0aGlzLnBsYWNlaG9sZGVyO1xcblxcdCAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRPcHRpb24udGV4dCkge1xcblxcdCAgICAgICAgICB0ZXh0ID0gdGhpcy5zZWxlY3RlZE9wdGlvbi50ZXh0O1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgcmV0dXJuIHRleHQ7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9LFxcblxcdCAgICBjdXN0b21BdHRyczogZnVuY3Rpb24gY3VzdG9tQXR0cnMoKSB7XFxuXFx0ICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXHRcXG5cXHQgICAgICB0cnkge1xcblxcdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zKSkge1xcblxcdCAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm1hcChmdW5jdGlvbiAobykge1xcblxcdCAgICAgICAgICAgIHJldHVybiBfdGhpcy5jdXN0b21BdHRyKG8pO1xcblxcdCAgICAgICAgICB9KTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9IGNhdGNoIChlKSB7fVxcblxcdCAgICAgIHJldHVybiBbXTtcXG5cXHQgICAgfSxcXG5cXHQgICAgdGV4dENsYXNzOiBmdW5jdGlvbiB0ZXh0Q2xhc3MoKSB7XFxuXFx0ICAgICAgaWYgKCF0aGlzLnNlbGVjdGVkT3B0aW9uLnRleHQgJiYgdGhpcy5wbGFjZWhvbGRlcikge1xcblxcdCAgICAgICAgcmV0dXJuICdkZWZhdWx0JztcXG5cXHQgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgcmV0dXJuICcnO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHQgICAgbWVudUNsYXNzOiBmdW5jdGlvbiBtZW51Q2xhc3MoKSB7XFxuXFx0ICAgICAgcmV0dXJuIHtcXG5cXHQgICAgICAgIHZpc2libGU6IHRoaXMuc2hvd01lbnUsXFxuXFx0ICAgICAgICBoaWRkZW46ICF0aGlzLnNob3dNZW51XFxuXFx0ICAgICAgfTtcXG5cXHQgICAgfSxcXG5cXHQgICAgbWVudVN0eWxlOiBmdW5jdGlvbiBtZW51U3R5bGUoKSB7XFxuXFx0ICAgICAgcmV0dXJuIHtcXG5cXHQgICAgICAgIGRpc3BsYXk6IHRoaXMuc2hvd01lbnUgPyAnYmxvY2snIDogJ25vbmUnXFxuXFx0ICAgICAgfTtcXG5cXHQgICAgfSxcXG5cXHQgICAgZmlsdGVyZWRPcHRpb25zOiBmdW5jdGlvbiBmaWx0ZXJlZE9wdGlvbnMoKSB7XFxuXFx0ICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFx0XFxuXFx0ICAgICAgaWYgKHRoaXMuc2VhcmNoVGV4dCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKG9wdGlvbikge1xcblxcdCAgICAgICAgICB0cnkge1xcblxcdCAgICAgICAgICAgIHJldHVybiBfdGhpczIuZmlsdGVyUHJlZGljYXRlKG9wdGlvbi50ZXh0LCBfdGhpczIuc2VhcmNoVGV4dCk7XFxuXFx0ICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXG5cXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG5cXHQgICAgICAgICAgfVxcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICB9LFxcblxcdCAgbWV0aG9kczoge1xcblxcdCAgICBkZWxldGVUZXh0T3JJdGVtOiBmdW5jdGlvbiBkZWxldGVUZXh0T3JJdGVtKCkge1xcblxcdCAgICAgIGlmICghdGhpcy5zZWFyY2hUZXh0ICYmIHRoaXMuc2VsZWN0ZWRPcHRpb24pIHtcXG5cXHQgICAgICAgIHRoaXMuc2VsZWN0SXRlbSh7fSk7XFxuXFx0ICAgICAgICB0aGlzLm9wZW5PcHRpb25zKCk7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9LFxcblxcdCAgICBvcGVuT3B0aW9uczogZnVuY3Rpb24gb3Blbk9wdGlvbnMoKSB7XFxuXFx0ICAgICAgX2NvbW1vbjIuZGVmYXVsdC5vcGVuT3B0aW9ucyh0aGlzKTtcXG5cXHQgICAgfSxcXG5cXHQgICAgYmx1cklucHV0OiBmdW5jdGlvbiBibHVySW5wdXQoKSB7XFxuXFx0ICAgICAgX2NvbW1vbjIuZGVmYXVsdC5ibHVySW5wdXQodGhpcyk7XFxuXFx0ICAgIH0sXFxuXFx0ICAgIGNsb3NlT3B0aW9uczogZnVuY3Rpb24gY2xvc2VPcHRpb25zKCkge1xcblxcdCAgICAgIF9jb21tb24yLmRlZmF1bHQuY2xvc2VPcHRpb25zKHRoaXMpO1xcblxcdCAgICB9LFxcblxcdCAgICBwcmV2SXRlbTogZnVuY3Rpb24gcHJldkl0ZW0oKSB7XFxuXFx0ICAgICAgX2NvbW1vbjIuZGVmYXVsdC5wcmV2SXRlbSh0aGlzKTtcXG5cXHQgICAgfSxcXG5cXHQgICAgbmV4dEl0ZW06IGZ1bmN0aW9uIG5leHRJdGVtKCkge1xcblxcdCAgICAgIF9jb21tb24yLmRlZmF1bHQubmV4dEl0ZW0odGhpcyk7XFxuXFx0ICAgIH0sXFxuXFx0ICAgIGVudGVySXRlbTogZnVuY3Rpb24gZW50ZXJJdGVtKCkge1xcblxcdCAgICAgIF9jb21tb24yLmRlZmF1bHQuZW50ZXJJdGVtKHRoaXMpO1xcblxcdCAgICB9LFxcblxcdCAgICBwb2ludGVyU2V0OiBmdW5jdGlvbiBwb2ludGVyU2V0KGluZGV4KSB7XFxuXFx0ICAgICAgX2NvbW1vbjIuZGVmYXVsdC5wb2ludGVyU2V0KHRoaXMsIGluZGV4KTtcXG5cXHQgICAgfSxcXG5cXHQgICAgcG9pbnRlckFkanVzdDogZnVuY3Rpb24gcG9pbnRlckFkanVzdCgpIHtcXG5cXHQgICAgICBfY29tbW9uMi5kZWZhdWx0LnBvaW50ZXJBZGp1c3QodGhpcyk7XFxuXFx0ICAgIH0sXFxuXFx0ICAgIG1vdXNlZG93bkl0ZW06IGZ1bmN0aW9uIG1vdXNlZG93bkl0ZW0oKSB7XFxuXFx0ICAgICAgX2NvbW1vbjIuZGVmYXVsdC5tb3VzZWRvd25JdGVtKHRoaXMpO1xcblxcdCAgICB9LFxcblxcdCAgICBzZWxlY3RJdGVtOiBmdW5jdGlvbiBzZWxlY3RJdGVtKG9wdGlvbikge1xcblxcdCAgICAgIHRoaXMuc2VhcmNoVGV4dCA9ICcnO1xcblxcdCAgICAgIHRoaXMuY2xvc2VPcHRpb25zKCk7XFxuXFx0ICAgICAgdGhpcy4kZW1pdCgnc2VsZWN0Jywgb3B0aW9uKTtcXG5cXHQgICAgICBpZiAob3B0aW9uLnZhbHVlID09PSBvcHRpb24udGV4dCkge1xcblxcdCAgICAgICAgdGhpcy5zZWFyY2hUZXh0ID0gb3B0aW9uLnZhbHVlO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgfVxcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiA0OCAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdCd1c2Ugc3RyaWN0JztcXG5cXHRcXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuXFx0ICB2YWx1ZTogdHJ1ZVxcblxcdH0pO1xcblxcdFxcblxcdHZhciBfa2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xcblxcdFxcblxcdHZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcXG5cXHRcXG5cXHR2YXIgX0Jhc2ljU2VsZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XFxuXFx0XFxuXFx0dmFyIF9CYXNpY1NlbGVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXNpY1NlbGVjdCk7XFxuXFx0XFxuXFx0dmFyIF9taXhpbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xcblxcdFxcblxcdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFx0XFxuXFx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xcblxcdCAgbWl4aW5zOiBbX21peGlucy5jb21tb25NaXhpbl0sXFxuXFx0ICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihjcmVhdGVFbGVtZW50KSB7XFxuXFx0ICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFx0XFxuXFx0ICAgIHJldHVybiBjcmVhdGVFbGVtZW50KF9CYXNpY1NlbGVjdDIuZGVmYXVsdCwge1xcblxcdCAgICAgIHByb3BzOiB7XFxuXFx0ICAgICAgICBpZDogdGhpcy5pZCxcXG5cXHQgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcXG5cXHQgICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcXG5cXHQgICAgICAgIHNlbGVjdGVkT3B0aW9uOiB0aGlzLml0ZW0sXFxuXFx0ICAgICAgICBpc0Vycm9yOiB0aGlzLmlzRXJyb3IsXFxuXFx0ICAgICAgICBpc0Rpc2FibGVkOiB0aGlzLmlzRGlzYWJsZWQsXFxuXFx0ICAgICAgICBwbGFjZWhvbGRlcjogdGhpcy5wbGFjZWhvbGRlcixcXG5cXHQgICAgICAgIGZpbHRlclByZWRpY2F0ZTogdGhpcy5maWx0ZXJQcmVkaWNhdGVcXG5cXHQgICAgICB9LFxcblxcdCAgICAgIG9uOiB7XFxuXFx0ICAgICAgICBzZWxlY3Q6IHRoaXMub25TZWxlY3QsXFxuXFx0ICAgICAgICBzZWFyY2hjaGFuZ2U6IGZ1bmN0aW9uIHNlYXJjaGNoYW5nZShzZWFyY2hUZXh0KSB7XFxuXFx0ICAgICAgICAgIHJldHVybiBfdGhpcy4kZW1pdCgnc2VhcmNoY2hhbmdlJywgc2VhcmNoVGV4dCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgfVxcblxcdCAgICB9KTtcXG5cXHQgIH0sXFxuXFx0ICBwcm9wczoge1xcblxcdCAgICBsaXN0OiB7XFxuXFx0ICAgICAgdHlwZTogQXJyYXlcXG5cXHQgICAgfSxcXG5cXHQgICAgb3B0aW9uVmFsdWU6IHtcXG5cXHQgICAgICB0eXBlOiBTdHJpbmdcXG5cXHQgICAgfSxcXG5cXHQgICAgb3B0aW9uVGV4dDoge1xcblxcdCAgICAgIHR5cGU6IFN0cmluZ1xcblxcdCAgICB9LFxcblxcdCAgICBjdXN0b21UZXh0OiB7XFxuXFx0ICAgICAgdHlwZTogRnVuY3Rpb25cXG5cXHQgICAgfSxcXG5cXHQgICAgc2VsZWN0ZWRJdGVtOiB7XFxuXFx0ICAgICAgdHlwZTogT2JqZWN0XFxuXFx0ICAgIH1cXG5cXHQgIH0sXFxuXFx0ICBjb21wdXRlZDoge1xcblxcdCAgICBvcHRpb25zOiBmdW5jdGlvbiBvcHRpb25zKCkge1xcblxcdCAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xcblxcdFxcblxcdCAgICAgIHJldHVybiB0aGlzLmxpc3QubWFwKGZ1bmN0aW9uIChlLCBpKSB7XFxuXFx0ICAgICAgICByZXR1cm4geyB2YWx1ZTogZVtfdGhpczIub3B0aW9uVmFsdWVdLCB0ZXh0OiBfdGhpczIuYnVpbGRUZXh0KGUpIH07XFxuXFx0ICAgICAgfSk7XFxuXFx0ICAgIH0sXFxuXFx0ICAgIGl0ZW06IGZ1bmN0aW9uIGl0ZW0oKSB7XFxuXFx0ICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJdGVtKSB7XFxuXFx0ICAgICAgICByZXR1cm4geyB2YWx1ZTogdGhpcy5zZWxlY3RlZEl0ZW1bdGhpcy5vcHRpb25WYWx1ZV0sIHRleHQ6IHRoaXMuYnVpbGRUZXh0KHRoaXMuc2VsZWN0ZWRJdGVtKSB9O1xcblxcdCAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICByZXR1cm4geyB2YWx1ZTogJycsIHRleHQ6ICcnIH07XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICB9LFxcblxcdCAgbWV0aG9kczoge1xcblxcdCAgICBidWlsZFRleHQ6IGZ1bmN0aW9uIGJ1aWxkVGV4dChlKSB7XFxuXFx0ICAgICAgaWYgKGVbdGhpcy5vcHRpb25WYWx1ZV0gIT09IHVuZGVmaW5lZCkge1xcblxcdCAgICAgICAgaWYgKHRoaXMuY3VzdG9tVGV4dCkge1xcblxcdCAgICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21UZXh0KGUpO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgcmV0dXJuIGVbdGhpcy5vcHRpb25UZXh0XTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgcmV0dXJuICcnO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHQgICAgb25TZWxlY3Q6IGZ1bmN0aW9uIG9uU2VsZWN0KG9wdGlvbikge1xcblxcdCAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xcblxcdFxcblxcdCAgICAgIGlmICgoMCwgX2tleXMyLmRlZmF1bHQpKG9wdGlvbikubGVuZ3RoID09PSAwICYmIG9wdGlvbi5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XFxuXFx0ICAgICAgICB0aGlzLiRlbWl0KCdzZWxlY3QnLCBvcHRpb24pO1xcblxcdCAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICB2YXIgaXRlbSA9IHRoaXMubGlzdC5maW5kKGZ1bmN0aW9uIChlLCBpKSB7XFxuXFx0ICAgICAgICAgIHJldHVybiBlW190aGlzMy5vcHRpb25WYWx1ZV0gPT09IG9wdGlvbi52YWx1ZTtcXG5cXHQgICAgICAgIH0pO1xcblxcdCAgICAgICAgdGhpcy4kZW1pdCgnc2VsZWN0JywgaXRlbSk7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICB9LFxcblxcdCAgY29tcG9uZW50czoge1xcblxcdCAgICBCYXNpY1NlbGVjdDogX0Jhc2ljU2VsZWN0Mi5kZWZhdWx0XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDQ5ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0J3VzZSBzdHJpY3QnO1xcblxcdFxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG5cXHQgIHZhbHVlOiB0cnVlXFxuXFx0fSk7XFxuXFx0XFxuXFx0dmFyIF9rZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XFxuXFx0XFxuXFx0dmFyIF9rZXlzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleXMpO1xcblxcdFxcblxcdHZhciBfdHlwZW9mMiA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xcblxcdFxcblxcdHZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xcblxcdFxcblxcdHZhciBfTW9kZWxTZWxlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcXG5cXHRcXG5cXHR2YXIgX01vZGVsU2VsZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vZGVsU2VsZWN0KTtcXG5cXHRcXG5cXHR2YXIgX21peGlucyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XFxuXFx0XFxuXFx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXHRcXG5cXHRleHBvcnRzLmRlZmF1bHQgPSB7XFxuXFx0ICBtaXhpbnM6IFtfbWl4aW5zLmNvbW1vbk1peGluXSxcXG5cXHQgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGNyZWF0ZUVsZW1lbnQpIHtcXG5cXHQgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXHRcXG5cXHQgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoX01vZGVsU2VsZWN0Mi5kZWZhdWx0LCB7XFxuXFx0ICAgICAgcHJvcHM6IHtcXG5cXHQgICAgICAgIGlkOiB0aGlzLmlkLFxcblxcdCAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxcblxcdCAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxcblxcdCAgICAgICAgdmFsdWU6IHRoaXMuaW5uZXJWYWx1ZSxcXG5cXHQgICAgICAgIGlzRXJyb3I6IHRoaXMuaXNFcnJvcixcXG5cXHQgICAgICAgIGlzRGlzYWJsZWQ6IHRoaXMuaXNEaXNhYmxlZCxcXG5cXHQgICAgICAgIHBsYWNlaG9sZGVyOiB0aGlzLnBsYWNlaG9sZGVyLFxcblxcdCAgICAgICAgZmlsdGVyUHJlZGljYXRlOiB0aGlzLmZpbHRlclByZWRpY2F0ZVxcblxcdCAgICAgIH0sXFxuXFx0ICAgICAgb246IHtcXG5cXHQgICAgICAgIGlucHV0OiB0aGlzLm9uSW5wdXQsXFxuXFx0ICAgICAgICBzZWFyY2hjaGFuZ2U6IGZ1bmN0aW9uIHNlYXJjaGNoYW5nZShzZWFyY2hUZXh0KSB7XFxuXFx0ICAgICAgICAgIHJldHVybiBfdGhpcy4kZW1pdCgnc2VhcmNoY2hhbmdlJywgc2VhcmNoVGV4dCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgfVxcblxcdCAgICB9KTtcXG5cXHQgIH0sXFxuXFx0ICBwcm9wczoge1xcblxcdCAgICBsaXN0OiB7XFxuXFx0ICAgICAgdHlwZTogQXJyYXlcXG5cXHQgICAgfSxcXG5cXHQgICAgb3B0aW9uVmFsdWU6IHtcXG5cXHQgICAgICB0eXBlOiBTdHJpbmdcXG5cXHQgICAgfSxcXG5cXHQgICAgb3B0aW9uVGV4dDoge1xcblxcdCAgICAgIHR5cGU6IFN0cmluZ1xcblxcdCAgICB9LFxcblxcdCAgICBjdXN0b21UZXh0OiB7XFxuXFx0ICAgICAgdHlwZTogRnVuY3Rpb25cXG5cXHQgICAgfSxcXG5cXHRcXG5cXHQgICAgdmFsdWU6IHtcXG5cXHQgICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXIsIE9iamVjdCwgQm9vbGVhbl1cXG5cXHQgICAgfVxcblxcdCAgfSxcXG5cXHQgIGNvbXB1dGVkOiB7XFxuXFx0ICAgIG9wdGlvbnM6IGZ1bmN0aW9uIG9wdGlvbnMoKSB7XFxuXFx0ICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFx0XFxuXFx0ICAgICAgcmV0dXJuIHRoaXMubGlzdC5tYXAoZnVuY3Rpb24gKGUpIHtcXG5cXHQgICAgICAgIHJldHVybiB7IHZhbHVlOiBlW190aGlzMi5vcHRpb25WYWx1ZV0sIHRleHQ6IF90aGlzMi5idWlsZFRleHQoZSkgfTtcXG5cXHQgICAgICB9KTtcXG5cXHQgICAgfSxcXG5cXHQgICAgaW5uZXJWYWx1ZTogZnVuY3Rpb24gaW5uZXJWYWx1ZSgpIHtcXG5cXHQgICAgICBpZiAoIXRoaXMudmFsdWUpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xcblxcdCAgICAgIH0gZWxzZSBpZiAoKDAsIF90eXBlb2YzLmRlZmF1bHQpKHRoaXMudmFsdWUpID09PSAnb2JqZWN0Jykge1xcblxcdCAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcXG5cXHQgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHRoaXMudmFsdWVbdGhpcy5vcHRpb25WYWx1ZV0sIHRleHQ6IHRoaXMuYnVpbGRUZXh0KHRoaXMudmFsdWUpIH07XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICByZXR1cm4geyB2YWx1ZTogJycsIHRleHQ6ICcnIH07XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgfSxcXG5cXHQgIG1ldGhvZHM6IHtcXG5cXHQgICAgYnVpbGRUZXh0OiBmdW5jdGlvbiBidWlsZFRleHQoZSkge1xcblxcdCAgICAgIGlmIChlW3RoaXMub3B0aW9uVmFsdWVdICE9PSB1bmRlZmluZWQpIHtcXG5cXHQgICAgICAgIGlmICh0aGlzLmN1c3RvbVRleHQpIHtcXG5cXHQgICAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tVGV4dChlKTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgIHJldHVybiBlW3RoaXMub3B0aW9uVGV4dF07XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgIHJldHVybiAnJztcXG5cXHQgICAgICB9XFxuXFx0ICAgIH0sXFxuXFx0ICAgIG9uSW5wdXQ6IGZ1bmN0aW9uIG9uSW5wdXQob3B0aW9uKSB7XFxuXFx0ICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XFxuXFx0XFxuXFx0ICAgICAgaWYgKG9wdGlvbiA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4kZW1pdCgnaW5wdXQnLCAnJyk7XFxuXFx0ICAgICAgfVxcblxcdCAgICAgIGlmICgoMCwgX2tleXMyLmRlZmF1bHQpKG9wdGlvbikubGVuZ3RoID09PSAwICYmIG9wdGlvbi5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XFxuXFx0ICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIG9wdGlvbik7XFxuXFx0ICAgICAgfSBlbHNlIGlmICgodHlwZW9mIG9wdGlvbiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShvcHRpb24pKSA9PT0gJ29iamVjdCcpIHtcXG5cXHQgICAgICAgIHZhciBpdGVtID0gdGhpcy5saXN0LmZpbmQoZnVuY3Rpb24gKGUpIHtcXG5cXHQgICAgICAgICAgcmV0dXJuIGVbX3RoaXMzLm9wdGlvblZhbHVlXSA9PT0gb3B0aW9uLnZhbHVlO1xcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIGl0ZW0pO1xcblxcdCAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIG9wdGlvbik7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICB9LFxcblxcdCAgY29tcG9uZW50czoge1xcblxcdCAgICBNb2RlbFNlbGVjdDogX01vZGVsU2VsZWN0Mi5kZWZhdWx0XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDUwICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0J3VzZSBzdHJpY3QnO1xcblxcdFxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG5cXHQgIHZhbHVlOiB0cnVlXFxuXFx0fSk7XFxuXFx0XFxuXFx0dmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XFxuXFx0XFxuXFx0dmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XFxuXFx0XFxuXFx0dmFyIF9jb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcXG5cXHRcXG5cXHR2YXIgX2NvbW1vbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21tb24pO1xcblxcdFxcblxcdHZhciBfbWl4aW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcXG5cXHRcXG5cXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxcblxcdFxcblxcdGV4cG9ydHMuZGVmYXVsdCA9IHtcXG5cXHQgIG1peGluczogW19taXhpbnMuYmFzZU1peGluLCBfbWl4aW5zLmNvbW1vbk1peGluLCBfbWl4aW5zLm9wdGlvbkF3YXJlTWl4aW5dLFxcblxcdCAgcHJvcHM6IHtcXG5cXHQgICAgdmFsdWU6IHtcXG5cXHQgICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXIsIE9iamVjdCwgQm9vbGVhbl1cXG5cXHQgICAgfVxcblxcdCAgfSxcXG5cXHQgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XFxuXFx0ICAgIHJldHVybiB7XFxuXFx0ICAgICAgc2hvd01lbnU6IGZhbHNlLFxcblxcdCAgICAgIHNlYXJjaFRleHQ6ICcnLFxcblxcdCAgICAgIG1vdXNlZG93blN0YXRlOiBmYWxzZSxcXG5cXHQgICAgICBwb2ludGVyOiAtMVxcblxcdCAgICB9O1xcblxcdCAgfSxcXG5cXHRcXG5cXHQgIHdhdGNoOiB7XFxuXFx0ICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShuZXdWYWx1ZSkge1xcblxcdCAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFx0XFxuXFx0ICAgICAgdGhpcy5wb2ludGVyID0gdGhpcy5maWx0ZXJlZE9wdGlvbnMuZmluZEluZGV4KGZ1bmN0aW9uIChvcHRpb24pIHtcXG5cXHQgICAgICAgIHJldHVybiBvcHRpb24udmFsdWUgPT09IF90aGlzLm9wdGlvblZhbHVlKG5ld1ZhbHVlKTtcXG5cXHQgICAgICB9KTtcXG5cXHQgICAgfVxcblxcdCAgfSxcXG5cXHQgIGNvbXB1dGVkOiB7XFxuXFx0ICAgIHNlYXJjaFRleHRDdXN0b21BdHRyOiBmdW5jdGlvbiBzZWFyY2hUZXh0Q3VzdG9tQXR0cigpIHtcXG5cXHQgICAgICBpZiAodGhpcy5zZWxlY3RlZE9wdGlvbiAmJiB0aGlzLnNlbGVjdGVkT3B0aW9uLnZhbHVlKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21BdHRyKHRoaXMuc2VsZWN0ZWRPcHRpb24pO1xcblxcdCAgICAgIH1cXG5cXHQgICAgICByZXR1cm4gJyc7XFxuXFx0ICAgIH0sXFxuXFx0ICAgIGlucHV0VGV4dDogZnVuY3Rpb24gaW5wdXRUZXh0KCkge1xcblxcdCAgICAgIGlmICh0aGlzLnNlYXJjaFRleHQpIHtcXG5cXHQgICAgICAgIHJldHVybiAnJztcXG5cXHQgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgdmFyIHRleHQgPSB0aGlzLnBsYWNlaG9sZGVyO1xcblxcdCAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRPcHRpb24pIHtcXG5cXHQgICAgICAgICAgdGV4dCA9IHRoaXMuc2VsZWN0ZWRPcHRpb24udGV4dDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiB0ZXh0O1xcblxcdCAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHQgICAgY3VzdG9tQXR0cnM6IGZ1bmN0aW9uIGN1c3RvbUF0dHJzKCkge1xcblxcdCAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xcblxcdFxcblxcdCAgICAgIHRyeSB7XFxuXFx0ICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMpKSB7XFxuXFx0ICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubWFwKGZ1bmN0aW9uIChvKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5jdXN0b21BdHRyKG8pO1xcblxcdCAgICAgICAgICB9KTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9IGNhdGNoIChlKSB7fVxcblxcdCAgICAgIHJldHVybiBbXTtcXG5cXHQgICAgfSxcXG5cXHQgICAgdGV4dENsYXNzOiBmdW5jdGlvbiB0ZXh0Q2xhc3MoKSB7XFxuXFx0ICAgICAgaWYgKCF0aGlzLnNlbGVjdGVkT3B0aW9uICYmIHRoaXMucGxhY2Vob2xkZXIpIHtcXG5cXHQgICAgICAgIHJldHVybiAnZGVmYXVsdCc7XFxuXFx0ICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgIHJldHVybiAnJztcXG5cXHQgICAgICB9XFxuXFx0ICAgIH0sXFxuXFx0ICAgIG1lbnVDbGFzczogZnVuY3Rpb24gbWVudUNsYXNzKCkge1xcblxcdCAgICAgIHJldHVybiB7XFxuXFx0ICAgICAgICB2aXNpYmxlOiB0aGlzLnNob3dNZW51LFxcblxcdCAgICAgICAgaGlkZGVuOiAhdGhpcy5zaG93TWVudVxcblxcdCAgICAgIH07XFxuXFx0ICAgIH0sXFxuXFx0ICAgIG1lbnVTdHlsZTogZnVuY3Rpb24gbWVudVN0eWxlKCkge1xcblxcdCAgICAgIHJldHVybiB7XFxuXFx0ICAgICAgICBkaXNwbGF5OiB0aGlzLnNob3dNZW51ID8gJ2Jsb2NrJyA6ICdub25lJ1xcblxcdCAgICAgIH07XFxuXFx0ICAgIH0sXFxuXFx0ICAgIGZpbHRlcmVkT3B0aW9uczogZnVuY3Rpb24gZmlsdGVyZWRPcHRpb25zKCkge1xcblxcdCAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xcblxcdFxcblxcdCAgICAgIGlmICh0aGlzLnNlYXJjaFRleHQpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChvcHRpb24pIHtcXG5cXHQgICAgICAgICAgdHJ5IHtcXG5cXHQgICAgICAgICAgICByZXR1cm4gX3RoaXMzLmZpbHRlclByZWRpY2F0ZShvcHRpb24udGV4dCwgX3RoaXMzLnNlYXJjaFRleHQpO1xcblxcdCAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuXFx0ICAgICAgICAgIH1cXG5cXHQgICAgICAgIH0pO1xcblxcdCAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHQgICAgc2VsZWN0ZWRPcHRpb246IGZ1bmN0aW9uIHNlbGVjdGVkT3B0aW9uKCkge1xcblxcdCAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xcblxcdFxcblxcdCAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZmluZChmdW5jdGlvbiAob3B0aW9uKSB7XFxuXFx0ICAgICAgICByZXR1cm4gb3B0aW9uLnZhbHVlID09PSBfdGhpczQub3B0aW9uVmFsdWUoX3RoaXM0LnZhbHVlKTtcXG5cXHQgICAgICB9KTtcXG5cXHQgICAgfVxcblxcdCAgfSxcXG5cXHQgIG1ldGhvZHM6IHtcXG5cXHQgICAgZGVsZXRlVGV4dE9ySXRlbTogZnVuY3Rpb24gZGVsZXRlVGV4dE9ySXRlbSgpIHtcXG5cXHQgICAgICBpZiAoIXRoaXMuc2VhcmNoVGV4dCAmJiB0aGlzLnZhbHVlKSB7XFxuXFx0ICAgICAgICB0aGlzLnNlbGVjdEl0ZW0oe30pO1xcblxcdCAgICAgICAgdGhpcy5vcGVuT3B0aW9ucygpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHQgICAgb3Blbk9wdGlvbnM6IGZ1bmN0aW9uIG9wZW5PcHRpb25zKCkge1xcblxcdCAgICAgIF9jb21tb24yLmRlZmF1bHQub3Blbk9wdGlvbnModGhpcyk7XFxuXFx0ICAgIH0sXFxuXFx0ICAgIGJsdXJJbnB1dDogZnVuY3Rpb24gYmx1cklucHV0KCkge1xcblxcdCAgICAgIF9jb21tb24yLmRlZmF1bHQuYmx1cklucHV0KHRoaXMpO1xcblxcdCAgICB9LFxcblxcdCAgICBjbG9zZU9wdGlvbnM6IGZ1bmN0aW9uIGNsb3NlT3B0aW9ucygpIHtcXG5cXHQgICAgICBfY29tbW9uMi5kZWZhdWx0LmNsb3NlT3B0aW9ucyh0aGlzKTtcXG5cXHQgICAgfSxcXG5cXHQgICAgcHJldkl0ZW06IGZ1bmN0aW9uIHByZXZJdGVtKCkge1xcblxcdCAgICAgIF9jb21tb24yLmRlZmF1bHQucHJldkl0ZW0odGhpcyk7XFxuXFx0ICAgIH0sXFxuXFx0ICAgIG5leHRJdGVtOiBmdW5jdGlvbiBuZXh0SXRlbSgpIHtcXG5cXHQgICAgICBfY29tbW9uMi5kZWZhdWx0Lm5leHRJdGVtKHRoaXMpO1xcblxcdCAgICB9LFxcblxcdCAgICBlbnRlckl0ZW06IGZ1bmN0aW9uIGVudGVySXRlbSgpIHtcXG5cXHQgICAgICBfY29tbW9uMi5kZWZhdWx0LmVudGVySXRlbSh0aGlzKTtcXG5cXHQgICAgfSxcXG5cXHQgICAgcG9pbnRlclNldDogZnVuY3Rpb24gcG9pbnRlclNldChpbmRleCkge1xcblxcdCAgICAgIF9jb21tb24yLmRlZmF1bHQucG9pbnRlclNldCh0aGlzLCBpbmRleCk7XFxuXFx0ICAgIH0sXFxuXFx0ICAgIHBvaW50ZXJBZGp1c3Q6IGZ1bmN0aW9uIHBvaW50ZXJBZGp1c3QoKSB7XFxuXFx0ICAgICAgX2NvbW1vbjIuZGVmYXVsdC5wb2ludGVyQWRqdXN0KHRoaXMpO1xcblxcdCAgICB9LFxcblxcdCAgICBtb3VzZWRvd25JdGVtOiBmdW5jdGlvbiBtb3VzZWRvd25JdGVtKCkge1xcblxcdCAgICAgIF9jb21tb24yLmRlZmF1bHQubW91c2Vkb3duSXRlbSh0aGlzKTtcXG5cXHQgICAgfSxcXG5cXHQgICAgc2VsZWN0SXRlbTogZnVuY3Rpb24gc2VsZWN0SXRlbShvcHRpb24pIHtcXG5cXHQgICAgICB0aGlzLnNlYXJjaFRleHQgPSAnJztcXG5cXHQgICAgICB0aGlzLmNsb3NlT3B0aW9ucygpO1xcblxcdCAgICAgIGlmICgoMCwgX3R5cGVvZjMuZGVmYXVsdCkodGhpcy52YWx1ZSkgPT09ICdvYmplY3QnICYmIHRoaXMudmFsdWUpIHtcXG5cXHQgICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0Jywgb3B0aW9uKTtcXG5cXHQgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCBvcHRpb24udmFsdWUpO1xcblxcdCAgICAgICAgaWYgKG9wdGlvbi52YWx1ZSA9PT0gb3B0aW9uLnRleHQpIHtcXG5cXHQgICAgICAgICAgdGhpcy5zZWFyY2hUZXh0ID0gb3B0aW9uLnZhbHVlO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHQgICAgb3B0aW9uVmFsdWU6IGZ1bmN0aW9uIG9wdGlvblZhbHVlKHZhbHVlKSB7XFxuXFx0ICAgICAgaWYgKCh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkodmFsdWUpKSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcXG5cXHQgICAgICAgIHJldHVybiB2YWx1ZS52YWx1ZTtcXG5cXHQgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgcmV0dXJuIHZhbHVlO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgfVxcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiA1MSAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdCd1c2Ugc3RyaWN0JztcXG5cXHRcXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuXFx0ICB2YWx1ZTogdHJ1ZVxcblxcdH0pO1xcblxcdFxcblxcdHZhciBfa2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xcblxcdFxcblxcdHZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcXG5cXHRcXG5cXHR2YXIgX011bHRpU2VsZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XFxuXFx0XFxuXFx0dmFyIF9NdWx0aVNlbGVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NdWx0aVNlbGVjdCk7XFxuXFx0XFxuXFx0dmFyIF9taXhpbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xcblxcdFxcblxcdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFx0XFxuXFx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xcblxcdCAgbWl4aW5zOiBbX21peGlucy5jb21tb25NaXhpbl0sXFxuXFx0ICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihjcmVhdGVFbGVtZW50KSB7XFxuXFx0ICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFx0XFxuXFx0ICAgIHJldHVybiBjcmVhdGVFbGVtZW50KF9NdWx0aVNlbGVjdDIuZGVmYXVsdCwge1xcblxcdCAgICAgIHByb3BzOiB7XFxuXFx0ICAgICAgICBpZDogdGhpcy5pZCxcXG5cXHQgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcXG5cXHQgICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcXG5cXHQgICAgICAgIHNlbGVjdGVkT3B0aW9uczogdGhpcy5pdGVtcyxcXG5cXHQgICAgICAgIGlzRXJyb3I6IHRoaXMuaXNFcnJvcixcXG5cXHQgICAgICAgIGlzRGlzYWJsZWQ6IHRoaXMuaXNEaXNhYmxlZCxcXG5cXHQgICAgICAgIHBsYWNlaG9sZGVyOiB0aGlzLnBsYWNlaG9sZGVyLFxcblxcdCAgICAgICAgZmlsdGVyUHJlZGljYXRlOiB0aGlzLmZpbHRlclByZWRpY2F0ZVxcblxcdCAgICAgIH0sXFxuXFx0ICAgICAgb246IHtcXG5cXHQgICAgICAgIHNlbGVjdDogdGhpcy5vblNlbGVjdCxcXG5cXHQgICAgICAgIHNlYXJjaGNoYW5nZTogZnVuY3Rpb24gc2VhcmNoY2hhbmdlKHNlYXJjaFRleHQpIHtcXG5cXHQgICAgICAgICAgcmV0dXJuIF90aGlzLiRlbWl0KCdzZWFyY2hjaGFuZ2UnLCBzZWFyY2hUZXh0KTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9XFxuXFx0ICAgIH0pO1xcblxcdCAgfSxcXG5cXHQgIHByb3BzOiB7XFxuXFx0ICAgIGxpc3Q6IHtcXG5cXHQgICAgICB0eXBlOiBBcnJheVxcblxcdCAgICB9LFxcblxcdCAgICBvcHRpb25WYWx1ZToge1xcblxcdCAgICAgIHR5cGU6IFN0cmluZ1xcblxcdCAgICB9LFxcblxcdCAgICBvcHRpb25UZXh0OiB7XFxuXFx0ICAgICAgdHlwZTogU3RyaW5nXFxuXFx0ICAgIH0sXFxuXFx0ICAgIGN1c3RvbVRleHQ6IHtcXG5cXHQgICAgICB0eXBlOiBGdW5jdGlvblxcblxcdCAgICB9LFxcblxcdCAgICBzZWxlY3RlZEl0ZW1zOiB7XFxuXFx0ICAgICAgdHlwZTogQXJyYXlcXG5cXHQgICAgfVxcblxcdCAgfSxcXG5cXHQgIGNvbXB1dGVkOiB7XFxuXFx0ICAgIG9wdGlvbnM6IGZ1bmN0aW9uIG9wdGlvbnMoKSB7XFxuXFx0ICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFx0XFxuXFx0ICAgICAgcmV0dXJuIHRoaXMubGlzdC5tYXAoZnVuY3Rpb24gKGUpIHtcXG5cXHQgICAgICAgIHJldHVybiB7IHZhbHVlOiBlW190aGlzMi5vcHRpb25WYWx1ZV0sIHRleHQ6IF90aGlzMi5idWlsZFRleHQoZSkgfTtcXG5cXHQgICAgICB9KTtcXG5cXHQgICAgfSxcXG5cXHQgICAgaXRlbXM6IGZ1bmN0aW9uIGl0ZW1zKCkge1xcblxcdCAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xcblxcdFxcblxcdCAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkSXRlbXMubWFwKGZ1bmN0aW9uIChlKSB7XFxuXFx0ICAgICAgICByZXR1cm4geyB2YWx1ZTogZVtfdGhpczMub3B0aW9uVmFsdWVdLCB0ZXh0OiBfdGhpczMuYnVpbGRUZXh0KGUpIH07XFxuXFx0ICAgICAgfSk7XFxuXFx0ICAgIH1cXG5cXHQgIH0sXFxuXFx0ICBtZXRob2RzOiB7XFxuXFx0ICAgIGJ1aWxkVGV4dDogZnVuY3Rpb24gYnVpbGRUZXh0KGUpIHtcXG5cXHQgICAgICBpZiAoZVt0aGlzLm9wdGlvblZhbHVlXSAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5jdXN0b21UZXh0KSB7XFxuXFx0ICAgICAgICAgIHJldHVybiB0aGlzLmN1c3RvbVRleHQoZSk7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICByZXR1cm4gZVt0aGlzLm9wdGlvblRleHRdO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICByZXR1cm4gJyc7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9LFxcblxcdCAgICBvblNlbGVjdDogZnVuY3Rpb24gb25TZWxlY3Qob3B0aW9ucywgb3B0aW9uKSB7XFxuXFx0ICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XFxuXFx0XFxuXFx0ICAgICAgaWYgKCgwLCBfa2V5czIuZGVmYXVsdCkob3B0aW9uKS5sZW5ndGggPT09IDAgJiYgb3B0aW9uLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcXG5cXHQgICAgICAgIHRoaXMuJGVtaXQoJ3NlbGVjdCcsIG9wdGlvbnMsIG9wdGlvbik7XFxuXFx0ICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgIHZhciBpdGVtcyA9IHRoaXMubGlzdC5maWx0ZXIoZnVuY3Rpb24gKGUsIGkpIHtcXG5cXHQgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZmluZChmdW5jdGlvbiAobywgaSkge1xcblxcdCAgICAgICAgICAgIHJldHVybiBlW190aGlzNC5vcHRpb25WYWx1ZV0gPT09IG8udmFsdWU7XFxuXFx0ICAgICAgICAgIH0pO1xcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgICAgICB2YXIgaXRlbSA9IHRoaXMubGlzdC5maW5kKGZ1bmN0aW9uIChlKSB7XFxuXFx0ICAgICAgICAgIHJldHVybiBlW190aGlzNC5vcHRpb25WYWx1ZV0gPT09IG9wdGlvbi52YWx1ZTtcXG5cXHQgICAgICAgIH0pO1xcblxcdCAgICAgICAgdGhpcy4kZW1pdCgnc2VsZWN0JywgaXRlbXMsIGl0ZW0pO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgfSxcXG5cXHQgIGNvbXBvbmVudHM6IHtcXG5cXHQgICAgTXVsdGlTZWxlY3Q6IF9NdWx0aVNlbGVjdDIuZGVmYXVsdFxcblxcdCAgfVxcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiA1MiAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdCd1c2Ugc3RyaWN0JztcXG5cXHRcXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuXFx0ICB2YWx1ZTogdHJ1ZVxcblxcdH0pO1xcblxcdFxcblxcdHZhciBfY29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XFxuXFx0XFxuXFx0dmFyIF9jb21tb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tbW9uKTtcXG5cXHRcXG5cXHR2YXIgX21peGlucyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XFxuXFx0XFxuXFx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXHRcXG5cXHRleHBvcnRzLmRlZmF1bHQgPSB7XFxuXFx0ICBtaXhpbnM6IFtfbWl4aW5zLmJhc2VNaXhpbiwgX21peGlucy5jb21tb25NaXhpbiwgX21peGlucy5vcHRpb25Bd2FyZU1peGluXSxcXG5cXHQgIHByb3BzOiB7XFxuXFx0ICAgIHNlbGVjdGVkT3B0aW9uczoge1xcblxcdCAgICAgIHR5cGU6IEFycmF5XFxuXFx0ICAgIH0sXFxuXFx0ICAgIGNsZWFuU2VhcmNoOiB7XFxuXFx0ICAgICAgdHlwZTogQm9vbGVhbixcXG5cXHQgICAgICBkZWZhdWx0OiB0cnVlXFxuXFx0ICAgIH0sXFxuXFx0ICAgIGhpZGVTZWxlY3RlZE9wdGlvbnM6IHtcXG5cXHQgICAgICB0eXBlOiBCb29sZWFuLFxcblxcdCAgICAgIGRlZmF1bHQ6IGZhbHNlXFxuXFx0ICAgIH1cXG5cXHQgIH0sXFxuXFx0ICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xcblxcdCAgICByZXR1cm4ge1xcblxcdCAgICAgIHNob3dNZW51OiBmYWxzZSxcXG5cXHQgICAgICBzZWFyY2hUZXh0OiAnJyxcXG5cXHQgICAgICBtb3VzZWRvd25TdGF0ZTogZmFsc2UsXFxuXFx0ICAgICAgcG9pbnRlcjogLTFcXG5cXHQgICAgfTtcXG5cXHQgIH0sXFxuXFx0XFxuXFx0ICB3YXRjaDoge1xcblxcdCAgICBzZWxlY3RlZE9wdGlvbnM6IGZ1bmN0aW9uIHNlbGVjdGVkT3B0aW9ucygpIHtcXG5cXHQgICAgICB0aGlzLnBvaW50ZXIgPSAtMTtcXG5cXHQgICAgfVxcblxcdCAgfSxcXG5cXHQgIGNvbXB1dGVkOiB7XFxuXFx0ICAgIGlucHV0VGV4dDogZnVuY3Rpb24gaW5wdXRUZXh0KCkge1xcblxcdCAgICAgIGlmICh0aGlzLnNlYXJjaFRleHQpIHtcXG5cXHQgICAgICAgIHJldHVybiAnJztcXG5cXHQgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMucGxhY2Vob2xkZXI7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9LFxcblxcdCAgICB0ZXh0Q2xhc3M6IGZ1bmN0aW9uIHRleHRDbGFzcygpIHtcXG5cXHQgICAgICBpZiAodGhpcy5wbGFjZWhvbGRlcikge1xcblxcdCAgICAgICAgcmV0dXJuICdkZWZhdWx0JztcXG5cXHQgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgcmV0dXJuICcnO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHQgICAgaW5wdXRXaWR0aDogZnVuY3Rpb24gaW5wdXRXaWR0aCgpIHtcXG5cXHQgICAgICByZXR1cm4ge1xcblxcdCAgICAgICAgd2lkdGg6ICh0aGlzLnNlYXJjaFRleHQubGVuZ3RoICsgMSkgKiA4ICsgMjAgKyAncHgnXFxuXFx0ICAgICAgfTtcXG5cXHQgICAgfSxcXG5cXHQgICAgbWVudUNsYXNzOiBmdW5jdGlvbiBtZW51Q2xhc3MoKSB7XFxuXFx0ICAgICAgcmV0dXJuIHtcXG5cXHQgICAgICAgIHZpc2libGU6IHRoaXMuc2hvd01lbnUsXFxuXFx0ICAgICAgICBoaWRkZW46ICF0aGlzLnNob3dNZW51XFxuXFx0ICAgICAgfTtcXG5cXHQgICAgfSxcXG5cXHQgICAgbWVudVN0eWxlOiBmdW5jdGlvbiBtZW51U3R5bGUoKSB7XFxuXFx0ICAgICAgcmV0dXJuIHtcXG5cXHQgICAgICAgIGRpc3BsYXk6IHRoaXMuc2hvd01lbnUgPyAnYmxvY2snIDogJ25vbmUnXFxuXFx0ICAgICAgfTtcXG5cXHQgICAgfSxcXG5cXHQgICAgbm9uU2VsZWN0T3B0aW9uczogZnVuY3Rpb24gbm9uU2VsZWN0T3B0aW9ucygpIHtcXG5cXHQgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcdFxcblxcdCAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xcblxcdCAgICAgICAgcmV0dXJuIF90aGlzLnNlbGVjdGVkT3B0aW9ucy5maW5kSW5kZXgoZnVuY3Rpb24gKG8pIHtcXG5cXHQgICAgICAgICAgcmV0dXJuIG8udmFsdWUgPT09IGVsLnZhbHVlO1xcblxcdCAgICAgICAgfSkgPT09IC0xO1xcblxcdCAgICAgIH0pO1xcblxcdCAgICB9LFxcblxcdCAgICBmaWx0ZXJlZE9wdGlvbnM6IGZ1bmN0aW9uIGZpbHRlcmVkT3B0aW9ucygpIHtcXG5cXHQgICAgICB2YXIgX3RoaXMyID0gdGhpcztcXG5cXHRcXG5cXHQgICAgICBpZiAodGhpcy5zZWFyY2hUZXh0KSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5ub25TZWxlY3RPcHRpb25zLmZpbHRlcihmdW5jdGlvbiAob3B0aW9uKSB7XFxuXFx0ICAgICAgICAgIHRyeSB7XFxuXFx0ICAgICAgICAgICAgaWYgKF90aGlzMi5jbGVhblNlYXJjaCkge1xcblxcdCAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5maWx0ZXJQcmVkaWNhdGUoX3RoaXMyLmFjY2VudHNUaWR5KG9wdGlvbi50ZXh0KSwgX3RoaXMyLnNlYXJjaFRleHQpO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLmZpbHRlclByZWRpY2F0ZShvcHRpb24udGV4dCwgX3RoaXMyLnNlYXJjaFRleHQpO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgfSBjYXRjaCAoZSkge1xcblxcdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xcblxcdCAgICAgICAgICB9XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMubm9uU2VsZWN0T3B0aW9ucztcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH0sXFxuXFx0ICBtZXRob2RzOiB7XFxuXFx0ICAgIGRlbGV0ZVRleHRPckxhc3RJdGVtOiBmdW5jdGlvbiBkZWxldGVUZXh0T3JMYXN0SXRlbSgpIHtcXG5cXHQgICAgICBpZiAoIXRoaXMuc2VhcmNoVGV4dCAmJiB0aGlzLnNlbGVjdGVkT3B0aW9ucy5sZW5ndGggPiAwKSB7XFxuXFx0ICAgICAgICB0aGlzLmRlbGV0ZUl0ZW0odGhpcy5zZWxlY3RlZE9wdGlvbnNbdGhpcy5zZWxlY3RlZE9wdGlvbnMubGVuZ3RoIC0gMV0pO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHQgICAgb3Blbk9wdGlvbnM6IGZ1bmN0aW9uIG9wZW5PcHRpb25zKCkge1xcblxcdCAgICAgIF9jb21tb24yLmRlZmF1bHQub3Blbk9wdGlvbnModGhpcyk7XFxuXFx0ICAgIH0sXFxuXFx0ICAgIGJsdXJJbnB1dDogZnVuY3Rpb24gYmx1cklucHV0KCkge1xcblxcdCAgICAgIF9jb21tb24yLmRlZmF1bHQuYmx1cklucHV0KHRoaXMpO1xcblxcdCAgICB9LFxcblxcdCAgICBjbG9zZU9wdGlvbnM6IGZ1bmN0aW9uIGNsb3NlT3B0aW9ucygpIHtcXG5cXHQgICAgICBfY29tbW9uMi5kZWZhdWx0LmNsb3NlT3B0aW9ucyh0aGlzKTtcXG5cXHQgICAgfSxcXG5cXHQgICAgcHJldkl0ZW06IGZ1bmN0aW9uIHByZXZJdGVtKCkge1xcblxcdCAgICAgIF9jb21tb24yLmRlZmF1bHQucHJldkl0ZW0odGhpcyk7XFxuXFx0ICAgICAgdGhpcy5jbG9zZU9wdGlvbnMoKTtcXG5cXHQgICAgICB0aGlzLm9wZW5PcHRpb25zKCk7XFxuXFx0ICAgIH0sXFxuXFx0ICAgIG5leHRJdGVtOiBmdW5jdGlvbiBuZXh0SXRlbSgpIHtcXG5cXHQgICAgICBfY29tbW9uMi5kZWZhdWx0Lm5leHRJdGVtKHRoaXMpO1xcblxcdCAgICAgIHRoaXMuY2xvc2VPcHRpb25zKCk7XFxuXFx0ICAgICAgdGhpcy5vcGVuT3B0aW9ucygpO1xcblxcdCAgICB9LFxcblxcdCAgICBlbnRlckl0ZW06IGZ1bmN0aW9uIGVudGVySXRlbSgpIHtcXG5cXHQgICAgICBfY29tbW9uMi5kZWZhdWx0LmVudGVySXRlbSh0aGlzKTtcXG5cXHQgICAgfSxcXG5cXHQgICAgcG9pbnRlclNldDogZnVuY3Rpb24gcG9pbnRlclNldChpbmRleCkge1xcblxcdCAgICAgIF9jb21tb24yLmRlZmF1bHQucG9pbnRlclNldCh0aGlzLCBpbmRleCk7XFxuXFx0ICAgIH0sXFxuXFx0ICAgIHBvaW50ZXJBZGp1c3Q6IGZ1bmN0aW9uIHBvaW50ZXJBZGp1c3QoKSB7XFxuXFx0ICAgICAgX2NvbW1vbjIuZGVmYXVsdC5wb2ludGVyQWRqdXN0KHRoaXMpO1xcblxcdCAgICB9LFxcblxcdCAgICBtb3VzZWRvd25JdGVtOiBmdW5jdGlvbiBtb3VzZWRvd25JdGVtKCkge1xcblxcdCAgICAgIF9jb21tb24yLmRlZmF1bHQubW91c2Vkb3duSXRlbSh0aGlzKTtcXG5cXHQgICAgfSxcXG5cXHQgICAgc2VsZWN0SXRlbTogZnVuY3Rpb24gc2VsZWN0SXRlbShvcHRpb24pIHtcXG5cXHQgICAgICB2YXIgdGVtcFNlbGVjdGVkT3B0aW9ucyA9IHRoaXMuc2VsZWN0ZWRPcHRpb25zLmNvbmNhdChvcHRpb24pO1xcblxcdCAgICAgIHZhciBzZWxlY3RlZE9wdGlvbnMgPSB0ZW1wU2VsZWN0ZWRPcHRpb25zLmZpbHRlcihmdW5jdGlvbiAoZWwsIGlkeCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRlbXBTZWxlY3RlZE9wdGlvbnMuaW5kZXhPZihlbCkgPT09IGlkeDtcXG5cXHQgICAgICB9KTtcXG5cXHQgICAgICB0aGlzLmNsb3NlT3B0aW9ucygpO1xcblxcdCAgICAgIHRoaXMuc2VhcmNoVGV4dCA9ICcnO1xcblxcdCAgICAgIHRoaXMuJGVtaXQoJ3NlbGVjdCcsIHNlbGVjdGVkT3B0aW9ucywgb3B0aW9uLCAnaW5zZXJ0Jyk7XFxuXFx0ICAgIH0sXFxuXFx0ICAgIGRlbGV0ZUl0ZW06IGZ1bmN0aW9uIGRlbGV0ZUl0ZW0ob3B0aW9uKSB7XFxuXFx0ICAgICAgdmFyIHNlbGVjdGVkT3B0aW9ucyA9IHRoaXMuc2VsZWN0ZWRPcHRpb25zLmZpbHRlcihmdW5jdGlvbiAobykge1xcblxcdCAgICAgICAgcmV0dXJuIG8udmFsdWUgIT09IG9wdGlvbi52YWx1ZTtcXG5cXHQgICAgICB9KTtcXG5cXHQgICAgICB0aGlzLiRlbWl0KCdzZWxlY3QnLCBzZWxlY3RlZE9wdGlvbnMsIG9wdGlvbiwgJ2RlbGV0ZScpO1xcblxcdCAgICB9LFxcblxcdCAgICBhY2NlbnRzVGlkeTogZnVuY3Rpb24gYWNjZW50c1RpZHkocykge1xcblxcdCAgICAgIHZhciByID0gcy50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XFxuXFx0ICAgICAgciA9IHIucmVwbGFjZShuZXcgUmVnRXhwKCdbw6DDocOiw6PDpMOlXScsICdnJyksICdhJyk7XFxuXFx0ICAgICAgciA9IHIucmVwbGFjZShuZXcgUmVnRXhwKCfDpicsICdnJyksICdhZScpO1xcblxcdCAgICAgIHIgPSByLnJlcGxhY2UobmV3IFJlZ0V4cCgnw6cnLCAnZycpLCAnYycpO1xcblxcdCAgICAgIHIgPSByLnJlcGxhY2UobmV3IFJlZ0V4cCgnW8Oow6nDqsOrXScsICdnJyksICdlJyk7XFxuXFx0ICAgICAgciA9IHIucmVwbGFjZShuZXcgUmVnRXhwKCdbw6zDrcOuw69dJywgJ2cnKSwgJ2knKTtcXG5cXHQgICAgICByID0gci5yZXBsYWNlKG5ldyBSZWdFeHAoJ8OxJywgJ2cnKSwgJ24nKTtcXG5cXHQgICAgICByID0gci5yZXBsYWNlKG5ldyBSZWdFeHAoJ1vDssOzw7TDtcO2XScsICdnJyksICdvJyk7XFxuXFx0ICAgICAgciA9IHIucmVwbGFjZShuZXcgUmVnRXhwKCfFkycsICdnJyksICdvZScpO1xcblxcdCAgICAgIHIgPSByLnJlcGxhY2UobmV3IFJlZ0V4cCgnW8O5w7rDu8O8XScsICdnJyksICd1Jyk7XFxuXFx0ICAgICAgciA9IHIucmVwbGFjZShuZXcgUmVnRXhwKCdbw73Dv10nLCAnZycpLCAneScpO1xcblxcdCAgICAgIHJldHVybiByO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDUzICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFx0J3VzZSBzdHJpY3QnO1xcblxcdFxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG5cXHQgIHZhbHVlOiB0cnVlXFxuXFx0fSk7XFxuXFx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xcblxcdCAgd2F0Y2g6IHtcXG5cXHQgICAgZmlsdGVyZWRPcHRpb25zOiBmdW5jdGlvbiBmaWx0ZXJlZE9wdGlvbnMoKSB7XFxuXFx0ICAgICAgdGhpcy5wb2ludGVyQWRqdXN0KCk7XFxuXFx0ICAgIH0sXFxuXFx0ICAgIHNlYXJjaFRleHQ6IGZ1bmN0aW9uIHNlYXJjaFRleHQoKSB7XFxuXFx0ICAgICAgdGhpcy4kZW1pdCgnc2VhcmNoY2hhbmdlJywgdGhpcy5zZWFyY2hUZXh0KTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiA1NCAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdCd1c2Ugc3RyaWN0JztcXG5cXHRcXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuXFx0ICB2YWx1ZTogdHJ1ZVxcblxcdH0pO1xcblxcdFxcblxcdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcXG5cXHRcXG5cXHRleHBvcnRzLmRlZmF1bHQgPSB7XFxuXFx0ICBwcm9wczoge1xcblxcdCAgICBpZDoge1xcblxcdCAgICAgIGRlZmF1bHQ6IG51bGxcXG5cXHQgICAgfSxcXG5cXHQgICAgbmFtZToge1xcblxcdCAgICAgIHR5cGU6IFN0cmluZyxcXG5cXHQgICAgICBkZWZhdWx0OiAnJ1xcblxcdCAgICB9LFxcblxcdCAgICBpc0Vycm9yOiB7XFxuXFx0ICAgICAgdHlwZTogQm9vbGVhbixcXG5cXHQgICAgICBkZWZhdWx0OiBmYWxzZVxcblxcdCAgICB9LFxcblxcdCAgICBjdXN0b21BdHRyOiB7XFxuXFx0ICAgICAgdHlwZTogRnVuY3Rpb24sXFxuXFx0ICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XFxuXFx0ICAgICAgICByZXR1cm4gJyc7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9LFxcblxcdCAgICBpc0Rpc2FibGVkOiB7XFxuXFx0ICAgICAgdHlwZTogQm9vbGVhbixcXG5cXHQgICAgICBkZWZhdWx0OiBmYWxzZVxcblxcdCAgICB9LFxcblxcdCAgICBwbGFjZWhvbGRlcjoge1xcblxcdCAgICAgIHR5cGU6IFN0cmluZyxcXG5cXHQgICAgICBkZWZhdWx0OiAnJ1xcblxcdCAgICB9LFxcblxcdCAgICBmaWx0ZXJQcmVkaWNhdGU6IHtcXG5cXHQgICAgICB0eXBlOiBGdW5jdGlvbixcXG5cXHQgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCh0ZXh0LCBpbnB1dFRleHQpIHtcXG5cXHQgICAgICAgIHJldHVybiB0ZXh0Lm1hdGNoKCgwLCBfdXRpbHMuZXNjYXBlZFJlZ0V4cCkoaW5wdXRUZXh0KSk7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDU1ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFx0J3VzZSBzdHJpY3QnO1xcblxcdFxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG5cXHQgIHZhbHVlOiB0cnVlXFxuXFx0fSk7XFxuXFx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xcblxcdCAgcHJvcHM6IHtcXG5cXHQgICAgY3VzdG9tQXR0cjoge1xcblxcdCAgICAgIHR5cGU6IEZ1bmN0aW9uLFxcblxcdCAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xcblxcdCAgICAgICAgcmV0dXJuICcnO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHQgICAgb3B0aW9uczoge1xcblxcdCAgICAgIHR5cGU6IEFycmF5XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogNTYgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHQndXNlIHN0cmljdCc7XFxuXFx0XFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcblxcdCAgdmFsdWU6IHRydWVcXG5cXHR9KTtcXG5cXHRleHBvcnRzLmVzY2FwZWRSZWdFeHAgPSBlc2NhcGVkUmVnRXhwO1xcblxcdGZ1bmN0aW9uIGVzY2FwZWRSZWdFeHAoc3RyKSB7XFxuXFx0ICByZXR1cm4gbmV3IFJlZ0V4cChzdHIucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXFxdXFxcXFxcXFxdL2csICdcXFxcXFxcXCQmJyksICdpJyk7XFxuXFx0fVxcblxcbi8qKiovIH0sXFxuLyogNTcgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRtb2R1bGUuZXhwb3J0cyA9IHsgXFxcImRlZmF1bHRcXFwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xcblxcbi8qKiovIH0sXFxuLyogNTggKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRtb2R1bGUuZXhwb3J0cyA9IHsgXFxcImRlZmF1bHRcXFwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xcblxcbi8qKiovIH0sXFxuLyogNTkgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDgzKTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpLk9iamVjdC5rZXlzO1xcblxcbi8qKiovIH0sXFxuLyogNjAgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDg2KTtcXG5cXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDg0KTtcXG5cXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDg3KTtcXG5cXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDg4KTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpLlN5bWJvbDtcXG5cXG4vKioqLyB9LFxcbi8qIDYxICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0X193ZWJwYWNrX3JlcXVpcmVfXyg4NSk7XFxuXFx0X193ZWJwYWNrX3JlcXVpcmVfXyg4OSk7XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKS5mKCdpdGVyYXRvcicpO1xcblxcbi8qKiovIH0sXFxuLyogNjIgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcXG5cXHQgIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XFxuXFx0ICByZXR1cm4gaXQ7XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDYzICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9O1xcblxcbi8qKiovIH0sXFxuLyogNjQgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXFxuXFx0Ly8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcXG5cXHR2YXIgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKVxcblxcdCAgLCB0b0xlbmd0aCAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxKVxcblxcdCAgLCB0b0luZGV4ICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwKTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKElTX0lOQ0xVREVTKXtcXG5cXHQgIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XFxuXFx0ICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoJHRoaXMpXFxuXFx0ICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcXG5cXHQgICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXFxuXFx0ICAgICAgLCB2YWx1ZTtcXG5cXHQgICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxcblxcdCAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XFxuXFx0ICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xcblxcdCAgICAgIGlmKHZhbHVlICE9IHZhbHVlKXJldHVybiB0cnVlO1xcblxcdCAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XFxuXFx0ICAgIH0gZWxzZSBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pe1xcblxcdCAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcXG5cXHQgICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xcblxcdCAgfTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogNjUgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcXG5cXHR2YXIgYUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mik7XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcXG5cXHQgIGFGdW5jdGlvbihmbik7XFxuXFx0ICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xcblxcdCAgc3dpdGNoKGxlbmd0aCl7XFxuXFx0ICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xcblxcdCAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xcblxcdCAgICB9O1xcblxcdCAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcXG5cXHQgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XFxuXFx0ICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XFxuXFx0ICAgIH07XFxuXFx0ICB9XFxuXFx0ICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XFxuXFx0ICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xcblxcdCAgfTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogNjYgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xcblxcdHZhciBnZXRLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMylcXG5cXHQgICwgZ09QUyAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDApXFxuXFx0ICAsIHBJRSAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcXG5cXHQgIHZhciByZXN1bHQgICAgID0gZ2V0S2V5cyhpdClcXG5cXHQgICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mO1xcblxcdCAgaWYoZ2V0U3ltYm9scyl7XFxuXFx0ICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdClcXG5cXHQgICAgICAsIGlzRW51bSAgPSBwSUUuZlxcblxcdCAgICAgICwgaSAgICAgICA9IDBcXG5cXHQgICAgICAsIGtleTtcXG5cXHQgICAgd2hpbGUoc3ltYm9scy5sZW5ndGggPiBpKWlmKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKXJlc3VsdC5wdXNoKGtleSk7XFxuXFx0ICB9IHJldHVybiByZXN1bHQ7XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDY3ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcXG5cXG4vKioqLyB9LFxcbi8qIDY4ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Ly8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcXG5cXHR2YXIgY29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcXG5cXHQgIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogNjkgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxcblxcdHZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xcblxcdCAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDcwICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0J3VzZSBzdHJpY3QnO1xcblxcdHZhciBjcmVhdGUgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpXFxuXFx0ICAsIGRlc2NyaXB0b3IgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNilcXG5cXHQgICwgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KVxcblxcdCAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xcblxcdFxcblxcdC8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXFxuXFx0X193ZWJwYWNrX3JlcXVpcmVfXyg4KShJdGVyYXRvclByb3RvdHlwZSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMCkoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcXG5cXHRcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcXG5cXHQgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge25leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCl9KTtcXG5cXHQgIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiA3MSAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xcblxcdCAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDcyICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0dmFyIGdldEtleXMgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpXFxuXFx0ICAsIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGVsKXtcXG5cXHQgIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxcblxcdCAgICAsIGtleXMgICA9IGdldEtleXMoTylcXG5cXHQgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxcblxcdCAgICAsIGluZGV4ICA9IDBcXG5cXHQgICAgLCBrZXk7XFxuXFx0ICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiA3MyAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdHZhciBNRVRBICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpKCdtZXRhJylcXG5cXHQgICwgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KVxcblxcdCAgLCBoYXMgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMilcXG5cXHQgICwgc2V0RGVzYyAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpLmZcXG5cXHQgICwgaWQgICAgICAgPSAwO1xcblxcdHZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XFxuXFx0ICByZXR1cm4gdHJ1ZTtcXG5cXHR9O1xcblxcdHZhciBGUkVFWkUgPSAhX193ZWJwYWNrX3JlcXVpcmVfXygxMikoZnVuY3Rpb24oKXtcXG5cXHQgIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XFxuXFx0fSk7XFxuXFx0dmFyIHNldE1ldGEgPSBmdW5jdGlvbihpdCl7XFxuXFx0ICBzZXREZXNjKGl0LCBNRVRBLCB7dmFsdWU6IHtcXG5cXHQgICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXFxuXFx0ICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXFxuXFx0ICB9fSk7XFxuXFx0fTtcXG5cXHR2YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xcblxcdCAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxcblxcdCAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xcblxcdCAgaWYoIWhhcyhpdCwgTUVUQSkpe1xcblxcdCAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxcblxcdCAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xcblxcdCAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxcblxcdCAgICBpZighY3JlYXRlKXJldHVybiAnRSc7XFxuXFx0ICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXFxuXFx0ICAgIHNldE1ldGEoaXQpO1xcblxcdCAgLy8gcmV0dXJuIG9iamVjdCBJRFxcblxcdCAgfSByZXR1cm4gaXRbTUVUQV0uaTtcXG5cXHR9O1xcblxcdHZhciBnZXRXZWFrID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XFxuXFx0ICBpZighaGFzKGl0LCBNRVRBKSl7XFxuXFx0ICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XFxuXFx0ICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiB0cnVlO1xcblxcdCAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxcblxcdCAgICBpZighY3JlYXRlKXJldHVybiBmYWxzZTtcXG5cXHQgICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcXG5cXHQgICAgc2V0TWV0YShpdCk7XFxuXFx0ICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xcblxcdCAgfSByZXR1cm4gaXRbTUVUQV0udztcXG5cXHR9O1xcblxcdC8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xcblxcdHZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uKGl0KXtcXG5cXHQgIGlmKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSlzZXRNZXRhKGl0KTtcXG5cXHQgIHJldHVybiBpdDtcXG5cXHR9O1xcblxcdHZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XFxuXFx0ICBLRVk6ICAgICAgTUVUQSxcXG5cXHQgIE5FRUQ6ICAgICBmYWxzZSxcXG5cXHQgIGZhc3RLZXk6ICBmYXN0S2V5LFxcblxcdCAgZ2V0V2VhazogIGdldFdlYWssXFxuXFx0ICBvbkZyZWV6ZTogb25GcmVlemVcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogNzQgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHR2YXIgZFAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpXFxuXFx0ICAsIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNClcXG5cXHQgICwgZ2V0S2V5cyAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcXG5cXHRcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XFxuXFx0ICBhbk9iamVjdChPKTtcXG5cXHQgIHZhciBrZXlzICAgPSBnZXRLZXlzKFByb3BlcnRpZXMpXFxuXFx0ICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcXG5cXHQgICAgLCBpID0gMFxcblxcdCAgICAsIFA7XFxuXFx0ICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XFxuXFx0ICByZXR1cm4gTztcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogNzUgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHR2YXIgcElFICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KVxcblxcdCAgLCBjcmVhdGVEZXNjICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpXFxuXFx0ICAsIHRvSU9iamVjdCAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKVxcblxcdCAgLCB0b1ByaW1pdGl2ZSAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzApXFxuXFx0ICAsIGhhcyAgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKVxcblxcdCAgLCBJRThfRE9NX0RFRklORSA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpXFxuXFx0ICAsIGdPUEQgICAgICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcXG5cXHRcXG5cXHRleHBvcnRzLmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKXtcXG5cXHQgIE8gPSB0b0lPYmplY3QoTyk7XFxuXFx0ICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XFxuXFx0ICBpZihJRThfRE9NX0RFRklORSl0cnkge1xcblxcdCAgICByZXR1cm4gZ09QRChPLCBQKTtcXG5cXHQgIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cXG5cXHQgIGlmKGhhcyhPLCBQKSlyZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDc2ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Ly8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xcblxcdHZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpXFxuXFx0ICAsIGdPUE4gICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpLmZcXG5cXHQgICwgdG9TdHJpbmcgID0ge30udG9TdHJpbmc7XFxuXFx0XFxuXFx0dmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcXG5cXHQgID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xcblxcdFxcblxcdHZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uKGl0KXtcXG5cXHQgIHRyeSB7XFxuXFx0ICAgIHJldHVybiBnT1BOKGl0KTtcXG5cXHQgIH0gY2F0Y2goZSl7XFxuXFx0ICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xcblxcdCAgfVxcblxcdH07XFxuXFx0XFxuXFx0bW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xcblxcdCAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcXG5cXHR9O1xcblxcblxcbi8qKiovIH0sXFxuLyogNzcgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxcblxcdHZhciBoYXMgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMilcXG5cXHQgICwgdG9PYmplY3QgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKVxcblxcdCAgLCBJRV9QUk9UTyAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpKCdJRV9QUk9UTycpXFxuXFx0ICAsIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcXG5cXHRcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbihPKXtcXG5cXHQgIE8gPSB0b09iamVjdChPKTtcXG5cXHQgIGlmKGhhcyhPLCBJRV9QUk9UTykpcmV0dXJuIE9bSUVfUFJPVE9dO1xcblxcdCAgaWYodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcil7XFxuXFx0ICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcXG5cXHQgIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDc4ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Ly8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXFxuXFx0dmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKVxcblxcdCAgLCBjb3JlICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSlcXG5cXHQgICwgZmFpbHMgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xcblxcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBleGVjKXtcXG5cXHQgIHZhciBmbiAgPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV1cXG5cXHQgICAgLCBleHAgPSB7fTtcXG5cXHQgIGV4cFtLRVldID0gZXhlYyhmbik7XFxuXFx0ICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDc5ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0dmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpXFxuXFx0ICAsIGRlZmluZWQgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xcblxcdC8vIHRydWUgIC0+IFN0cmluZyNhdFxcblxcdC8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxcblxcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVE9fU1RSSU5HKXtcXG5cXHQgIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xcblxcdCAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxcblxcdCAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXFxuXFx0ICAgICAgLCBsID0gcy5sZW5ndGhcXG5cXHQgICAgICAsIGEsIGI7XFxuXFx0ICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XFxuXFx0ICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XFxuXFx0ICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXFxuXFx0ICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcXG5cXHQgICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcXG5cXHQgIH07XFxuXFx0fTtcXG5cXG4vKioqLyB9LFxcbi8qIDgwICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0dmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpXFxuXFx0ICAsIG1heCAgICAgICA9IE1hdGgubWF4XFxuXFx0ICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xcblxcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XFxuXFx0ICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XFxuXFx0ICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcXG5cXHR9O1xcblxcbi8qKiovIH0sXFxuLyogODEgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyA3LjEuMTUgVG9MZW5ndGhcXG5cXHR2YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSlcXG5cXHQgICwgbWluICAgICAgID0gTWF0aC5taW47XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XFxuXFx0ICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxcblxcdH07XFxuXFxuLyoqKi8gfSxcXG4vKiA4MiAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdCd1c2Ugc3RyaWN0JztcXG5cXHR2YXIgYWRkVG9VbnNjb3BhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjMpXFxuXFx0ICAsIHN0ZXAgICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKVxcblxcdCAgLCBJdGVyYXRvcnMgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMylcXG5cXHQgICwgdG9JT2JqZWN0ICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XFxuXFx0XFxuXFx0Ly8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxcblxcdC8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXFxuXFx0Ly8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxcblxcdC8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxcblxcdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcXG5cXHQgIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcXG5cXHQgIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XFxuXFx0ICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxcblxcdC8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxcblxcdH0sIGZ1bmN0aW9uKCl7XFxuXFx0ICB2YXIgTyAgICAgPSB0aGlzLl90XFxuXFx0ICAgICwga2luZCAgPSB0aGlzLl9rXFxuXFx0ICAgICwgaW5kZXggPSB0aGlzLl9pKys7XFxuXFx0ICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XFxuXFx0ICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XFxuXFx0ICAgIHJldHVybiBzdGVwKDEpO1xcblxcdCAgfVxcblxcdCAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XFxuXFx0ICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcXG5cXHQgIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcXG5cXHR9LCAndmFsdWVzJyk7XFxuXFx0XFxuXFx0Ly8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxcblxcdEl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XFxuXFx0XFxuXFx0YWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xcblxcdGFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xcblxcdGFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcXG5cXG4vKioqLyB9LFxcbi8qIDgzICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Ly8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXFxuXFx0dmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MylcXG5cXHQgICwgJGtleXMgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcXG5cXHRcXG5cXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDc4KSgna2V5cycsIGZ1bmN0aW9uKCl7XFxuXFx0ICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCl7XFxuXFx0ICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xcblxcdCAgfTtcXG5cXHR9KTtcXG5cXG4vKioqLyB9LFxcbi8qIDg0ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFxuXFxuLyoqKi8gfSxcXG4vKiA4NSAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdCd1c2Ugc3RyaWN0JztcXG5cXHR2YXIgJGF0ICA9IF9fd2VicGFja19yZXF1aXJlX18oNzkpKHRydWUpO1xcblxcdFxcblxcdC8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcXG5cXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XFxuXFx0ICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XFxuXFx0ICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxcblxcdC8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcXG5cXHR9LCBmdW5jdGlvbigpe1xcblxcdCAgdmFyIE8gICAgID0gdGhpcy5fdFxcblxcdCAgICAsIGluZGV4ID0gdGhpcy5faVxcblxcdCAgICAsIHBvaW50O1xcblxcdCAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcXG5cXHQgIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcXG5cXHQgIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xcblxcdCAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcXG5cXHR9KTtcXG5cXG4vKioqLyB9LFxcbi8qIDg2ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0J3VzZSBzdHJpY3QnO1xcblxcdC8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cXG5cXHR2YXIgZ2xvYmFsICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpXFxuXFx0ICAsIGhhcyAgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKVxcblxcdCAgLCBERVNDUklQVE9SUyAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNylcXG5cXHQgICwgJGV4cG9ydCAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKVxcblxcdCAgLCByZWRlZmluZSAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpXFxuXFx0ICAsIE1FVEEgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MykuS0VZXFxuXFx0ICAsICRmYWlscyAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMilcXG5cXHQgICwgc2hhcmVkICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KVxcblxcdCAgLCBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpXFxuXFx0ICAsIHVpZCAgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNylcXG5cXHQgICwgd2tzICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKVxcblxcdCAgLCB3a3NFeHQgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpXFxuXFx0ICAsIHdrc0RlZmluZSAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSlcXG5cXHQgICwga2V5T2YgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKVxcblxcdCAgLCBlbnVtS2V5cyAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpXFxuXFx0ICAsIGlzQXJyYXkgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OSlcXG5cXHQgICwgYW5PYmplY3QgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KVxcblxcdCAgLCB0b0lPYmplY3QgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMylcXG5cXHQgICwgdG9QcmltaXRpdmUgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKVxcblxcdCAgLCBjcmVhdGVEZXNjICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpXFxuXFx0ICAsIF9jcmVhdGUgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOClcXG5cXHQgICwgZ09QTkV4dCAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KVxcblxcdCAgLCAkR09QRCAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpXFxuXFx0ICAsICREUCAgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KVxcblxcdCAgLCAka2V5cyAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpXFxuXFx0ICAsIGdPUEQgICAgICAgICAgID0gJEdPUEQuZlxcblxcdCAgLCBkUCAgICAgICAgICAgICA9ICREUC5mXFxuXFx0ICAsIGdPUE4gICAgICAgICAgID0gZ09QTkV4dC5mXFxuXFx0ICAsICRTeW1ib2wgICAgICAgID0gZ2xvYmFsLlN5bWJvbFxcblxcdCAgLCAkSlNPTiAgICAgICAgICA9IGdsb2JhbC5KU09OXFxuXFx0ICAsIF9zdHJpbmdpZnkgICAgID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5XFxuXFx0ICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcXG5cXHQgICwgSElEREVOICAgICAgICAgPSB3a3MoJ19oaWRkZW4nKVxcblxcdCAgLCBUT19QUklNSVRJVkUgICA9IHdrcygndG9QcmltaXRpdmUnKVxcblxcdCAgLCBpc0VudW0gICAgICAgICA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlXFxuXFx0ICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxcblxcdCAgLCBBbGxTeW1ib2xzICAgICA9IHNoYXJlZCgnc3ltYm9scycpXFxuXFx0ICAsIE9QU3ltYm9scyAgICAgID0gc2hhcmVkKCdvcC1zeW1ib2xzJylcXG5cXHQgICwgT2JqZWN0UHJvdG8gICAgPSBPYmplY3RbUFJPVE9UWVBFXVxcblxcdCAgLCBVU0VfTkFUSVZFICAgICA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbidcXG5cXHQgICwgUU9iamVjdCAgICAgICAgPSBnbG9iYWwuUU9iamVjdDtcXG5cXHQvLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcXG5cXHR2YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcXG5cXHRcXG5cXHQvLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcXG5cXHR2YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbigpe1xcblxcdCAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xcblxcdCAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBkUCh0aGlzLCAnYScsIHt2YWx1ZTogN30pLmE7IH1cXG5cXHQgIH0pKS5hICE9IDc7XFxuXFx0fSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcXG5cXHQgIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xcblxcdCAgaWYocHJvdG9EZXNjKWRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xcblxcdCAgZFAoaXQsIGtleSwgRCk7XFxuXFx0ICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKWRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XFxuXFx0fSA6IGRQO1xcblxcdFxcblxcdHZhciB3cmFwID0gZnVuY3Rpb24odGFnKXtcXG5cXHQgIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XFxuXFx0ICBzeW0uX2sgPSB0YWc7XFxuXFx0ICByZXR1cm4gc3ltO1xcblxcdH07XFxuXFx0XFxuXFx0dmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uKGl0KXtcXG5cXHQgIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XFxuXFx0fSA6IGZ1bmN0aW9uKGl0KXtcXG5cXHQgIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XFxuXFx0fTtcXG5cXHRcXG5cXHR2YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCl7XFxuXFx0ICBpZihpdCA9PT0gT2JqZWN0UHJvdG8pJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcXG5cXHQgIGFuT2JqZWN0KGl0KTtcXG5cXHQgIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XFxuXFx0ICBhbk9iamVjdChEKTtcXG5cXHQgIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcXG5cXHQgICAgaWYoIUQuZW51bWVyYWJsZSl7XFxuXFx0ICAgICAgaWYoIWhhcyhpdCwgSElEREVOKSlkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XFxuXFx0ICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICBpZihoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKWl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xcblxcdCAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xcblxcdCAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xcblxcdCAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XFxuXFx0fTtcXG5cXHR2YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKXtcXG5cXHQgIGFuT2JqZWN0KGl0KTtcXG5cXHQgIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcXG5cXHQgICAgLCBpICAgID0gMFxcblxcdCAgICAsIGwgPSBrZXlzLmxlbmd0aFxcblxcdCAgICAsIGtleTtcXG5cXHQgIHdoaWxlKGwgPiBpKSRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xcblxcdCAgcmV0dXJuIGl0O1xcblxcdH07XFxuXFx0dmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApe1xcblxcdCAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xcblxcdH07XFxuXFx0dmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSl7XFxuXFx0ICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xcblxcdCAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuIGZhbHNlO1xcblxcdCAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xcblxcdH07XFxuXFx0dmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XFxuXFx0ICBpdCAgPSB0b0lPYmplY3QoaXQpO1xcblxcdCAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcXG5cXHQgIGlmKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm47XFxuXFx0ICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XFxuXFx0ICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpRC5lbnVtZXJhYmxlID0gdHJ1ZTtcXG5cXHQgIHJldHVybiBEO1xcblxcdH07XFxuXFx0dmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XFxuXFx0ICB2YXIgbmFtZXMgID0gZ09QTih0b0lPYmplY3QoaXQpKVxcblxcdCAgICAsIHJlc3VsdCA9IFtdXFxuXFx0ICAgICwgaSAgICAgID0gMFxcblxcdCAgICAsIGtleTtcXG5cXHQgIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xcblxcdCAgICBpZighaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpcmVzdWx0LnB1c2goa2V5KTtcXG5cXHQgIH0gcmV0dXJuIHJlc3VsdDtcXG5cXHR9O1xcblxcdHZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KXtcXG5cXHQgIHZhciBJU19PUCAgPSBpdCA9PT0gT2JqZWN0UHJvdG9cXG5cXHQgICAgLCBuYW1lcyAgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSlcXG5cXHQgICAgLCByZXN1bHQgPSBbXVxcblxcdCAgICAsIGkgICAgICA9IDBcXG5cXHQgICAgLCBrZXk7XFxuXFx0ICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKXtcXG5cXHQgICAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XFxuXFx0ICB9IHJldHVybiByZXN1bHQ7XFxuXFx0fTtcXG5cXHRcXG5cXHQvLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcXG5cXHRpZighVVNFX05BVElWRSl7XFxuXFx0ICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XFxuXFx0ICAgIGlmKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKXRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xcblxcdCAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcXG5cXHQgICAgdmFyICRzZXQgPSBmdW5jdGlvbih2YWx1ZSl7XFxuXFx0ICAgICAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8pJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xcblxcdCAgICAgIGlmKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcXG5cXHQgICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xcblxcdCAgICB9O1xcblxcdCAgICBpZihERVNDUklQVE9SUyAmJiBzZXR0ZXIpc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7Y29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXR9KTtcXG5cXHQgICAgcmV0dXJuIHdyYXAodGFnKTtcXG5cXHQgIH07XFxuXFx0ICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XFxuXFx0ICAgIHJldHVybiB0aGlzLl9rO1xcblxcdCAgfSk7XFxuXFx0XFxuXFx0ICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcXG5cXHQgICREUC5mICAgPSAkZGVmaW5lUHJvcGVydHk7XFxuXFx0ICBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XFxuXFx0ICBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KS5mICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcXG5cXHQgIF9fd2VicGFja19yZXF1aXJlX18oNDApLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xcblxcdFxcblxcdCAgaWYoREVTQ1JJUFRPUlMgJiYgIV9fd2VicGFja19yZXF1aXJlX18oMjQpKXtcXG5cXHQgICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XFxuXFx0ICB9XFxuXFx0XFxuXFx0ICB3a3NFeHQuZiA9IGZ1bmN0aW9uKG5hbWUpe1xcblxcdCAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xcblxcdCAgfVxcblxcdH1cXG5cXHRcXG5cXHQkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7U3ltYm9sOiAkU3ltYm9sfSk7XFxuXFx0XFxuXFx0Zm9yKHZhciBzeW1ib2xzID0gKFxcblxcdCAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcXG5cXHQgICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcXG5cXHQpLnNwbGl0KCcsJyksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3Moc3ltYm9sc1tpKytdKTtcXG5cXHRcXG5cXHRmb3IodmFyIHN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzRGVmaW5lKHN5bWJvbHNbaSsrXSk7XFxuXFx0XFxuXFx0JGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcXG5cXHQgIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxcblxcdCAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XFxuXFx0ICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcXG5cXHQgICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cXG5cXHQgICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XFxuXFx0ICB9LFxcblxcdCAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXFxuXFx0ICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihrZXkpe1xcblxcdCAgICBpZihpc1N5bWJvbChrZXkpKXJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcXG5cXHQgICAgdGhyb3cgVHlwZUVycm9yKGtleSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xcblxcdCAgfSxcXG5cXHQgIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcXG5cXHQgIHVzZVNpbXBsZTogZnVuY3Rpb24oKXsgc2V0dGVyID0gZmFsc2U7IH1cXG5cXHR9KTtcXG5cXHRcXG5cXHQkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xcblxcdCAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxcblxcdCAgY3JlYXRlOiAkY3JlYXRlLFxcblxcdCAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXFxuXFx0ICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxcblxcdCAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcXG5cXHQgIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxcblxcdCAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxcblxcdCAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxcblxcdCAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcXG5cXHQgIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxcblxcdCAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxcblxcdCAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXFxuXFx0fSk7XFxuXFx0XFxuXFx0Ly8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXFxuXFx0JEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uKCl7XFxuXFx0ICB2YXIgUyA9ICRTeW1ib2woKTtcXG5cXHQgIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XFxuXFx0ICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcXG5cXHQgIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXFxuXFx0ICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoe2E6IFN9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xcblxcdH0pKSwgJ0pTT04nLCB7XFxuXFx0ICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XFxuXFx0ICAgIGlmKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKXJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxcblxcdCAgICB2YXIgYXJncyA9IFtpdF1cXG5cXHQgICAgICAsIGkgICAgPSAxXFxuXFx0ICAgICAgLCByZXBsYWNlciwgJHJlcGxhY2VyO1xcblxcdCAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xcblxcdCAgICByZXBsYWNlciA9IGFyZ3NbMV07XFxuXFx0ICAgIGlmKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSRyZXBsYWNlciA9IHJlcGxhY2VyO1xcblxcdCAgICBpZigkcmVwbGFjZXIgfHwgIWlzQXJyYXkocmVwbGFjZXIpKXJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XFxuXFx0ICAgICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XFxuXFx0ICAgICAgaWYoIWlzU3ltYm9sKHZhbHVlKSlyZXR1cm4gdmFsdWU7XFxuXFx0ICAgIH07XFxuXFx0ICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcXG5cXHQgICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xcblxcdCAgfVxcblxcdH0pO1xcblxcdFxcblxcdC8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcXG5cXHQkU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XFxuXFx0Ly8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxcblxcdHNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcXG5cXHQvLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXFxuXFx0c2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcXG5cXHQvLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxcblxcdHNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xcblxcbi8qKiovIH0sXFxuLyogODcgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKSgnYXN5bmNJdGVyYXRvcicpO1xcblxcbi8qKiovIH0sXFxuLyogODggKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKSgnb2JzZXJ2YWJsZScpO1xcblxcbi8qKiovIH0sXFxuLyogODkgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDgyKTtcXG5cXHR2YXIgZ2xvYmFsICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMSlcXG5cXHQgICwgaGlkZSAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oOClcXG5cXHQgICwgSXRlcmF0b3JzICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpXFxuXFx0ICAsIFRPX1NUUklOR19UQUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSgndG9TdHJpbmdUYWcnKTtcXG5cXHRcXG5cXHRmb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcXG5cXHQgIHZhciBOQU1FICAgICAgID0gY29sbGVjdGlvbnNbaV1cXG5cXHQgICAgLCBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdXFxuXFx0ICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XFxuXFx0ICBpZihwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10paGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XFxuXFx0ICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XFxuXFx0fVxcblxcbi8qKiovIH0sXFxuLyogOTAgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKCk7XFxuXFx0Ly8gaW1wb3J0c1xcblxcdFxcblxcdFxcblxcdC8vIG1vZHVsZVxcblxcdGV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcXFwiXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG4vKiBNZW51IEl0ZW0gSG92ZXIgKi9cXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pdGVtOmhvdmVyIHtcXFxcbiAgYmFja2dyb3VuZDogbm9uZSB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBNZW51IEl0ZW0gSG92ZXIgZm9yIEtleSBldmVudCAqL1xcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW0uY3VycmVudCB7XFxcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4wNSkgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXCIsIFxcXCJcXFwiXSk7XFxuXFx0XFxuXFx0Ly8gZXhwb3J0c1xcblxcblxcbi8qKiovIH0sXFxuLyogOTEgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKCk7XFxuXFx0Ly8gaW1wb3J0c1xcblxcdFxcblxcdFxcblxcdC8vIG1vZHVsZVxcblxcdGV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcXFwiLyohXFxcXG4gKiAjIFNlbWFudGljIFVJIDIuMi4zIC0gRHJvcGRvd25cXFxcbiAqIGh0dHA6Ly9naXRodWIuY29tL3NlbWFudGljLW9yZy9zZW1hbnRpYy11aS9cXFxcbiAqXFxcXG4gKlxcXFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXFxcXG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXFxcXG4gKlxcXFxuICovXFxcXG5cXFxcblxcXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXFxcbiAgICAgICAgICAgIERyb3Bkb3duXFxcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcXFxuLnVpLmRyb3Bkb3duW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXFxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcXFxuICBvdXRsaW5lOiBub25lO1xcXFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcXFxuICAtd2Via2l0LXRyYW5zaXRpb246IGJveC1zaGFkb3cgMC4xcyBlYXNlLCB3aWR0aCAwLjFzIGVhc2U7XFxcXG4gIHRyYW5zaXRpb246IGJveC1zaGFkb3cgMC4xcyBlYXNlLCB3aWR0aCAwLjFzIGVhc2U7XFxcXG4gIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcXFxcbn1cXFxcblxcXFxuXFxcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcXFxuICAgICAgICAgICAgQ29udGVudFxcXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXFxcblxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gICAgICBNZW51XFxcXG4tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLmRyb3Bkb3duIC5tZW51W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBjdXJzb3I6IGF1dG87XFxcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcbiAgZGlzcGxheTogbm9uZTtcXFxcbiAgb3V0bGluZTogbm9uZTtcXFxcbiAgdG9wOiAxMDAlO1xcXFxuICBtaW4td2lkdGg6IC13ZWJraXQtbWF4LWNvbnRlbnQ7XFxcXG4gIG1pbi13aWR0aDogLW1vei1tYXgtY29udGVudDtcXFxcbiAgbWluLXdpZHRoOiBtYXgtY29udGVudDtcXFxcbiAgbWFyZ2luOiAwZW07XFxcXG4gIHBhZGRpbmc6IDBlbSAwZW07XFxcXG4gIGJhY2tncm91bmQ6ICNGRkZGRkY7XFxcXG4gIGZvbnQtc2l6ZTogMWVtO1xcXFxuICB0ZXh0LXNoYWRvdzogbm9uZTtcXFxcbiAgdGV4dC1hbGlnbjogbGVmdDtcXFxcbiAgYm94LXNoYWRvdzogMHB4IDJweCAzcHggMHB4IHJnYmEoMzQsIDM2LCAzOCwgMC4xNSk7XFxcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMzQsIDM2LCAzOCwgMC4xNSk7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjg1NzE0MjlyZW07XFxcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAwLjFzIGVhc2U7XFxcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMC4xcyBlYXNlO1xcXFxuICB6LWluZGV4OiAxMTtcXFxcbiAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybSwgb3BhY2l0eTtcXFxcbn1cXFxcbi51aS5kcm9wZG93biAubWVudSA+ICpbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgSGlkZGVuIElucHV0XFxcXG4tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLmRyb3Bkb3duID4gaW5wdXRbZGF0YS12LTNhMGM3YmVhXTpub3QoLnNlYXJjaCk6Zmlyc3QtY2hpbGQsXFxcXG4udWkuZHJvcGRvd24gPiBzZWxlY3RbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuIERyb3Bkb3duIEljb25cXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZHJvcGRvd24gPiAuZHJvcGRvd24uaWNvbltkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcXFxuICB3aWR0aDogYXV0bztcXFxcbiAgZm9udC1zaXplOiAwLjg1NzE0Mjg2ZW07XFxcXG4gIG1hcmdpbjogMGVtIDBlbSAwZW0gMWVtO1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW0gLmRyb3Bkb3duLmljb25bZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIHdpZHRoOiBhdXRvO1xcXFxuICBmbG9hdDogcmlnaHQ7XFxcXG4gIG1hcmdpbjogMGVtIDBlbSAwZW0gMWVtO1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW0gLmRyb3Bkb3duLmljb24gKyAudGV4dFtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgbWFyZ2luLXJpZ2h0OiAxZW07XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgIFRleHRcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZHJvcGRvd24gPiAudGV4dFtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcXFxuICAtd2Via2l0LXRyYW5zaXRpb246IG5vbmU7XFxcXG4gIHRyYW5zaXRpb246IG5vbmU7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICBNZW51IEl0ZW1cXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxcXG4gIGRpc3BsYXk6IGJsb2NrO1xcXFxuICBib3JkZXI6IG5vbmU7XFxcXG4gIGhlaWdodDogYXV0bztcXFxcbiAgdGV4dC1hbGlnbjogbGVmdDtcXFxcbiAgYm9yZGVyLXRvcDogbm9uZTtcXFxcbiAgbGluZS1oZWlnaHQ6IDFlbTtcXFxcbiAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44Nyk7XFxcXG4gIHBhZGRpbmc6IDAuNzg1NzE0MjlyZW0gMS4xNDI4NTcxNHJlbSAhaW1wb3J0YW50O1xcXFxuICBmb250LXNpemU6IDFyZW07XFxcXG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xcXFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcXFxuICBib3gtc2hhZG93OiBub25lO1xcXFxuICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbVtkYXRhLXYtM2EwYzdiZWFdOmZpcnN0LWNoaWxkIHtcXFxcbiAgYm9yZGVyLXRvcC13aWR0aDogMHB4O1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gIEZsb2F0ZWQgQ29udGVudFxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcbi51aS5kcm9wZG93biA+IC50ZXh0ID4gW2NsYXNzKj1cXFxcXFxcInJpZ2h0IGZsb2F0ZWRcXFxcXFxcIl1bZGF0YS12LTNhMGM3YmVhXSxcXFxcbi51aS5kcm9wZG93biAubWVudSAuaXRlbSA+IFtjbGFzcyo9XFxcXFxcXCJyaWdodCBmbG9hdGVkXFxcXFxcXCJdW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBmbG9hdDogcmlnaHQgIWltcG9ydGFudDtcXFxcbiAgbWFyZ2luLXJpZ2h0OiAwZW0gIWltcG9ydGFudDtcXFxcbiAgbWFyZ2luLWxlZnQ6IDFlbSAhaW1wb3J0YW50O1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duID4gLnRleHQgPiBbY2xhc3MqPVxcXFxcXFwibGVmdCBmbG9hdGVkXFxcXFxcXCJdW2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgLml0ZW0gPiBbY2xhc3MqPVxcXFxcXFwibGVmdCBmbG9hdGVkXFxcXFxcXCJdW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBmbG9hdDogbGVmdCAhaW1wb3J0YW50O1xcXFxuICBtYXJnaW4tbGVmdDogMGVtICFpbXBvcnRhbnQ7XFxcXG4gIG1hcmdpbi1yaWdodDogMWVtICFpbXBvcnRhbnQ7XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLm1lbnUgLml0ZW0gPiAuaWNvbi5mbG9hdGVkW2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgLml0ZW0gPiAuZmxhZy5mbG9hdGVkW2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgLml0ZW0gPiAuaW1hZ2UuZmxvYXRlZFtkYXRhLXYtM2EwYzdiZWFdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51IC5pdGVtID4gaW1nLmZsb2F0ZWRbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIG1hcmdpbi10b3A6IDBlbTtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICBNZW51IERpdmlkZXJcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaGVhZGVyW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBtYXJnaW46IDFyZW0gMHJlbSAwLjc1cmVtO1xcXFxuICBwYWRkaW5nOiAwZW0gMS4xNDI4NTcxNHJlbTtcXFxcbiAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44NSk7XFxcXG4gIGZvbnQtc2l6ZTogMC43ODU3MTQyOWVtO1xcXFxuICBmb250LXdlaWdodDogYm9sZDtcXFxcbiAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXFxcbn1cXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5kaXZpZGVyW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBib3JkZXItdG9wOiAxcHggc29saWQgcmdiYSgzNCwgMzYsIDM4LCAwLjEpO1xcXFxuICBoZWlnaHQ6IDBlbTtcXFxcbiAgbWFyZ2luOiAwLjVlbSAwZW07XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaW5wdXRbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIHdpZHRoOiBhdXRvO1xcXFxuICBkaXNwbGF5OiAtd2Via2l0LWJveDtcXFxcbiAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xcXFxuICBkaXNwbGF5OiAtbXMtZmxleGJveDtcXFxcbiAgZGlzcGxheTogZmxleDtcXFxcbiAgbWFyZ2luOiAxLjE0Mjg1NzE0cmVtIDAuNzg1NzE0MjlyZW07XFxcXG4gIG1pbi13aWR0aDogMTByZW07XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaGVhZGVyICsgLmlucHV0W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBtYXJnaW4tdG9wOiAwZW07XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaW5wdXQ6bm90KC50cmFuc3BhcmVudCkgaW5wdXRbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIHBhZGRpbmc6IDAuNWVtIDFlbTtcXFxcbn1cXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pbnB1dDpub3QoLnRyYW5zcGFyZW50KSAuYnV0dG9uW2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaW5wdXQ6bm90KC50cmFuc3BhcmVudCkgLmljb25bZGF0YS12LTNhMGM3YmVhXSxcXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pbnB1dDpub3QoLnRyYW5zcGFyZW50KSAubGFiZWxbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIHBhZGRpbmctdG9wOiAwLjVlbTtcXFxcbiAgcGFkZGluZy1ib3R0b206IDAuNWVtO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gIEl0ZW0gRGVzY3JpcHRpb25cXFxcbi0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLmRyb3Bkb3duID4gLnRleHQgPiAuZGVzY3JpcHRpb25bZGF0YS12LTNhMGM3YmVhXSxcXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pdGVtID4gLmRlc2NyaXB0aW9uW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBmbG9hdDogcmlnaHQ7XFxcXG4gIG1hcmdpbjogMGVtIDBlbSAwZW0gMWVtO1xcXFxuICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjQpO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gICAgICAgTWVzc2FnZVxcXFxuLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAubWVzc2FnZVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgcGFkZGluZzogMC43ODU3MTQyOXJlbSAxLjE0Mjg1NzE0cmVtO1xcXFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLm1lc3NhZ2VbZGF0YS12LTNhMGM3YmVhXTpub3QoLnVpKSB7XFxcXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNCk7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICBTdWIgTWVudVxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcbi51aS5kcm9wZG93biAubWVudSAubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgdG9wOiAwJSAhaW1wb3J0YW50O1xcXFxuICBsZWZ0OiAxMDAlICFpbXBvcnRhbnQ7XFxcXG4gIHJpZ2h0OiBhdXRvICFpbXBvcnRhbnQ7XFxcXG4gIG1hcmdpbjogMGVtIDBlbSAwZW0gLTAuNWVtICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjg1NzE0MjlyZW0gIWltcG9ydGFudDtcXFxcbiAgei1pbmRleDogMjEgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogSGlkZSBBcnJvdyAqL1xcXFxuLnVpLmRyb3Bkb3duIC5tZW51IC5tZW51W2RhdGEtdi0zYTBjN2JlYV06YWZ0ZXIge1xcXFxuICBkaXNwbGF5OiBub25lO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gICBTdWIgRWxlbWVudHNcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG5cXFxcblxcXFxuLyogSWNvbnMgLyBGbGFncyAvIExhYmVscyAvIEltYWdlICovXFxcXG4udWkuZHJvcGRvd24gPiAudGV4dCA+IC5pY29uW2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkuZHJvcGRvd24gPiAudGV4dCA+IC5sYWJlbFtkYXRhLXYtM2EwYzdiZWFdLFxcXFxuLnVpLmRyb3Bkb3duID4gLnRleHQgPiAuZmxhZ1tkYXRhLXYtM2EwYzdiZWFdLFxcXFxuLnVpLmRyb3Bkb3duID4gLnRleHQgPiBpbWdbZGF0YS12LTNhMGM3YmVhXSxcXFxcbi51aS5kcm9wZG93biA+IC50ZXh0ID4gLmltYWdlW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBtYXJnaW4tdG9wOiAwZW07XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbSA+IC5pY29uW2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbSA+IC5sYWJlbFtkYXRhLXYtM2EwYzdiZWFdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW0gPiAuZmxhZ1tkYXRhLXYtM2EwYzdiZWFdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW0gPiAuaW1hZ2VbZGF0YS12LTNhMGM3YmVhXSxcXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pdGVtID4gaW1nW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBtYXJnaW4tdG9wOiAwZW07XFxcXG59XFxcXG4udWkuZHJvcGRvd24gPiAudGV4dCA+IC5pY29uW2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkuZHJvcGRvd24gPiAudGV4dCA+IC5sYWJlbFtkYXRhLXYtM2EwYzdiZWFdLFxcXFxuLnVpLmRyb3Bkb3duID4gLnRleHQgPiAuZmxhZ1tkYXRhLXYtM2EwYzdiZWFdLFxcXFxuLnVpLmRyb3Bkb3duID4gLnRleHQgPiBpbWdbZGF0YS12LTNhMGM3YmVhXSxcXFxcbi51aS5kcm9wZG93biA+IC50ZXh0ID4gLmltYWdlW2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbSA+IC5pY29uW2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbSA+IC5sYWJlbFtkYXRhLXYtM2EwYzdiZWFdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW0gPiAuZmxhZ1tkYXRhLXYtM2EwYzdiZWFdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW0gPiAuaW1hZ2VbZGF0YS12LTNhMGM3YmVhXSxcXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pdGVtID4gaW1nW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBtYXJnaW4tbGVmdDogMGVtO1xcXFxuICBmbG9hdDogbm9uZTtcXFxcbiAgbWFyZ2luLXJpZ2h0OiAwLjc4NTcxNDI5cmVtO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gICAgIEltYWdlXFxcXG4tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLmRyb3Bkb3duID4gLnRleHQgPiBpbWdbZGF0YS12LTNhMGM3YmVhXSxcXFxcbi51aS5kcm9wZG93biA+IC50ZXh0ID4gLmltYWdlW2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbSA+IC5pbWFnZVtkYXRhLXYtM2EwYzdiZWFdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW0gPiBpbWdbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXFxcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXFxcbiAgd2lkdGg6IGF1dG87XFxcXG4gIG1heC1oZWlnaHQ6IDJlbTtcXFxcbn1cXFxcblxcXFxuXFxcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcXFxuICAgICAgICAgICAgQ291cGxpbmdcXFxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxcXG5cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgICAgTWVudVxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiBSZW1vdmUgTWVudSBJdGVtIERpdmlkZXIgKi9cXFxcbi51aS5kcm9wZG93biAudWkubWVudSA+IC5pdGVtW2RhdGEtdi0zYTBjN2JlYV06YmVmb3JlLFxcXFxuLnVpLm1lbnUgLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW1bZGF0YS12LTNhMGM3YmVhXTpiZWZvcmUge1xcXFxuICBkaXNwbGF5OiBub25lO1xcXFxufVxcXFxuXFxcXG4vKiBQcmV2ZW50IE1lbnUgSXRlbSBCb3JkZXIgKi9cXFxcbi51aS5tZW51IC51aS5kcm9wZG93biAubWVudSAuYWN0aXZlLml0ZW1bZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGJvcmRlci1sZWZ0OiBub25lO1xcXFxufVxcXFxuXFxcXG4vKiBBdXRvbWF0aWNhbGx5IGZsb2F0IGRyb3Bkb3duIG1lbnUgcmlnaHQgb24gbGFzdCBtZW51IGl0ZW0gKi9cXFxcbi51aS5tZW51IC5yaWdodC5tZW51IC5kcm9wZG93bjpsYXN0LWNoaWxkIC5tZW51W2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkubWVudSAucmlnaHQuZHJvcGRvd24uaXRlbSAubWVudVtkYXRhLXYtM2EwYzdiZWFdLFxcXFxuLnVpLmJ1dHRvbnMgPiAudWkuZHJvcGRvd246bGFzdC1jaGlsZCAubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgbGVmdDogYXV0bztcXFxcbiAgcmlnaHQ6IDBlbTtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgICAgTGFiZWxcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG5cXFxcblxcXFxuLyogRHJvcGRvd24gTWVudSAqL1xcXFxuLnVpLmxhYmVsLmRyb3Bkb3duIC5tZW51W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBtaW4td2lkdGg6IDEwMCU7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgQnV0dG9uXFxcXG4tLS0tLS0tLS0tLS0tLS0qL1xcXFxuXFxcXG5cXFxcbi8qIE5vIE1hcmdpbiBPbiBJY29uIEJ1dHRvbiAqL1xcXFxuLnVpLmRyb3Bkb3duLmljb24uYnV0dG9uID4gLmRyb3Bkb3duLmljb25bZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIG1hcmdpbjogMGVtO1xcXFxufVxcXFxuLnVpLmJ1dHRvbi5kcm9wZG93biAubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgbWluLXdpZHRoOiAxMDAlO1xcXFxufVxcXFxuXFxcXG5cXFxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxcXG4gICAgICAgICAgICAgIFR5cGVzXFxcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcXFxuXFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICBTZWxlY3Rpb25cXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG5cXFxcblxcXFxuLyogRGlzcGxheXMgbGlrZSBhIHNlbGVjdCBib3ggKi9cXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd25bZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGN1cnNvcjogcG9pbnRlcjtcXFxcbiAgd29yZC13cmFwOiBicmVhay13b3JkO1xcXFxuICBsaW5lLWhlaWdodDogMWVtO1xcXFxuICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xcXFxuICBvdXRsaW5lOiAwO1xcXFxuICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlWigwZGVnKTtcXFxcbiAgICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXFxcbiAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZVooMGRlZyk7XFxcXG4gIG1pbi13aWR0aDogMTRlbTtcXFxcbiAgbWluLWhlaWdodDogMi43MTQyZW07XFxcXG4gIGJhY2tncm91bmQ6ICNGRkZGRkY7XFxcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXFxcbiAgcGFkZGluZzogMC43ODU3MTQyOWVtIDIuMWVtIDAuNzg1NzE0MjllbSAxZW07XFxcXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODcpO1xcXFxuICBib3gtc2hhZG93OiBub25lO1xcXFxuICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDM0LCAzNiwgMzgsIDAuMTUpO1xcXFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5cmVtO1xcXFxuICAtd2Via2l0LXRyYW5zaXRpb246IGJveC1zaGFkb3cgMC4xcyBlYXNlLCB3aWR0aCAwLjFzIGVhc2U7XFxcXG4gIHRyYW5zaXRpb246IGJveC1zaGFkb3cgMC4xcyBlYXNlLCB3aWR0aCAwLjFzIGVhc2U7XFxcXG59XFxcXG4udWkuc2VsZWN0aW9uLmRyb3Bkb3duLnZpc2libGVbZGF0YS12LTNhMGM3YmVhXSxcXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24uYWN0aXZlW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICB6LWluZGV4OiAxMDtcXFxcbn1cXFxcbnNlbGVjdC51aS5kcm9wZG93bltkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgaGVpZ2h0OiAzOHB4O1xcXFxuICBwYWRkaW5nOiAwLjVlbTtcXFxcbiAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgzNCwgMzYsIDM4LCAwLjE1KTtcXFxcbiAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXFxcbn1cXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24gPiAuc2VhcmNoLmljb25bZGF0YS12LTNhMGM3YmVhXSxcXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24gPiAuZGVsZXRlLmljb25bZGF0YS12LTNhMGM3YmVhXSxcXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24gPiAuZHJvcGRvd24uaWNvbltkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgY3Vyc29yOiBwb2ludGVyO1xcXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxcXG4gIHdpZHRoOiBhdXRvO1xcXFxuICBoZWlnaHQ6IGF1dG87XFxcXG4gIGxpbmUtaGVpZ2h0OiAxLjIxNDJlbTtcXFxcbiAgdG9wOiAwLjc4NTcxNDI5ZW07XFxcXG4gIHJpZ2h0OiAxZW07XFxcXG4gIHotaW5kZXg6IDM7XFxcXG4gIG1hcmdpbjogLTAuNzg1NzE0MjllbTtcXFxcbiAgcGFkZGluZzogMC43ODU3MTQyOWVtO1xcXFxuICBvcGFjaXR5OiAwLjg7XFxcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAwLjFzIGVhc2U7XFxcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMC4xcyBlYXNlO1xcXFxufVxcXFxuXFxcXG4vKiBDb21wYWN0ICovXFxcXG4udWkuY29tcGFjdC5zZWxlY3Rpb24uZHJvcGRvd25bZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIG1pbi13aWR0aDogMHB4O1xcXFxufVxcXFxuXFxcXG4vKiAgU2VsZWN0aW9uIE1lbnUgKi9cXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24gLm1lbnVbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcXFxcbiAgb3ZlcmZsb3cteTogYXV0bztcXFxcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxcXG4gICAgICAgICAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcXFxuICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2g7XFxcXG4gIGJvcmRlci10b3Atd2lkdGg6IDBweCAhaW1wb3J0YW50O1xcXFxuICB3aWR0aDogYXV0bztcXFxcbiAgb3V0bGluZTogbm9uZTtcXFxcbiAgbWFyZ2luOiAwcHggLTFweDtcXFxcbiAgbWluLXdpZHRoOiBjYWxjKDEwMCUgKyAgMnB4ICk7XFxcXG4gIHdpZHRoOiBjYWxjKDEwMCUgKyAgMnB4ICk7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDBlbSAwZW0gMC4yODU3MTQyOXJlbSAwLjI4NTcxNDI5cmVtO1xcXFxuICBib3gtc2hhZG93OiAwcHggMnB4IDNweCAwcHggcmdiYSgzNCwgMzYsIDM4LCAwLjE1KTtcXFxcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBvcGFjaXR5IDAuMXMgZWFzZTtcXFxcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjFzIGVhc2U7XFxcXG59XFxcXG4udWkuc2VsZWN0aW9uLmRyb3Bkb3duIC5tZW51W2RhdGEtdi0zYTBjN2JlYV06YWZ0ZXIsXFxcXG4udWkuc2VsZWN0aW9uLmRyb3Bkb3duIC5tZW51W2RhdGEtdi0zYTBjN2JlYV06YmVmb3JlIHtcXFxcbiAgZGlzcGxheTogbm9uZTtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgIE1lc3NhZ2VcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuc2VsZWN0aW9uLmRyb3Bkb3duIC5tZW51ID4gLm1lc3NhZ2VbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIHBhZGRpbmc6IDAuNzg1NzE0MjlyZW0gMS4xNDI4NTcxNHJlbTtcXFxcbn1cXFxcbkBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1heC13aWR0aDogNzY3cHgpIHtcXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24gLm1lbnVbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gICAgbWF4LWhlaWdodDogOC4wMTQyODU3MXJlbTtcXFxcbn1cXFxcbn1cXFxcbkBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNzY4cHgpIHtcXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24gLm1lbnVbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gICAgbWF4LWhlaWdodDogMTAuNjg1NzE0MjlyZW07XFxcXG59XFxcXG59XFxcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDk5MnB4KSB7XFxcXG4udWkuc2VsZWN0aW9uLmRyb3Bkb3duIC5tZW51W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICAgIG1heC1oZWlnaHQ6IDE2LjAyODU3MTQzcmVtO1xcXFxufVxcXFxufVxcXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiAxOTIwcHgpIHtcXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24gLm1lbnVbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gICAgbWF4LWhlaWdodDogMjEuMzcxNDI4NTdyZW07XFxcXG59XFxcXG59XFxcXG5cXFxcbi8qIE1lbnUgSXRlbSAqL1xcXFxuLnVpLnNlbGVjdGlvbi5kcm9wZG93biAubWVudSA+IC5pdGVtW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBib3JkZXItdG9wOiAxcHggc29saWQgI0ZBRkFGQTtcXFxcbiAgcGFkZGluZzogMC43ODU3MTQyOXJlbSAxLjE0Mjg1NzE0cmVtICFpbXBvcnRhbnQ7XFxcXG4gIHdoaXRlLXNwYWNlOiBub3JtYWw7XFxcXG4gIHdvcmQtd3JhcDogbm9ybWFsO1xcXFxufVxcXFxuXFxcXG4vKiBVc2VyIEl0ZW0gKi9cXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24gLm1lbnUgPiAuaGlkZGVuLmFkZGl0aW9uLml0ZW1bZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGRpc3BsYXk6IG5vbmU7XFxcXG59XFxcXG5cXFxcbi8qIEhvdmVyICovXFxcXG4udWkuc2VsZWN0aW9uLmRyb3Bkb3duW2RhdGEtdi0zYTBjN2JlYV06aG92ZXIge1xcXFxuICBib3JkZXItY29sb3I6IHJnYmEoMzQsIDM2LCAzOCwgMC4zNSk7XFxcXG4gIGJveC1zaGFkb3c6IG5vbmU7XFxcXG59XFxcXG5cXFxcbi8qIEFjdGl2ZSAqL1xcXFxuLnVpLnNlbGVjdGlvbi5hY3RpdmUuZHJvcGRvd25bZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGJvcmRlci1jb2xvcjogIzk2QzhEQTtcXFxcbiAgYm94LXNoYWRvdzogMHB4IDJweCAzcHggMHB4IHJnYmEoMzQsIDM2LCAzOCwgMC4xNSk7XFxcXG59XFxcXG4udWkuc2VsZWN0aW9uLmFjdGl2ZS5kcm9wZG93biAubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjOTZDOERBO1xcXFxuICBib3gtc2hhZG93OiAwcHggMnB4IDNweCAwcHggcmdiYSgzNCwgMzYsIDM4LCAwLjE1KTtcXFxcbn1cXFxcblxcXFxuLyogRm9jdXMgKi9cXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd25bZGF0YS12LTNhMGM3YmVhXTpmb2N1cyB7XFxcXG4gIGJvcmRlci1jb2xvcjogIzk2QzhEQTtcXFxcbiAgYm94LXNoYWRvdzogbm9uZTtcXFxcbn1cXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd246Zm9jdXMgLm1lbnVbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGJvcmRlci1jb2xvcjogIzk2QzhEQTtcXFxcbiAgYm94LXNoYWRvdzogMHB4IDJweCAzcHggMHB4IHJnYmEoMzQsIDM2LCAzOCwgMC4xNSk7XFxcXG59XFxcXG5cXFxcbi8qIFZpc2libGUgKi9cXFxcbi51aS5zZWxlY3Rpb24udmlzaWJsZS5kcm9wZG93biA+IC50ZXh0W2RhdGEtdi0zYTBjN2JlYV06bm90KC5kZWZhdWx0KSB7XFxcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxcXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOCk7XFxcXG59XFxcXG5cXFxcbi8qIFZpc2libGUgSG92ZXIgKi9cXFxcbi51aS5zZWxlY3Rpb24uYWN0aXZlLmRyb3Bkb3duW2RhdGEtdi0zYTBjN2JlYV06aG92ZXIge1xcXFxuICBib3JkZXItY29sb3I6ICM5NkM4REE7XFxcXG4gIGJveC1zaGFkb3c6IDBweCAycHggM3B4IDBweCByZ2JhKDM0LCAzNiwgMzgsIDAuMTUpO1xcXFxufVxcXFxuLnVpLnNlbGVjdGlvbi5hY3RpdmUuZHJvcGRvd246aG92ZXIgLm1lbnVbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGJvcmRlci1jb2xvcjogIzk2QzhEQTtcXFxcbiAgYm94LXNoYWRvdzogMHB4IDJweCAzcHggMHB4IHJnYmEoMzQsIDM2LCAzOCwgMC4xNSk7XFxcXG59XFxcXG5cXFxcbi8qIERyb3Bkb3duIEljb24gKi9cXFxcbi51aS5hY3RpdmUuc2VsZWN0aW9uLmRyb3Bkb3duID4gLmRyb3Bkb3duLmljb25bZGF0YS12LTNhMGM3YmVhXSxcXFxcbi51aS52aXNpYmxlLnNlbGVjdGlvbi5kcm9wZG93biA+IC5kcm9wZG93bi5pY29uW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBvcGFjaXR5OiAxO1xcXFxuICB6LWluZGV4OiAzO1xcXFxufVxcXFxuXFxcXG4vKiBDb25uZWN0aW5nIEJvcmRlciAqL1xcXFxuLnVpLmFjdGl2ZS5zZWxlY3Rpb24uZHJvcGRvd25bZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDBlbSAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMGVtICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIEVtcHR5IENvbm5lY3RpbmcgQm9yZGVyICovXFxcXG4udWkuYWN0aXZlLmVtcHR5LnNlbGVjdGlvbi5kcm9wZG93bltkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgYm9yZGVyLXJhZGl1czogMC4yODU3MTQyOXJlbSAhaW1wb3J0YW50O1xcXFxuICBib3gtc2hhZG93OiBub25lICFpbXBvcnRhbnQ7XFxcXG59XFxcXG4udWkuYWN0aXZlLmVtcHR5LnNlbGVjdGlvbi5kcm9wZG93biAubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7XFxcXG4gIGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgU2VhcmNoYWJsZVxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiBTZWFyY2ggU2VsZWN0aW9uICovXFxcXG4udWkuc2VhcmNoLmRyb3Bkb3duW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBtaW4td2lkdGg6ICcnO1xcXFxufVxcXFxuXFxcXG4vKiBTZWFyY2ggRHJvcGRvd24gKi9cXFxcbi51aS5zZWFyY2guZHJvcGRvd24gPiBpbnB1dC5zZWFyY2hbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGJhY2tncm91bmQ6IG5vbmUgdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7XFxcXG4gIGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcXFxcbiAgY3Vyc29yOiB0ZXh0O1xcXFxuICB0b3A6IDBlbTtcXFxcbiAgbGVmdDogMXB4O1xcXFxuICB3aWR0aDogMTAwJTtcXFxcbiAgb3V0bGluZTogbm9uZTtcXFxcbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDApO1xcXFxuICBwYWRkaW5nOiBpbmhlcml0O1xcXFxufVxcXFxuXFxcXG4vKiBUZXh0IExheWVyaW5nICovXFxcXG4udWkuc2VhcmNoLmRyb3Bkb3duID4gaW5wdXQuc2VhcmNoW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxcXG4gIHotaW5kZXg6IDI7XFxcXG59XFxcXG4udWkuc2VhcmNoLmRyb3Bkb3duID4gLnRleHRbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGN1cnNvcjogdGV4dDtcXFxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcXFxuICBsZWZ0OiAxcHg7XFxcXG4gIHotaW5kZXg6IDM7XFxcXG59XFxcXG5cXFxcbi8qIFNlYXJjaCBTZWxlY3Rpb24gKi9cXFxcbi51aS5zZWFyY2guc2VsZWN0aW9uLmRyb3Bkb3duID4gaW5wdXQuc2VhcmNoW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBsaW5lLWhlaWdodDogMS4yMTQyZW07XFxcXG4gIHBhZGRpbmc6IDAuNjc4NjE0MjllbSAyLjFlbSAwLjY3ODYxNDI5ZW0gMWVtO1xcXFxufVxcXFxuXFxcXG4vKiBVc2VkIHRvIHNpemUgbXVsdGkgc2VsZWN0IGlucHV0IHRvIGNoYXJhY3RlciB3aWR0aCAqL1xcXFxuLnVpLnNlYXJjaC5zZWxlY3Rpb24uZHJvcGRvd24gPiBzcGFuLnNpemVyW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBsaW5lLWhlaWdodDogMS4yMTQyZW07XFxcXG4gIHBhZGRpbmc6IDAuNjc4NjE0MjllbSAyLjFlbSAwLjY3ODYxNDI5ZW0gMWVtO1xcXFxuICBkaXNwbGF5OiBub25lO1xcXFxuICB3aGl0ZS1zcGFjZTogcHJlO1xcXFxufVxcXFxuXFxcXG4vKiBBY3RpdmUvVmlzaWJsZSBTZWFyY2ggKi9cXFxcbi51aS5zZWFyY2guZHJvcGRvd24uYWN0aXZlID4gaW5wdXQuc2VhcmNoW2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkuc2VhcmNoLmRyb3Bkb3duLnZpc2libGUgPiBpbnB1dC5zZWFyY2hbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGN1cnNvcjogYXV0bztcXFxcbn1cXFxcbi51aS5zZWFyY2guZHJvcGRvd24uYWN0aXZlID4gLnRleHRbZGF0YS12LTNhMGM3YmVhXSxcXFxcbi51aS5zZWFyY2guZHJvcGRvd24udmlzaWJsZSA+IC50ZXh0W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXFxcbn1cXFxcblxcXFxuLyogRmlsdGVyZWQgVGV4dCAqL1xcXFxuLnVpLmFjdGl2ZS5zZWFyY2guZHJvcGRvd24gaW5wdXQuc2VhcmNoOmZvY3VzICsgLnRleHQgLmljb25bZGF0YS12LTNhMGM3YmVhXSxcXFxcbi51aS5hY3RpdmUuc2VhcmNoLmRyb3Bkb3duIGlucHV0LnNlYXJjaDpmb2N1cyArIC50ZXh0IC5mbGFnW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBvcGFjaXR5OiAwLjQ1O1xcXFxufVxcXFxuLnVpLmFjdGl2ZS5zZWFyY2guZHJvcGRvd24gaW5wdXQuc2VhcmNoOmZvY3VzICsgLnRleHRbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGNvbG9yOiByZ2JhKDExNSwgMTE1LCAxMTUsIDAuODcpICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIFNlYXJjaCBNZW51ICovXFxcXG4udWkuc2VhcmNoLmRyb3Bkb3duIC5tZW51W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBvdmVyZmxvdy14OiBoaWRkZW47XFxcXG4gIG92ZXJmbG93LXk6IGF1dG87XFxcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcXFxuICAgICAgICAgIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXFxcbiAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoO1xcXFxufVxcXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xcXFxuLnVpLnNlYXJjaC5kcm9wZG93biAubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgICBtYXgtaGVpZ2h0OiA4LjAxNDI4NTcxcmVtO1xcXFxufVxcXFxufVxcXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3NjhweCkge1xcXFxuLnVpLnNlYXJjaC5kcm9wZG93biAubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgICBtYXgtaGVpZ2h0OiAxMC42ODU3MTQyOXJlbTtcXFxcbn1cXFxcbn1cXFxcbkBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogOTkycHgpIHtcXFxcbi51aS5zZWFyY2guZHJvcGRvd24gLm1lbnVbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gICAgbWF4LWhlaWdodDogMTYuMDI4NTcxNDNyZW07XFxcXG59XFxcXG59XFxcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDE5MjBweCkge1xcXFxuLnVpLnNlYXJjaC5kcm9wZG93biAubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgICBtYXgtaGVpZ2h0OiAyMS4zNzE0Mjg1N3JlbTtcXFxcbn1cXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgIE11bHRpcGxlXFxcXG4tLS0tLS0tLS0tLS0tLS0qL1xcXFxuXFxcXG5cXFxcbi8qIE11bHRpcGxlIFNlbGVjdGlvbiAqL1xcXFxuLnVpLm11bHRpcGxlLmRyb3Bkb3duW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBwYWRkaW5nOiAwLjIyNjIwNDc2ZW0gMi4xZW0gMC4yMjYyMDQ3NmVtIDAuMzU3MTQyODZlbTtcXFxcbn1cXFxcbi51aS5tdWx0aXBsZS5kcm9wZG93biAubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgY3Vyc29yOiBhdXRvO1xcXFxufVxcXFxuXFxcXG4vKiBNdWx0aXBsZSBTZWFyY2ggU2VsZWN0aW9uICovXFxcXG4udWkubXVsdGlwbGUuc2VhcmNoLmRyb3Bkb3duW2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkubXVsdGlwbGUuc2VhcmNoLmRyb3Bkb3duID4gaW5wdXQuc2VhcmNoW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBjdXJzb3I6IHRleHQ7XFxcXG59XFxcXG5cXFxcbi8qIFNlbGVjdGlvbiBMYWJlbCAqL1xcXFxuLnVpLm11bHRpcGxlLmRyb3Bkb3duID4gLmxhYmVsW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcXFxuICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcXFxuICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcXFxuICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xcXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxcXG4gIHZlcnRpY2FsLWFsaWduOiB0b3A7XFxcXG4gIHdoaXRlLXNwYWNlOiBub3JtYWw7XFxcXG4gIGZvbnQtc2l6ZTogMWVtO1xcXFxuICBwYWRkaW5nOiAwLjM1NzE0Mjg2ZW0gMC43ODU3MTQyOWVtO1xcXFxuICBtYXJnaW46IDAuMTQyODU3MTRyZW0gMC4yODU3MTQyOXJlbSAwLjE0Mjg1NzE0cmVtIDBlbTtcXFxcbiAgYm94LXNoYWRvdzogMHB4IDBweCAwcHggMXB4IHJnYmEoMzQsIDM2LCAzOCwgMC4xNSkgaW5zZXQ7XFxcXG59XFxcXG5cXFxcbi8qIERyb3Bkb3duIEljb24gKi9cXFxcbi51aS5tdWx0aXBsZS5kcm9wZG93biAuZHJvcGRvd24uaWNvbltkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgbWFyZ2luOiAnJztcXFxcbiAgcGFkZGluZzogJyc7XFxcXG59XFxcXG5cXFxcbi8qIFRleHQgKi9cXFxcbi51aS5tdWx0aXBsZS5kcm9wZG93biA+IC50ZXh0W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBwb3NpdGlvbjogc3RhdGljO1xcXFxuICBwYWRkaW5nOiAwO1xcXFxuICBtYXgtd2lkdGg6IDEwMCU7XFxcXG4gIG1hcmdpbjogMC40NTI0MDk1MmVtIDBlbSAwLjQ1MjQwOTUyZW0gMC42NDI4NTcxNGVtO1xcXFxuICBsaW5lLWhlaWdodDogMS4yMTQyODU3MWVtO1xcXFxufVxcXFxuLnVpLm11bHRpcGxlLmRyb3Bkb3duID4gLmxhYmVsIH4gaW5wdXQuc2VhcmNoW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBtYXJnaW4tbGVmdDogMC4xNDI4NTcxNGVtICFpbXBvcnRhbnQ7XFxcXG59XFxcXG4udWkubXVsdGlwbGUuZHJvcGRvd24gPiAubGFiZWwgfiAudGV4dFtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgZGlzcGxheTogbm9uZTtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLS0tLVxcXFxuICBNdWx0aXBsZSBTZWFyY2hcXFxcbi0tLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiBQcm9tcHQgVGV4dCAqL1xcXFxuLnVpLm11bHRpcGxlLnNlYXJjaC5kcm9wZG93biA+IC50ZXh0W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcbiAgdG9wOiAwO1xcXFxuICBsZWZ0OiAwO1xcXFxuICBwYWRkaW5nOiBpbmhlcml0O1xcXFxuICBtYXJnaW46IDAuNDUyNDA5NTJlbSAwZW0gMC40NTI0MDk1MmVtIDAuNjQyODU3MTRlbTtcXFxcbiAgbGluZS1oZWlnaHQ6IDEuMjE0Mjg1NzFlbTtcXFxcbn1cXFxcbi51aS5tdWx0aXBsZS5zZWFyY2guZHJvcGRvd24gPiAubGFiZWwgfiAudGV4dFtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgZGlzcGxheTogbm9uZTtcXFxcbn1cXFxcblxcXFxuLyogU2VhcmNoICovXFxcXG4udWkubXVsdGlwbGUuc2VhcmNoLmRyb3Bkb3duID4gaW5wdXQuc2VhcmNoW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBwb3NpdGlvbjogc3RhdGljO1xcXFxuICBwYWRkaW5nOiAwO1xcXFxuICBtYXgtd2lkdGg6IDEwMCU7XFxcXG4gIG1hcmdpbjogMC40NTI0MDk1MmVtIDBlbSAwLjQ1MjQwOTUyZW0gMC42NDI4NTcxNGVtO1xcXFxuICB3aWR0aDogMi4yZW07XFxcXG4gIGxpbmUtaGVpZ2h0OiAxLjIxNDI4NTcxZW07XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgSW5saW5lXFxcXG4tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLmlubGluZS5kcm9wZG93bltkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgY3Vyc29yOiBwb2ludGVyO1xcXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxcXG4gIGNvbG9yOiBpbmhlcml0O1xcXFxufVxcXFxuLnVpLmlubGluZS5kcm9wZG93biAuZHJvcGRvd24uaWNvbltkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgbWFyZ2luOiAwZW0gMC41ZW0gMGVtIDAuMjE0Mjg1NzFlbTtcXFxcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcXFxufVxcXFxuLnVpLmlubGluZS5kcm9wZG93biA+IC50ZXh0W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBmb250LXdlaWdodDogYm9sZDtcXFxcbn1cXFxcbi51aS5pbmxpbmUuZHJvcGRvd24gLm1lbnVbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGN1cnNvcjogYXV0bztcXFxcbiAgbWFyZ2luLXRvcDogMC4yMTQyODU3MWVtO1xcXFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5cmVtO1xcXFxufVxcXFxuXFxcXG5cXFxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxcXG4gICAgICAgICAgICBTdGF0ZXNcXFxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxcXG5cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLVxcXFxuICAgICAgICBBY3RpdmVcXFxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcXFxuXFxcXG5cXFxcbi8qIE1lbnUgSXRlbSBBY3RpdmUgKi9cXFxcbi51aS5kcm9wZG93biAubWVudSAuYWN0aXZlLml0ZW1bZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcXFxuICBmb250LXdlaWdodDogYm9sZDtcXFxcbiAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC45NSk7XFxcXG4gIGJveC1zaGFkb3c6IG5vbmU7XFxcXG4gIHotaW5kZXg6IDEyO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gICAgICAgIEhvdmVyXFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiBNZW51IEl0ZW0gSG92ZXIgKi9cXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pdGVtW2RhdGEtdi0zYTBjN2JlYV06aG92ZXIge1xcXFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuMDUpO1xcXFxuICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjk1KTtcXFxcbiAgei1pbmRleDogMTM7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgICBMb2FkaW5nXFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLmxvYWRpbmcuZHJvcGRvd24gPiBpLmljb25bZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGhlaWdodDogMWVtICFpbXBvcnRhbnQ7XFxcXG4gIHBhZGRpbmc6IDEuMTQyODU3MTRlbSAxLjA3MTQyODU3ZW0gIWltcG9ydGFudDtcXFxcbn1cXFxcbi51aS5sb2FkaW5nLmRyb3Bkb3duID4gaS5pY29uW2RhdGEtdi0zYTBjN2JlYV06YmVmb3JlIHtcXFxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcXFxuICBjb250ZW50OiAnJztcXFxcbiAgdG9wOiA1MCU7XFxcXG4gIGxlZnQ6IDUwJTtcXFxcbiAgbWFyZ2luOiAtMC42NDI4NTcxNGVtIDBlbSAwZW0gLTAuNjQyODU3MTRlbTtcXFxcbiAgd2lkdGg6IDEuMjg1NzE0MjllbTtcXFxcbiAgaGVpZ2h0OiAxLjI4NTcxNDI5ZW07XFxcXG4gIGJvcmRlci1yYWRpdXM6IDUwMHJlbTtcXFxcbiAgYm9yZGVyOiAwLjJlbSBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMSk7XFxcXG59XFxcXG4udWkubG9hZGluZy5kcm9wZG93biA+IGkuaWNvbltkYXRhLXYtM2EwYzdiZWFdOmFmdGVyIHtcXFxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcXFxuICBjb250ZW50OiAnJztcXFxcbiAgdG9wOiA1MCU7XFxcXG4gIGxlZnQ6IDUwJTtcXFxcbiAgYm94LXNoYWRvdzogMHB4IDBweCAwcHggMXB4IHRyYW5zcGFyZW50O1xcXFxuICBtYXJnaW46IC0wLjY0Mjg1NzE0ZW0gMGVtIDBlbSAtMC42NDI4NTcxNGVtO1xcXFxuICB3aWR0aDogMS4yODU3MTQyOWVtO1xcXFxuICBoZWlnaHQ6IDEuMjg1NzE0MjllbTtcXFxcbiAgLXdlYmtpdC1hbmltYXRpb246IGRyb3Bkb3duLXNwaW4gMC42cyBsaW5lYXI7XFxcXG4gICAgICAgICAgYW5pbWF0aW9uOiBkcm9wZG93bi1zcGluIDAuNnMgbGluZWFyO1xcXFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IGluZmluaXRlO1xcXFxuICAgICAgICAgIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IGluZmluaXRlO1xcXFxuICBib3JkZXItcmFkaXVzOiA1MDByZW07XFxcXG4gIGJvcmRlci1jb2xvcjogIzc2NzY3NiB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtcXFxcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXFxcbiAgYm9yZGVyLXdpZHRoOiAwLjJlbTtcXFxcbn1cXFxcblxcXFxuLyogQ291cGxpbmcgKi9cXFxcbi51aS5sb2FkaW5nLmRyb3Bkb3duLmJ1dHRvbiA+IGkuaWNvbltkYXRhLXYtM2EwYzdiZWFdOmJlZm9yZSxcXFxcbi51aS5sb2FkaW5nLmRyb3Bkb3duLmJ1dHRvbiA+IGkuaWNvbltkYXRhLXYtM2EwYzdiZWFdOmFmdGVyIHtcXFxcbiAgZGlzcGxheTogbm9uZTtcXFxcbn1cXFxcbkAtd2Via2l0LWtleWZyYW1lcyBkcm9wZG93bi1zcGluIHtcXFxcbmZyb20ge1xcXFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXFxcbn1cXFxcbnRvIHtcXFxcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcXFxufVxcXFxufVxcXFxuQGtleWZyYW1lcyBkcm9wZG93bi1zcGluIHtcXFxcbmZyb20ge1xcXFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXFxcbn1cXFxcbnRvIHtcXFxcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcXFxufVxcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gICAgIERlZmF1bHQgVGV4dFxcXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZHJvcGRvd246bm90KC5idXR0b24pID4gLmRlZmF1bHQudGV4dFtkYXRhLXYtM2EwYzdiZWFdLFxcXFxuLnVpLmRlZmF1bHQuZHJvcGRvd246bm90KC5idXR0b24pID4gLnRleHRbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGNvbG9yOiByZ2JhKDE5MSwgMTkxLCAxOTEsIDAuODcpO1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duOm5vdCguYnV0dG9uKSA+IGlucHV0OmZvY3VzICsgLmRlZmF1bHQudGV4dFtkYXRhLXYtM2EwYzdiZWFdLFxcXFxuLnVpLmRlZmF1bHQuZHJvcGRvd246bm90KC5idXR0b24pID4gaW5wdXQ6Zm9jdXMgKyAudGV4dFtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgY29sb3I6IHJnYmEoMTE1LCAxMTUsIDExNSwgMC44Nyk7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgICAgTG9hZGluZ1xcXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkubG9hZGluZy5kcm9wZG93biA+IC50ZXh0W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICAtd2Via2l0LXRyYW5zaXRpb246IG5vbmU7XFxcXG4gIHRyYW5zaXRpb246IG5vbmU7XFxcXG59XFxcXG5cXFxcbi8qIFVzZWQgVG8gQ2hlY2sgUG9zaXRpb24gKi9cXFxcbi51aS5kcm9wZG93biAubG9hZGluZy5tZW51W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBkaXNwbGF5OiBibG9jaztcXFxcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcXFxuICB6LWluZGV4OiAtMTtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLVxcXFxuICAgIEtleWJvYXJkIFNlbGVjdFxcXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG5cXFxcblxcXFxuLyogU2VsZWN0ZWQgSXRlbSAqL1xcXFxuLnVpLmRyb3Bkb3duLnNlbGVjdGVkW2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgLnNlbGVjdGVkLml0ZW1bZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4wMyk7XFxcXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOTUpO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gICAgU2VhcmNoIEZpbHRlcmVkXFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiBGaWx0ZXJlZCBJdGVtICovXFxcXG4udWkuZHJvcGRvd24gPiAuZmlsdGVyZWQudGV4dFtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duIC5maWx0ZXJlZC5pdGVtW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgICAgRXJyb3JcXFxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLmRyb3Bkb3duLmVycm9yW2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkuZHJvcGRvd24uZXJyb3IgPiAudGV4dFtkYXRhLXYtM2EwYzdiZWFdLFxcXFxuLnVpLmRyb3Bkb3duLmVycm9yID4gLmRlZmF1bHQudGV4dFtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgY29sb3I6ICM5RjNBMzg7XFxcXG59XFxcXG4udWkuc2VsZWN0aW9uLmRyb3Bkb3duLmVycm9yW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBiYWNrZ3JvdW5kOiAjRkZGNkY2O1xcXFxuICBib3JkZXItY29sb3I6ICNFMEI0QjQ7XFxcXG59XFxcXG4udWkuc2VsZWN0aW9uLmRyb3Bkb3duLmVycm9yW2RhdGEtdi0zYTBjN2JlYV06aG92ZXIge1xcXFxuICBib3JkZXItY29sb3I6ICNFMEI0QjQ7XFxcXG59XFxcXG4udWkuZHJvcGRvd24uZXJyb3IgPiAubWVudVtkYXRhLXYtM2EwYzdiZWFdLFxcXFxuLnVpLmRyb3Bkb3duLmVycm9yID4gLm1lbnUgLm1lbnVbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGJvcmRlci1jb2xvcjogI0UwQjRCNDtcXFxcbn1cXFxcbi51aS5kcm9wZG93bi5lcnJvciA+IC5tZW51ID4gLml0ZW1bZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGNvbG9yOiAjOUYzQTM4O1xcXFxufVxcXFxuLnVpLm11bHRpcGxlLnNlbGVjdGlvbi5lcnJvci5kcm9wZG93biA+IC5sYWJlbFtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjRTBCNEI0O1xcXFxufVxcXFxuXFxcXG4vKiBJdGVtIEhvdmVyICovXFxcXG4udWkuZHJvcGRvd24uZXJyb3IgPiAubWVudSA+IC5pdGVtW2RhdGEtdi0zYTBjN2JlYV06aG92ZXIge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGMkYyO1xcXFxufVxcXFxuXFxcXG4vKiBJdGVtIEFjdGl2ZSAqL1xcXFxuLnVpLmRyb3Bkb3duLmVycm9yID4gLm1lbnUgLmFjdGl2ZS5pdGVtW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkRDRkNGO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gICAgICAgIERpc2FibGVkXFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiBEaXNhYmxlZCAqL1xcXFxuLnVpLmRpc2FibGVkLmRyb3Bkb3duW2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuZGlzYWJsZWQuaXRlbVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgY3Vyc29yOiBkZWZhdWx0O1xcXFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXFxcbiAgb3BhY2l0eTogMC40NTtcXFxcbn1cXFxcblxcXFxuXFxcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcXFxuICAgICAgICAgICBWYXJpYXRpb25zXFxcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcXFxuXFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICBEaXJlY3Rpb25cXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG5cXFxcblxcXFxuLyogRmx5b3V0IERpcmVjdGlvbiAqL1xcXFxuLnVpLmRyb3Bkb3duIC5tZW51W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBsZWZ0OiAwcHg7XFxcXG59XFxcXG5cXFxcbi8qIERlZmF1bHQgU2lkZSAoUmlnaHQpICovXFxcXG4udWkuZHJvcGRvd24gLnJpZ2h0Lm1lbnUgPiAubWVudVtkYXRhLXYtM2EwYzdiZWFdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51IC5yaWdodC5tZW51W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBsZWZ0OiAxMDAlICFpbXBvcnRhbnQ7XFxcXG4gIHJpZ2h0OiBhdXRvICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjg1NzE0MjlyZW0gIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogTGVmdCBGbHlvdXQgTWVudSAqL1xcXFxuLnVpLmRyb3Bkb3duID4gLmxlZnQubWVudSAubWVudVtkYXRhLXYtM2EwYzdiZWFdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51IC5sZWZ0Lm1lbnVbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGxlZnQ6IGF1dG8gIWltcG9ydGFudDtcXFxcbiAgcmlnaHQ6IDEwMCUgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLXJhZGl1czogMC4yODU3MTQyOXJlbSAhaW1wb3J0YW50O1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duIC5pdGVtIC5sZWZ0LmRyb3Bkb3duLmljb25bZGF0YS12LTNhMGM3YmVhXSxcXFxcbi51aS5kcm9wZG93biAubGVmdC5tZW51IC5pdGVtIC5kcm9wZG93bi5pY29uW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICB3aWR0aDogYXV0bztcXFxcbiAgZmxvYXQ6IGxlZnQ7XFxcXG4gIG1hcmdpbjogMGVtIDAuNzg1NzE0MjlyZW0gMGVtIDBlbTtcXFxcbn1cXFxcbi51aS5kcm9wZG93biAuaXRlbSAubGVmdC5kcm9wZG93bi5pY29uW2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkuZHJvcGRvd24gLmxlZnQubWVudSAuaXRlbSAuZHJvcGRvd24uaWNvbltkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgd2lkdGg6IGF1dG87XFxcXG4gIGZsb2F0OiBsZWZ0O1xcXFxuICBtYXJnaW46IDBlbSAwLjc4NTcxNDI5cmVtIDBlbSAwZW07XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLml0ZW0gLmxlZnQuZHJvcGRvd24uaWNvbiArIC50ZXh0W2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkuZHJvcGRvd24gLmxlZnQubWVudSAuaXRlbSAuZHJvcGRvd24uaWNvbiArIC50ZXh0W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBtYXJnaW4tbGVmdDogMWVtO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gICAgIFVwd2FyZFxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiBVcHdhcmQgTWFpbiBNZW51ICovXFxcXG4udWkudXB3YXJkLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIHRvcDogYXV0bztcXFxcbiAgYm90dG9tOiAxMDAlO1xcXFxuICBib3gtc2hhZG93OiAwcHggMHB4IDNweCAwcHggcmdiYSgwLCAwLCAwLCAwLjA4KTtcXFxcbiAgYm9yZGVyLXJhZGl1czogMC4yODU3MTQyOXJlbSAwLjI4NTcxNDI5cmVtIDBlbSAwZW07XFxcXG59XFxcXG5cXFxcbi8qIFVwd2FyZCBTdWIgTWVudSAqL1xcXFxuLnVpLmRyb3Bkb3duIC51cHdhcmQubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgdG9wOiBhdXRvICFpbXBvcnRhbnQ7XFxcXG4gIGJvdHRvbTogMCAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBBY3RpdmUgVXB3YXJkICovXFxcXG4udWkuc2ltcGxlLnVwd2FyZC5hY3RpdmUuZHJvcGRvd25bZGF0YS12LTNhMGM3YmVhXSxcXFxcbi51aS5zaW1wbGUudXB3YXJkLmRyb3Bkb3duW2RhdGEtdi0zYTBjN2JlYV06aG92ZXIge1xcXFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5cmVtIDAuMjg1NzE0MjlyZW0gMGVtIDBlbSAhaW1wb3J0YW50O1xcXFxufVxcXFxuLnVpLnVwd2FyZC5kcm9wZG93bi5idXR0b246bm90KC5wb2ludGluZyk6bm90KC5mbG9hdGluZykuYWN0aXZlW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5cmVtIDAuMjg1NzE0MjlyZW0gMGVtIDBlbTtcXFxcbn1cXFxcblxcXFxuLyogU2VsZWN0aW9uICovXFxcXG4udWkudXB3YXJkLnNlbGVjdGlvbi5kcm9wZG93biAubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgYm9yZGVyLXRvcC13aWR0aDogMXB4ICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1ib3R0b20td2lkdGg6IDBweCAhaW1wb3J0YW50O1xcXFxuICBib3gtc2hhZG93OiAwcHggLTJweCAzcHggMHB4IHJnYmEoMCwgMCwgMCwgMC4wOCk7XFxcXG59XFxcXG4udWkudXB3YXJkLnNlbGVjdGlvbi5kcm9wZG93bltkYXRhLXYtM2EwYzdiZWFdOmhvdmVyIHtcXFxcbiAgYm94LXNoYWRvdzogMHB4IDBweCAycHggMHB4IHJnYmEoMCwgMCwgMCwgMC4wNSk7XFxcXG59XFxcXG5cXFxcbi8qIEFjdGl2ZSBVcHdhcmQgKi9cXFxcbi51aS5hY3RpdmUudXB3YXJkLnNlbGVjdGlvbi5kcm9wZG93bltkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgYm9yZGVyLXJhZGl1czogMGVtIDBlbSAwLjI4NTcxNDI5cmVtIDAuMjg1NzE0MjlyZW0gIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogVmlzaWJsZSBVcHdhcmQgKi9cXFxcbi51aS51cHdhcmQuc2VsZWN0aW9uLmRyb3Bkb3duLnZpc2libGVbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGJveC1zaGFkb3c6IDBweCAwcHggM3B4IDBweCByZ2JhKDAsIDAsIDAsIDAuMDgpO1xcXFxuICBib3JkZXItcmFkaXVzOiAwZW0gMGVtIDAuMjg1NzE0MjlyZW0gMC4yODU3MTQyOXJlbSAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBWaXNpYmxlIEhvdmVyIFVwd2FyZCAqL1xcXFxuLnVpLnVwd2FyZC5hY3RpdmUuc2VsZWN0aW9uLmRyb3Bkb3duW2RhdGEtdi0zYTBjN2JlYV06aG92ZXIge1xcXFxuICBib3gtc2hhZG93OiAwcHggMHB4IDNweCAwcHggcmdiYSgwLCAwLCAwLCAwLjA1KTtcXFxcbn1cXFxcbi51aS51cHdhcmQuYWN0aXZlLnNlbGVjdGlvbi5kcm9wZG93bjpob3ZlciAubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgYm94LXNoYWRvdzogMHB4IC0ycHggM3B4IDBweCByZ2JhKDAsIDAsIDAsIDAuMDgpO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gICAgIFNpbXBsZVxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiAgU2VsZWN0aW9uIE1lbnUgKi9cXFxcbi51aS5zY3JvbGxpbmcuZHJvcGRvd24gLm1lbnVbZGF0YS12LTNhMGM3YmVhXSxcXFxcbi51aS5kcm9wZG93biAuc2Nyb2xsaW5nLm1lbnVbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcXFxcbiAgb3ZlcmZsb3cteTogYXV0bztcXFxcbn1cXFxcbi51aS5zY3JvbGxpbmcuZHJvcGRvd24gLm1lbnVbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcXFxcbiAgb3ZlcmZsb3cteTogYXV0bztcXFxcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxcXG4gICAgICAgICAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcXFxuICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2g7XFxcXG4gIG1pbi13aWR0aDogMTAwJSAhaW1wb3J0YW50O1xcXFxuICB3aWR0aDogYXV0byAhaW1wb3J0YW50O1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duIC5zY3JvbGxpbmcubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgcG9zaXRpb246IHN0YXRpYztcXFxcbiAgb3ZlcmZsb3cteTogYXV0bztcXFxcbiAgYm9yZGVyOiBub25lO1xcXFxuICBib3gtc2hhZG93OiBub25lICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDAgIWltcG9ydGFudDtcXFxcbiAgbWFyZ2luOiAwICFpbXBvcnRhbnQ7XFxcXG4gIG1pbi13aWR0aDogMTAwJSAhaW1wb3J0YW50O1xcXFxuICB3aWR0aDogYXV0byAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItdG9wOiAxcHggc29saWQgcmdiYSgzNCwgMzYsIDM4LCAwLjE1KTtcXFxcbn1cXFxcbi51aS5zY3JvbGxpbmcuZHJvcGRvd24gLm1lbnUgLml0ZW0uaXRlbS5pdGVtW2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkuZHJvcGRvd24gLnNjcm9sbGluZy5tZW51ID4gLml0ZW0uaXRlbS5pdGVtW2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBib3JkZXItdG9wOiBub25lO1xcXFxuICBwYWRkaW5nLXJpZ2h0OiBjYWxjKCAxLjE0Mjg1NzE0cmVtICArICAxN3B4ICkgIWltcG9ydGFudDtcXFxcbn1cXFxcbi51aS5zY3JvbGxpbmcuZHJvcGRvd24gLm1lbnUgLml0ZW1bZGF0YS12LTNhMGM3YmVhXTpmaXJzdC1jaGlsZCxcXFxcbi51aS5kcm9wZG93biAuc2Nyb2xsaW5nLm1lbnUgLml0ZW1bZGF0YS12LTNhMGM3YmVhXTpmaXJzdC1jaGlsZCB7XFxcXG4gIGJvcmRlci10b3A6IG5vbmU7XFxcXG59XFxcXG4udWkuZHJvcGRvd24gPiAuYW5pbWF0aW5nLm1lbnUgLnNjcm9sbGluZy5tZW51W2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkuZHJvcGRvd24gPiAudmlzaWJsZS5tZW51IC5zY3JvbGxpbmcubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgZGlzcGxheTogYmxvY2s7XFxcXG59XFxcXG5cXFxcbi8qIFNjcm9sbGJhciBpbiBJRSAqL1xcXFxuQG1lZGlhIGFsbCBhbmQgKC1tcy1oaWdoLWNvbnRyYXN0OiBub25lKSB7XFxcXG4udWkuc2Nyb2xsaW5nLmRyb3Bkb3duIC5tZW51W2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4gIC51aS5kcm9wZG93biAuc2Nyb2xsaW5nLm1lbnVbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gICAgbWluLXdpZHRoOiBjYWxjKDEwMCUgLSAgMTdweCApO1xcXFxufVxcXFxufVxcXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xcXFxuLnVpLnNjcm9sbGluZy5kcm9wZG93biAubWVudVtkYXRhLXYtM2EwYzdiZWFdLFxcXFxuICAudWkuZHJvcGRvd24gLnNjcm9sbGluZy5tZW51W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICAgIG1heC1oZWlnaHQ6IDEwLjI4NTcxNDI5cmVtO1xcXFxufVxcXFxufVxcXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3NjhweCkge1xcXFxuLnVpLnNjcm9sbGluZy5kcm9wZG93biAubWVudVtkYXRhLXYtM2EwYzdiZWFdLFxcXFxuICAudWkuZHJvcGRvd24gLnNjcm9sbGluZy5tZW51W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICAgIG1heC1oZWlnaHQ6IDE1LjQyODU3MTQzcmVtO1xcXFxufVxcXFxufVxcXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA5OTJweCkge1xcXFxuLnVpLnNjcm9sbGluZy5kcm9wZG93biAubWVudVtkYXRhLXYtM2EwYzdiZWFdLFxcXFxuICAudWkuZHJvcGRvd24gLnNjcm9sbGluZy5tZW51W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICAgIG1heC1oZWlnaHQ6IDIwLjU3MTQyODU3cmVtO1xcXFxufVxcXFxufVxcXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiAxOTIwcHgpIHtcXFxcbi51aS5zY3JvbGxpbmcuZHJvcGRvd24gLm1lbnVbZGF0YS12LTNhMGM3YmVhXSxcXFxcbiAgLnVpLmRyb3Bkb3duIC5zY3JvbGxpbmcubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgICBtYXgtaGVpZ2h0OiAyMC41NzE0Mjg1N3JlbTtcXFxcbn1cXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgICBTaW1wbGVcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG5cXFxcblxcXFxuLyogRGlzcGxheXMgd2l0aG91dCBqYXZhc2NyaXB0ICovXFxcXG4udWkuc2ltcGxlLmRyb3Bkb3duIC5tZW51W2RhdGEtdi0zYTBjN2JlYV06YmVmb3JlLFxcXFxuLnVpLnNpbXBsZS5kcm9wZG93biAubWVudVtkYXRhLXYtM2EwYzdiZWFdOmFmdGVyIHtcXFxcbiAgZGlzcGxheTogbm9uZTtcXFxcbn1cXFxcbi51aS5zaW1wbGUuZHJvcGRvd24gLm1lbnVbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcbiAgZGlzcGxheTogYmxvY2s7XFxcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxcXG4gIHRvcDogLTk5OTlweCAhaW1wb3J0YW50O1xcXFxuICBvcGFjaXR5OiAwO1xcXFxuICB3aWR0aDogMDtcXFxcbiAgaGVpZ2h0OiAwO1xcXFxuICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgMC4xcyBlYXNlO1xcXFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMXMgZWFzZTtcXFxcbn1cXFxcbi51aS5zaW1wbGUuYWN0aXZlLmRyb3Bkb3duW2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkuc2ltcGxlLmRyb3Bkb3duW2RhdGEtdi0zYTBjN2JlYV06aG92ZXIge1xcXFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwZW0gIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDBlbSAhaW1wb3J0YW50O1xcXFxufVxcXFxuLnVpLnNpbXBsZS5hY3RpdmUuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtM2EwYzdiZWFdLFxcXFxuLnVpLnNpbXBsZS5kcm9wZG93bjpob3ZlciA+IC5tZW51W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBvdmVyZmxvdzogdmlzaWJsZTtcXFxcbiAgd2lkdGg6IGF1dG87XFxcXG4gIGhlaWdodDogYXV0bztcXFxcbiAgdG9wOiAxMDAlICFpbXBvcnRhbnQ7XFxcXG4gIG9wYWNpdHk6IDE7XFxcXG59XFxcXG4udWkuc2ltcGxlLmRyb3Bkb3duID4gLm1lbnUgPiAuaXRlbTphY3RpdmUgPiAubWVudVtkYXRhLXYtM2EwYzdiZWFdLFxcXFxuLnVpLnNpbXBsZS5kcm9wZG93bjpob3ZlciA+IC5tZW51ID4gLml0ZW06aG92ZXIgPiAubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgb3ZlcmZsb3c6IHZpc2libGU7XFxcXG4gIHdpZHRoOiBhdXRvO1xcXFxuICBoZWlnaHQ6IGF1dG87XFxcXG4gIHRvcDogMCUgIWltcG9ydGFudDtcXFxcbiAgbGVmdDogMTAwJSAhaW1wb3J0YW50O1xcXFxuICBvcGFjaXR5OiAxO1xcXFxufVxcXFxuLnVpLnNpbXBsZS5kaXNhYmxlZC5kcm9wZG93bjpob3ZlciAubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgZGlzcGxheTogbm9uZTtcXFxcbiAgaGVpZ2h0OiAwcHg7XFxcXG4gIHdpZHRoOiAwcHg7XFxcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxcXG59XFxcXG5cXFxcbi8qIFZpc2libGUgKi9cXFxcbi51aS5zaW1wbGUudmlzaWJsZS5kcm9wZG93biA+IC5tZW51W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBkaXNwbGF5OiBibG9jaztcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgICAgRmx1aWRcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZmx1aWQuZHJvcGRvd25bZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGRpc3BsYXk6IGJsb2NrO1xcXFxuICB3aWR0aDogMTAwJTtcXFxcbiAgbWluLXdpZHRoOiAwZW07XFxcXG59XFxcXG4udWkuZmx1aWQuZHJvcGRvd24gPiAuZHJvcGRvd24uaWNvbltkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgZmxvYXQ6IHJpZ2h0O1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gICAgRmxvYXRpbmdcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZmxvYXRpbmcuZHJvcGRvd24gLm1lbnVbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGxlZnQ6IDA7XFxcXG4gIHJpZ2h0OiBhdXRvO1xcXFxuICBib3gtc2hhZG93OiAwcHggMnB4IDRweCAwcHggcmdiYSgzNCwgMzYsIDM4LCAwLjEyKSwgMHB4IDJweCAxMHB4IDBweCByZ2JhKDM0LCAzNiwgMzgsIDAuMTUpICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjg1NzE0MjlyZW0gIWltcG9ydGFudDtcXFxcbn1cXFxcbi51aS5mbG9hdGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICBtYXJnaW4tdG9wOiAwLjVlbSAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5cmVtICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgUG9pbnRpbmdcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgdG9wOiAxMDAlO1xcXFxuICBtYXJnaW4tdG9wOiAwLjc4NTcxNDI5cmVtO1xcXFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5cmVtO1xcXFxufVxcXFxuLnVpLnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LTNhMGM3YmVhXTphZnRlciB7XFxcXG4gIGRpc3BsYXk6IGJsb2NrO1xcXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcXFxuICBjb250ZW50OiAnJztcXFxcbiAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXFxcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxcXG4gICAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcXFxuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXFxcbiAgd2lkdGg6IDAuNWVtO1xcXFxuICBoZWlnaHQ6IDAuNWVtO1xcXFxuICBib3gtc2hhZG93OiAtMXB4IC0xcHggMHB4IDFweCByZ2JhKDM0LCAzNiwgMzgsIDAuMTUpO1xcXFxuICBiYWNrZ3JvdW5kOiAjRkZGRkZGO1xcXFxuICB6LWluZGV4OiAyO1xcXFxufVxcXFxuLnVpLnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LTNhMGM3YmVhXTphZnRlciB7XFxcXG4gIHRvcDogLTAuMjVlbTtcXFxcbiAgbGVmdDogNTAlO1xcXFxuICBtYXJnaW46IDBlbSAwZW0gMGVtIC0wLjI1ZW07XFxcXG59XFxcXG5cXFxcbi8qIFRvcCBMZWZ0IFBvaW50aW5nICovXFxcXG4udWkudG9wLmxlZnQucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgdG9wOiAxMDAlO1xcXFxuICBib3R0b206IGF1dG87XFxcXG4gIGxlZnQ6IDAlO1xcXFxuICByaWdodDogYXV0bztcXFxcbiAgbWFyZ2luOiAxZW0gMGVtIDBlbTtcXFxcbn1cXFxcbi51aS50b3AubGVmdC5wb2ludGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICB0b3A6IDEwMCU7XFxcXG4gIGJvdHRvbTogYXV0bztcXFxcbiAgbGVmdDogMCU7XFxcXG4gIHJpZ2h0OiBhdXRvO1xcXFxuICBtYXJnaW46IDFlbSAwZW0gMGVtO1xcXFxufVxcXFxuLnVpLnRvcC5sZWZ0LnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LTNhMGM3YmVhXTphZnRlciB7XFxcXG4gIHRvcDogLTAuMjVlbTtcXFxcbiAgbGVmdDogMWVtO1xcXFxuICByaWdodDogYXV0bztcXFxcbiAgbWFyZ2luOiAwZW07XFxcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcXFxuICAgICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXFxcbiAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxcXG59XFxcXG5cXFxcbi8qIFRvcCBSaWdodCAgUG9pbnRpbmcgKi9cXFxcbi51aS50b3AucmlnaHQucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgdG9wOiAxMDAlO1xcXFxuICBib3R0b206IGF1dG87XFxcXG4gIHJpZ2h0OiAwJTtcXFxcbiAgbGVmdDogYXV0bztcXFxcbiAgbWFyZ2luOiAxZW0gMGVtIDBlbTtcXFxcbn1cXFxcbi51aS50b3AucmlnaHQucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtM2EwYzdiZWFdOmFmdGVyIHtcXFxcbiAgdG9wOiAtMC4yNWVtO1xcXFxuICBsZWZ0OiBhdXRvO1xcXFxuICByaWdodDogMWVtO1xcXFxuICBtYXJnaW46IDBlbTtcXFxcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxcXG4gICAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcXFxuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXFxcbn1cXFxcblxcXFxuLyogTGVmdCBQb2ludGluZyAqL1xcXFxuLnVpLmxlZnQucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgdG9wOiAwJTtcXFxcbiAgbGVmdDogMTAwJTtcXFxcbiAgcmlnaHQ6IGF1dG87XFxcXG4gIG1hcmdpbjogMGVtIDBlbSAwZW0gMWVtO1xcXFxufVxcXFxuLnVpLmxlZnQucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtM2EwYzdiZWFdOmFmdGVyIHtcXFxcbiAgdG9wOiAxZW07XFxcXG4gIGxlZnQ6IC0wLjI1ZW07XFxcXG4gIG1hcmdpbjogMGVtIDBlbSAwZW0gMGVtO1xcXFxuICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKC00NWRlZyk7XFxcXG4gICAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoLTQ1ZGVnKTtcXFxcbiAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtNDVkZWcpO1xcXFxufVxcXFxuXFxcXG4vKiBSaWdodCBQb2ludGluZyAqL1xcXFxuLnVpLnJpZ2h0LnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIHRvcDogMCU7XFxcXG4gIGxlZnQ6IGF1dG87XFxcXG4gIHJpZ2h0OiAxMDAlO1xcXFxuICBtYXJnaW46IDBlbSAxZW0gMGVtIDBlbTtcXFxcbn1cXFxcbi51aS5yaWdodC5wb2ludGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi0zYTBjN2JlYV06YWZ0ZXIge1xcXFxuICB0b3A6IDFlbTtcXFxcbiAgbGVmdDogYXV0bztcXFxcbiAgcmlnaHQ6IC0wLjI1ZW07XFxcXG4gIG1hcmdpbjogMGVtIDBlbSAwZW0gMGVtO1xcXFxuICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDEzNWRlZyk7XFxcXG4gICAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMTM1ZGVnKTtcXFxcbiAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxMzVkZWcpO1xcXFxufVxcXFxuXFxcXG4vKiBCb3R0b20gUG9pbnRpbmcgKi9cXFxcbi51aS5ib3R0b20ucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgdG9wOiBhdXRvO1xcXFxuICBib3R0b206IDEwMCU7XFxcXG4gIGxlZnQ6IDAlO1xcXFxuICByaWdodDogYXV0bztcXFxcbiAgbWFyZ2luOiAwZW0gMGVtIDFlbTtcXFxcbn1cXFxcbi51aS5ib3R0b20ucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtM2EwYzdiZWFdOmFmdGVyIHtcXFxcbiAgdG9wOiBhdXRvO1xcXFxuICBib3R0b206IC0wLjI1ZW07XFxcXG4gIHJpZ2h0OiBhdXRvO1xcXFxuICBtYXJnaW46IDBlbTtcXFxcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgtMTM1ZGVnKTtcXFxcbiAgICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgtMTM1ZGVnKTtcXFxcbiAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtMTM1ZGVnKTtcXFxcbn1cXFxcblxcXFxuLyogUmV2ZXJzZSBTdWItTWVudSBEaXJlY3Rpb24gKi9cXFxcbi51aS5ib3R0b20ucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudSAubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgdG9wOiBhdXRvICFpbXBvcnRhbnQ7XFxcXG4gIGJvdHRvbTogMHB4ICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIEJvdHRvbSBMZWZ0ICovXFxcXG4udWkuYm90dG9tLmxlZnQucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgbGVmdDogMCU7XFxcXG4gIHJpZ2h0OiBhdXRvO1xcXFxufVxcXFxuLnVpLmJvdHRvbS5sZWZ0LnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LTNhMGM3YmVhXTphZnRlciB7XFxcXG4gIGxlZnQ6IDFlbTtcXFxcbiAgcmlnaHQ6IGF1dG87XFxcXG59XFxcXG5cXFxcbi8qIEJvdHRvbSBSaWdodCAqL1xcXFxuLnVpLmJvdHRvbS5yaWdodC5wb2ludGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICByaWdodDogMCU7XFxcXG4gIGxlZnQ6IGF1dG87XFxcXG59XFxcXG4udWkuYm90dG9tLnJpZ2h0LnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LTNhMGM3YmVhXTphZnRlciB7XFxcXG4gIGxlZnQ6IGF1dG87XFxcXG4gIHJpZ2h0OiAxZW07XFxcXG59XFxcXG5cXFxcbi8qIFVwd2FyZCBwb2ludGluZyAqL1xcXFxuLnVpLnVwd2FyZC5wb2ludGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi0zYTBjN2JlYV0sXFxcXG4udWkudXB3YXJkLnRvcC5wb2ludGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi0zYTBjN2JlYV0ge1xcXFxuICB0b3A6IGF1dG87XFxcXG4gIGJvdHRvbTogMTAwJTtcXFxcbiAgbWFyZ2luOiAwZW0gMGVtIDAuNzg1NzE0MjlyZW07XFxcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjg1NzE0MjlyZW07XFxcXG59XFxcXG4udWkudXB3YXJkLnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LTNhMGM3YmVhXTphZnRlcixcXFxcbi51aS51cHdhcmQudG9wLnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LTNhMGM3YmVhXTphZnRlciB7XFxcXG4gIHRvcDogMTAwJTtcXFxcbiAgYm90dG9tOiBhdXRvO1xcXFxuICBib3gtc2hhZG93OiAxcHggMXB4IDBweCAxcHggcmdiYSgzNCwgMzYsIDM4LCAwLjE1KTtcXFxcbiAgbWFyZ2luOiAtMC4yNWVtIDBlbSAwZW07XFxcXG59XFxcXG5cXFxcblxcXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXFxcbiAgICAgICAgIFRoZW1lIE92ZXJyaWRlc1xcXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXFxcblxcXFxuXFxcXG4vKiBEcm9wZG93biBDYXJldHMgKi9cXFxcbkBmb250LWZhY2Uge1xcXFxuICBmb250LWZhbWlseTogJ0Ryb3Bkb3duJztcXFxcbiAgc3JjOiB1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtdHRmO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LEFBRUFBQUFMQUlBQUF3QXdUMU12TWdnakI1QUFBQUM4QUFBQVlHTnRZWEFQZnVJSUFBQUJIQUFBQUV4bllYTndBQUFBRUFBQUFXZ0FBQUFJWjJ4NVpqbzgyTGdBQUFGd0FBQUJWR2hsWVdRQVE4OGJBQUFDeEFBQUFEWm9hR1ZoQXdjQjZRQUFBdndBQUFBa2FHMTBlQVM0QUJJQUFBTWdBQUFBSUd4dlkyRUJOZ0RlQUFBRFFBQUFBQkp0WVhod0FBb0FGZ0FBQTFRQUFBQWdibUZ0WlZjWnB1NEFBQU4wQUFBQlJYQnZjM1FBQXdBQUFBQUV2QUFBQUNBQUF3SUFBWkFBQlFBQUFVd0JaZ0FBQUVjQlRBRm1BQUFBOVFBWkFJUUFBQUFBQUFBQUFBQUFBQUFBQUFBQkVBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBRHcyZ0hnLytELzRBSGdBQ0FBQUFBQkFBQUFBQUFBQUFBQUFBQWdBQUFBQUFBQ0FBQUFBd0FBQUJRQUF3QUJBQUFBRkFBRUFEZ0FBQUFLQUFnQUFnQUNBQUVBSVBEYS8vMy8vd0FBQUFBQUlQRFgvLzMvL3dBQi8rTVBMUUFEQUFFQUFBQUFBQUFBQUFBQUFBRUFBZi8vQUE4QUFRQUFBQUFBQUFBQUFBSUFBRGM1QVFBQUFBQUJBQUFBQUFBQUFBQUFBZ0FBTnprQkFBQUFBQUVBQUFBQUFBQUFBQUFDQUFBM09RRUFBQUFBQVFBQUFJQUJKUUVsQUJNQUFCTTBOelkzQlRZWEZoVVVEd0VHSndZdkFTWTFBQVVHQndFQUNBVUdCb0FGQ0FjR2dBVUJFZ2NHQlFFQkFRY0VDUVlIZndZQkFRWi9Cd1lBQVFBQUFHNEJKUUVTQUJNQUFEYzBQd0UyTXpJZkFSWVZGQWNHSXlFaUp5WTFBQVdBQmdjSUJZQUdCZ1VJL3dBSEJnV0FCd2FBQlFXQUJnY0hCZ1VGQmdjQUFBQUJBQklBU1FDM0FXNEFFd0FBTnpRL0FUWVhOaGNXSFFFVUJ3WW5CaThCSmpVU0JvQUZDQWNGQmdZRkJ3Z0ZnQWJiQndaL0J3RUJCd1FKL3dnRUJ3RUJCMzhHQmdBQUFBQUJBQUFBU1FDbEFXNEFFd0FBTnhFME56WXpNaDhCRmhVVUR3RUdJeUluSmpVQUJRWUhDQVdBQmdhQUJRZ0hCZ1ZiQVFBSUJRWUdnQVVJQndXQUJnWUZCd0FBQUFFQUFBQUJBQURadWFLT1h3ODg5UUFMQWdBQUFBQUEwQUJIV0FBQUFBRFFBRWRZQUFBQUFBRWxBVzRBQUFBSUFBSUFBQUFBQUFBQUFRQUFBZUQvNEFBQUFnQUFBQUFBQVNVQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFnQUFBQUFBQUFBQUFBQUFBQUJBQUFBQVNVQUFBRWxBQUFBdHdBU0FMY0FBQUFBQUFBQUNnQVVBQjRBUWdCa0FJZ0FxZ0FBQUFFQUFBQUlBQlFBQVFBQUFBQUFBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPQUs0QUFRQUFBQUFBQVFBT0FBQUFBUUFBQUFBQUFnQU9BRWNBQVFBQUFBQUFBd0FPQUNRQUFRQUFBQUFBQkFBT0FGVUFBUUFBQUFBQUJRQVdBQTRBQVFBQUFBQUFCZ0FIQURJQUFRQUFBQUFBQ2dBMEFHTUFBd0FCQkFrQUFRQU9BQUFBQXdBQkJBa0FBZ0FPQUVjQUF3QUJCQWtBQXdBT0FDUUFBd0FCQkFrQUJBQU9BRlVBQXdBQkJBa0FCUUFXQUE0QUF3QUJCQWtBQmdBT0FEa0FBd0FCQkFrQUNnQTBBR01BYVFCakFHOEFiUUJ2QUc4QWJnQldBR1VBY2dCekFHa0Fid0J1QUNBQU1RQXVBREFBYVFCakFHOEFiUUJ2QUc4QWJtbGpiMjF2YjI0QWFRQmpBRzhBYlFCdkFHOEFiZ0JTQUdVQVp3QjFBR3dBWVFCeUFHa0FZd0J2QUcwQWJ3QnZBRzRBUmdCdkFHNEFkQUFnQUdjQVpRQnVBR1VBY2dCaEFIUUFaUUJrQUNBQVlnQjVBQ0FBU1FCakFHOEFUUUJ2QUc4QWJnQXVBQUFBQUFNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQT0pIGZvcm1hdCgndHJ1ZXR5cGUnKSwgdXJsKGRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGQwOUdSazlVVkU4QUFBVndBQW9BQUFBQUJTZ0FBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCRFJrWWdBQUFBOUFBQUFka0FBQUhaTERYRS8wOVRMeklBQUFMUUFBQUFZQUFBQUdBSUl3ZVFZMjFoY0FBQUF6QUFBQUJNQUFBQVRBOSs0Z2huWVhOd0FBQURmQUFBQUFnQUFBQUlBQUFBRUdobFlXUUFBQU9FQUFBQU5nQUFBRFlBUTg4YmFHaGxZUUFBQTd3QUFBQWtBQUFBSkFNSEFlbG9iWFI0QUFBRDRBQUFBQ0FBQUFBZ0JMZ0FFbTFoZUhBQUFBUUFBQUFBQmdBQUFBWUFDRkFBYm1GdFpRQUFCQWdBQUFGRkFBQUJSVmNacHU1d2IzTjBBQUFGVUFBQUFDQUFBQUFnQUFNQUFBRUFCQVFBQVFFQkNHbGpiMjF2YjI0QUFRSUFBUUE2K0J3QytCc0QrQmdFSGdvQUdWUC9pNHNlQ2dBWlUvK0xpd3dIaTJ2NGxQaDBCUjBBQUFDSUR4MEFBQUNORVIwQUFBQUpIUUFBQWRBU0FBa0JBUWdQRVJNV0d5QWxLbWxqYjIxdmIyNXBZMjl0YjI5dWRUQjFNWFV5TUhWR01FUTNkVVl3UkRoMVJqQkVPWFZHTUVSQkFBQUNBWWtBQmdBSUFnQUJBQVFBQndBS0FBMEFWZ0NmQU9nQkwveVVEdnlVRHZ5VUR2dVVEdnR2aS9lbUZZdVFqWkNPam8rUGo0MlFpd2ozbElzRmtJdVFpWTZIajRpTmhvdUdpNGFKaDRlSENQc1UreFFGaUlpR2lZYUxob3VIalllT0NQc1U5eFFGaUkrSmo0dVFDQTc3YjR2M0ZCV0xrSTJQam84STl4VDNGQVdQam8rTmtJdVFpNUNKam9nSTl4VDdGQVdQaDQySGk0YUxob21IaDRlSWlJYUpob3NJKzVTTEJZYUxoNDJIam9pUGlZK0xrQWdPKzkyZDkyOFZpNUNOa0krT0NQY1U5eFFGam8rUWpaQ0xrSXVQaVk2SGo0aU5ob3VHQ0l2N2xBV0xob21IaDRpSWg0ZUpob3VHaTRhTmlJOEkreFQzRkFXSGpvbVBpNUFJRHZ2ZGkrWVZpL2VVQll1UWpaQ09qbytQajQyUWk1Q0xrSW1PaHdqM0ZQc1VCWStJallhTGhvdUdpWWVIaUFqN0ZQc1VCWWlIaG9tR2k0YUxoNDJIajRpT2lZK0xrQWdPK0pRVStKUVZpd3dLQUFBQUFBTUNBQUdRQUFVQUFBRk1BV1lBQUFCSEFVd0JaZ0FBQVBVQUdRQ0VBQUFBQUFBQUFBQUFBQUFBQUFBQUFSQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFBQUE4Tm9CNFAvZy8rQUI0QUFnQUFBQUFRQUFBQUFBQUFBQUFBQUFJQUFBQUFBQUFnQUFBQU1BQUFBVUFBTUFBUUFBQUJRQUJBQTRBQUFBQ2dBSUFBSUFBZ0FCQUNEdzJ2LzkvLzhBQUFBQUFDRHcxLy85Ly84QUFmL2pEeTBBQXdBQkFBQUFBQUFBQUFBQUFBQUJBQUgvL3dBUEFBRUFBQUFCQUFBNWVtb3pYdzg4OVFBTEFnQUFBQUFBMEFCSFdBQUFBQURRQUVkWUFBQUFBQUVsQVc0QUFBQUlBQUlBQUFBQUFBQUFBUUFBQWVELzRBQUFBZ0FBQUFBQUFTVUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBZ0FBQUFBQUFBQUFBQUFBQUFCQUFBQUFTVUFBQUVsQUFBQXR3QVNBTGNBQUFBQVVBQUFDQUFBQUFBQURnQ3VBQUVBQUFBQUFBRUFEZ0FBQUFFQUFBQUFBQUlBRGdCSEFBRUFBQUFBQUFNQURnQWtBQUVBQUFBQUFBUUFEZ0JWQUFFQUFBQUFBQVVBRmdBT0FBRUFBQUFBQUFZQUJ3QXlBQUVBQUFBQUFBb0FOQUJqQUFNQUFRUUpBQUVBRGdBQUFBTUFBUVFKQUFJQURnQkhBQU1BQVFRSkFBTUFEZ0FrQUFNQUFRUUpBQVFBRGdCVkFBTUFBUVFKQUFVQUZnQU9BQU1BQVFRSkFBWUFEZ0E1QUFNQUFRUUpBQW9BTkFCakFHa0FZd0J2QUcwQWJ3QnZBRzRBVmdCbEFISUFjd0JwQUc4QWJnQWdBREVBTGdBd0FHa0FZd0J2QUcwQWJ3QnZBRzVwWTI5dGIyOXVBR2tBWXdCdkFHMEFid0J2QUc0QVVnQmxBR2NBZFFCc0FHRUFjZ0JwQUdNQWJ3QnRBRzhBYndCdUFFWUFid0J1QUhRQUlBQm5BR1VBYmdCbEFISUFZUUIwQUdVQVpBQWdBR0lBZVFBZ0FFa0FZd0J2QUUwQWJ3QnZBRzRBTGdBQUFBQURBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBKSBmb3JtYXQoJ3dvZmYnKTtcXFxcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXFxcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duID4gLmRyb3Bkb3duLmljb25bZGF0YS12LTNhMGM3YmVhXSB7XFxcXG4gIGZvbnQtZmFtaWx5OiAnRHJvcGRvd24nO1xcXFxuICBsaW5lLWhlaWdodDogMTtcXFxcbiAgaGVpZ2h0OiAxZW07XFxcXG4gIHdpZHRoOiAxLjIzZW07XFxcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcXFxuICAgICAgICAgIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXFxcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXFxcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxcXG59XFxcXG4udWkuZHJvcGRvd24gPiAuZHJvcGRvd24uaWNvbltkYXRhLXYtM2EwYzdiZWFdIHtcXFxcbiAgd2lkdGg6IGF1dG87XFxcXG59XFxcXG4udWkuZHJvcGRvd24gPiAuZHJvcGRvd24uaWNvbltkYXRhLXYtM2EwYzdiZWFdOmJlZm9yZSB7XFxcXG4gIGNvbnRlbnQ6ICdcXFxcXFxcXEYwRDcnO1xcXFxufVxcXFxuXFxcXG4vKiBTdWIgTWVudSAqL1xcXFxuLnVpLmRyb3Bkb3duIC5tZW51IC5pdGVtIC5kcm9wZG93bi5pY29uW2RhdGEtdi0zYTBjN2JlYV06YmVmb3JlIHtcXFxcbiAgY29udGVudDogJ1xcXFxcXFxcRjBEQScgO1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duIC5pdGVtIC5sZWZ0LmRyb3Bkb3duLmljb25bZGF0YS12LTNhMGM3YmVhXTpiZWZvcmUsXFxcXG4udWkuZHJvcGRvd24gLmxlZnQubWVudSAuaXRlbSAuZHJvcGRvd24uaWNvbltkYXRhLXYtM2EwYzdiZWFdOmJlZm9yZSB7XFxcXG4gIGNvbnRlbnQ6IFxcXFxcXFwiXFxcXFxcXFxGMEQ5XFxcXFxcXCIgO1xcXFxufVxcXFxuXFxcXG4vKiBWZXJ0aWNhbCBNZW51IERyb3Bkb3duICovXFxcXG4udWkudmVydGljYWwubWVudSAuZHJvcGRvd24uaXRlbSA+IC5kcm9wZG93bi5pY29uW2RhdGEtdi0zYTBjN2JlYV06YmVmb3JlIHtcXFxcbiAgY29udGVudDogXFxcXFxcXCJcXFxcXFxcXEYwREFcXFxcXFxcIiA7XFxcXG59XFxcXG4vKiBJY29ucyBmb3IgUmVmZXJlbmNlXFxcXG4uZHJvcGRvd24uZG93bi5pY29uIHtcXFxcbiAgY29udGVudDogXFxcXFxcXCJcXFxcXFxcXGYwZDdcXFxcXFxcIjtcXFxcbn1cXFxcbi5kcm9wZG93bi51cC5pY29uIHtcXFxcbiAgY29udGVudDogXFxcXFxcXCJcXFxcXFxcXGYwZDhcXFxcXFxcIjtcXFxcbn1cXFxcbi5kcm9wZG93bi5sZWZ0Lmljb24ge1xcXFxuICBjb250ZW50OiBcXFxcXFxcIlxcXFxcXFxcZjBkOVxcXFxcXFwiO1xcXFxufVxcXFxuLmRyb3Bkb3duLmljb24uaWNvbiB7XFxcXG4gIGNvbnRlbnQ6IFxcXFxcXFwiXFxcXFxcXFxmMGRhXFxcXFxcXCI7XFxcXG59XFxcXG4qL1xcXFxuXFxcXG5cXFxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxcXG4gICAgICAgIFVzZXIgT3ZlcnJpZGVzXFxcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcXFxuXFxcXG5cXFwiLCBcXFwiXFxcIl0pO1xcblxcdFxcblxcdC8vIGV4cG9ydHNcXG5cXG5cXG4vKioqLyB9LFxcbi8qIDkyICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0ZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KSgpO1xcblxcdC8vIGltcG9ydHNcXG5cXHRcXG5cXHRcXG5cXHQvLyBtb2R1bGVcXG5cXHRleHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXFxcIlxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG4vKiBNZW51IEl0ZW0gSG92ZXIgKi9cXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pdGVtOmhvdmVyIHtcXFxcbiAgYmFja2dyb3VuZDogbm9uZSB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBNZW51IEl0ZW0gSG92ZXIgZm9yIEtleSBldmVudCAqL1xcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW0uY3VycmVudCB7XFxcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4wNSkgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXCIsIFxcXCJcXFwiXSk7XFxuXFx0XFxuXFx0Ly8gZXhwb3J0c1xcblxcblxcbi8qKiovIH0sXFxuLyogOTMgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKCk7XFxuXFx0Ly8gaW1wb3J0c1xcblxcdFxcblxcdFxcblxcdC8vIG1vZHVsZVxcblxcdGV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcXFwiLyohXFxcXG4gKiAjIFNlbWFudGljIFVJIDIuMi4zIC0gRHJvcGRvd25cXFxcbiAqIGh0dHA6Ly9naXRodWIuY29tL3NlbWFudGljLW9yZy9zZW1hbnRpYy11aS9cXFxcbiAqXFxcXG4gKlxcXFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXFxcXG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXFxcXG4gKlxcXFxuICovXFxcXG5cXFxcblxcXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXFxcbiAgICAgICAgICAgIERyb3Bkb3duXFxcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcXFxuLnVpLmRyb3Bkb3duW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXFxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcXFxuICBvdXRsaW5lOiBub25lO1xcXFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcXFxuICAtd2Via2l0LXRyYW5zaXRpb246IGJveC1zaGFkb3cgMC4xcyBlYXNlLCB3aWR0aCAwLjFzIGVhc2U7XFxcXG4gIHRyYW5zaXRpb246IGJveC1zaGFkb3cgMC4xcyBlYXNlLCB3aWR0aCAwLjFzIGVhc2U7XFxcXG4gIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcXFxcbn1cXFxcblxcXFxuXFxcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcXFxuICAgICAgICAgICAgQ29udGVudFxcXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXFxcblxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gICAgICBNZW51XFxcXG4tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLmRyb3Bkb3duIC5tZW51W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBjdXJzb3I6IGF1dG87XFxcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcbiAgZGlzcGxheTogbm9uZTtcXFxcbiAgb3V0bGluZTogbm9uZTtcXFxcbiAgdG9wOiAxMDAlO1xcXFxuICBtaW4td2lkdGg6IC13ZWJraXQtbWF4LWNvbnRlbnQ7XFxcXG4gIG1pbi13aWR0aDogLW1vei1tYXgtY29udGVudDtcXFxcbiAgbWluLXdpZHRoOiBtYXgtY29udGVudDtcXFxcbiAgbWFyZ2luOiAwZW07XFxcXG4gIHBhZGRpbmc6IDBlbSAwZW07XFxcXG4gIGJhY2tncm91bmQ6ICNGRkZGRkY7XFxcXG4gIGZvbnQtc2l6ZTogMWVtO1xcXFxuICB0ZXh0LXNoYWRvdzogbm9uZTtcXFxcbiAgdGV4dC1hbGlnbjogbGVmdDtcXFxcbiAgYm94LXNoYWRvdzogMHB4IDJweCAzcHggMHB4IHJnYmEoMzQsIDM2LCAzOCwgMC4xNSk7XFxcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMzQsIDM2LCAzOCwgMC4xNSk7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjg1NzE0MjlyZW07XFxcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAwLjFzIGVhc2U7XFxcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMC4xcyBlYXNlO1xcXFxuICB6LWluZGV4OiAxMTtcXFxcbiAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybSwgb3BhY2l0eTtcXFxcbn1cXFxcbi51aS5kcm9wZG93biAubWVudSA+ICpbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgSGlkZGVuIElucHV0XFxcXG4tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLmRyb3Bkb3duID4gaW5wdXRbZGF0YS12LTQwMzBkYWEyXTpub3QoLnNlYXJjaCk6Zmlyc3QtY2hpbGQsXFxcXG4udWkuZHJvcGRvd24gPiBzZWxlY3RbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuIERyb3Bkb3duIEljb25cXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZHJvcGRvd24gPiAuZHJvcGRvd24uaWNvbltkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcXFxuICB3aWR0aDogYXV0bztcXFxcbiAgZm9udC1zaXplOiAwLjg1NzE0Mjg2ZW07XFxcXG4gIG1hcmdpbjogMGVtIDBlbSAwZW0gMWVtO1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW0gLmRyb3Bkb3duLmljb25bZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIHdpZHRoOiBhdXRvO1xcXFxuICBmbG9hdDogcmlnaHQ7XFxcXG4gIG1hcmdpbjogMGVtIDBlbSAwZW0gMWVtO1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW0gLmRyb3Bkb3duLmljb24gKyAudGV4dFtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgbWFyZ2luLXJpZ2h0OiAxZW07XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgIFRleHRcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZHJvcGRvd24gPiAudGV4dFtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcXFxuICAtd2Via2l0LXRyYW5zaXRpb246IG5vbmU7XFxcXG4gIHRyYW5zaXRpb246IG5vbmU7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICBNZW51IEl0ZW1cXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxcXG4gIGRpc3BsYXk6IGJsb2NrO1xcXFxuICBib3JkZXI6IG5vbmU7XFxcXG4gIGhlaWdodDogYXV0bztcXFxcbiAgdGV4dC1hbGlnbjogbGVmdDtcXFxcbiAgYm9yZGVyLXRvcDogbm9uZTtcXFxcbiAgbGluZS1oZWlnaHQ6IDFlbTtcXFxcbiAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44Nyk7XFxcXG4gIHBhZGRpbmc6IDAuNzg1NzE0MjlyZW0gMS4xNDI4NTcxNHJlbSAhaW1wb3J0YW50O1xcXFxuICBmb250LXNpemU6IDFyZW07XFxcXG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xcXFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcXFxuICBib3gtc2hhZG93OiBub25lO1xcXFxuICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbVtkYXRhLXYtNDAzMGRhYTJdOmZpcnN0LWNoaWxkIHtcXFxcbiAgYm9yZGVyLXRvcC13aWR0aDogMHB4O1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gIEZsb2F0ZWQgQ29udGVudFxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcbi51aS5kcm9wZG93biA+IC50ZXh0ID4gW2NsYXNzKj1cXFxcXFxcInJpZ2h0IGZsb2F0ZWRcXFxcXFxcIl1bZGF0YS12LTQwMzBkYWEyXSxcXFxcbi51aS5kcm9wZG93biAubWVudSAuaXRlbSA+IFtjbGFzcyo9XFxcXFxcXCJyaWdodCBmbG9hdGVkXFxcXFxcXCJdW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBmbG9hdDogcmlnaHQgIWltcG9ydGFudDtcXFxcbiAgbWFyZ2luLXJpZ2h0OiAwZW0gIWltcG9ydGFudDtcXFxcbiAgbWFyZ2luLWxlZnQ6IDFlbSAhaW1wb3J0YW50O1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duID4gLnRleHQgPiBbY2xhc3MqPVxcXFxcXFwibGVmdCBmbG9hdGVkXFxcXFxcXCJdW2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgLml0ZW0gPiBbY2xhc3MqPVxcXFxcXFwibGVmdCBmbG9hdGVkXFxcXFxcXCJdW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBmbG9hdDogbGVmdCAhaW1wb3J0YW50O1xcXFxuICBtYXJnaW4tbGVmdDogMGVtICFpbXBvcnRhbnQ7XFxcXG4gIG1hcmdpbi1yaWdodDogMWVtICFpbXBvcnRhbnQ7XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLm1lbnUgLml0ZW0gPiAuaWNvbi5mbG9hdGVkW2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgLml0ZW0gPiAuZmxhZy5mbG9hdGVkW2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgLml0ZW0gPiAuaW1hZ2UuZmxvYXRlZFtkYXRhLXYtNDAzMGRhYTJdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51IC5pdGVtID4gaW1nLmZsb2F0ZWRbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIG1hcmdpbi10b3A6IDBlbTtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICBNZW51IERpdmlkZXJcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaGVhZGVyW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBtYXJnaW46IDFyZW0gMHJlbSAwLjc1cmVtO1xcXFxuICBwYWRkaW5nOiAwZW0gMS4xNDI4NTcxNHJlbTtcXFxcbiAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44NSk7XFxcXG4gIGZvbnQtc2l6ZTogMC43ODU3MTQyOWVtO1xcXFxuICBmb250LXdlaWdodDogYm9sZDtcXFxcbiAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXFxcbn1cXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5kaXZpZGVyW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBib3JkZXItdG9wOiAxcHggc29saWQgcmdiYSgzNCwgMzYsIDM4LCAwLjEpO1xcXFxuICBoZWlnaHQ6IDBlbTtcXFxcbiAgbWFyZ2luOiAwLjVlbSAwZW07XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaW5wdXRbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIHdpZHRoOiBhdXRvO1xcXFxuICBkaXNwbGF5OiAtd2Via2l0LWJveDtcXFxcbiAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xcXFxuICBkaXNwbGF5OiAtbXMtZmxleGJveDtcXFxcbiAgZGlzcGxheTogZmxleDtcXFxcbiAgbWFyZ2luOiAxLjE0Mjg1NzE0cmVtIDAuNzg1NzE0MjlyZW07XFxcXG4gIG1pbi13aWR0aDogMTByZW07XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaGVhZGVyICsgLmlucHV0W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBtYXJnaW4tdG9wOiAwZW07XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaW5wdXQ6bm90KC50cmFuc3BhcmVudCkgaW5wdXRbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIHBhZGRpbmc6IDAuNWVtIDFlbTtcXFxcbn1cXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pbnB1dDpub3QoLnRyYW5zcGFyZW50KSAuYnV0dG9uW2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaW5wdXQ6bm90KC50cmFuc3BhcmVudCkgLmljb25bZGF0YS12LTQwMzBkYWEyXSxcXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pbnB1dDpub3QoLnRyYW5zcGFyZW50KSAubGFiZWxbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIHBhZGRpbmctdG9wOiAwLjVlbTtcXFxcbiAgcGFkZGluZy1ib3R0b206IDAuNWVtO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gIEl0ZW0gRGVzY3JpcHRpb25cXFxcbi0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLmRyb3Bkb3duID4gLnRleHQgPiAuZGVzY3JpcHRpb25bZGF0YS12LTQwMzBkYWEyXSxcXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pdGVtID4gLmRlc2NyaXB0aW9uW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBmbG9hdDogcmlnaHQ7XFxcXG4gIG1hcmdpbjogMGVtIDBlbSAwZW0gMWVtO1xcXFxuICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjQpO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gICAgICAgTWVzc2FnZVxcXFxuLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAubWVzc2FnZVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgcGFkZGluZzogMC43ODU3MTQyOXJlbSAxLjE0Mjg1NzE0cmVtO1xcXFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLm1lc3NhZ2VbZGF0YS12LTQwMzBkYWEyXTpub3QoLnVpKSB7XFxcXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNCk7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICBTdWIgTWVudVxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcbi51aS5kcm9wZG93biAubWVudSAubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgdG9wOiAwJSAhaW1wb3J0YW50O1xcXFxuICBsZWZ0OiAxMDAlICFpbXBvcnRhbnQ7XFxcXG4gIHJpZ2h0OiBhdXRvICFpbXBvcnRhbnQ7XFxcXG4gIG1hcmdpbjogMGVtIDBlbSAwZW0gLTAuNWVtICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjg1NzE0MjlyZW0gIWltcG9ydGFudDtcXFxcbiAgei1pbmRleDogMjEgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogSGlkZSBBcnJvdyAqL1xcXFxuLnVpLmRyb3Bkb3duIC5tZW51IC5tZW51W2RhdGEtdi00MDMwZGFhMl06YWZ0ZXIge1xcXFxuICBkaXNwbGF5OiBub25lO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gICBTdWIgRWxlbWVudHNcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG5cXFxcblxcXFxuLyogSWNvbnMgLyBGbGFncyAvIExhYmVscyAvIEltYWdlICovXFxcXG4udWkuZHJvcGRvd24gPiAudGV4dCA+IC5pY29uW2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkuZHJvcGRvd24gPiAudGV4dCA+IC5sYWJlbFtkYXRhLXYtNDAzMGRhYTJdLFxcXFxuLnVpLmRyb3Bkb3duID4gLnRleHQgPiAuZmxhZ1tkYXRhLXYtNDAzMGRhYTJdLFxcXFxuLnVpLmRyb3Bkb3duID4gLnRleHQgPiBpbWdbZGF0YS12LTQwMzBkYWEyXSxcXFxcbi51aS5kcm9wZG93biA+IC50ZXh0ID4gLmltYWdlW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBtYXJnaW4tdG9wOiAwZW07XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbSA+IC5pY29uW2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbSA+IC5sYWJlbFtkYXRhLXYtNDAzMGRhYTJdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW0gPiAuZmxhZ1tkYXRhLXYtNDAzMGRhYTJdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW0gPiAuaW1hZ2VbZGF0YS12LTQwMzBkYWEyXSxcXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pdGVtID4gaW1nW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBtYXJnaW4tdG9wOiAwZW07XFxcXG59XFxcXG4udWkuZHJvcGRvd24gPiAudGV4dCA+IC5pY29uW2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkuZHJvcGRvd24gPiAudGV4dCA+IC5sYWJlbFtkYXRhLXYtNDAzMGRhYTJdLFxcXFxuLnVpLmRyb3Bkb3duID4gLnRleHQgPiAuZmxhZ1tkYXRhLXYtNDAzMGRhYTJdLFxcXFxuLnVpLmRyb3Bkb3duID4gLnRleHQgPiBpbWdbZGF0YS12LTQwMzBkYWEyXSxcXFxcbi51aS5kcm9wZG93biA+IC50ZXh0ID4gLmltYWdlW2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbSA+IC5pY29uW2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbSA+IC5sYWJlbFtkYXRhLXYtNDAzMGRhYTJdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW0gPiAuZmxhZ1tkYXRhLXYtNDAzMGRhYTJdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW0gPiAuaW1hZ2VbZGF0YS12LTQwMzBkYWEyXSxcXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pdGVtID4gaW1nW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBtYXJnaW4tbGVmdDogMGVtO1xcXFxuICBmbG9hdDogbm9uZTtcXFxcbiAgbWFyZ2luLXJpZ2h0OiAwLjc4NTcxNDI5cmVtO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gICAgIEltYWdlXFxcXG4tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLmRyb3Bkb3duID4gLnRleHQgPiBpbWdbZGF0YS12LTQwMzBkYWEyXSxcXFxcbi51aS5kcm9wZG93biA+IC50ZXh0ID4gLmltYWdlW2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbSA+IC5pbWFnZVtkYXRhLXYtNDAzMGRhYTJdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW0gPiBpbWdbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXFxcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXFxcbiAgd2lkdGg6IGF1dG87XFxcXG4gIG1heC1oZWlnaHQ6IDJlbTtcXFxcbn1cXFxcblxcXFxuXFxcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcXFxuICAgICAgICAgICAgQ291cGxpbmdcXFxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxcXG5cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgICAgTWVudVxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiBSZW1vdmUgTWVudSBJdGVtIERpdmlkZXIgKi9cXFxcbi51aS5kcm9wZG93biAudWkubWVudSA+IC5pdGVtW2RhdGEtdi00MDMwZGFhMl06YmVmb3JlLFxcXFxuLnVpLm1lbnUgLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW1bZGF0YS12LTQwMzBkYWEyXTpiZWZvcmUge1xcXFxuICBkaXNwbGF5OiBub25lO1xcXFxufVxcXFxuXFxcXG4vKiBQcmV2ZW50IE1lbnUgSXRlbSBCb3JkZXIgKi9cXFxcbi51aS5tZW51IC51aS5kcm9wZG93biAubWVudSAuYWN0aXZlLml0ZW1bZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGJvcmRlci1sZWZ0OiBub25lO1xcXFxufVxcXFxuXFxcXG4vKiBBdXRvbWF0aWNhbGx5IGZsb2F0IGRyb3Bkb3duIG1lbnUgcmlnaHQgb24gbGFzdCBtZW51IGl0ZW0gKi9cXFxcbi51aS5tZW51IC5yaWdodC5tZW51IC5kcm9wZG93bjpsYXN0LWNoaWxkIC5tZW51W2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkubWVudSAucmlnaHQuZHJvcGRvd24uaXRlbSAubWVudVtkYXRhLXYtNDAzMGRhYTJdLFxcXFxuLnVpLmJ1dHRvbnMgPiAudWkuZHJvcGRvd246bGFzdC1jaGlsZCAubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgbGVmdDogYXV0bztcXFxcbiAgcmlnaHQ6IDBlbTtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgICAgTGFiZWxcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG5cXFxcblxcXFxuLyogRHJvcGRvd24gTWVudSAqL1xcXFxuLnVpLmxhYmVsLmRyb3Bkb3duIC5tZW51W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBtaW4td2lkdGg6IDEwMCU7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgQnV0dG9uXFxcXG4tLS0tLS0tLS0tLS0tLS0qL1xcXFxuXFxcXG5cXFxcbi8qIE5vIE1hcmdpbiBPbiBJY29uIEJ1dHRvbiAqL1xcXFxuLnVpLmRyb3Bkb3duLmljb24uYnV0dG9uID4gLmRyb3Bkb3duLmljb25bZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIG1hcmdpbjogMGVtO1xcXFxufVxcXFxuLnVpLmJ1dHRvbi5kcm9wZG93biAubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgbWluLXdpZHRoOiAxMDAlO1xcXFxufVxcXFxuXFxcXG5cXFxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxcXG4gICAgICAgICAgICAgIFR5cGVzXFxcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcXFxuXFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICBTZWxlY3Rpb25cXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG5cXFxcblxcXFxuLyogRGlzcGxheXMgbGlrZSBhIHNlbGVjdCBib3ggKi9cXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd25bZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGN1cnNvcjogcG9pbnRlcjtcXFxcbiAgd29yZC13cmFwOiBicmVhay13b3JkO1xcXFxuICBsaW5lLWhlaWdodDogMWVtO1xcXFxuICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xcXFxuICBvdXRsaW5lOiAwO1xcXFxuICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlWigwZGVnKTtcXFxcbiAgICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXFxcbiAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZVooMGRlZyk7XFxcXG4gIG1pbi13aWR0aDogMTRlbTtcXFxcbiAgbWluLWhlaWdodDogMi43MTQyZW07XFxcXG4gIGJhY2tncm91bmQ6ICNGRkZGRkY7XFxcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXFxcbiAgcGFkZGluZzogMC43ODU3MTQyOWVtIDIuMWVtIDAuNzg1NzE0MjllbSAxZW07XFxcXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODcpO1xcXFxuICBib3gtc2hhZG93OiBub25lO1xcXFxuICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDM0LCAzNiwgMzgsIDAuMTUpO1xcXFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5cmVtO1xcXFxuICAtd2Via2l0LXRyYW5zaXRpb246IGJveC1zaGFkb3cgMC4xcyBlYXNlLCB3aWR0aCAwLjFzIGVhc2U7XFxcXG4gIHRyYW5zaXRpb246IGJveC1zaGFkb3cgMC4xcyBlYXNlLCB3aWR0aCAwLjFzIGVhc2U7XFxcXG59XFxcXG4udWkuc2VsZWN0aW9uLmRyb3Bkb3duLnZpc2libGVbZGF0YS12LTQwMzBkYWEyXSxcXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24uYWN0aXZlW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICB6LWluZGV4OiAxMDtcXFxcbn1cXFxcbnNlbGVjdC51aS5kcm9wZG93bltkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgaGVpZ2h0OiAzOHB4O1xcXFxuICBwYWRkaW5nOiAwLjVlbTtcXFxcbiAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgzNCwgMzYsIDM4LCAwLjE1KTtcXFxcbiAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXFxcbn1cXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24gPiAuc2VhcmNoLmljb25bZGF0YS12LTQwMzBkYWEyXSxcXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24gPiAuZGVsZXRlLmljb25bZGF0YS12LTQwMzBkYWEyXSxcXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24gPiAuZHJvcGRvd24uaWNvbltkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgY3Vyc29yOiBwb2ludGVyO1xcXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxcXG4gIHdpZHRoOiBhdXRvO1xcXFxuICBoZWlnaHQ6IGF1dG87XFxcXG4gIGxpbmUtaGVpZ2h0OiAxLjIxNDJlbTtcXFxcbiAgdG9wOiAwLjc4NTcxNDI5ZW07XFxcXG4gIHJpZ2h0OiAxZW07XFxcXG4gIHotaW5kZXg6IDM7XFxcXG4gIG1hcmdpbjogLTAuNzg1NzE0MjllbTtcXFxcbiAgcGFkZGluZzogMC43ODU3MTQyOWVtO1xcXFxuICBvcGFjaXR5OiAwLjg7XFxcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAwLjFzIGVhc2U7XFxcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMC4xcyBlYXNlO1xcXFxufVxcXFxuXFxcXG4vKiBDb21wYWN0ICovXFxcXG4udWkuY29tcGFjdC5zZWxlY3Rpb24uZHJvcGRvd25bZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIG1pbi13aWR0aDogMHB4O1xcXFxufVxcXFxuXFxcXG4vKiAgU2VsZWN0aW9uIE1lbnUgKi9cXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24gLm1lbnVbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcXFxcbiAgb3ZlcmZsb3cteTogYXV0bztcXFxcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxcXG4gICAgICAgICAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcXFxuICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2g7XFxcXG4gIGJvcmRlci10b3Atd2lkdGg6IDBweCAhaW1wb3J0YW50O1xcXFxuICB3aWR0aDogYXV0bztcXFxcbiAgb3V0bGluZTogbm9uZTtcXFxcbiAgbWFyZ2luOiAwcHggLTFweDtcXFxcbiAgbWluLXdpZHRoOiBjYWxjKDEwMCUgKyAgMnB4ICk7XFxcXG4gIHdpZHRoOiBjYWxjKDEwMCUgKyAgMnB4ICk7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDBlbSAwZW0gMC4yODU3MTQyOXJlbSAwLjI4NTcxNDI5cmVtO1xcXFxuICBib3gtc2hhZG93OiAwcHggMnB4IDNweCAwcHggcmdiYSgzNCwgMzYsIDM4LCAwLjE1KTtcXFxcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBvcGFjaXR5IDAuMXMgZWFzZTtcXFxcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjFzIGVhc2U7XFxcXG59XFxcXG4udWkuc2VsZWN0aW9uLmRyb3Bkb3duIC5tZW51W2RhdGEtdi00MDMwZGFhMl06YWZ0ZXIsXFxcXG4udWkuc2VsZWN0aW9uLmRyb3Bkb3duIC5tZW51W2RhdGEtdi00MDMwZGFhMl06YmVmb3JlIHtcXFxcbiAgZGlzcGxheTogbm9uZTtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgIE1lc3NhZ2VcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuc2VsZWN0aW9uLmRyb3Bkb3duIC5tZW51ID4gLm1lc3NhZ2VbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIHBhZGRpbmc6IDAuNzg1NzE0MjlyZW0gMS4xNDI4NTcxNHJlbTtcXFxcbn1cXFxcbkBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1heC13aWR0aDogNzY3cHgpIHtcXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24gLm1lbnVbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gICAgbWF4LWhlaWdodDogOC4wMTQyODU3MXJlbTtcXFxcbn1cXFxcbn1cXFxcbkBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNzY4cHgpIHtcXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24gLm1lbnVbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gICAgbWF4LWhlaWdodDogMTAuNjg1NzE0MjlyZW07XFxcXG59XFxcXG59XFxcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDk5MnB4KSB7XFxcXG4udWkuc2VsZWN0aW9uLmRyb3Bkb3duIC5tZW51W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICAgIG1heC1oZWlnaHQ6IDE2LjAyODU3MTQzcmVtO1xcXFxufVxcXFxufVxcXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiAxOTIwcHgpIHtcXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24gLm1lbnVbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gICAgbWF4LWhlaWdodDogMjEuMzcxNDI4NTdyZW07XFxcXG59XFxcXG59XFxcXG5cXFxcbi8qIE1lbnUgSXRlbSAqL1xcXFxuLnVpLnNlbGVjdGlvbi5kcm9wZG93biAubWVudSA+IC5pdGVtW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBib3JkZXItdG9wOiAxcHggc29saWQgI0ZBRkFGQTtcXFxcbiAgcGFkZGluZzogMC43ODU3MTQyOXJlbSAxLjE0Mjg1NzE0cmVtICFpbXBvcnRhbnQ7XFxcXG4gIHdoaXRlLXNwYWNlOiBub3JtYWw7XFxcXG4gIHdvcmQtd3JhcDogbm9ybWFsO1xcXFxufVxcXFxuXFxcXG4vKiBVc2VyIEl0ZW0gKi9cXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24gLm1lbnUgPiAuaGlkZGVuLmFkZGl0aW9uLml0ZW1bZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGRpc3BsYXk6IG5vbmU7XFxcXG59XFxcXG5cXFxcbi8qIEhvdmVyICovXFxcXG4udWkuc2VsZWN0aW9uLmRyb3Bkb3duW2RhdGEtdi00MDMwZGFhMl06aG92ZXIge1xcXFxuICBib3JkZXItY29sb3I6IHJnYmEoMzQsIDM2LCAzOCwgMC4zNSk7XFxcXG4gIGJveC1zaGFkb3c6IG5vbmU7XFxcXG59XFxcXG5cXFxcbi8qIEFjdGl2ZSAqL1xcXFxuLnVpLnNlbGVjdGlvbi5hY3RpdmUuZHJvcGRvd25bZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGJvcmRlci1jb2xvcjogIzk2QzhEQTtcXFxcbiAgYm94LXNoYWRvdzogMHB4IDJweCAzcHggMHB4IHJnYmEoMzQsIDM2LCAzOCwgMC4xNSk7XFxcXG59XFxcXG4udWkuc2VsZWN0aW9uLmFjdGl2ZS5kcm9wZG93biAubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjOTZDOERBO1xcXFxuICBib3gtc2hhZG93OiAwcHggMnB4IDNweCAwcHggcmdiYSgzNCwgMzYsIDM4LCAwLjE1KTtcXFxcbn1cXFxcblxcXFxuLyogRm9jdXMgKi9cXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd25bZGF0YS12LTQwMzBkYWEyXTpmb2N1cyB7XFxcXG4gIGJvcmRlci1jb2xvcjogIzk2QzhEQTtcXFxcbiAgYm94LXNoYWRvdzogbm9uZTtcXFxcbn1cXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd246Zm9jdXMgLm1lbnVbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGJvcmRlci1jb2xvcjogIzk2QzhEQTtcXFxcbiAgYm94LXNoYWRvdzogMHB4IDJweCAzcHggMHB4IHJnYmEoMzQsIDM2LCAzOCwgMC4xNSk7XFxcXG59XFxcXG5cXFxcbi8qIFZpc2libGUgKi9cXFxcbi51aS5zZWxlY3Rpb24udmlzaWJsZS5kcm9wZG93biA+IC50ZXh0W2RhdGEtdi00MDMwZGFhMl06bm90KC5kZWZhdWx0KSB7XFxcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxcXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOCk7XFxcXG59XFxcXG5cXFxcbi8qIFZpc2libGUgSG92ZXIgKi9cXFxcbi51aS5zZWxlY3Rpb24uYWN0aXZlLmRyb3Bkb3duW2RhdGEtdi00MDMwZGFhMl06aG92ZXIge1xcXFxuICBib3JkZXItY29sb3I6ICM5NkM4REE7XFxcXG4gIGJveC1zaGFkb3c6IDBweCAycHggM3B4IDBweCByZ2JhKDM0LCAzNiwgMzgsIDAuMTUpO1xcXFxufVxcXFxuLnVpLnNlbGVjdGlvbi5hY3RpdmUuZHJvcGRvd246aG92ZXIgLm1lbnVbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGJvcmRlci1jb2xvcjogIzk2QzhEQTtcXFxcbiAgYm94LXNoYWRvdzogMHB4IDJweCAzcHggMHB4IHJnYmEoMzQsIDM2LCAzOCwgMC4xNSk7XFxcXG59XFxcXG5cXFxcbi8qIERyb3Bkb3duIEljb24gKi9cXFxcbi51aS5hY3RpdmUuc2VsZWN0aW9uLmRyb3Bkb3duID4gLmRyb3Bkb3duLmljb25bZGF0YS12LTQwMzBkYWEyXSxcXFxcbi51aS52aXNpYmxlLnNlbGVjdGlvbi5kcm9wZG93biA+IC5kcm9wZG93bi5pY29uW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBvcGFjaXR5OiAxO1xcXFxuICB6LWluZGV4OiAzO1xcXFxufVxcXFxuXFxcXG4vKiBDb25uZWN0aW5nIEJvcmRlciAqL1xcXFxuLnVpLmFjdGl2ZS5zZWxlY3Rpb24uZHJvcGRvd25bZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDBlbSAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMGVtICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIEVtcHR5IENvbm5lY3RpbmcgQm9yZGVyICovXFxcXG4udWkuYWN0aXZlLmVtcHR5LnNlbGVjdGlvbi5kcm9wZG93bltkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgYm9yZGVyLXJhZGl1czogMC4yODU3MTQyOXJlbSAhaW1wb3J0YW50O1xcXFxuICBib3gtc2hhZG93OiBub25lICFpbXBvcnRhbnQ7XFxcXG59XFxcXG4udWkuYWN0aXZlLmVtcHR5LnNlbGVjdGlvbi5kcm9wZG93biAubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7XFxcXG4gIGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgU2VhcmNoYWJsZVxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiBTZWFyY2ggU2VsZWN0aW9uICovXFxcXG4udWkuc2VhcmNoLmRyb3Bkb3duW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBtaW4td2lkdGg6ICcnO1xcXFxufVxcXFxuXFxcXG4vKiBTZWFyY2ggRHJvcGRvd24gKi9cXFxcbi51aS5zZWFyY2guZHJvcGRvd24gPiBpbnB1dC5zZWFyY2hbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGJhY2tncm91bmQ6IG5vbmUgdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7XFxcXG4gIGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcXFxcbiAgY3Vyc29yOiB0ZXh0O1xcXFxuICB0b3A6IDBlbTtcXFxcbiAgbGVmdDogMXB4O1xcXFxuICB3aWR0aDogMTAwJTtcXFxcbiAgb3V0bGluZTogbm9uZTtcXFxcbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDApO1xcXFxuICBwYWRkaW5nOiBpbmhlcml0O1xcXFxufVxcXFxuXFxcXG4vKiBUZXh0IExheWVyaW5nICovXFxcXG4udWkuc2VhcmNoLmRyb3Bkb3duID4gaW5wdXQuc2VhcmNoW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxcXG4gIHotaW5kZXg6IDI7XFxcXG59XFxcXG4udWkuc2VhcmNoLmRyb3Bkb3duID4gLnRleHRbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGN1cnNvcjogdGV4dDtcXFxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcXFxuICBsZWZ0OiAxcHg7XFxcXG4gIHotaW5kZXg6IDM7XFxcXG59XFxcXG5cXFxcbi8qIFNlYXJjaCBTZWxlY3Rpb24gKi9cXFxcbi51aS5zZWFyY2guc2VsZWN0aW9uLmRyb3Bkb3duID4gaW5wdXQuc2VhcmNoW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBsaW5lLWhlaWdodDogMS4yMTQyZW07XFxcXG4gIHBhZGRpbmc6IDAuNjc4NjE0MjllbSAyLjFlbSAwLjY3ODYxNDI5ZW0gMWVtO1xcXFxufVxcXFxuXFxcXG4vKiBVc2VkIHRvIHNpemUgbXVsdGkgc2VsZWN0IGlucHV0IHRvIGNoYXJhY3RlciB3aWR0aCAqL1xcXFxuLnVpLnNlYXJjaC5zZWxlY3Rpb24uZHJvcGRvd24gPiBzcGFuLnNpemVyW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBsaW5lLWhlaWdodDogMS4yMTQyZW07XFxcXG4gIHBhZGRpbmc6IDAuNjc4NjE0MjllbSAyLjFlbSAwLjY3ODYxNDI5ZW0gMWVtO1xcXFxuICBkaXNwbGF5OiBub25lO1xcXFxuICB3aGl0ZS1zcGFjZTogcHJlO1xcXFxufVxcXFxuXFxcXG4vKiBBY3RpdmUvVmlzaWJsZSBTZWFyY2ggKi9cXFxcbi51aS5zZWFyY2guZHJvcGRvd24uYWN0aXZlID4gaW5wdXQuc2VhcmNoW2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkuc2VhcmNoLmRyb3Bkb3duLnZpc2libGUgPiBpbnB1dC5zZWFyY2hbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGN1cnNvcjogYXV0bztcXFxcbn1cXFxcbi51aS5zZWFyY2guZHJvcGRvd24uYWN0aXZlID4gLnRleHRbZGF0YS12LTQwMzBkYWEyXSxcXFxcbi51aS5zZWFyY2guZHJvcGRvd24udmlzaWJsZSA+IC50ZXh0W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXFxcbn1cXFxcblxcXFxuLyogRmlsdGVyZWQgVGV4dCAqL1xcXFxuLnVpLmFjdGl2ZS5zZWFyY2guZHJvcGRvd24gaW5wdXQuc2VhcmNoOmZvY3VzICsgLnRleHQgLmljb25bZGF0YS12LTQwMzBkYWEyXSxcXFxcbi51aS5hY3RpdmUuc2VhcmNoLmRyb3Bkb3duIGlucHV0LnNlYXJjaDpmb2N1cyArIC50ZXh0IC5mbGFnW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBvcGFjaXR5OiAwLjQ1O1xcXFxufVxcXFxuLnVpLmFjdGl2ZS5zZWFyY2guZHJvcGRvd24gaW5wdXQuc2VhcmNoOmZvY3VzICsgLnRleHRbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGNvbG9yOiByZ2JhKDExNSwgMTE1LCAxMTUsIDAuODcpICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIFNlYXJjaCBNZW51ICovXFxcXG4udWkuc2VhcmNoLmRyb3Bkb3duIC5tZW51W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBvdmVyZmxvdy14OiBoaWRkZW47XFxcXG4gIG92ZXJmbG93LXk6IGF1dG87XFxcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcXFxuICAgICAgICAgIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXFxcbiAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoO1xcXFxufVxcXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xcXFxuLnVpLnNlYXJjaC5kcm9wZG93biAubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgICBtYXgtaGVpZ2h0OiA4LjAxNDI4NTcxcmVtO1xcXFxufVxcXFxufVxcXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3NjhweCkge1xcXFxuLnVpLnNlYXJjaC5kcm9wZG93biAubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgICBtYXgtaGVpZ2h0OiAxMC42ODU3MTQyOXJlbTtcXFxcbn1cXFxcbn1cXFxcbkBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogOTkycHgpIHtcXFxcbi51aS5zZWFyY2guZHJvcGRvd24gLm1lbnVbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gICAgbWF4LWhlaWdodDogMTYuMDI4NTcxNDNyZW07XFxcXG59XFxcXG59XFxcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDE5MjBweCkge1xcXFxuLnVpLnNlYXJjaC5kcm9wZG93biAubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgICBtYXgtaGVpZ2h0OiAyMS4zNzE0Mjg1N3JlbTtcXFxcbn1cXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgIE11bHRpcGxlXFxcXG4tLS0tLS0tLS0tLS0tLS0qL1xcXFxuXFxcXG5cXFxcbi8qIE11bHRpcGxlIFNlbGVjdGlvbiAqL1xcXFxuLnVpLm11bHRpcGxlLmRyb3Bkb3duW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBwYWRkaW5nOiAwLjIyNjIwNDc2ZW0gMi4xZW0gMC4yMjYyMDQ3NmVtIDAuMzU3MTQyODZlbTtcXFxcbn1cXFxcbi51aS5tdWx0aXBsZS5kcm9wZG93biAubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgY3Vyc29yOiBhdXRvO1xcXFxufVxcXFxuXFxcXG4vKiBNdWx0aXBsZSBTZWFyY2ggU2VsZWN0aW9uICovXFxcXG4udWkubXVsdGlwbGUuc2VhcmNoLmRyb3Bkb3duW2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkubXVsdGlwbGUuc2VhcmNoLmRyb3Bkb3duID4gaW5wdXQuc2VhcmNoW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBjdXJzb3I6IHRleHQ7XFxcXG59XFxcXG5cXFxcbi8qIFNlbGVjdGlvbiBMYWJlbCAqL1xcXFxuLnVpLm11bHRpcGxlLmRyb3Bkb3duID4gLmxhYmVsW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcXFxuICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcXFxuICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcXFxuICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xcXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxcXG4gIHZlcnRpY2FsLWFsaWduOiB0b3A7XFxcXG4gIHdoaXRlLXNwYWNlOiBub3JtYWw7XFxcXG4gIGZvbnQtc2l6ZTogMWVtO1xcXFxuICBwYWRkaW5nOiAwLjM1NzE0Mjg2ZW0gMC43ODU3MTQyOWVtO1xcXFxuICBtYXJnaW46IDAuMTQyODU3MTRyZW0gMC4yODU3MTQyOXJlbSAwLjE0Mjg1NzE0cmVtIDBlbTtcXFxcbiAgYm94LXNoYWRvdzogMHB4IDBweCAwcHggMXB4IHJnYmEoMzQsIDM2LCAzOCwgMC4xNSkgaW5zZXQ7XFxcXG59XFxcXG5cXFxcbi8qIERyb3Bkb3duIEljb24gKi9cXFxcbi51aS5tdWx0aXBsZS5kcm9wZG93biAuZHJvcGRvd24uaWNvbltkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgbWFyZ2luOiAnJztcXFxcbiAgcGFkZGluZzogJyc7XFxcXG59XFxcXG5cXFxcbi8qIFRleHQgKi9cXFxcbi51aS5tdWx0aXBsZS5kcm9wZG93biA+IC50ZXh0W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBwb3NpdGlvbjogc3RhdGljO1xcXFxuICBwYWRkaW5nOiAwO1xcXFxuICBtYXgtd2lkdGg6IDEwMCU7XFxcXG4gIG1hcmdpbjogMC40NTI0MDk1MmVtIDBlbSAwLjQ1MjQwOTUyZW0gMC42NDI4NTcxNGVtO1xcXFxuICBsaW5lLWhlaWdodDogMS4yMTQyODU3MWVtO1xcXFxufVxcXFxuLnVpLm11bHRpcGxlLmRyb3Bkb3duID4gLmxhYmVsIH4gaW5wdXQuc2VhcmNoW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBtYXJnaW4tbGVmdDogMC4xNDI4NTcxNGVtICFpbXBvcnRhbnQ7XFxcXG59XFxcXG4udWkubXVsdGlwbGUuZHJvcGRvd24gPiAubGFiZWwgfiAudGV4dFtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgZGlzcGxheTogbm9uZTtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLS0tLVxcXFxuICBNdWx0aXBsZSBTZWFyY2hcXFxcbi0tLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiBQcm9tcHQgVGV4dCAqL1xcXFxuLnVpLm11bHRpcGxlLnNlYXJjaC5kcm9wZG93biA+IC50ZXh0W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcbiAgdG9wOiAwO1xcXFxuICBsZWZ0OiAwO1xcXFxuICBwYWRkaW5nOiBpbmhlcml0O1xcXFxuICBtYXJnaW46IDAuNDUyNDA5NTJlbSAwZW0gMC40NTI0MDk1MmVtIDAuNjQyODU3MTRlbTtcXFxcbiAgbGluZS1oZWlnaHQ6IDEuMjE0Mjg1NzFlbTtcXFxcbn1cXFxcbi51aS5tdWx0aXBsZS5zZWFyY2guZHJvcGRvd24gPiAubGFiZWwgfiAudGV4dFtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgZGlzcGxheTogbm9uZTtcXFxcbn1cXFxcblxcXFxuLyogU2VhcmNoICovXFxcXG4udWkubXVsdGlwbGUuc2VhcmNoLmRyb3Bkb3duID4gaW5wdXQuc2VhcmNoW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBwb3NpdGlvbjogc3RhdGljO1xcXFxuICBwYWRkaW5nOiAwO1xcXFxuICBtYXgtd2lkdGg6IDEwMCU7XFxcXG4gIG1hcmdpbjogMC40NTI0MDk1MmVtIDBlbSAwLjQ1MjQwOTUyZW0gMC42NDI4NTcxNGVtO1xcXFxuICB3aWR0aDogMi4yZW07XFxcXG4gIGxpbmUtaGVpZ2h0OiAxLjIxNDI4NTcxZW07XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgSW5saW5lXFxcXG4tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLmlubGluZS5kcm9wZG93bltkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgY3Vyc29yOiBwb2ludGVyO1xcXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxcXG4gIGNvbG9yOiBpbmhlcml0O1xcXFxufVxcXFxuLnVpLmlubGluZS5kcm9wZG93biAuZHJvcGRvd24uaWNvbltkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgbWFyZ2luOiAwZW0gMC41ZW0gMGVtIDAuMjE0Mjg1NzFlbTtcXFxcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcXFxufVxcXFxuLnVpLmlubGluZS5kcm9wZG93biA+IC50ZXh0W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBmb250LXdlaWdodDogYm9sZDtcXFxcbn1cXFxcbi51aS5pbmxpbmUuZHJvcGRvd24gLm1lbnVbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGN1cnNvcjogYXV0bztcXFxcbiAgbWFyZ2luLXRvcDogMC4yMTQyODU3MWVtO1xcXFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5cmVtO1xcXFxufVxcXFxuXFxcXG5cXFxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxcXG4gICAgICAgICAgICBTdGF0ZXNcXFxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxcXG5cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLVxcXFxuICAgICAgICBBY3RpdmVcXFxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcXFxuXFxcXG5cXFxcbi8qIE1lbnUgSXRlbSBBY3RpdmUgKi9cXFxcbi51aS5kcm9wZG93biAubWVudSAuYWN0aXZlLml0ZW1bZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcXFxuICBmb250LXdlaWdodDogYm9sZDtcXFxcbiAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC45NSk7XFxcXG4gIGJveC1zaGFkb3c6IG5vbmU7XFxcXG4gIHotaW5kZXg6IDEyO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gICAgICAgIEhvdmVyXFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiBNZW51IEl0ZW0gSG92ZXIgKi9cXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pdGVtW2RhdGEtdi00MDMwZGFhMl06aG92ZXIge1xcXFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuMDUpO1xcXFxuICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjk1KTtcXFxcbiAgei1pbmRleDogMTM7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgICBMb2FkaW5nXFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLmxvYWRpbmcuZHJvcGRvd24gPiBpLmljb25bZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGhlaWdodDogMWVtICFpbXBvcnRhbnQ7XFxcXG4gIHBhZGRpbmc6IDEuMTQyODU3MTRlbSAxLjA3MTQyODU3ZW0gIWltcG9ydGFudDtcXFxcbn1cXFxcbi51aS5sb2FkaW5nLmRyb3Bkb3duID4gaS5pY29uW2RhdGEtdi00MDMwZGFhMl06YmVmb3JlIHtcXFxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcXFxuICBjb250ZW50OiAnJztcXFxcbiAgdG9wOiA1MCU7XFxcXG4gIGxlZnQ6IDUwJTtcXFxcbiAgbWFyZ2luOiAtMC42NDI4NTcxNGVtIDBlbSAwZW0gLTAuNjQyODU3MTRlbTtcXFxcbiAgd2lkdGg6IDEuMjg1NzE0MjllbTtcXFxcbiAgaGVpZ2h0OiAxLjI4NTcxNDI5ZW07XFxcXG4gIGJvcmRlci1yYWRpdXM6IDUwMHJlbTtcXFxcbiAgYm9yZGVyOiAwLjJlbSBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMSk7XFxcXG59XFxcXG4udWkubG9hZGluZy5kcm9wZG93biA+IGkuaWNvbltkYXRhLXYtNDAzMGRhYTJdOmFmdGVyIHtcXFxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcXFxuICBjb250ZW50OiAnJztcXFxcbiAgdG9wOiA1MCU7XFxcXG4gIGxlZnQ6IDUwJTtcXFxcbiAgYm94LXNoYWRvdzogMHB4IDBweCAwcHggMXB4IHRyYW5zcGFyZW50O1xcXFxuICBtYXJnaW46IC0wLjY0Mjg1NzE0ZW0gMGVtIDBlbSAtMC42NDI4NTcxNGVtO1xcXFxuICB3aWR0aDogMS4yODU3MTQyOWVtO1xcXFxuICBoZWlnaHQ6IDEuMjg1NzE0MjllbTtcXFxcbiAgLXdlYmtpdC1hbmltYXRpb246IGRyb3Bkb3duLXNwaW4gMC42cyBsaW5lYXI7XFxcXG4gICAgICAgICAgYW5pbWF0aW9uOiBkcm9wZG93bi1zcGluIDAuNnMgbGluZWFyO1xcXFxuICAtd2Via2l0LWFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IGluZmluaXRlO1xcXFxuICAgICAgICAgIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IGluZmluaXRlO1xcXFxuICBib3JkZXItcmFkaXVzOiA1MDByZW07XFxcXG4gIGJvcmRlci1jb2xvcjogIzc2NzY3NiB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtcXFxcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXFxcbiAgYm9yZGVyLXdpZHRoOiAwLjJlbTtcXFxcbn1cXFxcblxcXFxuLyogQ291cGxpbmcgKi9cXFxcbi51aS5sb2FkaW5nLmRyb3Bkb3duLmJ1dHRvbiA+IGkuaWNvbltkYXRhLXYtNDAzMGRhYTJdOmJlZm9yZSxcXFxcbi51aS5sb2FkaW5nLmRyb3Bkb3duLmJ1dHRvbiA+IGkuaWNvbltkYXRhLXYtNDAzMGRhYTJdOmFmdGVyIHtcXFxcbiAgZGlzcGxheTogbm9uZTtcXFxcbn1cXFxcbkAtd2Via2l0LWtleWZyYW1lcyBkcm9wZG93bi1zcGluIHtcXFxcbmZyb20ge1xcXFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXFxcbn1cXFxcbnRvIHtcXFxcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcXFxufVxcXFxufVxcXFxuQGtleWZyYW1lcyBkcm9wZG93bi1zcGluIHtcXFxcbmZyb20ge1xcXFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXFxcbn1cXFxcbnRvIHtcXFxcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcXFxufVxcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gICAgIERlZmF1bHQgVGV4dFxcXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZHJvcGRvd246bm90KC5idXR0b24pID4gLmRlZmF1bHQudGV4dFtkYXRhLXYtNDAzMGRhYTJdLFxcXFxuLnVpLmRlZmF1bHQuZHJvcGRvd246bm90KC5idXR0b24pID4gLnRleHRbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGNvbG9yOiByZ2JhKDE5MSwgMTkxLCAxOTEsIDAuODcpO1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duOm5vdCguYnV0dG9uKSA+IGlucHV0OmZvY3VzICsgLmRlZmF1bHQudGV4dFtkYXRhLXYtNDAzMGRhYTJdLFxcXFxuLnVpLmRlZmF1bHQuZHJvcGRvd246bm90KC5idXR0b24pID4gaW5wdXQ6Zm9jdXMgKyAudGV4dFtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgY29sb3I6IHJnYmEoMTE1LCAxMTUsIDExNSwgMC44Nyk7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgICAgTG9hZGluZ1xcXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkubG9hZGluZy5kcm9wZG93biA+IC50ZXh0W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICAtd2Via2l0LXRyYW5zaXRpb246IG5vbmU7XFxcXG4gIHRyYW5zaXRpb246IG5vbmU7XFxcXG59XFxcXG5cXFxcbi8qIFVzZWQgVG8gQ2hlY2sgUG9zaXRpb24gKi9cXFxcbi51aS5kcm9wZG93biAubG9hZGluZy5tZW51W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBkaXNwbGF5OiBibG9jaztcXFxcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcXFxuICB6LWluZGV4OiAtMTtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLVxcXFxuICAgIEtleWJvYXJkIFNlbGVjdFxcXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG5cXFxcblxcXFxuLyogU2VsZWN0ZWQgSXRlbSAqL1xcXFxuLnVpLmRyb3Bkb3duLnNlbGVjdGVkW2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgLnNlbGVjdGVkLml0ZW1bZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4wMyk7XFxcXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOTUpO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gICAgU2VhcmNoIEZpbHRlcmVkXFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiBGaWx0ZXJlZCBJdGVtICovXFxcXG4udWkuZHJvcGRvd24gPiAuZmlsdGVyZWQudGV4dFtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duIC5maWx0ZXJlZC5pdGVtW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgICAgRXJyb3JcXFxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLmRyb3Bkb3duLmVycm9yW2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkuZHJvcGRvd24uZXJyb3IgPiAudGV4dFtkYXRhLXYtNDAzMGRhYTJdLFxcXFxuLnVpLmRyb3Bkb3duLmVycm9yID4gLmRlZmF1bHQudGV4dFtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgY29sb3I6ICM5RjNBMzg7XFxcXG59XFxcXG4udWkuc2VsZWN0aW9uLmRyb3Bkb3duLmVycm9yW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBiYWNrZ3JvdW5kOiAjRkZGNkY2O1xcXFxuICBib3JkZXItY29sb3I6ICNFMEI0QjQ7XFxcXG59XFxcXG4udWkuc2VsZWN0aW9uLmRyb3Bkb3duLmVycm9yW2RhdGEtdi00MDMwZGFhMl06aG92ZXIge1xcXFxuICBib3JkZXItY29sb3I6ICNFMEI0QjQ7XFxcXG59XFxcXG4udWkuZHJvcGRvd24uZXJyb3IgPiAubWVudVtkYXRhLXYtNDAzMGRhYTJdLFxcXFxuLnVpLmRyb3Bkb3duLmVycm9yID4gLm1lbnUgLm1lbnVbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGJvcmRlci1jb2xvcjogI0UwQjRCNDtcXFxcbn1cXFxcbi51aS5kcm9wZG93bi5lcnJvciA+IC5tZW51ID4gLml0ZW1bZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGNvbG9yOiAjOUYzQTM4O1xcXFxufVxcXFxuLnVpLm11bHRpcGxlLnNlbGVjdGlvbi5lcnJvci5kcm9wZG93biA+IC5sYWJlbFtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjRTBCNEI0O1xcXFxufVxcXFxuXFxcXG4vKiBJdGVtIEhvdmVyICovXFxcXG4udWkuZHJvcGRvd24uZXJyb3IgPiAubWVudSA+IC5pdGVtW2RhdGEtdi00MDMwZGFhMl06aG92ZXIge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGMkYyO1xcXFxufVxcXFxuXFxcXG4vKiBJdGVtIEFjdGl2ZSAqL1xcXFxuLnVpLmRyb3Bkb3duLmVycm9yID4gLm1lbnUgLmFjdGl2ZS5pdGVtW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkRDRkNGO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gICAgICAgIERpc2FibGVkXFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiBEaXNhYmxlZCAqL1xcXFxuLnVpLmRpc2FibGVkLmRyb3Bkb3duW2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuZGlzYWJsZWQuaXRlbVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgY3Vyc29yOiBkZWZhdWx0O1xcXFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXFxcbiAgb3BhY2l0eTogMC40NTtcXFxcbn1cXFxcblxcXFxuXFxcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcXFxuICAgICAgICAgICBWYXJpYXRpb25zXFxcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcXFxuXFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICBEaXJlY3Rpb25cXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG5cXFxcblxcXFxuLyogRmx5b3V0IERpcmVjdGlvbiAqL1xcXFxuLnVpLmRyb3Bkb3duIC5tZW51W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBsZWZ0OiAwcHg7XFxcXG59XFxcXG5cXFxcbi8qIERlZmF1bHQgU2lkZSAoUmlnaHQpICovXFxcXG4udWkuZHJvcGRvd24gLnJpZ2h0Lm1lbnUgPiAubWVudVtkYXRhLXYtNDAzMGRhYTJdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51IC5yaWdodC5tZW51W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBsZWZ0OiAxMDAlICFpbXBvcnRhbnQ7XFxcXG4gIHJpZ2h0OiBhdXRvICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjg1NzE0MjlyZW0gIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogTGVmdCBGbHlvdXQgTWVudSAqL1xcXFxuLnVpLmRyb3Bkb3duID4gLmxlZnQubWVudSAubWVudVtkYXRhLXYtNDAzMGRhYTJdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51IC5sZWZ0Lm1lbnVbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGxlZnQ6IGF1dG8gIWltcG9ydGFudDtcXFxcbiAgcmlnaHQ6IDEwMCUgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLXJhZGl1czogMC4yODU3MTQyOXJlbSAhaW1wb3J0YW50O1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duIC5pdGVtIC5sZWZ0LmRyb3Bkb3duLmljb25bZGF0YS12LTQwMzBkYWEyXSxcXFxcbi51aS5kcm9wZG93biAubGVmdC5tZW51IC5pdGVtIC5kcm9wZG93bi5pY29uW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICB3aWR0aDogYXV0bztcXFxcbiAgZmxvYXQ6IGxlZnQ7XFxcXG4gIG1hcmdpbjogMGVtIDAuNzg1NzE0MjlyZW0gMGVtIDBlbTtcXFxcbn1cXFxcbi51aS5kcm9wZG93biAuaXRlbSAubGVmdC5kcm9wZG93bi5pY29uW2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkuZHJvcGRvd24gLmxlZnQubWVudSAuaXRlbSAuZHJvcGRvd24uaWNvbltkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgd2lkdGg6IGF1dG87XFxcXG4gIGZsb2F0OiBsZWZ0O1xcXFxuICBtYXJnaW46IDBlbSAwLjc4NTcxNDI5cmVtIDBlbSAwZW07XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLml0ZW0gLmxlZnQuZHJvcGRvd24uaWNvbiArIC50ZXh0W2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkuZHJvcGRvd24gLmxlZnQubWVudSAuaXRlbSAuZHJvcGRvd24uaWNvbiArIC50ZXh0W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBtYXJnaW4tbGVmdDogMWVtO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gICAgIFVwd2FyZFxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiBVcHdhcmQgTWFpbiBNZW51ICovXFxcXG4udWkudXB3YXJkLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIHRvcDogYXV0bztcXFxcbiAgYm90dG9tOiAxMDAlO1xcXFxuICBib3gtc2hhZG93OiAwcHggMHB4IDNweCAwcHggcmdiYSgwLCAwLCAwLCAwLjA4KTtcXFxcbiAgYm9yZGVyLXJhZGl1czogMC4yODU3MTQyOXJlbSAwLjI4NTcxNDI5cmVtIDBlbSAwZW07XFxcXG59XFxcXG5cXFxcbi8qIFVwd2FyZCBTdWIgTWVudSAqL1xcXFxuLnVpLmRyb3Bkb3duIC51cHdhcmQubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgdG9wOiBhdXRvICFpbXBvcnRhbnQ7XFxcXG4gIGJvdHRvbTogMCAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBBY3RpdmUgVXB3YXJkICovXFxcXG4udWkuc2ltcGxlLnVwd2FyZC5hY3RpdmUuZHJvcGRvd25bZGF0YS12LTQwMzBkYWEyXSxcXFxcbi51aS5zaW1wbGUudXB3YXJkLmRyb3Bkb3duW2RhdGEtdi00MDMwZGFhMl06aG92ZXIge1xcXFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5cmVtIDAuMjg1NzE0MjlyZW0gMGVtIDBlbSAhaW1wb3J0YW50O1xcXFxufVxcXFxuLnVpLnVwd2FyZC5kcm9wZG93bi5idXR0b246bm90KC5wb2ludGluZyk6bm90KC5mbG9hdGluZykuYWN0aXZlW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5cmVtIDAuMjg1NzE0MjlyZW0gMGVtIDBlbTtcXFxcbn1cXFxcblxcXFxuLyogU2VsZWN0aW9uICovXFxcXG4udWkudXB3YXJkLnNlbGVjdGlvbi5kcm9wZG93biAubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgYm9yZGVyLXRvcC13aWR0aDogMXB4ICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1ib3R0b20td2lkdGg6IDBweCAhaW1wb3J0YW50O1xcXFxuICBib3gtc2hhZG93OiAwcHggLTJweCAzcHggMHB4IHJnYmEoMCwgMCwgMCwgMC4wOCk7XFxcXG59XFxcXG4udWkudXB3YXJkLnNlbGVjdGlvbi5kcm9wZG93bltkYXRhLXYtNDAzMGRhYTJdOmhvdmVyIHtcXFxcbiAgYm94LXNoYWRvdzogMHB4IDBweCAycHggMHB4IHJnYmEoMCwgMCwgMCwgMC4wNSk7XFxcXG59XFxcXG5cXFxcbi8qIEFjdGl2ZSBVcHdhcmQgKi9cXFxcbi51aS5hY3RpdmUudXB3YXJkLnNlbGVjdGlvbi5kcm9wZG93bltkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgYm9yZGVyLXJhZGl1czogMGVtIDBlbSAwLjI4NTcxNDI5cmVtIDAuMjg1NzE0MjlyZW0gIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogVmlzaWJsZSBVcHdhcmQgKi9cXFxcbi51aS51cHdhcmQuc2VsZWN0aW9uLmRyb3Bkb3duLnZpc2libGVbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGJveC1zaGFkb3c6IDBweCAwcHggM3B4IDBweCByZ2JhKDAsIDAsIDAsIDAuMDgpO1xcXFxuICBib3JkZXItcmFkaXVzOiAwZW0gMGVtIDAuMjg1NzE0MjlyZW0gMC4yODU3MTQyOXJlbSAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBWaXNpYmxlIEhvdmVyIFVwd2FyZCAqL1xcXFxuLnVpLnVwd2FyZC5hY3RpdmUuc2VsZWN0aW9uLmRyb3Bkb3duW2RhdGEtdi00MDMwZGFhMl06aG92ZXIge1xcXFxuICBib3gtc2hhZG93OiAwcHggMHB4IDNweCAwcHggcmdiYSgwLCAwLCAwLCAwLjA1KTtcXFxcbn1cXFxcbi51aS51cHdhcmQuYWN0aXZlLnNlbGVjdGlvbi5kcm9wZG93bjpob3ZlciAubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgYm94LXNoYWRvdzogMHB4IC0ycHggM3B4IDBweCByZ2JhKDAsIDAsIDAsIDAuMDgpO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gICAgIFNpbXBsZVxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiAgU2VsZWN0aW9uIE1lbnUgKi9cXFxcbi51aS5zY3JvbGxpbmcuZHJvcGRvd24gLm1lbnVbZGF0YS12LTQwMzBkYWEyXSxcXFxcbi51aS5kcm9wZG93biAuc2Nyb2xsaW5nLm1lbnVbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcXFxcbiAgb3ZlcmZsb3cteTogYXV0bztcXFxcbn1cXFxcbi51aS5zY3JvbGxpbmcuZHJvcGRvd24gLm1lbnVbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcXFxcbiAgb3ZlcmZsb3cteTogYXV0bztcXFxcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxcXG4gICAgICAgICAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcXFxuICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2g7XFxcXG4gIG1pbi13aWR0aDogMTAwJSAhaW1wb3J0YW50O1xcXFxuICB3aWR0aDogYXV0byAhaW1wb3J0YW50O1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duIC5zY3JvbGxpbmcubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgcG9zaXRpb246IHN0YXRpYztcXFxcbiAgb3ZlcmZsb3cteTogYXV0bztcXFxcbiAgYm9yZGVyOiBub25lO1xcXFxuICBib3gtc2hhZG93OiBub25lICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDAgIWltcG9ydGFudDtcXFxcbiAgbWFyZ2luOiAwICFpbXBvcnRhbnQ7XFxcXG4gIG1pbi13aWR0aDogMTAwJSAhaW1wb3J0YW50O1xcXFxuICB3aWR0aDogYXV0byAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItdG9wOiAxcHggc29saWQgcmdiYSgzNCwgMzYsIDM4LCAwLjE1KTtcXFxcbn1cXFxcbi51aS5zY3JvbGxpbmcuZHJvcGRvd24gLm1lbnUgLml0ZW0uaXRlbS5pdGVtW2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkuZHJvcGRvd24gLnNjcm9sbGluZy5tZW51ID4gLml0ZW0uaXRlbS5pdGVtW2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBib3JkZXItdG9wOiBub25lO1xcXFxuICBwYWRkaW5nLXJpZ2h0OiBjYWxjKCAxLjE0Mjg1NzE0cmVtICArICAxN3B4ICkgIWltcG9ydGFudDtcXFxcbn1cXFxcbi51aS5zY3JvbGxpbmcuZHJvcGRvd24gLm1lbnUgLml0ZW1bZGF0YS12LTQwMzBkYWEyXTpmaXJzdC1jaGlsZCxcXFxcbi51aS5kcm9wZG93biAuc2Nyb2xsaW5nLm1lbnUgLml0ZW1bZGF0YS12LTQwMzBkYWEyXTpmaXJzdC1jaGlsZCB7XFxcXG4gIGJvcmRlci10b3A6IG5vbmU7XFxcXG59XFxcXG4udWkuZHJvcGRvd24gPiAuYW5pbWF0aW5nLm1lbnUgLnNjcm9sbGluZy5tZW51W2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkuZHJvcGRvd24gPiAudmlzaWJsZS5tZW51IC5zY3JvbGxpbmcubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgZGlzcGxheTogYmxvY2s7XFxcXG59XFxcXG5cXFxcbi8qIFNjcm9sbGJhciBpbiBJRSAqL1xcXFxuQG1lZGlhIGFsbCBhbmQgKC1tcy1oaWdoLWNvbnRyYXN0OiBub25lKSB7XFxcXG4udWkuc2Nyb2xsaW5nLmRyb3Bkb3duIC5tZW51W2RhdGEtdi00MDMwZGFhMl0sXFxcXG4gIC51aS5kcm9wZG93biAuc2Nyb2xsaW5nLm1lbnVbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gICAgbWluLXdpZHRoOiBjYWxjKDEwMCUgLSAgMTdweCApO1xcXFxufVxcXFxufVxcXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xcXFxuLnVpLnNjcm9sbGluZy5kcm9wZG93biAubWVudVtkYXRhLXYtNDAzMGRhYTJdLFxcXFxuICAudWkuZHJvcGRvd24gLnNjcm9sbGluZy5tZW51W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICAgIG1heC1oZWlnaHQ6IDEwLjI4NTcxNDI5cmVtO1xcXFxufVxcXFxufVxcXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3NjhweCkge1xcXFxuLnVpLnNjcm9sbGluZy5kcm9wZG93biAubWVudVtkYXRhLXYtNDAzMGRhYTJdLFxcXFxuICAudWkuZHJvcGRvd24gLnNjcm9sbGluZy5tZW51W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICAgIG1heC1oZWlnaHQ6IDE1LjQyODU3MTQzcmVtO1xcXFxufVxcXFxufVxcXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA5OTJweCkge1xcXFxuLnVpLnNjcm9sbGluZy5kcm9wZG93biAubWVudVtkYXRhLXYtNDAzMGRhYTJdLFxcXFxuICAudWkuZHJvcGRvd24gLnNjcm9sbGluZy5tZW51W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICAgIG1heC1oZWlnaHQ6IDIwLjU3MTQyODU3cmVtO1xcXFxufVxcXFxufVxcXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiAxOTIwcHgpIHtcXFxcbi51aS5zY3JvbGxpbmcuZHJvcGRvd24gLm1lbnVbZGF0YS12LTQwMzBkYWEyXSxcXFxcbiAgLnVpLmRyb3Bkb3duIC5zY3JvbGxpbmcubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgICBtYXgtaGVpZ2h0OiAyMC41NzE0Mjg1N3JlbTtcXFxcbn1cXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgICBTaW1wbGVcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG5cXFxcblxcXFxuLyogRGlzcGxheXMgd2l0aG91dCBqYXZhc2NyaXB0ICovXFxcXG4udWkuc2ltcGxlLmRyb3Bkb3duIC5tZW51W2RhdGEtdi00MDMwZGFhMl06YmVmb3JlLFxcXFxuLnVpLnNpbXBsZS5kcm9wZG93biAubWVudVtkYXRhLXYtNDAzMGRhYTJdOmFmdGVyIHtcXFxcbiAgZGlzcGxheTogbm9uZTtcXFxcbn1cXFxcbi51aS5zaW1wbGUuZHJvcGRvd24gLm1lbnVbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcbiAgZGlzcGxheTogYmxvY2s7XFxcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxcXG4gIHRvcDogLTk5OTlweCAhaW1wb3J0YW50O1xcXFxuICBvcGFjaXR5OiAwO1xcXFxuICB3aWR0aDogMDtcXFxcbiAgaGVpZ2h0OiAwO1xcXFxuICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgMC4xcyBlYXNlO1xcXFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMXMgZWFzZTtcXFxcbn1cXFxcbi51aS5zaW1wbGUuYWN0aXZlLmRyb3Bkb3duW2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkuc2ltcGxlLmRyb3Bkb3duW2RhdGEtdi00MDMwZGFhMl06aG92ZXIge1xcXFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwZW0gIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDBlbSAhaW1wb3J0YW50O1xcXFxufVxcXFxuLnVpLnNpbXBsZS5hY3RpdmUuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtNDAzMGRhYTJdLFxcXFxuLnVpLnNpbXBsZS5kcm9wZG93bjpob3ZlciA+IC5tZW51W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBvdmVyZmxvdzogdmlzaWJsZTtcXFxcbiAgd2lkdGg6IGF1dG87XFxcXG4gIGhlaWdodDogYXV0bztcXFxcbiAgdG9wOiAxMDAlICFpbXBvcnRhbnQ7XFxcXG4gIG9wYWNpdHk6IDE7XFxcXG59XFxcXG4udWkuc2ltcGxlLmRyb3Bkb3duID4gLm1lbnUgPiAuaXRlbTphY3RpdmUgPiAubWVudVtkYXRhLXYtNDAzMGRhYTJdLFxcXFxuLnVpLnNpbXBsZS5kcm9wZG93bjpob3ZlciA+IC5tZW51ID4gLml0ZW06aG92ZXIgPiAubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgb3ZlcmZsb3c6IHZpc2libGU7XFxcXG4gIHdpZHRoOiBhdXRvO1xcXFxuICBoZWlnaHQ6IGF1dG87XFxcXG4gIHRvcDogMCUgIWltcG9ydGFudDtcXFxcbiAgbGVmdDogMTAwJSAhaW1wb3J0YW50O1xcXFxuICBvcGFjaXR5OiAxO1xcXFxufVxcXFxuLnVpLnNpbXBsZS5kaXNhYmxlZC5kcm9wZG93bjpob3ZlciAubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgZGlzcGxheTogbm9uZTtcXFxcbiAgaGVpZ2h0OiAwcHg7XFxcXG4gIHdpZHRoOiAwcHg7XFxcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxcXG59XFxcXG5cXFxcbi8qIFZpc2libGUgKi9cXFxcbi51aS5zaW1wbGUudmlzaWJsZS5kcm9wZG93biA+IC5tZW51W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBkaXNwbGF5OiBibG9jaztcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgICAgRmx1aWRcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZmx1aWQuZHJvcGRvd25bZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGRpc3BsYXk6IGJsb2NrO1xcXFxuICB3aWR0aDogMTAwJTtcXFxcbiAgbWluLXdpZHRoOiAwZW07XFxcXG59XFxcXG4udWkuZmx1aWQuZHJvcGRvd24gPiAuZHJvcGRvd24uaWNvbltkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgZmxvYXQ6IHJpZ2h0O1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gICAgRmxvYXRpbmdcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZmxvYXRpbmcuZHJvcGRvd24gLm1lbnVbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGxlZnQ6IDA7XFxcXG4gIHJpZ2h0OiBhdXRvO1xcXFxuICBib3gtc2hhZG93OiAwcHggMnB4IDRweCAwcHggcmdiYSgzNCwgMzYsIDM4LCAwLjEyKSwgMHB4IDJweCAxMHB4IDBweCByZ2JhKDM0LCAzNiwgMzgsIDAuMTUpICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjg1NzE0MjlyZW0gIWltcG9ydGFudDtcXFxcbn1cXFxcbi51aS5mbG9hdGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICBtYXJnaW4tdG9wOiAwLjVlbSAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5cmVtICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgUG9pbnRpbmdcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgdG9wOiAxMDAlO1xcXFxuICBtYXJnaW4tdG9wOiAwLjc4NTcxNDI5cmVtO1xcXFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5cmVtO1xcXFxufVxcXFxuLnVpLnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LTQwMzBkYWEyXTphZnRlciB7XFxcXG4gIGRpc3BsYXk6IGJsb2NrO1xcXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcXFxuICBjb250ZW50OiAnJztcXFxcbiAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXFxcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxcXG4gICAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcXFxuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXFxcbiAgd2lkdGg6IDAuNWVtO1xcXFxuICBoZWlnaHQ6IDAuNWVtO1xcXFxuICBib3gtc2hhZG93OiAtMXB4IC0xcHggMHB4IDFweCByZ2JhKDM0LCAzNiwgMzgsIDAuMTUpO1xcXFxuICBiYWNrZ3JvdW5kOiAjRkZGRkZGO1xcXFxuICB6LWluZGV4OiAyO1xcXFxufVxcXFxuLnVpLnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LTQwMzBkYWEyXTphZnRlciB7XFxcXG4gIHRvcDogLTAuMjVlbTtcXFxcbiAgbGVmdDogNTAlO1xcXFxuICBtYXJnaW46IDBlbSAwZW0gMGVtIC0wLjI1ZW07XFxcXG59XFxcXG5cXFxcbi8qIFRvcCBMZWZ0IFBvaW50aW5nICovXFxcXG4udWkudG9wLmxlZnQucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgdG9wOiAxMDAlO1xcXFxuICBib3R0b206IGF1dG87XFxcXG4gIGxlZnQ6IDAlO1xcXFxuICByaWdodDogYXV0bztcXFxcbiAgbWFyZ2luOiAxZW0gMGVtIDBlbTtcXFxcbn1cXFxcbi51aS50b3AubGVmdC5wb2ludGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICB0b3A6IDEwMCU7XFxcXG4gIGJvdHRvbTogYXV0bztcXFxcbiAgbGVmdDogMCU7XFxcXG4gIHJpZ2h0OiBhdXRvO1xcXFxuICBtYXJnaW46IDFlbSAwZW0gMGVtO1xcXFxufVxcXFxuLnVpLnRvcC5sZWZ0LnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LTQwMzBkYWEyXTphZnRlciB7XFxcXG4gIHRvcDogLTAuMjVlbTtcXFxcbiAgbGVmdDogMWVtO1xcXFxuICByaWdodDogYXV0bztcXFxcbiAgbWFyZ2luOiAwZW07XFxcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcXFxuICAgICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXFxcbiAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxcXG59XFxcXG5cXFxcbi8qIFRvcCBSaWdodCAgUG9pbnRpbmcgKi9cXFxcbi51aS50b3AucmlnaHQucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgdG9wOiAxMDAlO1xcXFxuICBib3R0b206IGF1dG87XFxcXG4gIHJpZ2h0OiAwJTtcXFxcbiAgbGVmdDogYXV0bztcXFxcbiAgbWFyZ2luOiAxZW0gMGVtIDBlbTtcXFxcbn1cXFxcbi51aS50b3AucmlnaHQucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtNDAzMGRhYTJdOmFmdGVyIHtcXFxcbiAgdG9wOiAtMC4yNWVtO1xcXFxuICBsZWZ0OiBhdXRvO1xcXFxuICByaWdodDogMWVtO1xcXFxuICBtYXJnaW46IDBlbTtcXFxcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxcXG4gICAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcXFxuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXFxcbn1cXFxcblxcXFxuLyogTGVmdCBQb2ludGluZyAqL1xcXFxuLnVpLmxlZnQucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgdG9wOiAwJTtcXFxcbiAgbGVmdDogMTAwJTtcXFxcbiAgcmlnaHQ6IGF1dG87XFxcXG4gIG1hcmdpbjogMGVtIDBlbSAwZW0gMWVtO1xcXFxufVxcXFxuLnVpLmxlZnQucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtNDAzMGRhYTJdOmFmdGVyIHtcXFxcbiAgdG9wOiAxZW07XFxcXG4gIGxlZnQ6IC0wLjI1ZW07XFxcXG4gIG1hcmdpbjogMGVtIDBlbSAwZW0gMGVtO1xcXFxuICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKC00NWRlZyk7XFxcXG4gICAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoLTQ1ZGVnKTtcXFxcbiAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtNDVkZWcpO1xcXFxufVxcXFxuXFxcXG4vKiBSaWdodCBQb2ludGluZyAqL1xcXFxuLnVpLnJpZ2h0LnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIHRvcDogMCU7XFxcXG4gIGxlZnQ6IGF1dG87XFxcXG4gIHJpZ2h0OiAxMDAlO1xcXFxuICBtYXJnaW46IDBlbSAxZW0gMGVtIDBlbTtcXFxcbn1cXFxcbi51aS5yaWdodC5wb2ludGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi00MDMwZGFhMl06YWZ0ZXIge1xcXFxuICB0b3A6IDFlbTtcXFxcbiAgbGVmdDogYXV0bztcXFxcbiAgcmlnaHQ6IC0wLjI1ZW07XFxcXG4gIG1hcmdpbjogMGVtIDBlbSAwZW0gMGVtO1xcXFxuICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDEzNWRlZyk7XFxcXG4gICAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMTM1ZGVnKTtcXFxcbiAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxMzVkZWcpO1xcXFxufVxcXFxuXFxcXG4vKiBCb3R0b20gUG9pbnRpbmcgKi9cXFxcbi51aS5ib3R0b20ucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgdG9wOiBhdXRvO1xcXFxuICBib3R0b206IDEwMCU7XFxcXG4gIGxlZnQ6IDAlO1xcXFxuICByaWdodDogYXV0bztcXFxcbiAgbWFyZ2luOiAwZW0gMGVtIDFlbTtcXFxcbn1cXFxcbi51aS5ib3R0b20ucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtNDAzMGRhYTJdOmFmdGVyIHtcXFxcbiAgdG9wOiBhdXRvO1xcXFxuICBib3R0b206IC0wLjI1ZW07XFxcXG4gIHJpZ2h0OiBhdXRvO1xcXFxuICBtYXJnaW46IDBlbTtcXFxcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgtMTM1ZGVnKTtcXFxcbiAgICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgtMTM1ZGVnKTtcXFxcbiAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtMTM1ZGVnKTtcXFxcbn1cXFxcblxcXFxuLyogUmV2ZXJzZSBTdWItTWVudSBEaXJlY3Rpb24gKi9cXFxcbi51aS5ib3R0b20ucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudSAubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgdG9wOiBhdXRvICFpbXBvcnRhbnQ7XFxcXG4gIGJvdHRvbTogMHB4ICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIEJvdHRvbSBMZWZ0ICovXFxcXG4udWkuYm90dG9tLmxlZnQucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgbGVmdDogMCU7XFxcXG4gIHJpZ2h0OiBhdXRvO1xcXFxufVxcXFxuLnVpLmJvdHRvbS5sZWZ0LnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LTQwMzBkYWEyXTphZnRlciB7XFxcXG4gIGxlZnQ6IDFlbTtcXFxcbiAgcmlnaHQ6IGF1dG87XFxcXG59XFxcXG5cXFxcbi8qIEJvdHRvbSBSaWdodCAqL1xcXFxuLnVpLmJvdHRvbS5yaWdodC5wb2ludGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICByaWdodDogMCU7XFxcXG4gIGxlZnQ6IGF1dG87XFxcXG59XFxcXG4udWkuYm90dG9tLnJpZ2h0LnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LTQwMzBkYWEyXTphZnRlciB7XFxcXG4gIGxlZnQ6IGF1dG87XFxcXG4gIHJpZ2h0OiAxZW07XFxcXG59XFxcXG5cXFxcbi8qIFVwd2FyZCBwb2ludGluZyAqL1xcXFxuLnVpLnVwd2FyZC5wb2ludGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi00MDMwZGFhMl0sXFxcXG4udWkudXB3YXJkLnRvcC5wb2ludGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi00MDMwZGFhMl0ge1xcXFxuICB0b3A6IGF1dG87XFxcXG4gIGJvdHRvbTogMTAwJTtcXFxcbiAgbWFyZ2luOiAwZW0gMGVtIDAuNzg1NzE0MjlyZW07XFxcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjg1NzE0MjlyZW07XFxcXG59XFxcXG4udWkudXB3YXJkLnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LTQwMzBkYWEyXTphZnRlcixcXFxcbi51aS51cHdhcmQudG9wLnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LTQwMzBkYWEyXTphZnRlciB7XFxcXG4gIHRvcDogMTAwJTtcXFxcbiAgYm90dG9tOiBhdXRvO1xcXFxuICBib3gtc2hhZG93OiAxcHggMXB4IDBweCAxcHggcmdiYSgzNCwgMzYsIDM4LCAwLjE1KTtcXFxcbiAgbWFyZ2luOiAtMC4yNWVtIDBlbSAwZW07XFxcXG59XFxcXG5cXFxcblxcXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXFxcbiAgICAgICAgIFRoZW1lIE92ZXJyaWRlc1xcXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXFxcblxcXFxuXFxcXG4vKiBEcm9wZG93biBDYXJldHMgKi9cXFxcbkBmb250LWZhY2Uge1xcXFxuICBmb250LWZhbWlseTogJ0Ryb3Bkb3duJztcXFxcbiAgc3JjOiB1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtdHRmO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LEFBRUFBQUFMQUlBQUF3QXdUMU12TWdnakI1QUFBQUM4QUFBQVlHTnRZWEFQZnVJSUFBQUJIQUFBQUV4bllYTndBQUFBRUFBQUFXZ0FBQUFJWjJ4NVpqbzgyTGdBQUFGd0FBQUJWR2hsWVdRQVE4OGJBQUFDeEFBQUFEWm9hR1ZoQXdjQjZRQUFBdndBQUFBa2FHMTBlQVM0QUJJQUFBTWdBQUFBSUd4dlkyRUJOZ0RlQUFBRFFBQUFBQkp0WVhod0FBb0FGZ0FBQTFRQUFBQWdibUZ0WlZjWnB1NEFBQU4wQUFBQlJYQnZjM1FBQXdBQUFBQUV2QUFBQUNBQUF3SUFBWkFBQlFBQUFVd0JaZ0FBQUVjQlRBRm1BQUFBOVFBWkFJUUFBQUFBQUFBQUFBQUFBQUFBQUFBQkVBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBRHcyZ0hnLytELzRBSGdBQ0FBQUFBQkFBQUFBQUFBQUFBQUFBQWdBQUFBQUFBQ0FBQUFBd0FBQUJRQUF3QUJBQUFBRkFBRUFEZ0FBQUFLQUFnQUFnQUNBQUVBSVBEYS8vMy8vd0FBQUFBQUlQRFgvLzMvL3dBQi8rTVBMUUFEQUFFQUFBQUFBQUFBQUFBQUFBRUFBZi8vQUE4QUFRQUFBQUFBQUFBQUFBSUFBRGM1QVFBQUFBQUJBQUFBQUFBQUFBQUFBZ0FBTnprQkFBQUFBQUVBQUFBQUFBQUFBQUFDQUFBM09RRUFBQUFBQVFBQUFJQUJKUUVsQUJNQUFCTTBOelkzQlRZWEZoVVVEd0VHSndZdkFTWTFBQVVHQndFQUNBVUdCb0FGQ0FjR2dBVUJFZ2NHQlFFQkFRY0VDUVlIZndZQkFRWi9Cd1lBQVFBQUFHNEJKUUVTQUJNQUFEYzBQd0UyTXpJZkFSWVZGQWNHSXlFaUp5WTFBQVdBQmdjSUJZQUdCZ1VJL3dBSEJnV0FCd2FBQlFXQUJnY0hCZ1VGQmdjQUFBQUJBQklBU1FDM0FXNEFFd0FBTnpRL0FUWVhOaGNXSFFFVUJ3WW5CaThCSmpVU0JvQUZDQWNGQmdZRkJ3Z0ZnQWJiQndaL0J3RUJCd1FKL3dnRUJ3RUJCMzhHQmdBQUFBQUJBQUFBU1FDbEFXNEFFd0FBTnhFME56WXpNaDhCRmhVVUR3RUdJeUluSmpVQUJRWUhDQVdBQmdhQUJRZ0hCZ1ZiQVFBSUJRWUdnQVVJQndXQUJnWUZCd0FBQUFFQUFBQUJBQURadWFLT1h3ODg5UUFMQWdBQUFBQUEwQUJIV0FBQUFBRFFBRWRZQUFBQUFBRWxBVzRBQUFBSUFBSUFBQUFBQUFBQUFRQUFBZUQvNEFBQUFnQUFBQUFBQVNVQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFnQUFBQUFBQUFBQUFBQUFBQUJBQUFBQVNVQUFBRWxBQUFBdHdBU0FMY0FBQUFBQUFBQUNnQVVBQjRBUWdCa0FJZ0FxZ0FBQUFFQUFBQUlBQlFBQVFBQUFBQUFBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPQUs0QUFRQUFBQUFBQVFBT0FBQUFBUUFBQUFBQUFnQU9BRWNBQVFBQUFBQUFBd0FPQUNRQUFRQUFBQUFBQkFBT0FGVUFBUUFBQUFBQUJRQVdBQTRBQVFBQUFBQUFCZ0FIQURJQUFRQUFBQUFBQ2dBMEFHTUFBd0FCQkFrQUFRQU9BQUFBQXdBQkJBa0FBZ0FPQUVjQUF3QUJCQWtBQXdBT0FDUUFBd0FCQkFrQUJBQU9BRlVBQXdBQkJBa0FCUUFXQUE0QUF3QUJCQWtBQmdBT0FEa0FBd0FCQkFrQUNnQTBBR01BYVFCakFHOEFiUUJ2QUc4QWJnQldBR1VBY2dCekFHa0Fid0J1QUNBQU1RQXVBREFBYVFCakFHOEFiUUJ2QUc4QWJtbGpiMjF2YjI0QWFRQmpBRzhBYlFCdkFHOEFiZ0JTQUdVQVp3QjFBR3dBWVFCeUFHa0FZd0J2QUcwQWJ3QnZBRzRBUmdCdkFHNEFkQUFnQUdjQVpRQnVBR1VBY2dCaEFIUUFaUUJrQUNBQVlnQjVBQ0FBU1FCakFHOEFUUUJ2QUc4QWJnQXVBQUFBQUFNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQT0pIGZvcm1hdCgndHJ1ZXR5cGUnKSwgdXJsKGRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGQwOUdSazlVVkU4QUFBVndBQW9BQUFBQUJTZ0FBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCRFJrWWdBQUFBOUFBQUFka0FBQUhaTERYRS8wOVRMeklBQUFMUUFBQUFZQUFBQUdBSUl3ZVFZMjFoY0FBQUF6QUFBQUJNQUFBQVRBOSs0Z2huWVhOd0FBQURmQUFBQUFnQUFBQUlBQUFBRUdobFlXUUFBQU9FQUFBQU5nQUFBRFlBUTg4YmFHaGxZUUFBQTd3QUFBQWtBQUFBSkFNSEFlbG9iWFI0QUFBRDRBQUFBQ0FBQUFBZ0JMZ0FFbTFoZUhBQUFBUUFBQUFBQmdBQUFBWUFDRkFBYm1GdFpRQUFCQWdBQUFGRkFBQUJSVmNacHU1d2IzTjBBQUFGVUFBQUFDQUFBQUFnQUFNQUFBRUFCQVFBQVFFQkNHbGpiMjF2YjI0QUFRSUFBUUE2K0J3QytCc0QrQmdFSGdvQUdWUC9pNHNlQ2dBWlUvK0xpd3dIaTJ2NGxQaDBCUjBBQUFDSUR4MEFBQUNORVIwQUFBQUpIUUFBQWRBU0FBa0JBUWdQRVJNV0d5QWxLbWxqYjIxdmIyNXBZMjl0YjI5dWRUQjFNWFV5TUhWR01FUTNkVVl3UkRoMVJqQkVPWFZHTUVSQkFBQUNBWWtBQmdBSUFnQUJBQVFBQndBS0FBMEFWZ0NmQU9nQkwveVVEdnlVRHZ5VUR2dVVEdnR2aS9lbUZZdVFqWkNPam8rUGo0MlFpd2ozbElzRmtJdVFpWTZIajRpTmhvdUdpNGFKaDRlSENQc1UreFFGaUlpR2lZYUxob3VIalllT0NQc1U5eFFGaUkrSmo0dVFDQTc3YjR2M0ZCV0xrSTJQam84STl4VDNGQVdQam8rTmtJdVFpNUNKam9nSTl4VDdGQVdQaDQySGk0YUxob21IaDRlSWlJYUpob3NJKzVTTEJZYUxoNDJIam9pUGlZK0xrQWdPKzkyZDkyOFZpNUNOa0krT0NQY1U5eFFGam8rUWpaQ0xrSXVQaVk2SGo0aU5ob3VHQ0l2N2xBV0xob21IaDRpSWg0ZUpob3VHaTRhTmlJOEkreFQzRkFXSGpvbVBpNUFJRHZ2ZGkrWVZpL2VVQll1UWpaQ09qbytQajQyUWk1Q0xrSW1PaHdqM0ZQc1VCWStJallhTGhvdUdpWWVIaUFqN0ZQc1VCWWlIaG9tR2k0YUxoNDJIajRpT2lZK0xrQWdPK0pRVStKUVZpd3dLQUFBQUFBTUNBQUdRQUFVQUFBRk1BV1lBQUFCSEFVd0JaZ0FBQVBVQUdRQ0VBQUFBQUFBQUFBQUFBQUFBQUFBQUFSQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFBQUE4Tm9CNFAvZy8rQUI0QUFnQUFBQUFRQUFBQUFBQUFBQUFBQUFJQUFBQUFBQUFnQUFBQU1BQUFBVUFBTUFBUUFBQUJRQUJBQTRBQUFBQ2dBSUFBSUFBZ0FCQUNEdzJ2LzkvLzhBQUFBQUFDRHcxLy85Ly84QUFmL2pEeTBBQXdBQkFBQUFBQUFBQUFBQUFBQUJBQUgvL3dBUEFBRUFBQUFCQUFBNWVtb3pYdzg4OVFBTEFnQUFBQUFBMEFCSFdBQUFBQURRQUVkWUFBQUFBQUVsQVc0QUFBQUlBQUlBQUFBQUFBQUFBUUFBQWVELzRBQUFBZ0FBQUFBQUFTVUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBZ0FBQUFBQUFBQUFBQUFBQUFCQUFBQUFTVUFBQUVsQUFBQXR3QVNBTGNBQUFBQVVBQUFDQUFBQUFBQURnQ3VBQUVBQUFBQUFBRUFEZ0FBQUFFQUFBQUFBQUlBRGdCSEFBRUFBQUFBQUFNQURnQWtBQUVBQUFBQUFBUUFEZ0JWQUFFQUFBQUFBQVVBRmdBT0FBRUFBQUFBQUFZQUJ3QXlBQUVBQUFBQUFBb0FOQUJqQUFNQUFRUUpBQUVBRGdBQUFBTUFBUVFKQUFJQURnQkhBQU1BQVFRSkFBTUFEZ0FrQUFNQUFRUUpBQVFBRGdCVkFBTUFBUVFKQUFVQUZnQU9BQU1BQVFRSkFBWUFEZ0E1QUFNQUFRUUpBQW9BTkFCakFHa0FZd0J2QUcwQWJ3QnZBRzRBVmdCbEFISUFjd0JwQUc4QWJnQWdBREVBTGdBd0FHa0FZd0J2QUcwQWJ3QnZBRzVwWTI5dGIyOXVBR2tBWXdCdkFHMEFid0J2QUc0QVVnQmxBR2NBZFFCc0FHRUFjZ0JwQUdNQWJ3QnRBRzhBYndCdUFFWUFid0J1QUhRQUlBQm5BR1VBYmdCbEFISUFZUUIwQUdVQVpBQWdBR0lBZVFBZ0FFa0FZd0J2QUUwQWJ3QnZBRzRBTGdBQUFBQURBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBKSBmb3JtYXQoJ3dvZmYnKTtcXFxcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXFxcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duID4gLmRyb3Bkb3duLmljb25bZGF0YS12LTQwMzBkYWEyXSB7XFxcXG4gIGZvbnQtZmFtaWx5OiAnRHJvcGRvd24nO1xcXFxuICBsaW5lLWhlaWdodDogMTtcXFxcbiAgaGVpZ2h0OiAxZW07XFxcXG4gIHdpZHRoOiAxLjIzZW07XFxcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcXFxuICAgICAgICAgIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXFxcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXFxcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxcXG59XFxcXG4udWkuZHJvcGRvd24gPiAuZHJvcGRvd24uaWNvbltkYXRhLXYtNDAzMGRhYTJdIHtcXFxcbiAgd2lkdGg6IGF1dG87XFxcXG59XFxcXG4udWkuZHJvcGRvd24gPiAuZHJvcGRvd24uaWNvbltkYXRhLXYtNDAzMGRhYTJdOmJlZm9yZSB7XFxcXG4gIGNvbnRlbnQ6ICdcXFxcXFxcXEYwRDcnO1xcXFxufVxcXFxuXFxcXG4vKiBTdWIgTWVudSAqL1xcXFxuLnVpLmRyb3Bkb3duIC5tZW51IC5pdGVtIC5kcm9wZG93bi5pY29uW2RhdGEtdi00MDMwZGFhMl06YmVmb3JlIHtcXFxcbiAgY29udGVudDogJ1xcXFxcXFxcRjBEQScgO1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duIC5pdGVtIC5sZWZ0LmRyb3Bkb3duLmljb25bZGF0YS12LTQwMzBkYWEyXTpiZWZvcmUsXFxcXG4udWkuZHJvcGRvd24gLmxlZnQubWVudSAuaXRlbSAuZHJvcGRvd24uaWNvbltkYXRhLXYtNDAzMGRhYTJdOmJlZm9yZSB7XFxcXG4gIGNvbnRlbnQ6IFxcXFxcXFwiXFxcXFxcXFxGMEQ5XFxcXFxcXCIgO1xcXFxufVxcXFxuXFxcXG4vKiBWZXJ0aWNhbCBNZW51IERyb3Bkb3duICovXFxcXG4udWkudmVydGljYWwubWVudSAuZHJvcGRvd24uaXRlbSA+IC5kcm9wZG93bi5pY29uW2RhdGEtdi00MDMwZGFhMl06YmVmb3JlIHtcXFxcbiAgY29udGVudDogXFxcXFxcXCJcXFxcXFxcXEYwREFcXFxcXFxcIiA7XFxcXG59XFxcXG4vKiBJY29ucyBmb3IgUmVmZXJlbmNlXFxcXG4uZHJvcGRvd24uZG93bi5pY29uIHtcXFxcbiAgY29udGVudDogXFxcXFxcXCJcXFxcXFxcXGYwZDdcXFxcXFxcIjtcXFxcbn1cXFxcbi5kcm9wZG93bi51cC5pY29uIHtcXFxcbiAgY29udGVudDogXFxcXFxcXCJcXFxcXFxcXGYwZDhcXFxcXFxcIjtcXFxcbn1cXFxcbi5kcm9wZG93bi5sZWZ0Lmljb24ge1xcXFxuICBjb250ZW50OiBcXFxcXFxcIlxcXFxcXFxcZjBkOVxcXFxcXFwiO1xcXFxufVxcXFxuLmRyb3Bkb3duLmljb24uaWNvbiB7XFxcXG4gIGNvbnRlbnQ6IFxcXFxcXFwiXFxcXFxcXFxmMGRhXFxcXFxcXCI7XFxcXG59XFxcXG4qL1xcXFxuXFxcXG5cXFxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxcXG4gICAgICAgIFVzZXIgT3ZlcnJpZGVzXFxcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcXFxuXFxcXG5cXFwiLCBcXFwiXFxcIl0pO1xcblxcdFxcblxcdC8vIGV4cG9ydHNcXG5cXG5cXG4vKioqLyB9LFxcbi8qIDk0ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0ZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KSgpO1xcblxcdC8vIGltcG9ydHNcXG5cXHRcXG5cXHRcXG5cXHQvLyBtb2R1bGVcXG5cXHRleHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXFxcIlxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblxcXFxuLyogTWVudSBJdGVtIEhvdmVyIGZvciBLZXkgZXZlbnQgKi9cXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pdGVtLmN1cnJlbnQge1xcXFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuMDUpO1xcXFxufVxcXFxuXFxcIiwgXFxcIlxcXCJdKTtcXG5cXHRcXG5cXHQvLyBleHBvcnRzXFxuXFxuXFxuLyoqKi8gfSxcXG4vKiA5NSAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNCkoKTtcXG5cXHQvLyBpbXBvcnRzXFxuXFx0XFxuXFx0XFxuXFx0Ly8gbW9kdWxlXFxuXFx0ZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFxcXCIvKiFcXFxcbiAqICMgU2VtYW50aWMgVUkgMi4yLjMgLSBEcm9wZG93blxcXFxuICogaHR0cDovL2dpdGh1Yi5jb20vc2VtYW50aWMtb3JnL3NlbWFudGljLXVpL1xcXFxuICpcXFxcbiAqXFxcXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcXFxcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcXFxcbiAqXFxcXG4gKi9cXFxcblxcXFxuXFxcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcXFxuICAgICAgICAgICAgRHJvcGRvd25cXFxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxcXG4udWkuZHJvcGRvd25bZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGN1cnNvcjogcG9pbnRlcjtcXFxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxcXG4gIG91dGxpbmU6IG5vbmU7XFxcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYm94LXNoYWRvdyAwLjFzIGVhc2UsIHdpZHRoIDAuMXMgZWFzZTtcXFxcbiAgdHJhbnNpdGlvbjogYm94LXNoYWRvdyAwLjFzIGVhc2UsIHdpZHRoIDAuMXMgZWFzZTtcXFxcbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApO1xcXFxufVxcXFxuXFxcXG5cXFxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxcXG4gICAgICAgICAgICBDb250ZW50XFxcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcXFxuXFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgIE1lbnVcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZHJvcGRvd24gLm1lbnVbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGN1cnNvcjogYXV0bztcXFxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcXFxuICBkaXNwbGF5OiBub25lO1xcXFxuICBvdXRsaW5lOiBub25lO1xcXFxuICB0b3A6IDEwMCU7XFxcXG4gIG1pbi13aWR0aDogLXdlYmtpdC1tYXgtY29udGVudDtcXFxcbiAgbWluLXdpZHRoOiAtbW96LW1heC1jb250ZW50O1xcXFxuICBtaW4td2lkdGg6IG1heC1jb250ZW50O1xcXFxuICBtYXJnaW46IDBlbTtcXFxcbiAgcGFkZGluZzogMGVtIDBlbTtcXFxcbiAgYmFja2dyb3VuZDogI0ZGRkZGRjtcXFxcbiAgZm9udC1zaXplOiAxZW07XFxcXG4gIHRleHQtc2hhZG93OiBub25lO1xcXFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcXFxuICBib3gtc2hhZG93OiAwcHggMnB4IDNweCAwcHggcmdiYSgzNCwgMzYsIDM4LCAwLjE1KTtcXFxcbiAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgzNCwgMzYsIDM4LCAwLjE1KTtcXFxcbiAgYm9yZGVyLXJhZGl1czogMC4yODU3MTQyOXJlbTtcXFxcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBvcGFjaXR5IDAuMXMgZWFzZTtcXFxcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjFzIGVhc2U7XFxcXG4gIHotaW5kZXg6IDExO1xcXFxuICB3aWxsLWNoYW5nZTogdHJhbnNmb3JtLCBvcGFjaXR5O1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gKltkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICBIaWRkZW4gSW5wdXRcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZHJvcGRvd24gPiBpbnB1dFtkYXRhLXYtYTNkYmZjMGNdOm5vdCguc2VhcmNoKTpmaXJzdC1jaGlsZCxcXFxcbi51aS5kcm9wZG93biA+IHNlbGVjdFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gRHJvcGRvd24gSWNvblxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcbi51aS5kcm9wZG93biA+IC5kcm9wZG93bi5pY29uW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxcXG4gIHdpZHRoOiBhdXRvO1xcXFxuICBmb250LXNpemU6IDAuODU3MTQyODZlbTtcXFxcbiAgbWFyZ2luOiAwZW0gMGVtIDBlbSAxZW07XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbSAuZHJvcGRvd24uaWNvbltkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgd2lkdGg6IGF1dG87XFxcXG4gIGZsb2F0OiByaWdodDtcXFxcbiAgbWFyZ2luOiAwZW0gMGVtIDBlbSAxZW07XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbSAuZHJvcGRvd24uaWNvbiArIC50ZXh0W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBtYXJnaW4tcmlnaHQ6IDFlbTtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgICAgVGV4dFxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcbi51aS5kcm9wZG93biA+IC50ZXh0W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogbm9uZTtcXFxcbiAgdHJhbnNpdGlvbjogbm9uZTtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgIE1lbnUgSXRlbVxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pdGVtW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxcXG4gIGN1cnNvcjogcG9pbnRlcjtcXFxcbiAgZGlzcGxheTogYmxvY2s7XFxcXG4gIGJvcmRlcjogbm9uZTtcXFxcbiAgaGVpZ2h0OiBhdXRvO1xcXFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcXFxuICBib3JkZXItdG9wOiBub25lO1xcXFxuICBsaW5lLWhlaWdodDogMWVtO1xcXFxuICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjg3KTtcXFxcbiAgcGFkZGluZzogMC43ODU3MTQyOXJlbSAxLjE0Mjg1NzE0cmVtICFpbXBvcnRhbnQ7XFxcXG4gIGZvbnQtc2l6ZTogMXJlbTtcXFxcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxcXG4gIGJveC1zaGFkb3c6IG5vbmU7XFxcXG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTtcXFxcbn1cXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pdGVtW2RhdGEtdi1hM2RiZmMwY106Zmlyc3QtY2hpbGQge1xcXFxuICBib3JkZXItdG9wLXdpZHRoOiAwcHg7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgRmxvYXRlZCBDb250ZW50XFxcXG4tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLmRyb3Bkb3duID4gLnRleHQgPiBbY2xhc3MqPVxcXFxcXFwicmlnaHQgZmxvYXRlZFxcXFxcXFwiXVtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51IC5pdGVtID4gW2NsYXNzKj1cXFxcXFxcInJpZ2h0IGZsb2F0ZWRcXFxcXFxcIl1bZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGZsb2F0OiByaWdodCAhaW1wb3J0YW50O1xcXFxuICBtYXJnaW4tcmlnaHQ6IDBlbSAhaW1wb3J0YW50O1xcXFxuICBtYXJnaW4tbGVmdDogMWVtICFpbXBvcnRhbnQ7XFxcXG59XFxcXG4udWkuZHJvcGRvd24gPiAudGV4dCA+IFtjbGFzcyo9XFxcXFxcXCJsZWZ0IGZsb2F0ZWRcXFxcXFxcIl1bZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5kcm9wZG93biAubWVudSAuaXRlbSA+IFtjbGFzcyo9XFxcXFxcXCJsZWZ0IGZsb2F0ZWRcXFxcXFxcIl1bZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGZsb2F0OiBsZWZ0ICFpbXBvcnRhbnQ7XFxcXG4gIG1hcmdpbi1sZWZ0OiAwZW0gIWltcG9ydGFudDtcXFxcbiAgbWFyZ2luLXJpZ2h0OiAxZW0gIWltcG9ydGFudDtcXFxcbn1cXFxcbi51aS5kcm9wZG93biAubWVudSAuaXRlbSA+IC5pY29uLmZsb2F0ZWRbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5kcm9wZG93biAubWVudSAuaXRlbSA+IC5mbGFnLmZsb2F0ZWRbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5kcm9wZG93biAubWVudSAuaXRlbSA+IC5pbWFnZS5mbG9hdGVkW2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgLml0ZW0gPiBpbWcuZmxvYXRlZFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgbWFyZ2luLXRvcDogMGVtO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gIE1lbnUgRGl2aWRlclxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5oZWFkZXJbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG1hcmdpbjogMXJlbSAwcmVtIDAuNzVyZW07XFxcXG4gIHBhZGRpbmc6IDBlbSAxLjE0Mjg1NzE0cmVtO1xcXFxuICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjg1KTtcXFxcbiAgZm9udC1zaXplOiAwLjc4NTcxNDI5ZW07XFxcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcXFxuICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLmRpdmlkZXJbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCByZ2JhKDM0LCAzNiwgMzgsIDAuMSk7XFxcXG4gIGhlaWdodDogMGVtO1xcXFxuICBtYXJnaW46IDAuNWVtIDBlbTtcXFxcbn1cXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pbnB1dFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgd2lkdGg6IGF1dG87XFxcXG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcXFxuICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XFxcXG4gIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xcXFxuICBkaXNwbGF5OiBmbGV4O1xcXFxuICBtYXJnaW46IDEuMTQyODU3MTRyZW0gMC43ODU3MTQyOXJlbTtcXFxcbiAgbWluLXdpZHRoOiAxMHJlbTtcXFxcbn1cXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5oZWFkZXIgKyAuaW5wdXRbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG1hcmdpbi10b3A6IDBlbTtcXFxcbn1cXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pbnB1dDpub3QoLnRyYW5zcGFyZW50KSBpbnB1dFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgcGFkZGluZzogMC41ZW0gMWVtO1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLmlucHV0Om5vdCgudHJhbnNwYXJlbnQpIC5idXR0b25bZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pbnB1dDpub3QoLnRyYW5zcGFyZW50KSAuaWNvbltkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLmlucHV0Om5vdCgudHJhbnNwYXJlbnQpIC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgcGFkZGluZy10b3A6IDAuNWVtO1xcXFxuICBwYWRkaW5nLWJvdHRvbTogMC41ZW07XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS1cXFxcbiAgSXRlbSBEZXNjcmlwdGlvblxcXFxuLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZHJvcGRvd24gPiAudGV4dCA+IC5kZXNjcmlwdGlvbltkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW0gPiAuZGVzY3JpcHRpb25bZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGZsb2F0OiByaWdodDtcXFxcbiAgbWFyZ2luOiAwZW0gMGVtIDBlbSAxZW07XFxcXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNCk7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgICBNZXNzYWdlXFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5tZXNzYWdlW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBwYWRkaW5nOiAwLjc4NTcxNDI5cmVtIDEuMTQyODU3MTRyZW07XFxcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAubWVzc2FnZVtkYXRhLXYtYTNkYmZjMGNdOm5vdCgudWkpIHtcXFxcbiAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC40KTtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgIFN1YiBNZW51XFxcXG4tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLmRyb3Bkb3duIC5tZW51IC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICB0b3A6IDAlICFpbXBvcnRhbnQ7XFxcXG4gIGxlZnQ6IDEwMCUgIWltcG9ydGFudDtcXFxcbiAgcmlnaHQ6IGF1dG8gIWltcG9ydGFudDtcXFxcbiAgbWFyZ2luOiAwZW0gMGVtIDBlbSAtMC41ZW0gIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLXJhZGl1czogMC4yODU3MTQyOXJlbSAhaW1wb3J0YW50O1xcXFxuICB6LWluZGV4OiAyMSAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBIaWRlIEFycm93ICovXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgLm1lbnVbZGF0YS12LWEzZGJmYzBjXTphZnRlciB7XFxcXG4gIGRpc3BsYXk6IG5vbmU7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgIFN1YiBFbGVtZW50c1xcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiBJY29ucyAvIEZsYWdzIC8gTGFiZWxzIC8gSW1hZ2UgKi9cXFxcbi51aS5kcm9wZG93biA+IC50ZXh0ID4gLmljb25bZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5kcm9wZG93biA+IC50ZXh0ID4gLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuZHJvcGRvd24gPiAudGV4dCA+IC5mbGFnW2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuZHJvcGRvd24gPiAudGV4dCA+IGltZ1tkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmRyb3Bkb3duID4gLnRleHQgPiAuaW1hZ2VbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG1hcmdpbi10b3A6IDBlbTtcXFxcbn1cXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pdGVtID4gLmljb25bZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pdGVtID4gLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbSA+IC5mbGFnW2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbSA+IC5pbWFnZVtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW0gPiBpbWdbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG1hcmdpbi10b3A6IDBlbTtcXFxcbn1cXFxcbi51aS5kcm9wZG93biA+IC50ZXh0ID4gLmljb25bZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5kcm9wZG93biA+IC50ZXh0ID4gLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuZHJvcGRvd24gPiAudGV4dCA+IC5mbGFnW2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuZHJvcGRvd24gPiAudGV4dCA+IGltZ1tkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmRyb3Bkb3duID4gLnRleHQgPiAuaW1hZ2VbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pdGVtID4gLmljb25bZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pdGVtID4gLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbSA+IC5mbGFnW2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbSA+IC5pbWFnZVtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW0gPiBpbWdbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG1hcmdpbi1sZWZ0OiAwZW07XFxcXG4gIGZsb2F0OiBub25lO1xcXFxuICBtYXJnaW4tcmlnaHQ6IDAuNzg1NzE0MjlyZW07XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgSW1hZ2VcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZHJvcGRvd24gPiAudGV4dCA+IGltZ1tkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmRyb3Bkb3duID4gLnRleHQgPiAuaW1hZ2VbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5pdGVtID4gLmltYWdlW2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbSA+IGltZ1tkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcXFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcXFxuICB3aWR0aDogYXV0bztcXFxcbiAgbWF4LWhlaWdodDogMmVtO1xcXFxufVxcXFxuXFxcXG5cXFxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxcXG4gICAgICAgICAgICBDb3VwbGluZ1xcXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXFxcblxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gICAgICBNZW51XFxcXG4tLS0tLS0tLS0tLS0tLS0qL1xcXFxuXFxcXG5cXFxcbi8qIFJlbW92ZSBNZW51IEl0ZW0gRGl2aWRlciAqL1xcXFxuLnVpLmRyb3Bkb3duIC51aS5tZW51ID4gLml0ZW1bZGF0YS12LWEzZGJmYzBjXTpiZWZvcmUsXFxcXG4udWkubWVudSAudWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbVtkYXRhLXYtYTNkYmZjMGNdOmJlZm9yZSB7XFxcXG4gIGRpc3BsYXk6IG5vbmU7XFxcXG59XFxcXG5cXFxcbi8qIFByZXZlbnQgTWVudSBJdGVtIEJvcmRlciAqL1xcXFxuLnVpLm1lbnUgLnVpLmRyb3Bkb3duIC5tZW51IC5hY3RpdmUuaXRlbVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgYm9yZGVyLWxlZnQ6IG5vbmU7XFxcXG59XFxcXG5cXFxcbi8qIEF1dG9tYXRpY2FsbHkgZmxvYXQgZHJvcGRvd24gbWVudSByaWdodCBvbiBsYXN0IG1lbnUgaXRlbSAqL1xcXFxuLnVpLm1lbnUgLnJpZ2h0Lm1lbnUgLmRyb3Bkb3duOmxhc3QtY2hpbGQgLm1lbnVbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5tZW51IC5yaWdodC5kcm9wZG93bi5pdGVtIC5tZW51W2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuYnV0dG9ucyA+IC51aS5kcm9wZG93bjpsYXN0LWNoaWxkIC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBsZWZ0OiBhdXRvO1xcXFxuICByaWdodDogMGVtO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gICAgICBMYWJlbFxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiBEcm9wZG93biBNZW51ICovXFxcXG4udWkubGFiZWwuZHJvcGRvd24gLm1lbnVbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG1pbi13aWR0aDogMTAwJTtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgICBCdXR0b25cXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG5cXFxcblxcXFxuLyogTm8gTWFyZ2luIE9uIEljb24gQnV0dG9uICovXFxcXG4udWkuZHJvcGRvd24uaWNvbi5idXR0b24gPiAuZHJvcGRvd24uaWNvbltkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgbWFyZ2luOiAwZW07XFxcXG59XFxcXG4udWkuYnV0dG9uLmRyb3Bkb3duIC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBtaW4td2lkdGg6IDEwMCU7XFxcXG59XFxcXG5cXFxcblxcXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXFxcbiAgICAgICAgICAgICAgVHlwZXNcXFxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxcXG5cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgIFNlbGVjdGlvblxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiBEaXNwbGF5cyBsaWtlIGEgc2VsZWN0IGJveCAqL1xcXFxuLnVpLnNlbGVjdGlvbi5kcm9wZG93bltkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgY3Vyc29yOiBwb2ludGVyO1xcXFxuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XFxcXG4gIGxpbmUtaGVpZ2h0OiAxZW07XFxcXG4gIHdoaXRlLXNwYWNlOiBub3JtYWw7XFxcXG4gIG91dGxpbmU6IDA7XFxcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGVaKDBkZWcpO1xcXFxuICAgICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcXFxuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlWigwZGVnKTtcXFxcbiAgbWluLXdpZHRoOiAxNGVtO1xcXFxuICBtaW4taGVpZ2h0OiAyLjcxNDJlbTtcXFxcbiAgYmFja2dyb3VuZDogI0ZGRkZGRjtcXFxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcXFxuICBwYWRkaW5nOiAwLjc4NTcxNDI5ZW0gMi4xZW0gMC43ODU3MTQyOWVtIDFlbTtcXFxcbiAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44Nyk7XFxcXG4gIGJveC1zaGFkb3c6IG5vbmU7XFxcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMzQsIDM2LCAzOCwgMC4xNSk7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjg1NzE0MjlyZW07XFxcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYm94LXNoYWRvdyAwLjFzIGVhc2UsIHdpZHRoIDAuMXMgZWFzZTtcXFxcbiAgdHJhbnNpdGlvbjogYm94LXNoYWRvdyAwLjFzIGVhc2UsIHdpZHRoIDAuMXMgZWFzZTtcXFxcbn1cXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24udmlzaWJsZVtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLnNlbGVjdGlvbi5kcm9wZG93bi5hY3RpdmVbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIHotaW5kZXg6IDEwO1xcXFxufVxcXFxuc2VsZWN0LnVpLmRyb3Bkb3duW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBoZWlnaHQ6IDM4cHg7XFxcXG4gIHBhZGRpbmc6IDAuNWVtO1xcXFxuICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDM0LCAzNiwgMzgsIDAuMTUpO1xcXFxuICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcXFxufVxcXFxuLnVpLnNlbGVjdGlvbi5kcm9wZG93biA+IC5zZWFyY2guaWNvbltkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLnNlbGVjdGlvbi5kcm9wZG93biA+IC5kZWxldGUuaWNvbltkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLnNlbGVjdGlvbi5kcm9wZG93biA+IC5kcm9wZG93bi5pY29uW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcbiAgd2lkdGg6IGF1dG87XFxcXG4gIGhlaWdodDogYXV0bztcXFxcbiAgbGluZS1oZWlnaHQ6IDEuMjE0MmVtO1xcXFxuICB0b3A6IDAuNzg1NzE0MjllbTtcXFxcbiAgcmlnaHQ6IDFlbTtcXFxcbiAgei1pbmRleDogMztcXFxcbiAgbWFyZ2luOiAtMC43ODU3MTQyOWVtO1xcXFxuICBwYWRkaW5nOiAwLjc4NTcxNDI5ZW07XFxcXG4gIG9wYWNpdHk6IDAuODtcXFxcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBvcGFjaXR5IDAuMXMgZWFzZTtcXFxcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjFzIGVhc2U7XFxcXG59XFxcXG5cXFxcbi8qIENvbXBhY3QgKi9cXFxcbi51aS5jb21wYWN0LnNlbGVjdGlvbi5kcm9wZG93bltkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgbWluLXdpZHRoOiAwcHg7XFxcXG59XFxcXG5cXFxcbi8qICBTZWxlY3Rpb24gTWVudSAqL1xcXFxuLnVpLnNlbGVjdGlvbi5kcm9wZG93biAubWVudVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgb3ZlcmZsb3cteDogaGlkZGVuO1xcXFxuICBvdmVyZmxvdy15OiBhdXRvO1xcXFxuICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXFxcbiAgICAgICAgICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxcXG4gIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcXFxcbiAgYm9yZGVyLXRvcC13aWR0aDogMHB4ICFpbXBvcnRhbnQ7XFxcXG4gIHdpZHRoOiBhdXRvO1xcXFxuICBvdXRsaW5lOiBub25lO1xcXFxuICBtYXJnaW46IDBweCAtMXB4O1xcXFxuICBtaW4td2lkdGg6IGNhbGMoMTAwJSArICAycHggKTtcXFxcbiAgd2lkdGg6IGNhbGMoMTAwJSArICAycHggKTtcXFxcbiAgYm9yZGVyLXJhZGl1czogMGVtIDBlbSAwLjI4NTcxNDI5cmVtIDAuMjg1NzE0MjlyZW07XFxcXG4gIGJveC1zaGFkb3c6IDBweCAycHggM3B4IDBweCByZ2JhKDM0LCAzNiwgMzgsIDAuMTUpO1xcXFxuICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgMC4xcyBlYXNlO1xcXFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMXMgZWFzZTtcXFxcbn1cXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24gLm1lbnVbZGF0YS12LWEzZGJmYzBjXTphZnRlcixcXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24gLm1lbnVbZGF0YS12LWEzZGJmYzBjXTpiZWZvcmUge1xcXFxuICBkaXNwbGF5OiBub25lO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gICAgTWVzc2FnZVxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24gLm1lbnUgPiAubWVzc2FnZVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgcGFkZGluZzogMC43ODU3MTQyOXJlbSAxLjE0Mjg1NzE0cmVtO1xcXFxufVxcXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xcXFxuLnVpLnNlbGVjdGlvbi5kcm9wZG93biAubWVudVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgICBtYXgtaGVpZ2h0OiA4LjAxNDI4NTcxcmVtO1xcXFxufVxcXFxufVxcXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3NjhweCkge1xcXFxuLnVpLnNlbGVjdGlvbi5kcm9wZG93biAubWVudVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgICBtYXgtaGVpZ2h0OiAxMC42ODU3MTQyOXJlbTtcXFxcbn1cXFxcbn1cXFxcbkBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogOTkycHgpIHtcXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24gLm1lbnVbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gICAgbWF4LWhlaWdodDogMTYuMDI4NTcxNDNyZW07XFxcXG59XFxcXG59XFxcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDE5MjBweCkge1xcXFxuLnVpLnNlbGVjdGlvbi5kcm9wZG93biAubWVudVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgICBtYXgtaGVpZ2h0OiAyMS4zNzE0Mjg1N3JlbTtcXFxcbn1cXFxcbn1cXFxcblxcXFxuLyogTWVudSBJdGVtICovXFxcXG4udWkuc2VsZWN0aW9uLmRyb3Bkb3duIC5tZW51ID4gLml0ZW1bZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCAjRkFGQUZBO1xcXFxuICBwYWRkaW5nOiAwLjc4NTcxNDI5cmVtIDEuMTQyODU3MTRyZW0gIWltcG9ydGFudDtcXFxcbiAgd2hpdGUtc3BhY2U6IG5vcm1hbDtcXFxcbiAgd29yZC13cmFwOiBub3JtYWw7XFxcXG59XFxcXG5cXFxcbi8qIFVzZXIgSXRlbSAqL1xcXFxuLnVpLnNlbGVjdGlvbi5kcm9wZG93biAubWVudSA+IC5oaWRkZW4uYWRkaXRpb24uaXRlbVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgZGlzcGxheTogbm9uZTtcXFxcbn1cXFxcblxcXFxuLyogSG92ZXIgKi9cXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd25bZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJvcmRlci1jb2xvcjogcmdiYSgzNCwgMzYsIDM4LCAwLjM1KTtcXFxcbiAgYm94LXNoYWRvdzogbm9uZTtcXFxcbn1cXFxcblxcXFxuLyogQWN0aXZlICovXFxcXG4udWkuc2VsZWN0aW9uLmFjdGl2ZS5kcm9wZG93bltkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjOTZDOERBO1xcXFxuICBib3gtc2hhZG93OiAwcHggMnB4IDNweCAwcHggcmdiYSgzNCwgMzYsIDM4LCAwLjE1KTtcXFxcbn1cXFxcbi51aS5zZWxlY3Rpb24uYWN0aXZlLmRyb3Bkb3duIC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBib3JkZXItY29sb3I6ICM5NkM4REE7XFxcXG4gIGJveC1zaGFkb3c6IDBweCAycHggM3B4IDBweCByZ2JhKDM0LCAzNiwgMzgsIDAuMTUpO1xcXFxufVxcXFxuXFxcXG4vKiBGb2N1cyAqL1xcXFxuLnVpLnNlbGVjdGlvbi5kcm9wZG93bltkYXRhLXYtYTNkYmZjMGNdOmZvY3VzIHtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjOTZDOERBO1xcXFxuICBib3gtc2hhZG93OiBub25lO1xcXFxufVxcXFxuLnVpLnNlbGVjdGlvbi5kcm9wZG93bjpmb2N1cyAubWVudVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjOTZDOERBO1xcXFxuICBib3gtc2hhZG93OiAwcHggMnB4IDNweCAwcHggcmdiYSgzNCwgMzYsIDM4LCAwLjE1KTtcXFxcbn1cXFxcblxcXFxuLyogVmlzaWJsZSAqL1xcXFxuLnVpLnNlbGVjdGlvbi52aXNpYmxlLmRyb3Bkb3duID4gLnRleHRbZGF0YS12LWEzZGJmYzBjXTpub3QoLmRlZmF1bHQpIHtcXFxcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXFxcbiAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44KTtcXFxcbn1cXFxcblxcXFxuLyogVmlzaWJsZSBIb3ZlciAqL1xcXFxuLnVpLnNlbGVjdGlvbi5hY3RpdmUuZHJvcGRvd25bZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJvcmRlci1jb2xvcjogIzk2QzhEQTtcXFxcbiAgYm94LXNoYWRvdzogMHB4IDJweCAzcHggMHB4IHJnYmEoMzQsIDM2LCAzOCwgMC4xNSk7XFxcXG59XFxcXG4udWkuc2VsZWN0aW9uLmFjdGl2ZS5kcm9wZG93bjpob3ZlciAubWVudVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjOTZDOERBO1xcXFxuICBib3gtc2hhZG93OiAwcHggMnB4IDNweCAwcHggcmdiYSgzNCwgMzYsIDM4LCAwLjE1KTtcXFxcbn1cXFxcblxcXFxuLyogRHJvcGRvd24gSWNvbiAqL1xcXFxuLnVpLmFjdGl2ZS5zZWxlY3Rpb24uZHJvcGRvd24gPiAuZHJvcGRvd24uaWNvbltkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLnZpc2libGUuc2VsZWN0aW9uLmRyb3Bkb3duID4gLmRyb3Bkb3duLmljb25bZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG9wYWNpdHk6IDE7XFxcXG4gIHotaW5kZXg6IDM7XFxcXG59XFxcXG5cXFxcbi8qIENvbm5lY3RpbmcgQm9yZGVyICovXFxcXG4udWkuYWN0aXZlLnNlbGVjdGlvbi5kcm9wZG93bltkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMGVtICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwZW0gIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogRW1wdHkgQ29ubmVjdGluZyBCb3JkZXIgKi9cXFxcbi51aS5hY3RpdmUuZW1wdHkuc2VsZWN0aW9uLmRyb3Bkb3duW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5cmVtICFpbXBvcnRhbnQ7XFxcXG4gIGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcXFxcbn1cXFxcbi51aS5hY3RpdmUuZW1wdHkuc2VsZWN0aW9uLmRyb3Bkb3duIC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBib3JkZXI6IG5vbmUgIWltcG9ydGFudDtcXFxcbiAgYm94LXNoYWRvdzogbm9uZSAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gICBTZWFyY2hhYmxlXFxcXG4tLS0tLS0tLS0tLS0tLS0qL1xcXFxuXFxcXG5cXFxcbi8qIFNlYXJjaCBTZWxlY3Rpb24gKi9cXFxcbi51aS5zZWFyY2guZHJvcGRvd25bZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG1pbi13aWR0aDogJyc7XFxcXG59XFxcXG5cXFxcbi8qIFNlYXJjaCBEcm9wZG93biAqL1xcXFxuLnVpLnNlYXJjaC5kcm9wZG93biA+IGlucHV0LnNlYXJjaFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgYmFja2dyb3VuZDogbm9uZSB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xcXFxuICBib3JkZXI6IG5vbmUgIWltcG9ydGFudDtcXFxcbiAgYm94LXNoYWRvdzogbm9uZSAhaW1wb3J0YW50O1xcXFxuICBjdXJzb3I6IHRleHQ7XFxcXG4gIHRvcDogMGVtO1xcXFxuICBsZWZ0OiAxcHg7XFxcXG4gIHdpZHRoOiAxMDAlO1xcXFxuICBvdXRsaW5lOiBub25lO1xcXFxuICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMCk7XFxcXG4gIHBhZGRpbmc6IGluaGVyaXQ7XFxcXG59XFxcXG5cXFxcbi8qIFRleHQgTGF5ZXJpbmcgKi9cXFxcbi51aS5zZWFyY2guZHJvcGRvd24gPiBpbnB1dC5zZWFyY2hbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcbiAgei1pbmRleDogMjtcXFxcbn1cXFxcbi51aS5zZWFyY2guZHJvcGRvd24gPiAudGV4dFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgY3Vyc29yOiB0ZXh0O1xcXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxcXG4gIGxlZnQ6IDFweDtcXFxcbiAgei1pbmRleDogMztcXFxcbn1cXFxcblxcXFxuLyogU2VhcmNoIFNlbGVjdGlvbiAqL1xcXFxuLnVpLnNlYXJjaC5zZWxlY3Rpb24uZHJvcGRvd24gPiBpbnB1dC5zZWFyY2hbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGxpbmUtaGVpZ2h0OiAxLjIxNDJlbTtcXFxcbiAgcGFkZGluZzogMC42Nzg2MTQyOWVtIDIuMWVtIDAuNjc4NjE0MjllbSAxZW07XFxcXG59XFxcXG5cXFxcbi8qIFVzZWQgdG8gc2l6ZSBtdWx0aSBzZWxlY3QgaW5wdXQgdG8gY2hhcmFjdGVyIHdpZHRoICovXFxcXG4udWkuc2VhcmNoLnNlbGVjdGlvbi5kcm9wZG93biA+IHNwYW4uc2l6ZXJbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGxpbmUtaGVpZ2h0OiAxLjIxNDJlbTtcXFxcbiAgcGFkZGluZzogMC42Nzg2MTQyOWVtIDIuMWVtIDAuNjc4NjE0MjllbSAxZW07XFxcXG4gIGRpc3BsYXk6IG5vbmU7XFxcXG4gIHdoaXRlLXNwYWNlOiBwcmU7XFxcXG59XFxcXG5cXFxcbi8qIEFjdGl2ZS9WaXNpYmxlIFNlYXJjaCAqL1xcXFxuLnVpLnNlYXJjaC5kcm9wZG93bi5hY3RpdmUgPiBpbnB1dC5zZWFyY2hbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5zZWFyY2guZHJvcGRvd24udmlzaWJsZSA+IGlucHV0LnNlYXJjaFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgY3Vyc29yOiBhdXRvO1xcXFxufVxcXFxuLnVpLnNlYXJjaC5kcm9wZG93bi5hY3RpdmUgPiAudGV4dFtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLnNlYXJjaC5kcm9wZG93bi52aXNpYmxlID4gLnRleHRbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcXFxufVxcXFxuXFxcXG4vKiBGaWx0ZXJlZCBUZXh0ICovXFxcXG4udWkuYWN0aXZlLnNlYXJjaC5kcm9wZG93biBpbnB1dC5zZWFyY2g6Zm9jdXMgKyAudGV4dCAuaWNvbltkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmFjdGl2ZS5zZWFyY2guZHJvcGRvd24gaW5wdXQuc2VhcmNoOmZvY3VzICsgLnRleHQgLmZsYWdbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG9wYWNpdHk6IDAuNDU7XFxcXG59XFxcXG4udWkuYWN0aXZlLnNlYXJjaC5kcm9wZG93biBpbnB1dC5zZWFyY2g6Zm9jdXMgKyAudGV4dFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgY29sb3I6IHJnYmEoMTE1LCAxMTUsIDExNSwgMC44NykgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogU2VhcmNoIE1lbnUgKi9cXFxcbi51aS5zZWFyY2guZHJvcGRvd24gLm1lbnVbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcXFxcbiAgb3ZlcmZsb3cteTogYXV0bztcXFxcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxcXG4gICAgICAgICAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcXFxuICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2g7XFxcXG59XFxcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDc2N3B4KSB7XFxcXG4udWkuc2VhcmNoLmRyb3Bkb3duIC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICAgIG1heC1oZWlnaHQ6IDguMDE0Mjg1NzFyZW07XFxcXG59XFxcXG59XFxcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDc2OHB4KSB7XFxcXG4udWkuc2VhcmNoLmRyb3Bkb3duIC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICAgIG1heC1oZWlnaHQ6IDEwLjY4NTcxNDI5cmVtO1xcXFxufVxcXFxufVxcXFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA5OTJweCkge1xcXFxuLnVpLnNlYXJjaC5kcm9wZG93biAubWVudVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgICBtYXgtaGVpZ2h0OiAxNi4wMjg1NzE0M3JlbTtcXFxcbn1cXFxcbn1cXFxcbkBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogMTkyMHB4KSB7XFxcXG4udWkuc2VhcmNoLmRyb3Bkb3duIC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICAgIG1heC1oZWlnaHQ6IDIxLjM3MTQyODU3cmVtO1xcXFxufVxcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gICAgTXVsdGlwbGVcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG5cXFxcblxcXFxuLyogTXVsdGlwbGUgU2VsZWN0aW9uICovXFxcXG4udWkubXVsdGlwbGUuZHJvcGRvd25bZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIHBhZGRpbmc6IDAuMjI2MjA0NzZlbSAyLjFlbSAwLjIyNjIwNDc2ZW0gMC4zNTcxNDI4NmVtO1xcXFxufVxcXFxuLnVpLm11bHRpcGxlLmRyb3Bkb3duIC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBjdXJzb3I6IGF1dG87XFxcXG59XFxcXG5cXFxcbi8qIE11bHRpcGxlIFNlYXJjaCBTZWxlY3Rpb24gKi9cXFxcbi51aS5tdWx0aXBsZS5zZWFyY2guZHJvcGRvd25bZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5tdWx0aXBsZS5zZWFyY2guZHJvcGRvd24gPiBpbnB1dC5zZWFyY2hbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGN1cnNvcjogdGV4dDtcXFxcbn1cXFxcblxcXFxuLyogU2VsZWN0aW9uIExhYmVsICovXFxcXG4udWkubXVsdGlwbGUuZHJvcGRvd24gPiAubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxcXG4gICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxcXG4gICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxcXG4gICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXFxcbiAgdmVydGljYWwtYWxpZ246IHRvcDtcXFxcbiAgd2hpdGUtc3BhY2U6IG5vcm1hbDtcXFxcbiAgZm9udC1zaXplOiAxZW07XFxcXG4gIHBhZGRpbmc6IDAuMzU3MTQyODZlbSAwLjc4NTcxNDI5ZW07XFxcXG4gIG1hcmdpbjogMC4xNDI4NTcxNHJlbSAwLjI4NTcxNDI5cmVtIDAuMTQyODU3MTRyZW0gMGVtO1xcXFxuICBib3gtc2hhZG93OiAwcHggMHB4IDBweCAxcHggcmdiYSgzNCwgMzYsIDM4LCAwLjE1KSBpbnNldDtcXFxcbn1cXFxcblxcXFxuLyogRHJvcGRvd24gSWNvbiAqL1xcXFxuLnVpLm11bHRpcGxlLmRyb3Bkb3duIC5kcm9wZG93bi5pY29uW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBtYXJnaW46ICcnO1xcXFxuICBwYWRkaW5nOiAnJztcXFxcbn1cXFxcblxcXFxuLyogVGV4dCAqL1xcXFxuLnVpLm11bHRpcGxlLmRyb3Bkb3duID4gLnRleHRbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIHBvc2l0aW9uOiBzdGF0aWM7XFxcXG4gIHBhZGRpbmc6IDA7XFxcXG4gIG1heC13aWR0aDogMTAwJTtcXFxcbiAgbWFyZ2luOiAwLjQ1MjQwOTUyZW0gMGVtIDAuNDUyNDA5NTJlbSAwLjY0Mjg1NzE0ZW07XFxcXG4gIGxpbmUtaGVpZ2h0OiAxLjIxNDI4NTcxZW07XFxcXG59XFxcXG4udWkubXVsdGlwbGUuZHJvcGRvd24gPiAubGFiZWwgfiBpbnB1dC5zZWFyY2hbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG1hcmdpbi1sZWZ0OiAwLjE0Mjg1NzE0ZW0gIWltcG9ydGFudDtcXFxcbn1cXFxcbi51aS5tdWx0aXBsZS5kcm9wZG93biA+IC5sYWJlbCB+IC50ZXh0W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBkaXNwbGF5OiBub25lO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gIE11bHRpcGxlIFNlYXJjaFxcXFxuLS0tLS0tLS0tLS0tLS0tLS0qL1xcXFxuXFxcXG5cXFxcbi8qIFByb21wdCBUZXh0ICovXFxcXG4udWkubXVsdGlwbGUuc2VhcmNoLmRyb3Bkb3duID4gLnRleHRbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXFxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcXFxuICB0b3A6IDA7XFxcXG4gIGxlZnQ6IDA7XFxcXG4gIHBhZGRpbmc6IGluaGVyaXQ7XFxcXG4gIG1hcmdpbjogMC40NTI0MDk1MmVtIDBlbSAwLjQ1MjQwOTUyZW0gMC42NDI4NTcxNGVtO1xcXFxuICBsaW5lLWhlaWdodDogMS4yMTQyODU3MWVtO1xcXFxufVxcXFxuLnVpLm11bHRpcGxlLnNlYXJjaC5kcm9wZG93biA+IC5sYWJlbCB+IC50ZXh0W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBkaXNwbGF5OiBub25lO1xcXFxufVxcXFxuXFxcXG4vKiBTZWFyY2ggKi9cXFxcbi51aS5tdWx0aXBsZS5zZWFyY2guZHJvcGRvd24gPiBpbnB1dC5zZWFyY2hbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIHBvc2l0aW9uOiBzdGF0aWM7XFxcXG4gIHBhZGRpbmc6IDA7XFxcXG4gIG1heC13aWR0aDogMTAwJTtcXFxcbiAgbWFyZ2luOiAwLjQ1MjQwOTUyZW0gMGVtIDAuNDUyNDA5NTJlbSAwLjY0Mjg1NzE0ZW07XFxcXG4gIHdpZHRoOiAyLjJlbTtcXFxcbiAgbGluZS1oZWlnaHQ6IDEuMjE0Mjg1NzFlbTtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgICBJbmxpbmVcXFxcbi0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuaW5saW5lLmRyb3Bkb3duW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXFxcbiAgY29sb3I6IGluaGVyaXQ7XFxcXG59XFxcXG4udWkuaW5saW5lLmRyb3Bkb3duIC5kcm9wZG93bi5pY29uW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBtYXJnaW46IDBlbSAwLjVlbSAwZW0gMC4yMTQyODU3MWVtO1xcXFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxcXG59XFxcXG4udWkuaW5saW5lLmRyb3Bkb3duID4gLnRleHRbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcXFxufVxcXFxuLnVpLmlubGluZS5kcm9wZG93biAubWVudVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgY3Vyc29yOiBhdXRvO1xcXFxuICBtYXJnaW4tdG9wOiAwLjIxNDI4NTcxZW07XFxcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjg1NzE0MjlyZW07XFxcXG59XFxcXG5cXFxcblxcXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXFxcbiAgICAgICAgICAgIFN0YXRlc1xcXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXFxcblxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gICAgICAgIEFjdGl2ZVxcXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG5cXFxcblxcXFxuLyogTWVudSBJdGVtIEFjdGl2ZSAqL1xcXFxuLnVpLmRyb3Bkb3duIC5tZW51IC5hY3RpdmUuaXRlbVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcXFxuICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjk1KTtcXFxcbiAgYm94LXNoYWRvdzogbm9uZTtcXFxcbiAgei1pbmRleDogMTI7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgICAgSG92ZXJcXFxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcXFxuXFxcXG5cXFxcbi8qIE1lbnUgSXRlbSBIb3ZlciAqL1xcXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW1bZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4wNSk7XFxcXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOTUpO1xcXFxuICB6LWluZGV4OiAxMztcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLVxcXFxuICAgICAgIExvYWRpbmdcXFxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkubG9hZGluZy5kcm9wZG93biA+IGkuaWNvbltkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgaGVpZ2h0OiAxZW0gIWltcG9ydGFudDtcXFxcbiAgcGFkZGluZzogMS4xNDI4NTcxNGVtIDEuMDcxNDI4NTdlbSAhaW1wb3J0YW50O1xcXFxufVxcXFxuLnVpLmxvYWRpbmcuZHJvcGRvd24gPiBpLmljb25bZGF0YS12LWEzZGJmYzBjXTpiZWZvcmUge1xcXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxcXG4gIGNvbnRlbnQ6ICcnO1xcXFxuICB0b3A6IDUwJTtcXFxcbiAgbGVmdDogNTAlO1xcXFxuICBtYXJnaW46IC0wLjY0Mjg1NzE0ZW0gMGVtIDBlbSAtMC42NDI4NTcxNGVtO1xcXFxuICB3aWR0aDogMS4yODU3MTQyOWVtO1xcXFxuICBoZWlnaHQ6IDEuMjg1NzE0MjllbTtcXFxcbiAgYm9yZGVyLXJhZGl1czogNTAwcmVtO1xcXFxuICBib3JkZXI6IDAuMmVtIHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4xKTtcXFxcbn1cXFxcbi51aS5sb2FkaW5nLmRyb3Bkb3duID4gaS5pY29uW2RhdGEtdi1hM2RiZmMwY106YWZ0ZXIge1xcXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxcXG4gIGNvbnRlbnQ6ICcnO1xcXFxuICB0b3A6IDUwJTtcXFxcbiAgbGVmdDogNTAlO1xcXFxuICBib3gtc2hhZG93OiAwcHggMHB4IDBweCAxcHggdHJhbnNwYXJlbnQ7XFxcXG4gIG1hcmdpbjogLTAuNjQyODU3MTRlbSAwZW0gMGVtIC0wLjY0Mjg1NzE0ZW07XFxcXG4gIHdpZHRoOiAxLjI4NTcxNDI5ZW07XFxcXG4gIGhlaWdodDogMS4yODU3MTQyOWVtO1xcXFxuICAtd2Via2l0LWFuaW1hdGlvbjogZHJvcGRvd24tc3BpbiAwLjZzIGxpbmVhcjtcXFxcbiAgICAgICAgICBhbmltYXRpb246IGRyb3Bkb3duLXNwaW4gMC42cyBsaW5lYXI7XFxcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogaW5maW5pdGU7XFxcXG4gICAgICAgICAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogaW5maW5pdGU7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDUwMHJlbTtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjNzY3Njc2IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O1xcXFxuICBib3JkZXItc3R5bGU6IHNvbGlkO1xcXFxuICBib3JkZXItd2lkdGg6IDAuMmVtO1xcXFxufVxcXFxuXFxcXG4vKiBDb3VwbGluZyAqL1xcXFxuLnVpLmxvYWRpbmcuZHJvcGRvd24uYnV0dG9uID4gaS5pY29uW2RhdGEtdi1hM2RiZmMwY106YmVmb3JlLFxcXFxuLnVpLmxvYWRpbmcuZHJvcGRvd24uYnV0dG9uID4gaS5pY29uW2RhdGEtdi1hM2RiZmMwY106YWZ0ZXIge1xcXFxuICBkaXNwbGF5OiBub25lO1xcXFxufVxcXFxuQC13ZWJraXQta2V5ZnJhbWVzIGRyb3Bkb3duLXNwaW4ge1xcXFxuZnJvbSB7XFxcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXFxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcXFxufVxcXFxudG8ge1xcXFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXFxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxcXG59XFxcXG59XFxcXG5Aa2V5ZnJhbWVzIGRyb3Bkb3duLXNwaW4ge1xcXFxuZnJvbSB7XFxcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXFxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcXFxufVxcXFxudG8ge1xcXFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXFxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxcXG59XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgRGVmYXVsdCBUZXh0XFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXFxcbi51aS5kcm9wZG93bjpub3QoLmJ1dHRvbikgPiAuZGVmYXVsdC50ZXh0W2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuZGVmYXVsdC5kcm9wZG93bjpub3QoLmJ1dHRvbikgPiAudGV4dFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgY29sb3I6IHJnYmEoMTkxLCAxOTEsIDE5MSwgMC44Nyk7XFxcXG59XFxcXG4udWkuZHJvcGRvd246bm90KC5idXR0b24pID4gaW5wdXQ6Zm9jdXMgKyAuZGVmYXVsdC50ZXh0W2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuZGVmYXVsdC5kcm9wZG93bjpub3QoLmJ1dHRvbikgPiBpbnB1dDpmb2N1cyArIC50ZXh0W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBjb2xvcjogcmdiYSgxMTUsIDExNSwgMTE1LCAwLjg3KTtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLVxcXFxuICAgICAgICBMb2FkaW5nXFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXFxcbi51aS5sb2FkaW5nLmRyb3Bkb3duID4gLnRleHRbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogbm9uZTtcXFxcbiAgdHJhbnNpdGlvbjogbm9uZTtcXFxcbn1cXFxcblxcXFxuLyogVXNlZCBUbyBDaGVjayBQb3NpdGlvbiAqL1xcXFxuLnVpLmRyb3Bkb3duIC5sb2FkaW5nLm1lbnVbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGRpc3BsYXk6IGJsb2NrO1xcXFxuICB2aXNpYmlsaXR5OiBoaWRkZW47XFxcXG4gIHotaW5kZXg6IC0xO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gICAgS2V5Ym9hcmQgU2VsZWN0XFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiBTZWxlY3RlZCBJdGVtICovXFxcXG4udWkuZHJvcGRvd24uc2VsZWN0ZWRbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5kcm9wZG93biAubWVudSAuc2VsZWN0ZWQuaXRlbVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjAzKTtcXFxcbiAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC45NSk7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbiAgICBTZWFyY2ggRmlsdGVyZWRcXFxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcXFxuXFxcXG5cXFxcbi8qIEZpbHRlcmVkIEl0ZW0gKi9cXFxcbi51aS5kcm9wZG93biA+IC5maWx0ZXJlZC50ZXh0W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICB2aXNpYmlsaXR5OiBoaWRkZW47XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLmZpbHRlcmVkLml0ZW1bZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLVxcXFxuICAgICAgICBFcnJvclxcXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZHJvcGRvd24uZXJyb3JbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5kcm9wZG93bi5lcnJvciA+IC50ZXh0W2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuZHJvcGRvd24uZXJyb3IgPiAuZGVmYXVsdC50ZXh0W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBjb2xvcjogIzlGM0EzODtcXFxcbn1cXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24uZXJyb3JbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJhY2tncm91bmQ6ICNGRkY2RjY7XFxcXG4gIGJvcmRlci1jb2xvcjogI0UwQjRCNDtcXFxcbn1cXFxcbi51aS5zZWxlY3Rpb24uZHJvcGRvd24uZXJyb3JbZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJvcmRlci1jb2xvcjogI0UwQjRCNDtcXFxcbn1cXFxcbi51aS5kcm9wZG93bi5lcnJvciA+IC5tZW51W2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuZHJvcGRvd24uZXJyb3IgPiAubWVudSAubWVudVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjRTBCNEI0O1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duLmVycm9yID4gLm1lbnUgPiAuaXRlbVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgY29sb3I6ICM5RjNBMzg7XFxcXG59XFxcXG4udWkubXVsdGlwbGUuc2VsZWN0aW9uLmVycm9yLmRyb3Bkb3duID4gLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBib3JkZXItY29sb3I6ICNFMEI0QjQ7XFxcXG59XFxcXG5cXFxcbi8qIEl0ZW0gSG92ZXIgKi9cXFxcbi51aS5kcm9wZG93bi5lcnJvciA+IC5tZW51ID4gLml0ZW1bZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGRkYyRjI7XFxcXG59XFxcXG5cXFxcbi8qIEl0ZW0gQWN0aXZlICovXFxcXG4udWkuZHJvcGRvd24uZXJyb3IgPiAubWVudSAuYWN0aXZlLml0ZW1bZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGRENGQ0Y7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgICAgRGlzYWJsZWRcXFxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcXFxuXFxcXG5cXFxcbi8qIERpc2FibGVkICovXFxcXG4udWkuZGlzYWJsZWQuZHJvcGRvd25bZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5kcm9wZG93biAubWVudSA+IC5kaXNhYmxlZC5pdGVtW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcXFxuICBvcGFjaXR5OiAwLjQ1O1xcXFxufVxcXFxuXFxcXG5cXFxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxcXG4gICAgICAgICAgIFZhcmlhdGlvbnNcXFxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxcXG5cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgIERpcmVjdGlvblxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiBGbHlvdXQgRGlyZWN0aW9uICovXFxcXG4udWkuZHJvcGRvd24gLm1lbnVbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGxlZnQ6IDBweDtcXFxcbn1cXFxcblxcXFxuLyogRGVmYXVsdCBTaWRlIChSaWdodCkgKi9cXFxcbi51aS5kcm9wZG93biAucmlnaHQubWVudSA+IC5tZW51W2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgLnJpZ2h0Lm1lbnVbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGxlZnQ6IDEwMCUgIWltcG9ydGFudDtcXFxcbiAgcmlnaHQ6IGF1dG8gIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLXJhZGl1czogMC4yODU3MTQyOXJlbSAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBMZWZ0IEZseW91dCBNZW51ICovXFxcXG4udWkuZHJvcGRvd24gPiAubGVmdC5tZW51IC5tZW51W2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgLmxlZnQubWVudVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgbGVmdDogYXV0byAhaW1wb3J0YW50O1xcXFxuICByaWdodDogMTAwJSAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5cmVtICFpbXBvcnRhbnQ7XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLml0ZW0gLmxlZnQuZHJvcGRvd24uaWNvbltkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmRyb3Bkb3duIC5sZWZ0Lm1lbnUgLml0ZW0gLmRyb3Bkb3duLmljb25bZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIHdpZHRoOiBhdXRvO1xcXFxuICBmbG9hdDogbGVmdDtcXFxcbiAgbWFyZ2luOiAwZW0gMC43ODU3MTQyOXJlbSAwZW0gMGVtO1xcXFxufVxcXFxuLnVpLmRyb3Bkb3duIC5pdGVtIC5sZWZ0LmRyb3Bkb3duLmljb25bZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5kcm9wZG93biAubGVmdC5tZW51IC5pdGVtIC5kcm9wZG93bi5pY29uW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICB3aWR0aDogYXV0bztcXFxcbiAgZmxvYXQ6IGxlZnQ7XFxcXG4gIG1hcmdpbjogMGVtIDAuNzg1NzE0MjlyZW0gMGVtIDBlbTtcXFxcbn1cXFxcbi51aS5kcm9wZG93biAuaXRlbSAubGVmdC5kcm9wZG93bi5pY29uICsgLnRleHRbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5kcm9wZG93biAubGVmdC5tZW51IC5pdGVtIC5kcm9wZG93bi5pY29uICsgLnRleHRbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG1hcmdpbi1sZWZ0OiAxZW07XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgVXB3YXJkXFxcXG4tLS0tLS0tLS0tLS0tLS0qL1xcXFxuXFxcXG5cXFxcbi8qIFVwd2FyZCBNYWluIE1lbnUgKi9cXFxcbi51aS51cHdhcmQuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgdG9wOiBhdXRvO1xcXFxuICBib3R0b206IDEwMCU7XFxcXG4gIGJveC1zaGFkb3c6IDBweCAwcHggM3B4IDBweCByZ2JhKDAsIDAsIDAsIDAuMDgpO1xcXFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5cmVtIDAuMjg1NzE0MjlyZW0gMGVtIDBlbTtcXFxcbn1cXFxcblxcXFxuLyogVXB3YXJkIFN1YiBNZW51ICovXFxcXG4udWkuZHJvcGRvd24gLnVwd2FyZC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICB0b3A6IGF1dG8gIWltcG9ydGFudDtcXFxcbiAgYm90dG9tOiAwICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIEFjdGl2ZSBVcHdhcmQgKi9cXFxcbi51aS5zaW1wbGUudXB3YXJkLmFjdGl2ZS5kcm9wZG93bltkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLnNpbXBsZS51cHdhcmQuZHJvcGRvd25bZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjg1NzE0MjlyZW0gMC4yODU3MTQyOXJlbSAwZW0gMGVtICFpbXBvcnRhbnQ7XFxcXG59XFxcXG4udWkudXB3YXJkLmRyb3Bkb3duLmJ1dHRvbjpub3QoLnBvaW50aW5nKTpub3QoLmZsb2F0aW5nKS5hY3RpdmVbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjg1NzE0MjlyZW0gMC4yODU3MTQyOXJlbSAwZW0gMGVtO1xcXFxufVxcXFxuXFxcXG4vKiBTZWxlY3Rpb24gKi9cXFxcbi51aS51cHdhcmQuc2VsZWN0aW9uLmRyb3Bkb3duIC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBib3JkZXItdG9wLXdpZHRoOiAxcHggIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWJvdHRvbS13aWR0aDogMHB4ICFpbXBvcnRhbnQ7XFxcXG4gIGJveC1zaGFkb3c6IDBweCAtMnB4IDNweCAwcHggcmdiYSgwLCAwLCAwLCAwLjA4KTtcXFxcbn1cXFxcbi51aS51cHdhcmQuc2VsZWN0aW9uLmRyb3Bkb3duW2RhdGEtdi1hM2RiZmMwY106aG92ZXIge1xcXFxuICBib3gtc2hhZG93OiAwcHggMHB4IDJweCAwcHggcmdiYSgwLCAwLCAwLCAwLjA1KTtcXFxcbn1cXFxcblxcXFxuLyogQWN0aXZlIFVwd2FyZCAqL1xcXFxuLnVpLmFjdGl2ZS51cHdhcmQuc2VsZWN0aW9uLmRyb3Bkb3duW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBib3JkZXItcmFkaXVzOiAwZW0gMGVtIDAuMjg1NzE0MjlyZW0gMC4yODU3MTQyOXJlbSAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBWaXNpYmxlIFVwd2FyZCAqL1xcXFxuLnVpLnVwd2FyZC5zZWxlY3Rpb24uZHJvcGRvd24udmlzaWJsZVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgYm94LXNoYWRvdzogMHB4IDBweCAzcHggMHB4IHJnYmEoMCwgMCwgMCwgMC4wOCk7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDBlbSAwZW0gMC4yODU3MTQyOXJlbSAwLjI4NTcxNDI5cmVtICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIFZpc2libGUgSG92ZXIgVXB3YXJkICovXFxcXG4udWkudXB3YXJkLmFjdGl2ZS5zZWxlY3Rpb24uZHJvcGRvd25bZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJveC1zaGFkb3c6IDBweCAwcHggM3B4IDBweCByZ2JhKDAsIDAsIDAsIDAuMDUpO1xcXFxufVxcXFxuLnVpLnVwd2FyZC5hY3RpdmUuc2VsZWN0aW9uLmRyb3Bkb3duOmhvdmVyIC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBib3gtc2hhZG93OiAwcHggLTJweCAzcHggMHB4IHJnYmEoMCwgMCwgMCwgMC4wOCk7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgU2ltcGxlXFxcXG4tLS0tLS0tLS0tLS0tLS0qL1xcXFxuXFxcXG5cXFxcbi8qICBTZWxlY3Rpb24gTWVudSAqL1xcXFxuLnVpLnNjcm9sbGluZy5kcm9wZG93biAubWVudVtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmRyb3Bkb3duIC5zY3JvbGxpbmcubWVudVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgb3ZlcmZsb3cteDogaGlkZGVuO1xcXFxuICBvdmVyZmxvdy15OiBhdXRvO1xcXFxufVxcXFxuLnVpLnNjcm9sbGluZy5kcm9wZG93biAubWVudVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgb3ZlcmZsb3cteDogaGlkZGVuO1xcXFxuICBvdmVyZmxvdy15OiBhdXRvO1xcXFxuICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXFxcbiAgICAgICAgICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxcXG4gIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcXFxcbiAgbWluLXdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7XFxcXG4gIHdpZHRoOiBhdXRvICFpbXBvcnRhbnQ7XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLnNjcm9sbGluZy5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBwb3NpdGlvbjogc3RhdGljO1xcXFxuICBvdmVyZmxvdy15OiBhdXRvO1xcXFxuICBib3JkZXI6IG5vbmU7XFxcXG4gIGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLXJhZGl1czogMCAhaW1wb3J0YW50O1xcXFxuICBtYXJnaW46IDAgIWltcG9ydGFudDtcXFxcbiAgbWluLXdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7XFxcXG4gIHdpZHRoOiBhdXRvICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCByZ2JhKDM0LCAzNiwgMzgsIDAuMTUpO1xcXFxufVxcXFxuLnVpLnNjcm9sbGluZy5kcm9wZG93biAubWVudSAuaXRlbS5pdGVtLml0ZW1bZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5kcm9wZG93biAuc2Nyb2xsaW5nLm1lbnUgPiAuaXRlbS5pdGVtLml0ZW1bZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJvcmRlci10b3A6IG5vbmU7XFxcXG4gIHBhZGRpbmctcmlnaHQ6IGNhbGMoIDEuMTQyODU3MTRyZW0gICsgIDE3cHggKSAhaW1wb3J0YW50O1xcXFxufVxcXFxuLnVpLnNjcm9sbGluZy5kcm9wZG93biAubWVudSAuaXRlbVtkYXRhLXYtYTNkYmZjMGNdOmZpcnN0LWNoaWxkLFxcXFxuLnVpLmRyb3Bkb3duIC5zY3JvbGxpbmcubWVudSAuaXRlbVtkYXRhLXYtYTNkYmZjMGNdOmZpcnN0LWNoaWxkIHtcXFxcbiAgYm9yZGVyLXRvcDogbm9uZTtcXFxcbn1cXFxcbi51aS5kcm9wZG93biA+IC5hbmltYXRpbmcubWVudSAuc2Nyb2xsaW5nLm1lbnVbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5kcm9wZG93biA+IC52aXNpYmxlLm1lbnUgLnNjcm9sbGluZy5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBkaXNwbGF5OiBibG9jaztcXFxcbn1cXFxcblxcXFxuLyogU2Nyb2xsYmFyIGluIElFICovXFxcXG5AbWVkaWEgYWxsIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6IG5vbmUpIHtcXFxcbi51aS5zY3JvbGxpbmcuZHJvcGRvd24gLm1lbnVbZGF0YS12LWEzZGJmYzBjXSxcXFxcbiAgLnVpLmRyb3Bkb3duIC5zY3JvbGxpbmcubWVudVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgICBtaW4td2lkdGg6IGNhbGMoMTAwJSAtICAxN3B4ICk7XFxcXG59XFxcXG59XFxcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDc2N3B4KSB7XFxcXG4udWkuc2Nyb2xsaW5nLmRyb3Bkb3duIC5tZW51W2RhdGEtdi1hM2RiZmMwY10sXFxcXG4gIC51aS5kcm9wZG93biAuc2Nyb2xsaW5nLm1lbnVbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gICAgbWF4LWhlaWdodDogMTAuMjg1NzE0MjlyZW07XFxcXG59XFxcXG59XFxcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDc2OHB4KSB7XFxcXG4udWkuc2Nyb2xsaW5nLmRyb3Bkb3duIC5tZW51W2RhdGEtdi1hM2RiZmMwY10sXFxcXG4gIC51aS5kcm9wZG93biAuc2Nyb2xsaW5nLm1lbnVbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gICAgbWF4LWhlaWdodDogMTUuNDI4NTcxNDNyZW07XFxcXG59XFxcXG59XFxcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDk5MnB4KSB7XFxcXG4udWkuc2Nyb2xsaW5nLmRyb3Bkb3duIC5tZW51W2RhdGEtdi1hM2RiZmMwY10sXFxcXG4gIC51aS5kcm9wZG93biAuc2Nyb2xsaW5nLm1lbnVbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gICAgbWF4LWhlaWdodDogMjAuNTcxNDI4NTdyZW07XFxcXG59XFxcXG59XFxcXG5AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDE5MjBweCkge1xcXFxuLnVpLnNjcm9sbGluZy5kcm9wZG93biAubWVudVtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuICAudWkuZHJvcGRvd24gLnNjcm9sbGluZy5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICAgIG1heC1oZWlnaHQ6IDIwLjU3MTQyODU3cmVtO1xcXFxufVxcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gICAgIFNpbXBsZVxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcblxcXFxuXFxcXG4vKiBEaXNwbGF5cyB3aXRob3V0IGphdmFzY3JpcHQgKi9cXFxcbi51aS5zaW1wbGUuZHJvcGRvd24gLm1lbnVbZGF0YS12LWEzZGJmYzBjXTpiZWZvcmUsXFxcXG4udWkuc2ltcGxlLmRyb3Bkb3duIC5tZW51W2RhdGEtdi1hM2RiZmMwY106YWZ0ZXIge1xcXFxuICBkaXNwbGF5OiBub25lO1xcXFxufVxcXFxuLnVpLnNpbXBsZS5kcm9wZG93biAubWVudVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcXFxuICBkaXNwbGF5OiBibG9jaztcXFxcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXFxcbiAgdG9wOiAtOTk5OXB4ICFpbXBvcnRhbnQ7XFxcXG4gIG9wYWNpdHk6IDA7XFxcXG4gIHdpZHRoOiAwO1xcXFxuICBoZWlnaHQ6IDA7XFxcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAwLjFzIGVhc2U7XFxcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMC4xcyBlYXNlO1xcXFxufVxcXFxuLnVpLnNpbXBsZS5hY3RpdmUuZHJvcGRvd25bZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5zaW1wbGUuZHJvcGRvd25bZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDBlbSAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMGVtICFpbXBvcnRhbnQ7XFxcXG59XFxcXG4udWkuc2ltcGxlLmFjdGl2ZS5kcm9wZG93biA+IC5tZW51W2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuc2ltcGxlLmRyb3Bkb3duOmhvdmVyID4gLm1lbnVbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG92ZXJmbG93OiB2aXNpYmxlO1xcXFxuICB3aWR0aDogYXV0bztcXFxcbiAgaGVpZ2h0OiBhdXRvO1xcXFxuICB0b3A6IDEwMCUgIWltcG9ydGFudDtcXFxcbiAgb3BhY2l0eTogMTtcXFxcbn1cXFxcbi51aS5zaW1wbGUuZHJvcGRvd24gPiAubWVudSA+IC5pdGVtOmFjdGl2ZSA+IC5tZW51W2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuc2ltcGxlLmRyb3Bkb3duOmhvdmVyID4gLm1lbnUgPiAuaXRlbTpob3ZlciA+IC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBvdmVyZmxvdzogdmlzaWJsZTtcXFxcbiAgd2lkdGg6IGF1dG87XFxcXG4gIGhlaWdodDogYXV0bztcXFxcbiAgdG9wOiAwJSAhaW1wb3J0YW50O1xcXFxuICBsZWZ0OiAxMDAlICFpbXBvcnRhbnQ7XFxcXG4gIG9wYWNpdHk6IDE7XFxcXG59XFxcXG4udWkuc2ltcGxlLmRpc2FibGVkLmRyb3Bkb3duOmhvdmVyIC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBkaXNwbGF5OiBub25lO1xcXFxuICBoZWlnaHQ6IDBweDtcXFxcbiAgd2lkdGg6IDBweDtcXFxcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXFxcbn1cXFxcblxcXFxuLyogVmlzaWJsZSAqL1xcXFxuLnVpLnNpbXBsZS52aXNpYmxlLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGRpc3BsYXk6IGJsb2NrO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tXFxcXG4gICAgICBGbHVpZFxcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcbi51aS5mbHVpZC5kcm9wZG93bltkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgZGlzcGxheTogYmxvY2s7XFxcXG4gIHdpZHRoOiAxMDAlO1xcXFxuICBtaW4td2lkdGg6IDBlbTtcXFxcbn1cXFxcbi51aS5mbHVpZC5kcm9wZG93biA+IC5kcm9wZG93bi5pY29uW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBmbG9hdDogcmlnaHQ7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS1cXFxcbiAgICBGbG9hdGluZ1xcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcbi51aS5mbG9hdGluZy5kcm9wZG93biAubWVudVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgbGVmdDogMDtcXFxcbiAgcmlnaHQ6IGF1dG87XFxcXG4gIGJveC1zaGFkb3c6IDBweCAycHggNHB4IDBweCByZ2JhKDM0LCAzNiwgMzgsIDAuMTIpLCAwcHggMnB4IDEwcHggMHB4IHJnYmEoMzQsIDM2LCAzOCwgMC4xNSkgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLXJhZGl1czogMC4yODU3MTQyOXJlbSAhaW1wb3J0YW50O1xcXFxufVxcXFxuLnVpLmZsb2F0aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG1hcmdpbi10b3A6IDAuNWVtICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjg1NzE0MjlyZW0gIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLVxcXFxuICAgICBQb2ludGluZ1xcXFxuLS0tLS0tLS0tLS0tLS0tKi9cXFxcbi51aS5wb2ludGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICB0b3A6IDEwMCU7XFxcXG4gIG1hcmdpbi10b3A6IDAuNzg1NzE0MjlyZW07XFxcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjg1NzE0MjlyZW07XFxcXG59XFxcXG4udWkucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtYTNkYmZjMGNdOmFmdGVyIHtcXFxcbiAgZGlzcGxheTogYmxvY2s7XFxcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxcXG4gIGNvbnRlbnQ6ICcnO1xcXFxuICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcXFxuICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXFxcbiAgICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxcXG4gICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcXFxuICB3aWR0aDogMC41ZW07XFxcXG4gIGhlaWdodDogMC41ZW07XFxcXG4gIGJveC1zaGFkb3c6IC0xcHggLTFweCAwcHggMXB4IHJnYmEoMzQsIDM2LCAzOCwgMC4xNSk7XFxcXG4gIGJhY2tncm91bmQ6ICNGRkZGRkY7XFxcXG4gIHotaW5kZXg6IDI7XFxcXG59XFxcXG4udWkucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtYTNkYmZjMGNdOmFmdGVyIHtcXFxcbiAgdG9wOiAtMC4yNWVtO1xcXFxuICBsZWZ0OiA1MCU7XFxcXG4gIG1hcmdpbjogMGVtIDBlbSAwZW0gLTAuMjVlbTtcXFxcbn1cXFxcblxcXFxuLyogVG9wIExlZnQgUG9pbnRpbmcgKi9cXFxcbi51aS50b3AubGVmdC5wb2ludGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICB0b3A6IDEwMCU7XFxcXG4gIGJvdHRvbTogYXV0bztcXFxcbiAgbGVmdDogMCU7XFxcXG4gIHJpZ2h0OiBhdXRvO1xcXFxuICBtYXJnaW46IDFlbSAwZW0gMGVtO1xcXFxufVxcXFxuLnVpLnRvcC5sZWZ0LnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIHRvcDogMTAwJTtcXFxcbiAgYm90dG9tOiBhdXRvO1xcXFxuICBsZWZ0OiAwJTtcXFxcbiAgcmlnaHQ6IGF1dG87XFxcXG4gIG1hcmdpbjogMWVtIDBlbSAwZW07XFxcXG59XFxcXG4udWkudG9wLmxlZnQucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtYTNkYmZjMGNdOmFmdGVyIHtcXFxcbiAgdG9wOiAtMC4yNWVtO1xcXFxuICBsZWZ0OiAxZW07XFxcXG4gIHJpZ2h0OiBhdXRvO1xcXFxuICBtYXJnaW46IDBlbTtcXFxcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxcXG4gICAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcXFxuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXFxcbn1cXFxcblxcXFxuLyogVG9wIFJpZ2h0ICBQb2ludGluZyAqL1xcXFxuLnVpLnRvcC5yaWdodC5wb2ludGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICB0b3A6IDEwMCU7XFxcXG4gIGJvdHRvbTogYXV0bztcXFxcbiAgcmlnaHQ6IDAlO1xcXFxuICBsZWZ0OiBhdXRvO1xcXFxuICBtYXJnaW46IDFlbSAwZW0gMGVtO1xcXFxufVxcXFxuLnVpLnRvcC5yaWdodC5wb2ludGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi1hM2RiZmMwY106YWZ0ZXIge1xcXFxuICB0b3A6IC0wLjI1ZW07XFxcXG4gIGxlZnQ6IGF1dG87XFxcXG4gIHJpZ2h0OiAxZW07XFxcXG4gIG1hcmdpbjogMGVtO1xcXFxuICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXFxcbiAgICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxcXG4gICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcXFxufVxcXFxuXFxcXG4vKiBMZWZ0IFBvaW50aW5nICovXFxcXG4udWkubGVmdC5wb2ludGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICB0b3A6IDAlO1xcXFxuICBsZWZ0OiAxMDAlO1xcXFxuICByaWdodDogYXV0bztcXFxcbiAgbWFyZ2luOiAwZW0gMGVtIDBlbSAxZW07XFxcXG59XFxcXG4udWkubGVmdC5wb2ludGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi1hM2RiZmMwY106YWZ0ZXIge1xcXFxuICB0b3A6IDFlbTtcXFxcbiAgbGVmdDogLTAuMjVlbTtcXFxcbiAgbWFyZ2luOiAwZW0gMGVtIDBlbSAwZW07XFxcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoLTQ1ZGVnKTtcXFxcbiAgICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgtNDVkZWcpO1xcXFxuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKC00NWRlZyk7XFxcXG59XFxcXG5cXFxcbi8qIFJpZ2h0IFBvaW50aW5nICovXFxcXG4udWkucmlnaHQucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgdG9wOiAwJTtcXFxcbiAgbGVmdDogYXV0bztcXFxcbiAgcmlnaHQ6IDEwMCU7XFxcXG4gIG1hcmdpbjogMGVtIDFlbSAwZW0gMGVtO1xcXFxufVxcXFxuLnVpLnJpZ2h0LnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LWEzZGJmYzBjXTphZnRlciB7XFxcXG4gIHRvcDogMWVtO1xcXFxuICBsZWZ0OiBhdXRvO1xcXFxuICByaWdodDogLTAuMjVlbTtcXFxcbiAgbWFyZ2luOiAwZW0gMGVtIDBlbSAwZW07XFxcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMTM1ZGVnKTtcXFxcbiAgICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgxMzVkZWcpO1xcXFxuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDEzNWRlZyk7XFxcXG59XFxcXG5cXFxcbi8qIEJvdHRvbSBQb2ludGluZyAqL1xcXFxuLnVpLmJvdHRvbS5wb2ludGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICB0b3A6IGF1dG87XFxcXG4gIGJvdHRvbTogMTAwJTtcXFxcbiAgbGVmdDogMCU7XFxcXG4gIHJpZ2h0OiBhdXRvO1xcXFxuICBtYXJnaW46IDBlbSAwZW0gMWVtO1xcXFxufVxcXFxuLnVpLmJvdHRvbS5wb2ludGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi1hM2RiZmMwY106YWZ0ZXIge1xcXFxuICB0b3A6IGF1dG87XFxcXG4gIGJvdHRvbTogLTAuMjVlbTtcXFxcbiAgcmlnaHQ6IGF1dG87XFxcXG4gIG1hcmdpbjogMGVtO1xcXFxuICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKC0xMzVkZWcpO1xcXFxuICAgICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKC0xMzVkZWcpO1xcXFxuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKC0xMzVkZWcpO1xcXFxufVxcXFxuXFxcXG4vKiBSZXZlcnNlIFN1Yi1NZW51IERpcmVjdGlvbiAqL1xcXFxuLnVpLmJvdHRvbS5wb2ludGluZy5kcm9wZG93biA+IC5tZW51IC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICB0b3A6IGF1dG8gIWltcG9ydGFudDtcXFxcbiAgYm90dG9tOiAwcHggIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogQm90dG9tIExlZnQgKi9cXFxcbi51aS5ib3R0b20ubGVmdC5wb2ludGluZy5kcm9wZG93biA+IC5tZW51W2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBsZWZ0OiAwJTtcXFxcbiAgcmlnaHQ6IGF1dG87XFxcXG59XFxcXG4udWkuYm90dG9tLmxlZnQucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtYTNkYmZjMGNdOmFmdGVyIHtcXFxcbiAgbGVmdDogMWVtO1xcXFxuICByaWdodDogYXV0bztcXFxcbn1cXFxcblxcXFxuLyogQm90dG9tIFJpZ2h0ICovXFxcXG4udWkuYm90dG9tLnJpZ2h0LnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIHJpZ2h0OiAwJTtcXFxcbiAgbGVmdDogYXV0bztcXFxcbn1cXFxcbi51aS5ib3R0b20ucmlnaHQucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtYTNkYmZjMGNdOmFmdGVyIHtcXFxcbiAgbGVmdDogYXV0bztcXFxcbiAgcmlnaHQ6IDFlbTtcXFxcbn1cXFxcblxcXFxuLyogVXB3YXJkIHBvaW50aW5nICovXFxcXG4udWkudXB3YXJkLnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS51cHdhcmQudG9wLnBvaW50aW5nLmRyb3Bkb3duID4gLm1lbnVbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIHRvcDogYXV0bztcXFxcbiAgYm90dG9tOiAxMDAlO1xcXFxuICBtYXJnaW46IDBlbSAwZW0gMC43ODU3MTQyOXJlbTtcXFxcbiAgYm9yZGVyLXJhZGl1czogMC4yODU3MTQyOXJlbTtcXFxcbn1cXFxcbi51aS51cHdhcmQucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtYTNkYmZjMGNdOmFmdGVyLFxcXFxuLnVpLnVwd2FyZC50b3AucG9pbnRpbmcuZHJvcGRvd24gPiAubWVudVtkYXRhLXYtYTNkYmZjMGNdOmFmdGVyIHtcXFxcbiAgdG9wOiAxMDAlO1xcXFxuICBib3R0b206IGF1dG87XFxcXG4gIGJveC1zaGFkb3c6IDFweCAxcHggMHB4IDFweCByZ2JhKDM0LCAzNiwgMzgsIDAuMTUpO1xcXFxuICBtYXJnaW46IC0wLjI1ZW0gMGVtIDBlbTtcXFxcbn1cXFxcblxcXFxuXFxcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcXFxuICAgICAgICAgVGhlbWUgT3ZlcnJpZGVzXFxcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcXFxuXFxcXG5cXFxcbi8qIERyb3Bkb3duIENhcmV0cyAqL1xcXFxuQGZvbnQtZmFjZSB7XFxcXG4gIGZvbnQtZmFtaWx5OiAnRHJvcGRvd24nO1xcXFxuICBzcmM6IHVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC10dGY7Y2hhcnNldD11dGYtODtiYXNlNjQsQUFFQUFBQUxBSUFBQXdBd1QxTXZNZ2dqQjVBQUFBQzhBQUFBWUdOdFlYQVBmdUlJQUFBQkhBQUFBRXhuWVhOd0FBQUFFQUFBQVdnQUFBQUlaMng1WmpvODJMZ0FBQUZ3QUFBQlZHaGxZV1FBUTg4YkFBQUN4QUFBQURab2FHVmhBd2NCNlFBQUF2d0FBQUFrYUcxMGVBUzRBQklBQUFNZ0FBQUFJR3h2WTJFQk5nRGVBQUFEUUFBQUFCSnRZWGh3QUFvQUZnQUFBMVFBQUFBZ2JtRnRaVmNacHU0QUFBTjBBQUFCUlhCdmMzUUFBd0FBQUFBRXZBQUFBQ0FBQXdJQUFaQUFCUUFBQVV3QlpnQUFBRWNCVEFGbUFBQUE5UUFaQUlRQUFBQUFBQUFBQUFBQUFBQUFBQUFCRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQUFEdzJnSGcvK0QvNEFIZ0FDQUFBQUFCQUFBQUFBQUFBQUFBQUFBZ0FBQUFBQUFDQUFBQUF3QUFBQlFBQXdBQkFBQUFGQUFFQURnQUFBQUtBQWdBQWdBQ0FBRUFJUERhLy8zLy93QUFBQUFBSVBEWC8vMy8vd0FCLytNUExRQURBQUVBQUFBQUFBQUFBQUFBQUFFQUFmLy9BQThBQVFBQUFBQUFBQUFBQUFJQUFEYzVBUUFBQUFBQkFBQUFBQUFBQUFBQUFnQUFOemtCQUFBQUFBRUFBQUFBQUFBQUFBQUNBQUEzT1FFQUFBQUFBUUFBQUlBQkpRRWxBQk1BQUJNME56WTNCVFlYRmhVVUR3RUdKd1l2QVNZMUFBVUdCd0VBQ0FVR0JvQUZDQWNHZ0FVQkVnY0dCUUVCQVFjRUNRWUhmd1lCQVFaL0J3WUFBUUFBQUc0QkpRRVNBQk1BQURjMFB3RTJNeklmQVJZVkZBY0dJeUVpSnlZMUFBV0FCZ2NJQllBR0JnVUkvd0FIQmdXQUJ3YUFCUVdBQmdjSEJnVUZCZ2NBQUFBQkFCSUFTUUMzQVc0QUV3QUFOelEvQVRZWE5oY1dIUUVVQndZbkJpOEJKalVTQm9BRkNBY0ZCZ1lGQndnRmdBYmJCd1ovQndFQkJ3UUovd2dFQndFQkIzOEdCZ0FBQUFBQkFBQUFTUUNsQVc0QUV3QUFOeEUwTnpZek1oOEJGaFVVRHdFR0l5SW5KalVBQlFZSENBV0FCZ2FBQlFnSEJnVmJBUUFJQlFZR2dBVUlCd1dBQmdZRkJ3QUFBQUVBQUFBQkFBRFp1YUtPWHc4ODlRQUxBZ0FBQUFBQTBBQkhXQUFBQUFEUUFFZFlBQUFBQUFFbEFXNEFBQUFJQUFJQUFBQUFBQUFBQVFBQUFlRC80QUFBQWdBQUFBQUFBU1VBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQWdBQUFBQUFBQUFBQUFBQUFBQkFBQUFBU1VBQUFFbEFBQUF0d0FTQUxjQUFBQUFBQUFBQ2dBVUFCNEFRZ0JrQUlnQXFnQUFBQUVBQUFBSUFCUUFBUUFBQUFBQUFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9BSzRBQVFBQUFBQUFBUUFPQUFBQUFRQUFBQUFBQWdBT0FFY0FBUUFBQUFBQUF3QU9BQ1FBQVFBQUFBQUFCQUFPQUZVQUFRQUFBQUFBQlFBV0FBNEFBUUFBQUFBQUJnQUhBRElBQVFBQUFBQUFDZ0EwQUdNQUF3QUJCQWtBQVFBT0FBQUFBd0FCQkFrQUFnQU9BRWNBQXdBQkJBa0FBd0FPQUNRQUF3QUJCQWtBQkFBT0FGVUFBd0FCQkFrQUJRQVdBQTRBQXdBQkJBa0FCZ0FPQURrQUF3QUJCQWtBQ2dBMEFHTUFhUUJqQUc4QWJRQnZBRzhBYmdCV0FHVUFjZ0J6QUdrQWJ3QnVBQ0FBTVFBdUFEQUFhUUJqQUc4QWJRQnZBRzhBYm1samIyMXZiMjRBYVFCakFHOEFiUUJ2QUc4QWJnQlNBR1VBWndCMUFHd0FZUUJ5QUdrQVl3QnZBRzBBYndCdkFHNEFSZ0J2QUc0QWRBQWdBR2NBWlFCdUFHVUFjZ0JoQUhRQVpRQmtBQ0FBWWdCNUFDQUFTUUJqQUc4QVRRQnZBRzhBYmdBdUFBQUFBQU1BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBPSkgZm9ybWF0KCd0cnVldHlwZScpLCB1cmwoZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmY7Y2hhcnNldD11dGYtODtiYXNlNjQsZDA5R1JrOVVWRThBQUFWd0FBb0FBQUFBQlNnQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJEUmtZZ0FBQUE5QUFBQWRrQUFBSFpMRFhFLzA5VEx6SUFBQUxRQUFBQVlBQUFBR0FJSXdlUVkyMWhjQUFBQXpBQUFBQk1BQUFBVEE5KzRnaG5ZWE53QUFBRGZBQUFBQWdBQUFBSUFBQUFFR2hsWVdRQUFBT0VBQUFBTmdBQUFEWUFRODhiYUdobFlRQUFBN3dBQUFBa0FBQUFKQU1IQWVsb2JYUjRBQUFENEFBQUFDQUFBQUFnQkxnQUVtMWhlSEFBQUFRQUFBQUFCZ0FBQUFZQUNGQUFibUZ0WlFBQUJBZ0FBQUZGQUFBQlJWY1pwdTV3YjNOMEFBQUZVQUFBQUNBQUFBQWdBQU1BQUFFQUJBUUFBUUVCQ0dsamIyMXZiMjRBQVFJQUFRQTYrQndDK0JzRCtCZ0VIZ29BR1ZQL2k0c2VDZ0FaVS8rTGl3d0hpMnY0bFBoMEJSMEFBQUNJRHgwQUFBQ05FUjBBQUFBSkhRQUFBZEFTQUFrQkFRZ1BFUk1XR3lBbEttbGpiMjF2YjI1cFkyOXRiMjl1ZFRCMU1YVXlNSFZHTUVRM2RVWXdSRGgxUmpCRU9YVkdNRVJCQUFBQ0FZa0FCZ0FJQWdBQkFBUUFCd0FLQUEwQVZnQ2ZBT2dCTC95VUR2eVVEdnlVRHZ1VUR2dHZpL2VtRll1UWpaQ09qbytQajQyUWl3ajNsSXNGa0l1UWlZNkhqNGlOaG91R2k0YUpoNGVIQ1BzVSt4UUZpSWlHaVlhTGhvdUhqWWVPQ1BzVTl4UUZpSStKajR1UUNBNzdiNHYzRkJXTGtJMlBqbzhJOXhUM0ZBV1BqbytOa0l1UWk1Q0pqb2dJOXhUN0ZBV1BoNDJIaTRhTGhvbUhoNGVJaUlhSmhvc0krNVNMQllhTGg0Mkhqb2lQaVkrTGtBZ08rOTJkOTI4Vmk1Q05rSStPQ1BjVTl4UUZqbytRalpDTGtJdVBpWTZIajRpTmhvdUdDSXY3bEFXTGhvbUhoNGlJaDRlSmhvdUdpNGFOaUk4SSt4VDNGQVdIam9tUGk1QUlEdnZkaStZVmkvZVVCWXVRalpDT2pvK1BqNDJRaTVDTGtJbU9od2ozRlBzVUJZK0lqWWFMaG91R2lZZUhpQWo3RlBzVUJZaUhob21HaTRhTGg0MkhqNGlPaVkrTGtBZ08rSlFVK0pRVml3d0tBQUFBQUFNQ0FBR1FBQVVBQUFGTUFXWUFBQUJIQVV3QlpnQUFBUFVBR1FDRUFBQUFBQUFBQUFBQUFBQUFBQUFBQVJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQThOb0I0UC9nLytBQjRBQWdBQUFBQVFBQUFBQUFBQUFBQUFBQUlBQUFBQUFBQWdBQUFBTUFBQUFVQUFNQUFRQUFBQlFBQkFBNEFBQUFDZ0FJQUFJQUFnQUJBQ0R3MnYvOS8vOEFBQUFBQUNEdzEvLzkvLzhBQWYvakR5MEFBd0FCQUFBQUFBQUFBQUFBQUFBQkFBSC8vd0FQQUFFQUFBQUJBQUE1ZW1velh3ODg5UUFMQWdBQUFBQUEwQUJIV0FBQUFBRFFBRWRZQUFBQUFBRWxBVzRBQUFBSUFBSUFBQUFBQUFBQUFRQUFBZUQvNEFBQUFnQUFBQUFBQVNVQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFnQUFBQUFBQUFBQUFBQUFBQUJBQUFBQVNVQUFBRWxBQUFBdHdBU0FMY0FBQUFBVUFBQUNBQUFBQUFBRGdDdUFBRUFBQUFBQUFFQURnQUFBQUVBQUFBQUFBSUFEZ0JIQUFFQUFBQUFBQU1BRGdBa0FBRUFBQUFBQUFRQURnQlZBQUVBQUFBQUFBVUFGZ0FPQUFFQUFBQUFBQVlBQndBeUFBRUFBQUFBQUFvQU5BQmpBQU1BQVFRSkFBRUFEZ0FBQUFNQUFRUUpBQUlBRGdCSEFBTUFBUVFKQUFNQURnQWtBQU1BQVFRSkFBUUFEZ0JWQUFNQUFRUUpBQVVBRmdBT0FBTUFBUVFKQUFZQURnQTVBQU1BQVFRSkFBb0FOQUJqQUdrQVl3QnZBRzBBYndCdkFHNEFWZ0JsQUhJQWN3QnBBRzhBYmdBZ0FERUFMZ0F3QUdrQVl3QnZBRzBBYndCdkFHNXBZMjl0YjI5dUFHa0FZd0J2QUcwQWJ3QnZBRzRBVWdCbEFHY0FkUUJzQUdFQWNnQnBBR01BYndCdEFHOEFid0J1QUVZQWJ3QnVBSFFBSUFCbkFHVUFiZ0JsQUhJQVlRQjBBR1VBWkFBZ0FHSUFlUUFnQUVrQVl3QnZBRTBBYndCdkFHNEFMZ0FBQUFBREFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUEpIGZvcm1hdCgnd29mZicpO1xcXFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcXFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxcXG59XFxcXG4udWkuZHJvcGRvd24gPiAuZHJvcGRvd24uaWNvbltkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgZm9udC1mYW1pbHk6ICdEcm9wZG93bic7XFxcXG4gIGxpbmUtaGVpZ2h0OiAxO1xcXFxuICBoZWlnaHQ6IDFlbTtcXFxcbiAgd2lkdGg6IDEuMjNlbTtcXFxcbiAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxcXG4gICAgICAgICAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcXFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcXFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXFxcbn1cXFxcbi51aS5kcm9wZG93biA+IC5kcm9wZG93bi5pY29uW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICB3aWR0aDogYXV0bztcXFxcbn1cXFxcbi51aS5kcm9wZG93biA+IC5kcm9wZG93bi5pY29uW2RhdGEtdi1hM2RiZmMwY106YmVmb3JlIHtcXFxcbiAgY29udGVudDogJ1xcXFxcXFxcRjBENyc7XFxcXG59XFxcXG5cXFxcbi8qIFN1YiBNZW51ICovXFxcXG4udWkuZHJvcGRvd24gLm1lbnUgLml0ZW0gLmRyb3Bkb3duLmljb25bZGF0YS12LWEzZGJmYzBjXTpiZWZvcmUge1xcXFxuICBjb250ZW50OiAnXFxcXFxcXFxGMERBJyA7XFxcXG59XFxcXG4udWkuZHJvcGRvd24gLml0ZW0gLmxlZnQuZHJvcGRvd24uaWNvbltkYXRhLXYtYTNkYmZjMGNdOmJlZm9yZSxcXFxcbi51aS5kcm9wZG93biAubGVmdC5tZW51IC5pdGVtIC5kcm9wZG93bi5pY29uW2RhdGEtdi1hM2RiZmMwY106YmVmb3JlIHtcXFxcbiAgY29udGVudDogXFxcXFxcXCJcXFxcXFxcXEYwRDlcXFxcXFxcIiA7XFxcXG59XFxcXG5cXFxcbi8qIFZlcnRpY2FsIE1lbnUgRHJvcGRvd24gKi9cXFxcbi51aS52ZXJ0aWNhbC5tZW51IC5kcm9wZG93bi5pdGVtID4gLmRyb3Bkb3duLmljb25bZGF0YS12LWEzZGJmYzBjXTpiZWZvcmUge1xcXFxuICBjb250ZW50OiBcXFxcXFxcIlxcXFxcXFxcRjBEQVxcXFxcXFwiIDtcXFxcbn1cXFxcbi8qIEljb25zIGZvciBSZWZlcmVuY2VcXFxcbi5kcm9wZG93bi5kb3duLmljb24ge1xcXFxuICBjb250ZW50OiBcXFxcXFxcIlxcXFxcXFxcZjBkN1xcXFxcXFwiO1xcXFxufVxcXFxuLmRyb3Bkb3duLnVwLmljb24ge1xcXFxuICBjb250ZW50OiBcXFxcXFxcIlxcXFxcXFxcZjBkOFxcXFxcXFwiO1xcXFxufVxcXFxuLmRyb3Bkb3duLmxlZnQuaWNvbiB7XFxcXG4gIGNvbnRlbnQ6IFxcXFxcXFwiXFxcXFxcXFxmMGQ5XFxcXFxcXCI7XFxcXG59XFxcXG4uZHJvcGRvd24uaWNvbi5pY29uIHtcXFxcbiAgY29udGVudDogXFxcXFxcXCJcXFxcXFxcXGYwZGFcXFxcXFxcIjtcXFxcbn1cXFxcbiovXFxcXG5cXFxcblxcXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXFxcbiAgICAgICAgVXNlciBPdmVycmlkZXNcXFxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxcXG5cXFxcblxcXCIsIFxcXCJcXFwiXSk7XFxuXFx0XFxuXFx0Ly8gZXhwb3J0c1xcblxcblxcbi8qKiovIH0sXFxuLyogOTYgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKCk7XFxuXFx0Ly8gaW1wb3J0c1xcblxcdFxcblxcdFxcblxcdC8vIG1vZHVsZVxcblxcdGV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcXFwiLyohXFxcXG4gKiAjIFNlbWFudGljIFVJIDIuMi4zIC0gTGFiZWxcXFxcbiAqIGh0dHA6Ly9naXRodWIuY29tL3NlbWFudGljLW9yZy9zZW1hbnRpYy11aS9cXFxcbiAqXFxcXG4gKlxcXFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXFxcXG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXFxcXG4gKlxcXFxuICovXFxcXG5cXFxcblxcXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXFxcbiAgICAgICAgICAgIExhYmVsXFxcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcXFxuLnVpLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxcXG4gIGxpbmUtaGVpZ2h0OiAxO1xcXFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxcXG4gIG1hcmdpbjogMGVtIDAuMTQyODU3MTRlbTtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogI0U4RThFODtcXFxcbiAgYmFja2dyb3VuZC1pbWFnZTogbm9uZTtcXFxcbiAgcGFkZGluZzogMC41ODMzZW0gMC44MzNlbTtcXFxcbiAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC42KTtcXFxcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcXFxuICBib3JkZXI6IDBweCBzb2xpZCB0cmFuc3BhcmVudDtcXFxcbiAgYm9yZGVyLXJhZGl1czogMC4yODU3MTQyOXJlbTtcXFxcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIDAuMXMgZWFzZTtcXFxcbiAgdHJhbnNpdGlvbjogYmFja2dyb3VuZCAwLjFzIGVhc2U7XFxcXG59XFxcXG4udWkubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpmaXJzdC1jaGlsZCB7XFxcXG4gIG1hcmdpbi1sZWZ0OiAwZW07XFxcXG59XFxcXG4udWkubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpsYXN0LWNoaWxkIHtcXFxcbiAgbWFyZ2luLXJpZ2h0OiAwZW07XFxcXG59XFxcXG5cXFxcbi8qIExpbmsgKi9cXFxcbmEudWkubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGN1cnNvcjogcG9pbnRlcjtcXFxcbn1cXFxcblxcXFxuLyogSW5zaWRlIExpbmsgKi9cXFxcbi51aS5sYWJlbCA+IGFbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGN1cnNvcjogcG9pbnRlcjtcXFxcbiAgY29sb3I6IGluaGVyaXQ7XFxcXG4gIG9wYWNpdHk6IDAuNTtcXFxcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiAwLjFzIG9wYWNpdHkgZWFzZTtcXFxcbiAgdHJhbnNpdGlvbjogMC4xcyBvcGFjaXR5IGVhc2U7XFxcXG59XFxcXG4udWkubGFiZWwgPiBhW2RhdGEtdi1hM2RiZmMwY106aG92ZXIge1xcXFxuICBvcGFjaXR5OiAxO1xcXFxufVxcXFxuXFxcXG4vKiBJbWFnZSAqL1xcXFxuLnVpLmxhYmVsID4gaW1nW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICB3aWR0aDogYXV0byAhaW1wb3J0YW50O1xcXFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcXFxuICBoZWlnaHQ6IDIuMTY2NmVtICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIEljb24gKi9cXFxcbi51aS5sYWJlbCA+IC5pY29uW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICB3aWR0aDogYXV0bztcXFxcbiAgbWFyZ2luOiAwZW0gMC43NWVtIDBlbSAwZW07XFxcXG59XFxcXG5cXFxcbi8qIERldGFpbCAqL1xcXFxuLnVpLmxhYmVsID4gLmRldGFpbFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcXFxuICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xcXFxuICBmb250LXdlaWdodDogYm9sZDtcXFxcbiAgbWFyZ2luLWxlZnQ6IDFlbTtcXFxcbiAgb3BhY2l0eTogMC44O1xcXFxufVxcXFxuLnVpLmxhYmVsID4gLmRldGFpbCAuaWNvbltkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgbWFyZ2luOiAwZW0gMC4yNWVtIDBlbSAwZW07XFxcXG59XFxcXG5cXFxcbi8qIFJlbW92YWJsZSBsYWJlbCAqL1xcXFxuLnVpLmxhYmVsID4gLmNsb3NlLmljb25bZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5sYWJlbCA+IC5kZWxldGUuaWNvbltkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgY3Vyc29yOiBwb2ludGVyO1xcXFxuICBtYXJnaW4tcmlnaHQ6IDBlbTtcXFxcbiAgbWFyZ2luLWxlZnQ6IDAuNWVtO1xcXFxuICBmb250LXNpemU6IDAuOTI4NTcxNDNlbTtcXFxcbiAgb3BhY2l0eTogMC41O1xcXFxuICAtd2Via2l0LXRyYW5zaXRpb246IGJhY2tncm91bmQgMC4xcyBlYXNlO1xcXFxuICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIDAuMXMgZWFzZTtcXFxcbn1cXFxcbi51aS5sYWJlbCA+IC5kZWxldGUuaWNvbltkYXRhLXYtYTNkYmZjMGNdOmhvdmVyIHtcXFxcbiAgb3BhY2l0eTogMTtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gICAgICAgR3JvdXBcXFxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXFxcbi51aS5sYWJlbHMgPiAubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG1hcmdpbjogMGVtIDAuNWVtIDAuNWVtIDBlbTtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gICAgICAgQ291cGxpbmdcXFxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXFxcbi51aS5oZWFkZXIgPiAudWkubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG1hcmdpbi10b3A6IC0wLjI5MTY1ZW07XFxcXG59XFxcXG5cXFxcbi8qIFJlbW92ZSBib3JkZXIgcmFkaXVzIG9uIGF0dGFjaGVkIHNlZ21lbnQgKi9cXFxcbi51aS5hdHRhY2hlZC5zZWdtZW50ID4gLnVpLnRvcC5sZWZ0LmF0dGFjaGVkLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuYm90dG9tLmF0dGFjaGVkLnNlZ21lbnQgPiAudWkudG9wLmxlZnQuYXR0YWNoZWQubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDA7XFxcXG59XFxcXG4udWkuYXR0YWNoZWQuc2VnbWVudCA+IC51aS50b3AucmlnaHQuYXR0YWNoZWQubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5ib3R0b20uYXR0YWNoZWQuc2VnbWVudCA+IC51aS50b3AucmlnaHQuYXR0YWNoZWQubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAwO1xcXFxufVxcXFxuLnVpLnRvcC5hdHRhY2hlZC5zZWdtZW50ID4gLnVpLmJvdHRvbS5sZWZ0LmF0dGFjaGVkLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwO1xcXFxufVxcXFxuLnVpLnRvcC5hdHRhY2hlZC5zZWdtZW50ID4gLnVpLmJvdHRvbS5yaWdodC5hdHRhY2hlZC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxcXG59XFxcXG5cXFxcbi8qIFBhZGRpbmcgb24gbmV4dCBjb250ZW50IGFmdGVyIGEgbGFiZWwgKi9cXFxcbi51aS50b3AuYXR0YWNoZWQubGFiZWw6Zmlyc3QtY2hpbGQgKyBbZGF0YS12LWEzZGJmYzBjXTpub3QoLmF0dGFjaGVkKSxcXFxcbi51aS50b3AuYXR0YWNoZWQubGFiZWwgKyBbY2xhc3MqPVxcXFxcXFwicmlnaHQgZmxvYXRlZFxcXFxcXFwiXSArICpbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG1hcmdpbi10b3A6IDJyZW0gIWltcG9ydGFudDtcXFxcbn1cXFxcbi51aS5ib3R0b20uYXR0YWNoZWQubGFiZWw6Zmlyc3QtY2hpbGQgfiBbZGF0YS12LWEzZGJmYzBjXTpsYXN0LWNoaWxkOm5vdCguYXR0YWNoZWQpIHtcXFxcbiAgbWFyZ2luLXRvcDogMGVtO1xcXFxuICBtYXJnaW4tYm90dG9tOiAycmVtICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcblxcXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXFxcbiAgICAgICAgICAgICBUeXBlc1xcXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXFxcbi51aS5pbWFnZS5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgd2lkdGg6IGF1dG8gIWltcG9ydGFudDtcXFxcbiAgbWFyZ2luLXRvcDogMGVtO1xcXFxuICBtYXJnaW4tYm90dG9tOiAwZW07XFxcXG4gIG1heC13aWR0aDogOTk5OXB4O1xcXFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxcXG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xcXFxuICBiYWNrZ3JvdW5kOiAjRThFOEU4O1xcXFxuICBwYWRkaW5nOiAwLjU4MzNlbSAwLjgzM2VtIDAuNTgzM2VtIDAuNWVtO1xcXFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5cmVtO1xcXFxuICBib3gtc2hhZG93OiBub25lO1xcXFxufVxcXFxuLnVpLmltYWdlLmxhYmVsIGltZ1tkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcXFxuICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xcXFxuICBoZWlnaHQ6IDIuMTY2NmVtO1xcXFxuICBtYXJnaW46IC0wLjU4MzNlbSAwLjVlbSAtMC41ODMzZW0gLTAuNWVtO1xcXFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5cmVtIDBlbSAwZW0gMC4yODU3MTQyOXJlbTtcXFxcbn1cXFxcbi51aS5pbWFnZS5sYWJlbCAuZGV0YWlsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuMSk7XFxcXG4gIG1hcmdpbjogLTAuNTgzM2VtIC0wLjgzM2VtIC0wLjU4MzNlbSAwLjVlbTtcXFxcbiAgcGFkZGluZzogMC41ODMzZW0gMC44MzNlbTtcXFxcbiAgYm9yZGVyLXJhZGl1czogMGVtIDAuMjg1NzE0MjlyZW0gMC4yODU3MTQyOXJlbSAwZW07XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLVxcXFxuICAgICAgICAgVGFnXFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkudGFnLmxhYmVscyAubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS50YWcubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG1hcmdpbi1sZWZ0OiAxZW07XFxcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXFxcbiAgcGFkZGluZy1sZWZ0OiAxLjVlbTtcXFxcbiAgcGFkZGluZy1yaWdodDogMS41ZW07XFxcXG4gIGJvcmRlci1yYWRpdXM6IDBlbSAwLjI4NTcxNDI5cmVtIDAuMjg1NzE0MjlyZW0gMGVtO1xcXFxuICAtd2Via2l0LXRyYW5zaXRpb246IG5vbmU7XFxcXG4gIHRyYW5zaXRpb246IG5vbmU7XFxcXG59XFxcXG4udWkudGFnLmxhYmVscyAubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpiZWZvcmUsXFxcXG4udWkudGFnLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106YmVmb3JlIHtcXFxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcXFxuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKSB0cmFuc2xhdGVYKDUwJSkgcm90YXRlKC00NWRlZyk7XFxcXG4gICAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpIHRyYW5zbGF0ZVgoNTAlKSByb3RhdGUoLTQ1ZGVnKTtcXFxcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSkgdHJhbnNsYXRlWCg1MCUpIHJvdGF0ZSgtNDVkZWcpO1xcXFxuICB0b3A6IDUwJTtcXFxcbiAgcmlnaHQ6IDEwMCU7XFxcXG4gIGNvbnRlbnQ6ICcnO1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xcXFxuICBiYWNrZ3JvdW5kLWltYWdlOiBub25lO1xcXFxuICB3aWR0aDogMS41NmVtO1xcXFxuICBoZWlnaHQ6IDEuNTZlbTtcXFxcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBub25lO1xcXFxuICB0cmFuc2l0aW9uOiBub25lO1xcXFxufVxcXFxuLnVpLnRhZy5sYWJlbHMgLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106YWZ0ZXIsXFxcXG4udWkudGFnLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106YWZ0ZXIge1xcXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxcXG4gIGNvbnRlbnQ6ICcnO1xcXFxuICB0b3A6IDUwJTtcXFxcbiAgbGVmdDogLTAuMjVlbTtcXFxcbiAgbWFyZ2luLXRvcDogLTAuMjVlbTtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRiAhaW1wb3J0YW50O1xcXFxuICB3aWR0aDogMC41ZW07XFxcXG4gIGhlaWdodDogMC41ZW07XFxcXG4gIGJveC1zaGFkb3c6IDAgLTFweCAxcHggMCByZ2JhKDAsIDAsIDAsIDAuMyk7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDUwMHJlbTtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gICAgQ29ybmVyIExhYmVsXFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuY29ybmVyLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxcXG4gIHRvcDogMGVtO1xcXFxuICByaWdodDogMGVtO1xcXFxuICBtYXJnaW46IDBlbTtcXFxcbiAgcGFkZGluZzogMGVtO1xcXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxcXG4gIGJvcmRlci1jb2xvcjogI0U4RThFODtcXFxcbiAgd2lkdGg6IDRlbTtcXFxcbiAgaGVpZ2h0OiA0ZW07XFxcXG4gIHotaW5kZXg6IDE7XFxcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYm9yZGVyLWNvbG9yIDAuMXMgZWFzZTtcXFxcbiAgdHJhbnNpdGlvbjogYm9yZGVyLWNvbG9yIDAuMXMgZWFzZTtcXFxcbn1cXFxcblxcXFxuLyogSWNvbiBMYWJlbCAqL1xcXFxuLnVpLmNvcm5lci5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcXFxcbn1cXFxcbi51aS5jb3JuZXIubGFiZWxbZGF0YS12LWEzZGJmYzBjXTphZnRlciB7XFxcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcbiAgY29udGVudDogXFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgcmlnaHQ6IDBlbTtcXFxcbiAgdG9wOiAwZW07XFxcXG4gIHotaW5kZXg6IC0xO1xcXFxuICB3aWR0aDogMGVtO1xcXFxuICBoZWlnaHQ6IDBlbTtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLXRvcDogMGVtIHNvbGlkIHRyYW5zcGFyZW50O1xcXFxuICBib3JkZXItcmlnaHQ6IDRlbSBzb2xpZCB0cmFuc3BhcmVudDtcXFxcbiAgYm9yZGVyLWJvdHRvbTogNGVtIHNvbGlkIHRyYW5zcGFyZW50O1xcXFxuICBib3JkZXItbGVmdDogMGVtIHNvbGlkIHRyYW5zcGFyZW50O1xcXFxuICBib3JkZXItcmlnaHQtY29sb3I6IGluaGVyaXQ7XFxcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYm9yZGVyLWNvbG9yIDAuMXMgZWFzZTtcXFxcbiAgdHJhbnNpdGlvbjogYm9yZGVyLWNvbG9yIDAuMXMgZWFzZTtcXFxcbn1cXFxcbi51aS5jb3JuZXIubGFiZWwgLmljb25bZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGN1cnNvcjogZGVmYXVsdDtcXFxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcXFxuICB0b3A6IDAuNjQyODU3MTRlbTtcXFxcbiAgbGVmdDogMC43ODU3MTQyOWVtO1xcXFxuICBmb250LXNpemU6IDEuMTQyODU3MTRlbTtcXFxcbiAgbWFyZ2luOiAwZW07XFxcXG59XFxcXG5cXFxcbi8qIExlZnQgQ29ybmVyICovXFxcXG4udWkubGVmdC5jb3JuZXIubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5sZWZ0LmNvcm5lci5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmFmdGVyIHtcXFxcbiAgcmlnaHQ6IGF1dG87XFxcXG4gIGxlZnQ6IDBlbTtcXFxcbn1cXFxcbi51aS5sZWZ0LmNvcm5lci5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmFmdGVyIHtcXFxcbiAgYm9yZGVyLXRvcDogNGVtIHNvbGlkIHRyYW5zcGFyZW50O1xcXFxuICBib3JkZXItcmlnaHQ6IDRlbSBzb2xpZCB0cmFuc3BhcmVudDtcXFxcbiAgYm9yZGVyLWJvdHRvbTogMGVtIHNvbGlkIHRyYW5zcGFyZW50O1xcXFxuICBib3JkZXItbGVmdDogMGVtIHNvbGlkIHRyYW5zcGFyZW50O1xcXFxuICBib3JkZXItdG9wLWNvbG9yOiBpbmhlcml0O1xcXFxufVxcXFxuLnVpLmxlZnQuY29ybmVyLmxhYmVsIC5pY29uW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBsZWZ0OiAtMC43ODU3MTQyOWVtO1xcXFxufVxcXFxuXFxcXG4vKiBTZWdtZW50ICovXFxcXG4udWkuc2VnbWVudCA+IC51aS5jb3JuZXIubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIHRvcDogLTFweDtcXFxcbiAgcmlnaHQ6IC0xcHg7XFxcXG59XFxcXG4udWkuc2VnbWVudCA+IC51aS5sZWZ0LmNvcm5lci5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgcmlnaHQ6IGF1dG87XFxcXG4gIGxlZnQ6IC0xcHg7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLVxcXFxuICAgICAgIFJpYmJvblxcXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLnJpYmJvbi5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcXFxuICBtYXJnaW46IDBlbTtcXFxcbiAgbWluLXdpZHRoOiAtd2Via2l0LW1heC1jb250ZW50O1xcXFxuICBtaW4td2lkdGg6IC1tb3otbWF4LWNvbnRlbnQ7XFxcXG4gIG1pbi13aWR0aDogbWF4LWNvbnRlbnQ7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDBlbSAwLjI4NTcxNDI5cmVtIDAuMjg1NzE0MjlyZW0gMGVtO1xcXFxuICBib3JkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4xNSk7XFxcXG59XFxcXG4udWkucmliYm9uLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106YWZ0ZXIge1xcXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxcXG4gIGNvbnRlbnQ6ICcnO1xcXFxuICB0b3A6IDEwMCU7XFxcXG4gIGxlZnQ6IDAlO1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItc3R5bGU6IHNvbGlkO1xcXFxuICBib3JkZXItd2lkdGg6IDBlbSAxLjJlbSAxLjJlbSAwZW07XFxcXG4gIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxcXG4gIGJvcmRlci1yaWdodC1jb2xvcjogaW5oZXJpdDtcXFxcbiAgd2lkdGg6IDBlbTtcXFxcbiAgaGVpZ2h0OiAwZW07XFxcXG59XFxcXG5cXFxcbi8qIFBvc2l0aW9uaW5nICovXFxcXG4udWkucmliYm9uLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBsZWZ0OiBjYWxjKCAtMXJlbSAgLSAgMS4yZW0gKTtcXFxcbiAgbWFyZ2luLXJpZ2h0OiAtMS4yZW07XFxcXG4gIHBhZGRpbmctbGVmdDogY2FsYyggMXJlbSAgKyAgMS4yZW0gKTtcXFxcbiAgcGFkZGluZy1yaWdodDogMS4yZW07XFxcXG59XFxcXG4udWlbY2xhc3MqPVxcXFxcXFwicmlnaHQgcmliYm9uXFxcXFxcXCJdLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBsZWZ0OiBjYWxjKDEwMCUgKyAgMXJlbSAgKyAgMS4yZW0gKTtcXFxcbiAgcGFkZGluZy1sZWZ0OiAxLjJlbTtcXFxcbiAgcGFkZGluZy1yaWdodDogY2FsYyggMXJlbSAgKyAgMS4yZW0gKTtcXFxcbn1cXFxcblxcXFxuLyogUmlnaHQgUmliYm9uICovXFxcXG4udWlbY2xhc3MqPVxcXFxcXFwicmlnaHQgcmliYm9uXFxcXFxcXCJdLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcXFxuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMTAwJSk7XFxcXG4gICAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC0xMDAlKTtcXFxcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTEwMCUpO1xcXFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5cmVtIDBlbSAwZW0gMC4yODU3MTQyOXJlbTtcXFxcbn1cXFxcbi51aVtjbGFzcyo9XFxcXFxcXCJyaWdodCByaWJib25cXFxcXFxcIl0ubGFiZWxbZGF0YS12LWEzZGJmYzBjXTphZnRlciB7XFxcXG4gIGxlZnQ6IGF1dG87XFxcXG4gIHJpZ2h0OiAwJTtcXFxcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXFxcbiAgYm9yZGVyLXdpZHRoOiAxLjJlbSAxLjJlbSAwZW0gMGVtO1xcXFxuICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcXFxuICBib3JkZXItdG9wLWNvbG9yOiBpbmhlcml0O1xcXFxufVxcXFxuXFxcXG4vKiBJbnNpZGUgVGFibGUgKi9cXFxcbi51aS5pbWFnZSA+IC5yaWJib24ubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5jYXJkIC5pbWFnZSA+IC5yaWJib24ubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcbiAgdG9wOiAxcmVtO1xcXFxufVxcXFxuLnVpLmNhcmQgLmltYWdlID4gLnVpLnJpYmJvbi5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmltYWdlID4gLnVpLnJpYmJvbi5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgbGVmdDogY2FsYyggMC4wNXJlbSAgLSAgMS4yZW0gKTtcXFxcbn1cXFxcbi51aS5jYXJkIC5pbWFnZSA+IC51aVtjbGFzcyo9XFxcXFxcXCJyaWdodCByaWJib25cXFxcXFxcIl0ubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5pbWFnZSA+IC51aVtjbGFzcyo9XFxcXFxcXCJyaWdodCByaWJib25cXFxcXFxcIl0ubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGxlZnQ6IGNhbGMoMTAwJSArICAtMC4wNXJlbSAgKyAgMS4yZW0gKTtcXFxcbiAgcGFkZGluZy1sZWZ0OiAwLjgzM2VtO1xcXFxufVxcXFxuXFxcXG4vKiBJbnNpZGUgVGFibGUgKi9cXFxcbi51aS50YWJsZSB0ZCA+IC51aS5yaWJib24ubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGxlZnQ6IGNhbGMoIC0wLjc4NTcxNDI5ZW0gIC0gIDEuMmVtICk7XFxcXG59XFxcXG4udWkudGFibGUgdGQgPiAudWlbY2xhc3MqPVxcXFxcXFwicmlnaHQgcmliYm9uXFxcXFxcXCJdLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBsZWZ0OiBjYWxjKDEwMCUgKyAgMC43ODU3MTQyOWVtICArICAxLjJlbSApO1xcXFxuICBwYWRkaW5nLWxlZnQ6IDAuODMzZW07XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLVxcXFxuICAgICAgQXR0YWNoZWRcXFxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXFxcbi51aVtjbGFzcyo9XFxcXFxcXCJ0b3AgYXR0YWNoZWRcXFxcXFxcIl0ubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5hdHRhY2hlZC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgd2lkdGg6IDEwMCU7XFxcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcbiAgbWFyZ2luOiAwZW07XFxcXG4gIHRvcDogMGVtO1xcXFxuICBsZWZ0OiAwZW07XFxcXG4gIHBhZGRpbmc6IDAuNzVlbSAxZW07XFxcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjE0Mjg1NzFyZW0gMC4yMTQyODU3MXJlbSAwZW0gMGVtO1xcXFxufVxcXFxuLnVpW2NsYXNzKj1cXFxcXFxcImJvdHRvbSBhdHRhY2hlZFxcXFxcXFwiXS5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgdG9wOiBhdXRvO1xcXFxuICBib3R0b206IDBlbTtcXFxcbiAgYm9yZGVyLXJhZGl1czogMGVtIDBlbSAwLjIxNDI4NTcxcmVtIDAuMjE0Mjg1NzFyZW07XFxcXG59XFxcXG4udWlbY2xhc3MqPVxcXFxcXFwidG9wIGxlZnQgYXR0YWNoZWRcXFxcXFxcIl0ubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIHdpZHRoOiBhdXRvO1xcXFxuICBtYXJnaW4tdG9wOiAwZW0gIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLXJhZGl1czogMC4yMTQyODU3MXJlbSAwZW0gMC4yODU3MTQyOXJlbSAwZW07XFxcXG59XFxcXG4udWlbY2xhc3MqPVxcXFxcXFwidG9wIHJpZ2h0IGF0dGFjaGVkXFxcXFxcXCJdLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICB3aWR0aDogYXV0bztcXFxcbiAgbGVmdDogYXV0bztcXFxcbiAgcmlnaHQ6IDBlbTtcXFxcbiAgYm9yZGVyLXJhZGl1czogMGVtIDAuMjE0Mjg1NzFyZW0gMGVtIDAuMjg1NzE0MjlyZW07XFxcXG59XFxcXG4udWlbY2xhc3MqPVxcXFxcXFwiYm90dG9tIGxlZnQgYXR0YWNoZWRcXFxcXFxcIl0ubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIHdpZHRoOiBhdXRvO1xcXFxuICB0b3A6IGF1dG87XFxcXG4gIGJvdHRvbTogMGVtO1xcXFxuICBib3JkZXItcmFkaXVzOiAwZW0gMC4yODU3MTQyOXJlbSAwZW0gMC4yMTQyODU3MXJlbTtcXFxcbn1cXFxcbi51aVtjbGFzcyo9XFxcXFxcXCJib3R0b20gcmlnaHQgYXR0YWNoZWRcXFxcXFxcIl0ubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIHRvcDogYXV0bztcXFxcbiAgYm90dG9tOiAwZW07XFxcXG4gIGxlZnQ6IGF1dG87XFxcXG4gIHJpZ2h0OiAwZW07XFxcXG4gIHdpZHRoOiBhdXRvO1xcXFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5cmVtIDBlbSAwLjIxNDI4NTcxcmVtIDBlbTtcXFxcbn1cXFxcblxcXFxuXFxcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcXFxuICAgICAgICAgICAgIFN0YXRlc1xcXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXFxcblxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgIERpc2FibGVkXFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkubGFiZWwuZGlzYWJsZWRbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG9wYWNpdHk6IDAuNTtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gICAgICAgIEhvdmVyXFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG5hLnVpLmxhYmVscyAubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlcixcXFxcbmEudWkubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNFMEUwRTA7XFxcXG4gIGJvcmRlci1jb2xvcjogI0UwRTBFMDtcXFxcbiAgYmFja2dyb3VuZC1pbWFnZTogbm9uZTtcXFxcbiAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44KTtcXFxcbn1cXFxcbi51aS5sYWJlbHMgYS5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyOmJlZm9yZSxcXFxcbmEudWkubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlcjpiZWZvcmUge1xcXFxuICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjgpO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgICAgQWN0aXZlXFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuYWN0aXZlLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRDBEMEQwO1xcXFxuICBib3JkZXItY29sb3I6ICNEMEQwRDA7XFxcXG4gIGJhY2tncm91bmQtaW1hZ2U6IG5vbmU7XFxcXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOTUpO1xcXFxufVxcXFxuLnVpLmFjdGl2ZS5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmJlZm9yZSB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNEMEQwRDA7XFxcXG4gIGJhY2tncm91bmQtaW1hZ2U6IG5vbmU7XFxcXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOTUpO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgQWN0aXZlIEhvdmVyXFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG5hLnVpLmxhYmVscyAuYWN0aXZlLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIsXFxcXG5hLnVpLmFjdGl2ZS5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogI0M4QzhDODtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjQzhDOEM4O1xcXFxuICBiYWNrZ3JvdW5kLWltYWdlOiBub25lO1xcXFxuICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjk1KTtcXFxcbn1cXFxcbi51aS5sYWJlbHMgYS5hY3RpdmUubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpBY3RpdmVIb3ZlcjpiZWZvcmUsXFxcXG5hLnVpLmFjdGl2ZS5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOkFjdGl2ZUhvdmVyOmJlZm9yZSB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNDOEM4Qzg7XFxcXG4gIGJhY2tncm91bmQtaW1hZ2U6IG5vbmU7XFxcXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOTUpO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgIFZpc2libGVcXFxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXFxcbi51aS5sYWJlbHMudmlzaWJsZSAubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5sYWJlbC52aXNpYmxlW2RhdGEtdi1hM2RiZmMwY106bm90KC5kcm9wZG93bikge1xcXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2sgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gICAgICBIaWRkZW5cXFxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXFxcbi51aS5sYWJlbHMuaGlkZGVuIC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmxhYmVsLmhpZGRlbltkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG5cXFxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxcXG4gICAgICAgICAgIFZhcmlhdGlvbnNcXFxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxcXG5cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gICAgICAgQ29sb3JzXFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG5cXFxcblxcXFxuLyotLS0gUmVkIC0tLSovXFxcXG4udWkucmVkLmxhYmVscyAubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5yZWQubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNEQjI4MjggIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjREIyODI4ICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIExpbmsgKi9cXFxcbi51aS5yZWQubGFiZWxzIC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyLFxcXFxuYS51aS5yZWQubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNkMDE5MTkgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjZDAxOTE5ICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIENvcm5lciAqL1xcXFxuLnVpLnJlZC5jb3JuZXIubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5yZWQuY29ybmVyLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBSaWJib24gKi9cXFxcbi51aS5yZWQucmliYm9uLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBib3JkZXItY29sb3I6ICNiMjFlMWUgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogQmFzaWMgKi9cXFxcbi51aS5iYXNpYy5yZWQubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkYgIWltcG9ydGFudDtcXFxcbiAgY29sb3I6ICNEQjI4MjggIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjREIyODI4ICFpbXBvcnRhbnQ7XFxcXG59XFxcXG4udWkuYmFzaWMucmVkLmxhYmVscyBhLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIsXFxcXG5hLnVpLmJhc2ljLnJlZC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRiAhaW1wb3J0YW50O1xcXFxuICBjb2xvcjogI2QwMTkxOSAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItY29sb3I6ICNkMDE5MTkgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyotLS0gT3JhbmdlIC0tLSovXFxcXG4udWkub3JhbmdlLmxhYmVscyAubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5vcmFuZ2UubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGMjcxMUMgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjRjI3MTFDICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIExpbmsgKi9cXFxcbi51aS5vcmFuZ2UubGFiZWxzIC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyLFxcXFxuYS51aS5vcmFuZ2UubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmMjYyMDIgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjZjI2MjAyICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIENvcm5lciAqL1xcXFxuLnVpLm9yYW5nZS5jb3JuZXIubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5vcmFuZ2UuY29ybmVyLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBSaWJib24gKi9cXFxcbi51aS5vcmFuZ2UucmliYm9uLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBib3JkZXItY29sb3I6ICNjZjU5MGMgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogQmFzaWMgKi9cXFxcbi51aS5iYXNpYy5vcmFuZ2UubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkYgIWltcG9ydGFudDtcXFxcbiAgY29sb3I6ICNGMjcxMUMgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjRjI3MTFDICFpbXBvcnRhbnQ7XFxcXG59XFxcXG4udWkuYmFzaWMub3JhbmdlLmxhYmVscyBhLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIsXFxcXG5hLnVpLmJhc2ljLm9yYW5nZS5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRiAhaW1wb3J0YW50O1xcXFxuICBjb2xvcjogI2YyNjIwMiAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItY29sb3I6ICNmMjYyMDIgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyotLS0gWWVsbG93IC0tLSovXFxcXG4udWkueWVsbG93LmxhYmVscyAubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS55ZWxsb3cubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGQkJEMDggIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjRkJCRDA4ICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIExpbmsgKi9cXFxcbi51aS55ZWxsb3cubGFiZWxzIC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyLFxcXFxuYS51aS55ZWxsb3cubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlYWFlMDAgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjZWFhZTAwICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIENvcm5lciAqL1xcXFxuLnVpLnllbGxvdy5jb3JuZXIubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS55ZWxsb3cuY29ybmVyLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBSaWJib24gKi9cXFxcbi51aS55ZWxsb3cucmliYm9uLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBib3JkZXItY29sb3I6ICNjZDk5MDMgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogQmFzaWMgKi9cXFxcbi51aS5iYXNpYy55ZWxsb3cubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkYgIWltcG9ydGFudDtcXFxcbiAgY29sb3I6ICNGQkJEMDggIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjRkJCRDA4ICFpbXBvcnRhbnQ7XFxcXG59XFxcXG4udWkuYmFzaWMueWVsbG93LmxhYmVscyBhLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIsXFxcXG5hLnVpLmJhc2ljLnllbGxvdy5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRiAhaW1wb3J0YW50O1xcXFxuICBjb2xvcjogI2VhYWUwMCAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItY29sb3I6ICNlYWFlMDAgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyotLS0gT2xpdmUgLS0tKi9cXFxcbi51aS5vbGl2ZS5sYWJlbHMgLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkub2xpdmUubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNCNUNDMTggIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjQjVDQzE4ICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIExpbmsgKi9cXFxcbi51aS5vbGl2ZS5sYWJlbHMgLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIsXFxcXG5hLnVpLm9saXZlLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjYTdiZDBkICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1jb2xvcjogI2E3YmQwZCAhaW1wb3J0YW50O1xcXFxuICBjb2xvcjogI0ZGRkZGRiAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBDb3JuZXIgKi9cXFxcbi51aS5vbGl2ZS5jb3JuZXIubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5vbGl2ZS5jb3JuZXIubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIFJpYmJvbiAqL1xcXFxuLnVpLm9saXZlLnJpYmJvbi5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjMTk4ZjM1ICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIEJhc2ljICovXFxcXG4udWkuYmFzaWMub2xpdmUubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkYgIWltcG9ydGFudDtcXFxcbiAgY29sb3I6ICNCNUNDMTggIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjQjVDQzE4ICFpbXBvcnRhbnQ7XFxcXG59XFxcXG4udWkuYmFzaWMub2xpdmUubGFiZWxzIGEubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlcixcXFxcbmEudWkuYmFzaWMub2xpdmUubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkYgIWltcG9ydGFudDtcXFxcbiAgY29sb3I6ICNhN2JkMGQgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjYTdiZDBkICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qLS0tIEdyZWVuIC0tLSovXFxcXG4udWkuZ3JlZW4ubGFiZWxzIC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmdyZWVuLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjFCQTQ1ICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1jb2xvcjogIzIxQkE0NSAhaW1wb3J0YW50O1xcXFxuICBjb2xvcjogI0ZGRkZGRiAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBMaW5rICovXFxcXG4udWkuZ3JlZW4ubGFiZWxzIC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyLFxcXFxuYS51aS5ncmVlbi5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogIzE2YWIzOSAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItY29sb3I6ICMxNmFiMzkgIWltcG9ydGFudDtcXFxcbiAgY29sb3I6ICNGRkZGRkYgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogQ29ybmVyICovXFxcXG4udWkuZ3JlZW4uY29ybmVyLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuZ3JlZW4uY29ybmVyLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBSaWJib24gKi9cXFxcbi51aS5ncmVlbi5yaWJib24ubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJvcmRlci1jb2xvcjogIzE5OGYzNSAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBCYXNpYyAqL1xcXFxuLnVpLmJhc2ljLmdyZWVuLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjMjFCQTQ1ICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1jb2xvcjogIzIxQkE0NSAhaW1wb3J0YW50O1xcXFxufVxcXFxuLnVpLmJhc2ljLmdyZWVuLmxhYmVscyBhLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIsXFxcXG5hLnVpLmJhc2ljLmdyZWVuLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjMTZhYjM5ICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1jb2xvcjogIzE2YWIzOSAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKi0tLSBUZWFsIC0tLSovXFxcXG4udWkudGVhbC5sYWJlbHMgLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkudGVhbC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogIzAwQjVBRCAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItY29sb3I6ICMwMEI1QUQgIWltcG9ydGFudDtcXFxcbiAgY29sb3I6ICNGRkZGRkYgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogTGluayAqL1xcXFxuLnVpLnRlYWwubGFiZWxzIC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyLFxcXFxuYS51aS50ZWFsLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDA5Yzk1ICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1jb2xvcjogIzAwOWM5NSAhaW1wb3J0YW50O1xcXFxuICBjb2xvcjogI0ZGRkZGRiAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBDb3JuZXIgKi9cXFxcbi51aS50ZWFsLmNvcm5lci5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLnRlYWwuY29ybmVyLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBSaWJib24gKi9cXFxcbi51aS50ZWFsLnJpYmJvbi5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjMDA4MjdjICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIEJhc2ljICovXFxcXG4udWkuYmFzaWMudGVhbC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRiAhaW1wb3J0YW50O1xcXFxuICBjb2xvcjogIzAwQjVBRCAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItY29sb3I6ICMwMEI1QUQgIWltcG9ydGFudDtcXFxcbn1cXFxcbi51aS5iYXNpYy50ZWFsLmxhYmVscyBhLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIsXFxcXG5hLnVpLmJhc2ljLnRlYWwubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkYgIWltcG9ydGFudDtcXFxcbiAgY29sb3I6ICMwMDljOTUgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjMDA5Yzk1ICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qLS0tIEJsdWUgLS0tKi9cXFxcbi51aS5ibHVlLmxhYmVscyAubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5ibHVlLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjE4NUQwICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1jb2xvcjogIzIxODVEMCAhaW1wb3J0YW50O1xcXFxuICBjb2xvcjogI0ZGRkZGRiAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBMaW5rICovXFxcXG4udWkuYmx1ZS5sYWJlbHMgLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIsXFxcXG5hLnVpLmJsdWUubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICMxNjc4YzIgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjMTY3OGMyICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIENvcm5lciAqL1xcXFxuLnVpLmJsdWUuY29ybmVyLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuYmx1ZS5jb3JuZXIubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIFJpYmJvbiAqL1xcXFxuLnVpLmJsdWUucmliYm9uLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBib3JkZXItY29sb3I6ICMxYTY5YTQgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogQmFzaWMgKi9cXFxcbi51aS5iYXNpYy5ibHVlLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjMjE4NUQwICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1jb2xvcjogIzIxODVEMCAhaW1wb3J0YW50O1xcXFxufVxcXFxuLnVpLmJhc2ljLmJsdWUubGFiZWxzIGEubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlcixcXFxcbmEudWkuYmFzaWMuYmx1ZS5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRiAhaW1wb3J0YW50O1xcXFxuICBjb2xvcjogIzE2NzhjMiAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItY29sb3I6ICMxNjc4YzIgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyotLS0gVmlvbGV0IC0tLSovXFxcXG4udWkudmlvbGV0LmxhYmVscyAubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS52aW9sZXQubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICM2NDM1QzkgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjNjQzNUM5ICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIExpbmsgKi9cXFxcbi51aS52aW9sZXQubGFiZWxzIC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyLFxcXFxuYS51aS52aW9sZXQubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICM1ODI5YmIgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjNTgyOWJiICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIENvcm5lciAqL1xcXFxuLnVpLnZpb2xldC5jb3JuZXIubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS52aW9sZXQuY29ybmVyLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBSaWJib24gKi9cXFxcbi51aS52aW9sZXQucmliYm9uLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBib3JkZXItY29sb3I6ICM1MDJhYTEgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogQmFzaWMgKi9cXFxcbi51aS5iYXNpYy52aW9sZXQubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkYgIWltcG9ydGFudDtcXFxcbiAgY29sb3I6ICM2NDM1QzkgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjNjQzNUM5ICFpbXBvcnRhbnQ7XFxcXG59XFxcXG4udWkuYmFzaWMudmlvbGV0LmxhYmVscyBhLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIsXFxcXG5hLnVpLmJhc2ljLnZpb2xldC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRiAhaW1wb3J0YW50O1xcXFxuICBjb2xvcjogIzU4MjliYiAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItY29sb3I6ICM1ODI5YmIgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyotLS0gUHVycGxlIC0tLSovXFxcXG4udWkucHVycGxlLmxhYmVscyAubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5wdXJwbGUubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNBMzMzQzggIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjQTMzM0M4ICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIExpbmsgKi9cXFxcbi51aS5wdXJwbGUubGFiZWxzIC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyLFxcXFxuYS51aS5wdXJwbGUubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICM5NjI3YmEgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjOTYyN2JhICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIENvcm5lciAqL1xcXFxuLnVpLnB1cnBsZS5jb3JuZXIubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5wdXJwbGUuY29ybmVyLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBSaWJib24gKi9cXFxcbi51aS5wdXJwbGUucmliYm9uLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBib3JkZXItY29sb3I6ICM4MjI5OWYgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogQmFzaWMgKi9cXFxcbi51aS5iYXNpYy5wdXJwbGUubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkYgIWltcG9ydGFudDtcXFxcbiAgY29sb3I6ICNBMzMzQzggIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjQTMzM0M4ICFpbXBvcnRhbnQ7XFxcXG59XFxcXG4udWkuYmFzaWMucHVycGxlLmxhYmVscyBhLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIsXFxcXG5hLnVpLmJhc2ljLnB1cnBsZS5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRiAhaW1wb3J0YW50O1xcXFxuICBjb2xvcjogIzk2MjdiYSAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItY29sb3I6ICM5NjI3YmEgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyotLS0gUGluayAtLS0qL1xcXFxuLnVpLnBpbmsubGFiZWxzIC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLnBpbmsubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNFMDM5OTcgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjRTAzOTk3ICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIExpbmsgKi9cXFxcbi51aS5waW5rLmxhYmVscyAubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlcixcXFxcbmEudWkucGluay5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogI2U2MWE4ZCAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItY29sb3I6ICNlNjFhOGQgIWltcG9ydGFudDtcXFxcbiAgY29sb3I6ICNGRkZGRkYgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogQ29ybmVyICovXFxcXG4udWkucGluay5jb3JuZXIubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5waW5rLmNvcm5lci5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogUmliYm9uICovXFxcXG4udWkucGluay5yaWJib24ubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJvcmRlci1jb2xvcjogI2M3MWY3ZSAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBCYXNpYyAqL1xcXFxuLnVpLmJhc2ljLnBpbmsubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkYgIWltcG9ydGFudDtcXFxcbiAgY29sb3I6ICNFMDM5OTcgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjRTAzOTk3ICFpbXBvcnRhbnQ7XFxcXG59XFxcXG4udWkuYmFzaWMucGluay5sYWJlbHMgYS5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyLFxcXFxuYS51aS5iYXNpYy5waW5rLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjZTYxYThkICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1jb2xvcjogI2U2MWE4ZCAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKi0tLSBCcm93biAtLS0qL1xcXFxuLnVpLmJyb3duLmxhYmVscyAubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5icm93bi5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogI0E1NjczRiAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItY29sb3I6ICNBNTY3M0YgIWltcG9ydGFudDtcXFxcbiAgY29sb3I6ICNGRkZGRkYgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogTGluayAqL1xcXFxuLnVpLmJyb3duLmxhYmVscyAubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlcixcXFxcbmEudWkuYnJvd24ubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICM5NzViMzMgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjOTc1YjMzICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIENvcm5lciAqL1xcXFxuLnVpLmJyb3duLmNvcm5lci5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmJyb3duLmNvcm5lci5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogUmliYm9uICovXFxcXG4udWkuYnJvd24ucmliYm9uLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBib3JkZXItY29sb3I6ICM4MDUwMzEgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogQmFzaWMgKi9cXFxcbi51aS5iYXNpYy5icm93bi5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRiAhaW1wb3J0YW50O1xcXFxuICBjb2xvcjogI0E1NjczRiAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItY29sb3I6ICNBNTY3M0YgIWltcG9ydGFudDtcXFxcbn1cXFxcbi51aS5iYXNpYy5icm93bi5sYWJlbHMgYS5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyLFxcXFxuYS51aS5iYXNpYy5icm93bi5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRiAhaW1wb3J0YW50O1xcXFxuICBjb2xvcjogIzk3NWIzMyAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItY29sb3I6ICM5NzViMzMgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyotLS0gR3JleSAtLS0qL1xcXFxuLnVpLmdyZXkubGFiZWxzIC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmdyZXkubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICM3Njc2NzYgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjNzY3Njc2ICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIExpbmsgKi9cXFxcbi51aS5ncmV5LmxhYmVscyAubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlcixcXFxcbmEudWkuZ3JleS5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogIzgzODM4MyAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItY29sb3I6ICM4MzgzODMgIWltcG9ydGFudDtcXFxcbiAgY29sb3I6ICNGRkZGRkYgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogQ29ybmVyICovXFxcXG4udWkuZ3JleS5jb3JuZXIubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5ncmV5LmNvcm5lci5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogUmliYm9uICovXFxcXG4udWkuZ3JleS5yaWJib24ubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJvcmRlci1jb2xvcjogIzgwNTAzMSAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKiBCYXNpYyAqL1xcXFxuLnVpLmJhc2ljLmdyZXkubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkYgIWltcG9ydGFudDtcXFxcbiAgY29sb3I6ICM3Njc2NzYgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjNzY3Njc2ICFpbXBvcnRhbnQ7XFxcXG59XFxcXG4udWkuYmFzaWMuZ3JleS5sYWJlbHMgYS5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyLFxcXFxuYS51aS5iYXNpYy5ncmV5LmxhYmVsW2RhdGEtdi1hM2RiZmMwY106aG92ZXIge1xcXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjODM4MzgzICFpbXBvcnRhbnQ7XFxcXG4gIGJvcmRlci1jb2xvcjogIzgzODM4MyAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKi0tLSBCbGFjayAtLS0qL1xcXFxuLnVpLmJsYWNrLmxhYmVscyAubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5ibGFjay5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogIzFCMUMxRCAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItY29sb3I6ICMxQjFDMUQgIWltcG9ydGFudDtcXFxcbiAgY29sb3I6ICNGRkZGRkYgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogTGluayAqL1xcXFxuLnVpLmJsYWNrLmxhYmVscyAubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlcixcXFxcbmEudWkuYmxhY2subGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6ICMyNzI5MmEgIWltcG9ydGFudDtcXFxcbiAgYm9yZGVyLWNvbG9yOiAjMjcyOTJhICFpbXBvcnRhbnQ7XFxcXG4gIGNvbG9yOiAjRkZGRkZGICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qIENvcm5lciAqL1xcXFxuLnVpLmJsYWNrLmNvcm5lci5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmJsYWNrLmNvcm5lci5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogUmliYm9uICovXFxcXG4udWkuYmxhY2sucmliYm9uLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBib3JkZXItY29sb3I6ICM4MDUwMzEgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyogQmFzaWMgKi9cXFxcbi51aS5iYXNpYy5ibGFjay5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRiAhaW1wb3J0YW50O1xcXFxuICBjb2xvcjogIzFCMUMxRCAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItY29sb3I6ICMxQjFDMUQgIWltcG9ydGFudDtcXFxcbn1cXFxcbi51aS5iYXNpYy5ibGFjay5sYWJlbHMgYS5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyLFxcXFxuYS51aS5iYXNpYy5ibGFjay5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmhvdmVyIHtcXFxcbiAgYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRiAhaW1wb3J0YW50O1xcXFxuICBjb2xvcjogIzI3MjkyYSAhaW1wb3J0YW50O1xcXFxuICBib3JkZXItY29sb3I6ICMyNzI5MmEgIWltcG9ydGFudDtcXFxcbn1cXFxcblxcXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gICAgICAgIEJhc2ljXFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuYmFzaWMubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGJhY2tncm91bmQ6IG5vbmUgI0ZGRkZGRjtcXFxcbiAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgzNCwgMzYsIDM4LCAwLjE1KTtcXFxcbiAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44Nyk7XFxcXG4gIGJveC1zaGFkb3c6IG5vbmU7XFxcXG59XFxcXG5cXFxcbi8qIExpbmsgKi9cXFxcbmEudWkuYmFzaWMubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpob3ZlciB7XFxcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXFxcbiAgYmFja2dyb3VuZDogbm9uZSAjRkZGRkZGO1xcXFxuICBjb2xvcjogIzFlNzBiZjtcXFxcbiAgYm94LXNoYWRvdzogMXB4IHNvbGlkIHJnYmEoMzQsIDM2LCAzOCwgMC4xNSk7XFxcXG4gIGJveC1zaGFkb3c6IG5vbmU7XFxcXG59XFxcXG5cXFxcbi8qIFBvaW50aW5nICovXFxcXG4udWkuYmFzaWMucG9pbnRpbmcubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpiZWZvcmUge1xcXFxuICBib3JkZXItY29sb3I6IGluaGVyaXQ7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLVxcXFxuICAgICAgIEZsdWlkXFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkubGFiZWwuZmx1aWRbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5mbHVpZC5sYWJlbHMgPiAubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIHdpZHRoOiAxMDAlO1xcXFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgICBJbnZlcnRlZFxcXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLmludmVydGVkLmxhYmVscyAubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5pbnZlcnRlZC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC45KSAhaW1wb3J0YW50O1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgSG9yaXpvbnRhbFxcXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLmhvcml6b250YWwubGFiZWxzIC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmhvcml6b250YWwubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG1hcmdpbjogMGVtIDAuNWVtIDBlbSAwZW07XFxcXG4gIHBhZGRpbmc6IDAuNGVtIDAuODMzZW07XFxcXG4gIG1pbi13aWR0aDogM2VtO1xcXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLVxcXFxuICAgICAgIENpcmN1bGFyXFxcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuY2lyY3VsYXIubGFiZWxzIC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmNpcmN1bGFyLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBtaW4td2lkdGg6IDJlbTtcXFxcbiAgbWluLWhlaWdodDogMmVtO1xcXFxuICBwYWRkaW5nOiAwLjVlbSAhaW1wb3J0YW50O1xcXFxuICBsaW5lLWhlaWdodDogMWVtO1xcXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxcXG4gIGJvcmRlci1yYWRpdXM6IDUwMHJlbTtcXFxcbn1cXFxcbi51aS5lbXB0eS5jaXJjdWxhci5sYWJlbHMgLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkuZW1wdHkuY2lyY3VsYXIubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG1pbi13aWR0aDogMGVtO1xcXFxuICBtaW4taGVpZ2h0OiAwZW07XFxcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxcXG4gIHdpZHRoOiAwLjVlbTtcXFxcbiAgaGVpZ2h0OiAwLjVlbTtcXFxcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcXFxufVxcXFxuXFxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbiAgICAgICBQb2ludGluZ1xcXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLnBvaW50aW5nLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxcXG59XFxcXG4udWkuYXR0YWNoZWQucG9pbnRpbmcubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcbn1cXFxcbi51aS5wb2ludGluZy5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmJlZm9yZSB7XFxcXG4gIGJhY2tncm91bmQtY29sb3I6IGluaGVyaXQ7XFxcXG4gIGJhY2tncm91bmQtaW1hZ2U6IGluaGVyaXQ7XFxcXG4gIGJvcmRlci13aWR0aDogbm9uZTtcXFxcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXFxcbiAgYm9yZGVyLWNvbG9yOiBpbmhlcml0O1xcXFxufVxcXFxuXFxcXG4vKiBBcnJvdyAqL1xcXFxuLnVpLnBvaW50aW5nLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106YmVmb3JlIHtcXFxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcXFxuICBjb250ZW50OiAnJztcXFxcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxcXG4gICAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcXFxuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXFxcbiAgYmFja2dyb3VuZC1pbWFnZTogbm9uZTtcXFxcbiAgei1pbmRleDogMjtcXFxcbiAgd2lkdGg6IDAuNjY2NmVtO1xcXFxuICBoZWlnaHQ6IDAuNjY2NmVtO1xcXFxuICAtd2Via2l0LXRyYW5zaXRpb246IGJhY2tncm91bmQgMC4xcyBlYXNlO1xcXFxuICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIDAuMXMgZWFzZTtcXFxcbn1cXFxcblxcXFxuLyotLS0gQWJvdmUgLS0tKi9cXFxcbi51aS5wb2ludGluZy5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpW2NsYXNzKj1cXFxcXFxcInBvaW50aW5nIGFib3ZlXFxcXFxcXCJdLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBtYXJnaW4tdG9wOiAxZW07XFxcXG59XFxcXG4udWkucG9pbnRpbmcubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpiZWZvcmUsXFxcXG4udWlbY2xhc3MqPVxcXFxcXFwicG9pbnRpbmcgYWJvdmVcXFxcXFxcIl0ubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpiZWZvcmUge1xcXFxuICBib3JkZXItd2lkdGg6IDFweCAwcHggMHB4IDFweDtcXFxcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgtNTAlKSByb3RhdGUoNDVkZWcpO1xcXFxuICAgICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC01MCUpIHJvdGF0ZSg0NWRlZyk7XFxcXG4gICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSkgcm90YXRlKDQ1ZGVnKTtcXFxcbiAgdG9wOiAwJTtcXFxcbiAgbGVmdDogNTAlO1xcXFxufVxcXFxuXFxcXG4vKi0tLSBCZWxvdyAtLS0qL1xcXFxuLnVpW2NsYXNzKj1cXFxcXFxcImJvdHRvbSBwb2ludGluZ1xcXFxcXFwiXS5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpW2NsYXNzKj1cXFxcXFxcInBvaW50aW5nIGJlbG93XFxcXFxcXCJdLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBtYXJnaW4tdG9wOiAwZW07XFxcXG4gIG1hcmdpbi1ib3R0b206IDFlbTtcXFxcbn1cXFxcbi51aVtjbGFzcyo9XFxcXFxcXCJib3R0b20gcG9pbnRpbmdcXFxcXFxcIl0ubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpiZWZvcmUsXFxcXG4udWlbY2xhc3MqPVxcXFxcXFwicG9pbnRpbmcgYmVsb3dcXFxcXFxcIl0ubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpiZWZvcmUge1xcXFxuICBib3JkZXItd2lkdGg6IDBweCAxcHggMXB4IDBweDtcXFxcbiAgdG9wOiBhdXRvO1xcXFxuICByaWdodDogYXV0bztcXFxcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgtNTAlKSByb3RhdGUoNDVkZWcpO1xcXFxuICAgICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC01MCUpIHJvdGF0ZSg0NWRlZyk7XFxcXG4gICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSkgcm90YXRlKDQ1ZGVnKTtcXFxcbiAgdG9wOiAxMDAlO1xcXFxuICBsZWZ0OiA1MCU7XFxcXG59XFxcXG5cXFxcbi8qLS0tIExlZnQgLS0tKi9cXFxcbi51aVtjbGFzcyo9XFxcXFxcXCJsZWZ0IHBvaW50aW5nXFxcXFxcXCJdLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBtYXJnaW4tdG9wOiAwZW07XFxcXG4gIG1hcmdpbi1sZWZ0OiAwLjY2NjZlbTtcXFxcbn1cXFxcbi51aVtjbGFzcyo9XFxcXFxcXCJsZWZ0IHBvaW50aW5nXFxcXFxcXCJdLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106YmVmb3JlIHtcXFxcbiAgYm9yZGVyLXdpZHRoOiAwcHggMHB4IDFweCAxcHg7XFxcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSkgcm90YXRlKDQ1ZGVnKTtcXFxcbiAgICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgtNTAlKSByb3RhdGUoNDVkZWcpO1xcXFxuICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC01MCUpIHJvdGF0ZSg0NWRlZyk7XFxcXG4gIGJvdHRvbTogYXV0bztcXFxcbiAgcmlnaHQ6IGF1dG87XFxcXG4gIHRvcDogNTAlO1xcXFxuICBsZWZ0OiAwZW07XFxcXG59XFxcXG5cXFxcbi8qLS0tIFJpZ2h0IC0tLSovXFxcXG4udWlbY2xhc3MqPVxcXFxcXFwicmlnaHQgcG9pbnRpbmdcXFxcXFxcIl0ubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIG1hcmdpbi10b3A6IDBlbTtcXFxcbiAgbWFyZ2luLXJpZ2h0OiAwLjY2NjZlbTtcXFxcbn1cXFxcbi51aVtjbGFzcyo9XFxcXFxcXCJyaWdodCBwb2ludGluZ1xcXFxcXFwiXS5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmJlZm9yZSB7XFxcXG4gIGJvcmRlci13aWR0aDogMXB4IDFweCAwcHggMHB4O1xcXFxuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCg1MCUpIHRyYW5zbGF0ZVkoLTUwJSkgcm90YXRlKDQ1ZGVnKTtcXFxcbiAgICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoNTAlKSB0cmFuc2xhdGVZKC01MCUpIHJvdGF0ZSg0NWRlZyk7XFxcXG4gICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDUwJSkgdHJhbnNsYXRlWSgtNTAlKSByb3RhdGUoNDVkZWcpO1xcXFxuICB0b3A6IDUwJTtcXFxcbiAgcmlnaHQ6IDAlO1xcXFxuICBib3R0b206IGF1dG87XFxcXG4gIGxlZnQ6IGF1dG87XFxcXG59XFxcXG5cXFxcbi8qIEJhc2ljIFBvaW50aW5nICovXFxcXG5cXFxcbi8qLS0tIEFib3ZlIC0tLSovXFxcXG4udWkuYmFzaWMucG9pbnRpbmcubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpiZWZvcmUsXFxcXG4udWkuYmFzaWNbY2xhc3MqPVxcXFxcXFwicG9pbnRpbmcgYWJvdmVcXFxcXFxcIl0ubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpiZWZvcmUge1xcXFxuICBtYXJnaW4tdG9wOiAtMXB4O1xcXFxufVxcXFxuXFxcXG4vKi0tLSBCZWxvdyAtLS0qL1xcXFxuLnVpLmJhc2ljW2NsYXNzKj1cXFxcXFxcImJvdHRvbSBwb2ludGluZ1xcXFxcXFwiXS5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmJlZm9yZSxcXFxcbi51aS5iYXNpY1tjbGFzcyo9XFxcXFxcXCJwb2ludGluZyBiZWxvd1xcXFxcXFwiXS5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdOmJlZm9yZSB7XFxcXG4gIGJvdHRvbTogYXV0bztcXFxcbiAgdG9wOiAxMDAlO1xcXFxuICBtYXJnaW4tdG9wOiAxcHg7XFxcXG59XFxcXG5cXFxcbi8qLS0tIExlZnQgLS0tKi9cXFxcbi51aS5iYXNpY1tjbGFzcyo9XFxcXFxcXCJsZWZ0IHBvaW50aW5nXFxcXFxcXCJdLmxhYmVsW2RhdGEtdi1hM2RiZmMwY106YmVmb3JlIHtcXFxcbiAgdG9wOiA1MCU7XFxcXG4gIGxlZnQ6IC0xcHg7XFxcXG59XFxcXG5cXFxcbi8qLS0tIFJpZ2h0IC0tLSovXFxcXG4udWkuYmFzaWNbY2xhc3MqPVxcXFxcXFwicmlnaHQgcG9pbnRpbmdcXFxcXFxcIl0ubGFiZWxbZGF0YS12LWEzZGJmYzBjXTpiZWZvcmUge1xcXFxuICB0b3A6IDUwJTtcXFxcbiAgcmlnaHQ6IC0xcHg7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tXFxcXG4gICBGbG9hdGluZyBMYWJlbFxcXFxuLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxcXG4udWkuZmxvYXRpbmcubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcbiAgei1pbmRleDogMTAwO1xcXFxuICB0b3A6IC0xZW07XFxcXG4gIGxlZnQ6IDEwMCU7XFxcXG4gIG1hcmdpbjogMGVtIDBlbSAwZW0gLTEuNWVtICFpbXBvcnRhbnQ7XFxcXG59XFxcXG5cXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLVxcXFxuICAgICAgICBTaXplc1xcXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcXFxuLnVpLm1pbmkubGFiZWxzIC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLm1pbmkubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGZvbnQtc2l6ZTogMC42NDI4NTcxNHJlbTtcXFxcbn1cXFxcbi51aS50aW55LmxhYmVscyAubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS50aW55LmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBmb250LXNpemU6IDAuNzE0Mjg1NzFyZW07XFxcXG59XFxcXG4udWkuc21hbGwubGFiZWxzIC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLnNtYWxsLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBmb250LXNpemU6IDAuNzg1NzE0MjlyZW07XFxcXG59XFxcXG4udWkubGFiZWxzIC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBmb250LXNpemU6IDAuODU3MTQyODZyZW07XFxcXG59XFxcXG4udWkubGFyZ2UubGFiZWxzIC5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdLFxcXFxuLnVpLmxhcmdlLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBmb250LXNpemU6IDFyZW07XFxcXG59XFxcXG4udWkuYmlnLmxhYmVscyAubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5iaWcubGFiZWxbZGF0YS12LWEzZGJmYzBjXSB7XFxcXG4gIGZvbnQtc2l6ZTogMS4yODU3MTQyOXJlbTtcXFxcbn1cXFxcbi51aS5odWdlLmxhYmVscyAubGFiZWxbZGF0YS12LWEzZGJmYzBjXSxcXFxcbi51aS5odWdlLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10ge1xcXFxuICBmb250LXNpemU6IDEuNDI4NTcxNDNyZW07XFxcXG59XFxcXG4udWkubWFzc2l2ZS5sYWJlbHMgLmxhYmVsW2RhdGEtdi1hM2RiZmMwY10sXFxcXG4udWkubWFzc2l2ZS5sYWJlbFtkYXRhLXYtYTNkYmZjMGNdIHtcXFxcbiAgZm9udC1zaXplOiAxLjcxNDI4NTcxcmVtO1xcXFxufVxcXFxuXFxcXG5cXFxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxcXG4gICAgICAgICBUaGVtZSBPdmVycmlkZXNcXFxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxcXG5cXFxcblxcXFxuXFxcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcXFxuICAgICAgICAgU2l0ZSBPdmVycmlkZXNcXFxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxcXG5cXFxcblxcXCIsIFxcXCJcXFwiXSk7XFxuXFx0XFxuXFx0Ly8gZXhwb3J0c1xcblxcblxcbi8qKiovIH0sXFxuLyogOTcgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHR2YXIgX192dWVfZXhwb3J0c19fLCBfX3Z1ZV9vcHRpb25zX19cXG5cXHR2YXIgX192dWVfc3R5bGVzX18gPSB7fVxcblxcdFxcblxcdC8qIHNjcmlwdCAqL1xcblxcdF9fdnVlX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpXFxuXFx0X192dWVfb3B0aW9uc19fID0gX192dWVfZXhwb3J0c19fID0gX192dWVfZXhwb3J0c19fIHx8IHt9XFxuXFx0aWYgKFxcblxcdCAgdHlwZW9mIF9fdnVlX2V4cG9ydHNfXy5kZWZhdWx0ID09PSBcXFwib2JqZWN0XFxcIiB8fFxcblxcdCAgdHlwZW9mIF9fdnVlX2V4cG9ydHNfXy5kZWZhdWx0ID09PSBcXFwiZnVuY3Rpb25cXFwiXFxuXFx0KSB7XFxuXFx0X192dWVfb3B0aW9uc19fID0gX192dWVfZXhwb3J0c19fID0gX192dWVfZXhwb3J0c19fLmRlZmF1bHRcXG5cXHR9XFxuXFx0aWYgKHR5cGVvZiBfX3Z1ZV9vcHRpb25zX18gPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXG5cXHQgIF9fdnVlX29wdGlvbnNfXyA9IF9fdnVlX29wdGlvbnNfXy5vcHRpb25zXFxuXFx0fVxcblxcdFxcblxcdFxcblxcdG1vZHVsZS5leHBvcnRzID0gX192dWVfZXhwb3J0c19fXFxuXFxuXFxuLyoqKi8gfSxcXG4vKiA5OCAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdHZhciBfX3Z1ZV9leHBvcnRzX18sIF9fdnVlX29wdGlvbnNfX1xcblxcdHZhciBfX3Z1ZV9zdHlsZXNfXyA9IHt9XFxuXFx0XFxuXFx0Lyogc2NyaXB0ICovXFxuXFx0X192dWVfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSlcXG5cXHRfX3Z1ZV9vcHRpb25zX18gPSBfX3Z1ZV9leHBvcnRzX18gPSBfX3Z1ZV9leHBvcnRzX18gfHwge31cXG5cXHRpZiAoXFxuXFx0ICB0eXBlb2YgX192dWVfZXhwb3J0c19fLmRlZmF1bHQgPT09IFxcXCJvYmplY3RcXFwiIHx8XFxuXFx0ICB0eXBlb2YgX192dWVfZXhwb3J0c19fLmRlZmF1bHQgPT09IFxcXCJmdW5jdGlvblxcXCJcXG5cXHQpIHtcXG5cXHRfX3Z1ZV9vcHRpb25zX18gPSBfX3Z1ZV9leHBvcnRzX18gPSBfX3Z1ZV9leHBvcnRzX18uZGVmYXVsdFxcblxcdH1cXG5cXHRpZiAodHlwZW9mIF9fdnVlX29wdGlvbnNfXyA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcblxcdCAgX192dWVfb3B0aW9uc19fID0gX192dWVfb3B0aW9uc19fLm9wdGlvbnNcXG5cXHR9XFxuXFx0XFxuXFx0XFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9leHBvcnRzX19cXG5cXG5cXG4vKioqLyB9LFxcbi8qIDk5ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0dmFyIF9fdnVlX2V4cG9ydHNfXywgX192dWVfb3B0aW9uc19fXFxuXFx0dmFyIF9fdnVlX3N0eWxlc19fID0ge31cXG5cXHRcXG5cXHQvKiBzY3JpcHQgKi9cXG5cXHRfX3Z1ZV9leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKVxcblxcdF9fdnVlX29wdGlvbnNfXyA9IF9fdnVlX2V4cG9ydHNfXyA9IF9fdnVlX2V4cG9ydHNfXyB8fCB7fVxcblxcdGlmIChcXG5cXHQgIHR5cGVvZiBfX3Z1ZV9leHBvcnRzX18uZGVmYXVsdCA9PT0gXFxcIm9iamVjdFxcXCIgfHxcXG5cXHQgIHR5cGVvZiBfX3Z1ZV9leHBvcnRzX18uZGVmYXVsdCA9PT0gXFxcImZ1bmN0aW9uXFxcIlxcblxcdCkge1xcblxcdF9fdnVlX29wdGlvbnNfXyA9IF9fdnVlX2V4cG9ydHNfXyA9IF9fdnVlX2V4cG9ydHNfXy5kZWZhdWx0XFxuXFx0fVxcblxcdGlmICh0eXBlb2YgX192dWVfb3B0aW9uc19fID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuXFx0ICBfX3Z1ZV9vcHRpb25zX18gPSBfX3Z1ZV9vcHRpb25zX18ub3B0aW9uc1xcblxcdH1cXG5cXHRcXG5cXHRcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IF9fdnVlX2V4cG9ydHNfX1xcblxcblxcbi8qKiovIH0sXFxuLyogMTAwICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFx0bW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcXG5cXHQgIHJldHVybiBfYygnZGl2Jywge1xcblxcdCAgICBzdGF0aWNDbGFzczogXFxcInVpIGZsdWlkIHNlYXJjaCBzZWxlY3Rpb24gZHJvcGRvd25cXFwiLFxcblxcdCAgICBjbGFzczoge1xcblxcdCAgICAgICdhY3RpdmUgdmlzaWJsZSc6IF92bS5zaG93TWVudSwgJ2Vycm9yJzogX3ZtLmlzRXJyb3IsICdkaXNhYmxlZCc6IF92bS5pc0Rpc2FibGVkXFxuXFx0ICAgIH0sXFxuXFx0ICAgIG9uOiB7XFxuXFx0ICAgICAgXFxcImNsaWNrXFxcIjogX3ZtLm9wZW5PcHRpb25zLFxcblxcdCAgICAgIFxcXCJmb2N1c1xcXCI6IF92bS5vcGVuT3B0aW9uc1xcblxcdCAgICB9XFxuXFx0ICB9LCBbX2MoJ2knLCB7XFxuXFx0ICAgIHN0YXRpY0NsYXNzOiBcXFwiZHJvcGRvd24gaWNvblxcXCJcXG5cXHQgIH0pLCBfdm0uX3YoXFxcIiBcXFwiKSwgX2MoJ2lucHV0Jywge1xcblxcdCAgICByZWY6IFxcXCJpbnB1dFxcXCIsXFxuXFx0ICAgIHN0YXRpY0NsYXNzOiBcXFwic2VhcmNoXFxcIixcXG5cXHQgICAgYXR0cnM6IHtcXG5cXHQgICAgICBcXFwiYXV0b2NvbXBsZXRlXFxcIjogXFxcIm9mZlxcXCIsXFxuXFx0ICAgICAgXFxcInRhYmluZGV4XFxcIjogXFxcIjBcXFwiLFxcblxcdCAgICAgIFxcXCJpZFxcXCI6IF92bS5pZCxcXG5cXHQgICAgICBcXFwibmFtZVxcXCI6IF92bS5uYW1lXFxuXFx0ICAgIH0sXFxuXFx0ICAgIGRvbVByb3BzOiB7XFxuXFx0ICAgICAgXFxcInZhbHVlXFxcIjogX3ZtLnNlYXJjaFRleHRcXG5cXHQgICAgfSxcXG5cXHQgICAgb246IHtcXG5cXHQgICAgICBcXFwiaW5wdXRcXFwiOiBmdW5jdGlvbigkZXZlbnQpIHtcXG5cXHQgICAgICAgIF92bS5zZWFyY2hUZXh0ID0gJGV2ZW50LnRhcmdldC52YWx1ZVxcblxcdCAgICAgIH0sXFxuXFx0ICAgICAgXFxcImZvY3VzXFxcIjogZnVuY3Rpb24oJGV2ZW50KSB7XFxuXFx0ICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHQgICAgICAgIF92bS5vcGVuT3B0aW9ucygkZXZlbnQpXFxuXFx0ICAgICAgfSxcXG5cXHQgICAgICBcXFwia2V5dXBcXFwiOiBbZnVuY3Rpb24oJGV2ZW50KSB7XFxuXFx0ICAgICAgICBpZiAoX3ZtLl9rKCRldmVudC5rZXlDb2RlLCBcXFwiZXNjXFxcIiwgMjcpKSB7IHJldHVybjsgfVxcblxcdCAgICAgICAgX3ZtLmNsb3NlT3B0aW9ucygkZXZlbnQpXFxuXFx0ICAgICAgfSwgZnVuY3Rpb24oJGV2ZW50KSB7XFxuXFx0ICAgICAgICBpZiAoX3ZtLl9rKCRldmVudC5rZXlDb2RlLCBcXFwiZW50ZXJcXFwiLCAxMykpIHsgcmV0dXJuOyB9XFxuXFx0ICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHQgICAgICAgIF92bS5lbnRlckl0ZW0oJGV2ZW50KVxcblxcdCAgICAgIH1dLFxcblxcdCAgICAgIFxcXCJibHVyXFxcIjogX3ZtLmJsdXJJbnB1dCxcXG5cXHQgICAgICBcXFwia2V5ZG93blxcXCI6IFtmdW5jdGlvbigkZXZlbnQpIHtcXG5cXHQgICAgICAgIGlmIChfdm0uX2soJGV2ZW50LmtleUNvZGUsIFxcXCJ1cFxcXCIsIDM4KSkgeyByZXR1cm47IH1cXG5cXHQgICAgICAgIF92bS5wcmV2SXRlbSgkZXZlbnQpXFxuXFx0ICAgICAgfSwgZnVuY3Rpb24oJGV2ZW50KSB7XFxuXFx0ICAgICAgICBpZiAoX3ZtLl9rKCRldmVudC5rZXlDb2RlLCBcXFwiZG93blxcXCIsIDQwKSkgeyByZXR1cm47IH1cXG5cXHQgICAgICAgIF92bS5uZXh0SXRlbSgkZXZlbnQpXFxuXFx0ICAgICAgfSwgZnVuY3Rpb24oJGV2ZW50KSB7XFxuXFx0ICAgICAgICBpZiAoX3ZtLl9rKCRldmVudC5rZXlDb2RlLCBcXFwiZW50ZXJcXFwiLCAxMykpIHsgcmV0dXJuOyB9XFxuXFx0ICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHQgICAgICB9LCBmdW5jdGlvbigkZXZlbnQpIHtcXG5cXHQgICAgICAgIGlmIChfdm0uX2soJGV2ZW50LmtleUNvZGUsIFxcXCJkZWxldGVcXFwiLCBbOCwgNDZdKSkgeyByZXR1cm47IH1cXG5cXHQgICAgICAgIF92bS5kZWxldGVUZXh0T3JJdGVtKCRldmVudClcXG5cXHQgICAgICB9XVxcblxcdCAgICB9XFxuXFx0ICB9KSwgX3ZtLl92KFxcXCIgXFxcIiksIF9jKCdkaXYnLCB7XFxuXFx0ICAgIHN0YXRpY0NsYXNzOiBcXFwidGV4dFxcXCIsXFxuXFx0ICAgIGNsYXNzOiBfdm0udGV4dENsYXNzLFxcblxcdCAgICBhdHRyczoge1xcblxcdCAgICAgIFxcXCJkYXRhLXZzcy1jdXN0b20tYXR0clxcXCI6IF92bS5zZWFyY2hUZXh0Q3VzdG9tQXR0clxcblxcdCAgICB9XFxuXFx0ICB9LCBbX3ZtLl92KF92bS5fcyhfdm0uaW5wdXRUZXh0KSArIFxcXCJcXFxcbiAgXFxcIildKSwgX3ZtLl92KFxcXCIgXFxcIiksIF9jKCdkaXYnLCB7XFxuXFx0ICAgIHJlZjogXFxcIm1lbnVcXFwiLFxcblxcdCAgICBzdGF0aWNDbGFzczogXFxcIm1lbnVcXFwiLFxcblxcdCAgICBjbGFzczogX3ZtLm1lbnVDbGFzcyxcXG5cXHQgICAgc3R5bGU6IChfdm0ubWVudVN0eWxlKSxcXG5cXHQgICAgYXR0cnM6IHtcXG5cXHQgICAgICBcXFwidGFiaW5kZXhcXFwiOiBcXFwiLTFcXFwiXFxuXFx0ICAgIH0sXFxuXFx0ICAgIG9uOiB7XFxuXFx0ICAgICAgXFxcIm1vdXNlZG93blxcXCI6IGZ1bmN0aW9uKCRldmVudCkge1xcblxcdCAgICAgICAgJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICB9LCBbX3ZtLl9sKChfdm0uZmlsdGVyZWRPcHRpb25zKSwgZnVuY3Rpb24ob3B0aW9uLCBpZHgpIHtcXG5cXHQgICAgcmV0dXJuIFtfYygnZGl2Jywge1xcblxcdCAgICAgIHN0YXRpY0NsYXNzOiBcXFwiaXRlbVxcXCIsXFxuXFx0ICAgICAgY2xhc3M6IHtcXG5cXHQgICAgICAgICdzZWxlY3RlZCc6IG9wdGlvbi5zZWxlY3RlZCwgJ2N1cnJlbnQnOiBfdm0ucG9pbnRlciA9PT0gaWR4XFxuXFx0ICAgICAgfSxcXG5cXHQgICAgICBhdHRyczoge1xcblxcdCAgICAgICAgXFxcImRhdGEtdnNzLWN1c3RvbS1hdHRyXFxcIjogX3ZtLmN1c3RvbUF0dHJzW2lkeF0gPyBfdm0uY3VzdG9tQXR0cnNbaWR4XSA6ICcnXFxuXFx0ICAgICAgfSxcXG5cXHQgICAgICBvbjoge1xcblxcdCAgICAgICAgXFxcImNsaWNrXFxcIjogZnVuY3Rpb24oJGV2ZW50KSB7XFxuXFx0ICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXHQgICAgICAgICAgX3ZtLnNlbGVjdEl0ZW0ob3B0aW9uKVxcblxcdCAgICAgICAgfSxcXG5cXHQgICAgICAgIFxcXCJtb3VzZWRvd25cXFwiOiBfdm0ubW91c2Vkb3duSXRlbSxcXG5cXHQgICAgICAgIFxcXCJtb3VzZWVudGVyXFxcIjogZnVuY3Rpb24oJGV2ZW50KSB7XFxuXFx0ICAgICAgICAgIF92bS5wb2ludGVyU2V0KGlkeClcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9XFxuXFx0ICAgIH0sIFtfdm0uX3YoXFxcIlxcXFxuICAgICAgICBcXFwiICsgX3ZtLl9zKG9wdGlvbi50ZXh0KSArIFxcXCJcXFxcbiAgICAgIFxcXCIpXSldXFxuXFx0ICB9KV0sIDIpXSlcXG5cXHR9LHN0YXRpY1JlbmRlckZuczogW119XFxuXFxuLyoqKi8gfSxcXG4vKiAxMDEgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHRtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xcblxcdCAgcmV0dXJuIF9jKCdkaXYnLCB7XFxuXFx0ICAgIHN0YXRpY0NsYXNzOiBcXFwidWkgZmx1aWQgc2VhcmNoIHNlbGVjdGlvbiBkcm9wZG93blxcXCIsXFxuXFx0ICAgIGNsYXNzOiB7XFxuXFx0ICAgICAgJ2FjdGl2ZSB2aXNpYmxlJzogX3ZtLnNob3dNZW51LCAnZXJyb3InOiBfdm0uaXNFcnJvciwgJ2Rpc2FibGVkJzogX3ZtLmlzRGlzYWJsZWRcXG5cXHQgICAgfSxcXG5cXHQgICAgb246IHtcXG5cXHQgICAgICBcXFwiY2xpY2tcXFwiOiBfdm0ub3Blbk9wdGlvbnMsXFxuXFx0ICAgICAgXFxcImZvY3VzXFxcIjogX3ZtLm9wZW5PcHRpb25zXFxuXFx0ICAgIH1cXG5cXHQgIH0sIFtfYygnaScsIHtcXG5cXHQgICAgc3RhdGljQ2xhc3M6IFxcXCJkcm9wZG93biBpY29uXFxcIlxcblxcdCAgfSksIF92bS5fdihcXFwiIFxcXCIpLCBfYygnaW5wdXQnLCB7XFxuXFx0ICAgIHJlZjogXFxcImlucHV0XFxcIixcXG5cXHQgICAgc3RhdGljQ2xhc3M6IFxcXCJzZWFyY2hcXFwiLFxcblxcdCAgICBhdHRyczoge1xcblxcdCAgICAgIFxcXCJhdXRvY29tcGxldGVcXFwiOiBcXFwib2ZmXFxcIixcXG5cXHQgICAgICBcXFwidGFiaW5kZXhcXFwiOiBcXFwiMFxcXCIsXFxuXFx0ICAgICAgXFxcImlkXFxcIjogX3ZtLmlkLFxcblxcdCAgICAgIFxcXCJuYW1lXFxcIjogX3ZtLm5hbWVcXG5cXHQgICAgfSxcXG5cXHQgICAgZG9tUHJvcHM6IHtcXG5cXHQgICAgICBcXFwidmFsdWVcXFwiOiBfdm0uc2VhcmNoVGV4dFxcblxcdCAgICB9LFxcblxcdCAgICBvbjoge1xcblxcdCAgICAgIFxcXCJpbnB1dFxcXCI6IGZ1bmN0aW9uKCRldmVudCkge1xcblxcdCAgICAgICAgX3ZtLnNlYXJjaFRleHQgPSAkZXZlbnQudGFyZ2V0LnZhbHVlXFxuXFx0ICAgICAgfSxcXG5cXHQgICAgICBcXFwiZm9jdXNcXFwiOiBmdW5jdGlvbigkZXZlbnQpIHtcXG5cXHQgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdCAgICAgICAgX3ZtLm9wZW5PcHRpb25zKCRldmVudClcXG5cXHQgICAgICB9LFxcblxcdCAgICAgIFxcXCJrZXl1cFxcXCI6IFtmdW5jdGlvbigkZXZlbnQpIHtcXG5cXHQgICAgICAgIGlmIChfdm0uX2soJGV2ZW50LmtleUNvZGUsIFxcXCJlc2NcXFwiLCAyNykpIHsgcmV0dXJuOyB9XFxuXFx0ICAgICAgICBfdm0uY2xvc2VPcHRpb25zKCRldmVudClcXG5cXHQgICAgICB9LCBmdW5jdGlvbigkZXZlbnQpIHtcXG5cXHQgICAgICAgIGlmIChfdm0uX2soJGV2ZW50LmtleUNvZGUsIFxcXCJlbnRlclxcXCIsIDEzKSkgeyByZXR1cm47IH1cXG5cXHQgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdCAgICAgICAgX3ZtLmVudGVySXRlbSgkZXZlbnQpXFxuXFx0ICAgICAgfV0sXFxuXFx0ICAgICAgXFxcImJsdXJcXFwiOiBfdm0uYmx1cklucHV0LFxcblxcdCAgICAgIFxcXCJrZXlkb3duXFxcIjogW2Z1bmN0aW9uKCRldmVudCkge1xcblxcdCAgICAgICAgaWYgKF92bS5faygkZXZlbnQua2V5Q29kZSwgXFxcInVwXFxcIiwgMzgpKSB7IHJldHVybjsgfVxcblxcdCAgICAgICAgX3ZtLnByZXZJdGVtKCRldmVudClcXG5cXHQgICAgICB9LCBmdW5jdGlvbigkZXZlbnQpIHtcXG5cXHQgICAgICAgIGlmIChfdm0uX2soJGV2ZW50LmtleUNvZGUsIFxcXCJkb3duXFxcIiwgNDApKSB7IHJldHVybjsgfVxcblxcdCAgICAgICAgX3ZtLm5leHRJdGVtKCRldmVudClcXG5cXHQgICAgICB9LCBmdW5jdGlvbigkZXZlbnQpIHtcXG5cXHQgICAgICAgIGlmIChfdm0uX2soJGV2ZW50LmtleUNvZGUsIFxcXCJlbnRlclxcXCIsIDEzKSkgeyByZXR1cm47IH1cXG5cXHQgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdCAgICAgIH0sIGZ1bmN0aW9uKCRldmVudCkge1xcblxcdCAgICAgICAgaWYgKF92bS5faygkZXZlbnQua2V5Q29kZSwgXFxcImRlbGV0ZVxcXCIsIFs4LCA0Nl0pKSB7IHJldHVybjsgfVxcblxcdCAgICAgICAgX3ZtLmRlbGV0ZVRleHRPckl0ZW0oJGV2ZW50KVxcblxcdCAgICAgIH1dXFxuXFx0ICAgIH1cXG5cXHQgIH0pLCBfdm0uX3YoXFxcIiBcXFwiKSwgX2MoJ2RpdicsIHtcXG5cXHQgICAgc3RhdGljQ2xhc3M6IFxcXCJ0ZXh0XFxcIixcXG5cXHQgICAgY2xhc3M6IF92bS50ZXh0Q2xhc3MsXFxuXFx0ICAgIGF0dHJzOiB7XFxuXFx0ICAgICAgXFxcImRhdGEtdnNzLWN1c3RvbS1hdHRyXFxcIjogX3ZtLnNlYXJjaFRleHRDdXN0b21BdHRyXFxuXFx0ICAgIH1cXG5cXHQgIH0sIFtfdm0uX3YoX3ZtLl9zKF92bS5pbnB1dFRleHQpICsgXFxcIlxcXFxuICBcXFwiKV0pLCBfdm0uX3YoXFxcIiBcXFwiKSwgX2MoJ2RpdicsIHtcXG5cXHQgICAgcmVmOiBcXFwibWVudVxcXCIsXFxuXFx0ICAgIHN0YXRpY0NsYXNzOiBcXFwibWVudVxcXCIsXFxuXFx0ICAgIGNsYXNzOiBfdm0ubWVudUNsYXNzLFxcblxcdCAgICBzdHlsZTogKF92bS5tZW51U3R5bGUpLFxcblxcdCAgICBhdHRyczoge1xcblxcdCAgICAgIFxcXCJ0YWJpbmRleFxcXCI6IFxcXCItMVxcXCJcXG5cXHQgICAgfSxcXG5cXHQgICAgb246IHtcXG5cXHQgICAgICBcXFwibW91c2Vkb3duXFxcIjogZnVuY3Rpb24oJGV2ZW50KSB7XFxuXFx0ICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH0sIFtfdm0uX2woKF92bS5maWx0ZXJlZE9wdGlvbnMpLCBmdW5jdGlvbihvcHRpb24sIGlkeCkge1xcblxcdCAgICByZXR1cm4gW19jKCdkaXYnLCB7XFxuXFx0ICAgICAgc3RhdGljQ2xhc3M6IFxcXCJpdGVtXFxcIixcXG5cXHQgICAgICBjbGFzczoge1xcblxcdCAgICAgICAgJ3NlbGVjdGVkJzogb3B0aW9uLnNlbGVjdGVkLCAnY3VycmVudCc6IF92bS5wb2ludGVyID09PSBpZHhcXG5cXHQgICAgICB9LFxcblxcdCAgICAgIGF0dHJzOiB7XFxuXFx0ICAgICAgICBcXFwiZGF0YS12c3MtY3VzdG9tLWF0dHJcXFwiOiBfdm0uY3VzdG9tQXR0cnNbaWR4XSA/IF92bS5jdXN0b21BdHRyc1tpZHhdIDogJydcXG5cXHQgICAgICB9LFxcblxcdCAgICAgIG9uOiB7XFxuXFx0ICAgICAgICBcXFwiY2xpY2tcXFwiOiBmdW5jdGlvbigkZXZlbnQpIHtcXG5cXHQgICAgICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xcblxcdCAgICAgICAgICBfdm0uc2VsZWN0SXRlbShvcHRpb24pXFxuXFx0ICAgICAgICB9LFxcblxcdCAgICAgICAgXFxcIm1vdXNlZG93blxcXCI6IF92bS5tb3VzZWRvd25JdGVtLFxcblxcdCAgICAgICAgXFxcIm1vdXNlZW50ZXJcXFwiOiBmdW5jdGlvbigkZXZlbnQpIHtcXG5cXHQgICAgICAgICAgX3ZtLnBvaW50ZXJTZXQoaWR4KVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgIH1cXG5cXHQgICAgfSwgW192bS5fdihcXFwiXFxcXG4gICAgICAgIFxcXCIgKyBfdm0uX3Mob3B0aW9uLnRleHQpICsgXFxcIlxcXFxuICAgICAgXFxcIildKV1cXG5cXHQgIH0pXSwgMildKVxcblxcdH0sc3RhdGljUmVuZGVyRm5zOiBbXX1cXG5cXG4vKioqLyB9LFxcbi8qIDEwMiAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdG1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XFxuXFx0ICByZXR1cm4gX2MoJ2RpdicsIHtcXG5cXHQgICAgc3RhdGljQ2xhc3M6IFxcXCJ1aSBmbHVpZCBtdWx0aXBsZSBzZWFyY2ggc2VsZWN0aW9uIGRyb3Bkb3duXFxcIixcXG5cXHQgICAgY2xhc3M6IHtcXG5cXHQgICAgICAnYWN0aXZlIHZpc2libGUnOiBfdm0uc2hvd01lbnUsICdlcnJvcic6IF92bS5pc0Vycm9yLCAnZGlzYWJsZWQnOiBfdm0uaXNEaXNhYmxlZFxcblxcdCAgICB9LFxcblxcdCAgICBvbjoge1xcblxcdCAgICAgIFxcXCJjbGlja1xcXCI6IF92bS5vcGVuT3B0aW9ucyxcXG5cXHQgICAgICBcXFwiZm9jdXNcXFwiOiBfdm0ub3Blbk9wdGlvbnNcXG5cXHQgICAgfVxcblxcdCAgfSwgW19jKCdpJywge1xcblxcdCAgICBzdGF0aWNDbGFzczogXFxcImRyb3Bkb3duIGljb25cXFwiXFxuXFx0ICB9KSwgX3ZtLl92KFxcXCIgXFxcIiksIF92bS5fbCgoX3ZtLnNlbGVjdGVkT3B0aW9ucyksIGZ1bmN0aW9uKG9wdGlvbiwgaWR4KSB7XFxuXFx0ICAgIHJldHVybiAoIV92bS5oaWRlU2VsZWN0ZWRPcHRpb25zKSA/IFtfYygnYScsIHtcXG5cXHQgICAgICBzdGF0aWNDbGFzczogXFxcInVpIGxhYmVsIHRyYW5zaXRpb24gdmlzaWJsZVxcXCIsXFxuXFx0ICAgICAgc3RhdGljU3R5bGU6IHtcXG5cXHQgICAgICAgIFxcXCJkaXNwbGF5XFxcIjogXFxcImlubGluZS1ibG9jayAhaW1wb3J0YW50XFxcIlxcblxcdCAgICAgIH0sXFxuXFx0ICAgICAgYXR0cnM6IHtcXG5cXHQgICAgICAgIFxcXCJkYXRhLXZzcy1jdXN0b20tYXR0clxcXCI6IF92bS5jdXN0b21BdHRyKG9wdGlvbilcXG5cXHQgICAgICB9XFxuXFx0ICAgIH0sIFtfdm0uX3YoXFxcIlxcXFxuICAgICAgXFxcIiArIF92bS5fcyhvcHRpb24udGV4dCkpLCBfYygnaScsIHtcXG5cXHQgICAgICBzdGF0aWNDbGFzczogXFxcImRlbGV0ZSBpY29uXFxcIixcXG5cXHQgICAgICBvbjoge1xcblxcdCAgICAgICAgXFxcImNsaWNrXFxcIjogZnVuY3Rpb24oJGV2ZW50KSB7XFxuXFx0ICAgICAgICAgIF92bS5kZWxldGVJdGVtKG9wdGlvbilcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9XFxuXFx0ICAgIH0pXSldIDogX3ZtLl9lKClcXG5cXHQgIH0pLCBfdm0uX3YoXFxcIiBcXFwiKSwgX2MoJ2lucHV0Jywge1xcblxcdCAgICBkaXJlY3RpdmVzOiBbe1xcblxcdCAgICAgIG5hbWU6IFxcXCJtb2RlbFxcXCIsXFxuXFx0ICAgICAgcmF3TmFtZTogXFxcInYtbW9kZWxcXFwiLFxcblxcdCAgICAgIHZhbHVlOiAoX3ZtLnNlYXJjaFRleHQpLFxcblxcdCAgICAgIGV4cHJlc3Npb246IFxcXCJzZWFyY2hUZXh0XFxcIlxcblxcdCAgICB9XSxcXG5cXHQgICAgcmVmOiBcXFwiaW5wdXRcXFwiLFxcblxcdCAgICBzdGF0aWNDbGFzczogXFxcInNlYXJjaFxcXCIsXFxuXFx0ICAgIHN0eWxlOiAoX3ZtLmlucHV0V2lkdGgpLFxcblxcdCAgICBhdHRyczoge1xcblxcdCAgICAgIFxcXCJhdXRvY29tcGxldGVcXFwiOiBcXFwib2ZmXFxcIixcXG5cXHQgICAgICBcXFwidGFiaW5kZXhcXFwiOiBcXFwiMFxcXCIsXFxuXFx0ICAgICAgXFxcImlkXFxcIjogX3ZtLmlkLFxcblxcdCAgICAgIFxcXCJuYW1lXFxcIjogX3ZtLm5hbWVcXG5cXHQgICAgfSxcXG5cXHQgICAgZG9tUHJvcHM6IHtcXG5cXHQgICAgICBcXFwidmFsdWVcXFwiOiBfdm0uX3MoX3ZtLnNlYXJjaFRleHQpXFxuXFx0ICAgIH0sXFxuXFx0ICAgIG9uOiB7XFxuXFx0ICAgICAgXFxcImZvY3VzXFxcIjogZnVuY3Rpb24oJGV2ZW50KSB7XFxuXFx0ICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHQgICAgICAgIF92bS5vcGVuT3B0aW9ucygkZXZlbnQpXFxuXFx0ICAgICAgfSxcXG5cXHQgICAgICBcXFwia2V5dXBcXFwiOiBbZnVuY3Rpb24oJGV2ZW50KSB7XFxuXFx0ICAgICAgICBpZiAoX3ZtLl9rKCRldmVudC5rZXlDb2RlLCBcXFwiZXNjXFxcIiwgMjcpKSB7IHJldHVybjsgfVxcblxcdCAgICAgICAgX3ZtLmNsb3NlT3B0aW9ucygkZXZlbnQpXFxuXFx0ICAgICAgfSwgZnVuY3Rpb24oJGV2ZW50KSB7XFxuXFx0ICAgICAgICBpZiAoX3ZtLl9rKCRldmVudC5rZXlDb2RlLCBcXFwiZW50ZXJcXFwiLCAxMykpIHsgcmV0dXJuOyB9XFxuXFx0ICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHQgICAgICAgIF92bS5lbnRlckl0ZW0oJGV2ZW50KVxcblxcdCAgICAgIH1dLFxcblxcdCAgICAgIFxcXCJibHVyXFxcIjogX3ZtLmJsdXJJbnB1dCxcXG5cXHQgICAgICBcXFwia2V5ZG93blxcXCI6IFtmdW5jdGlvbigkZXZlbnQpIHtcXG5cXHQgICAgICAgIGlmIChfdm0uX2soJGV2ZW50LmtleUNvZGUsIFxcXCJ1cFxcXCIsIDM4KSkgeyByZXR1cm47IH1cXG5cXHQgICAgICAgIF92bS5wcmV2SXRlbSgkZXZlbnQpXFxuXFx0ICAgICAgfSwgZnVuY3Rpb24oJGV2ZW50KSB7XFxuXFx0ICAgICAgICBpZiAoX3ZtLl9rKCRldmVudC5rZXlDb2RlLCBcXFwiZG93blxcXCIsIDQwKSkgeyByZXR1cm47IH1cXG5cXHQgICAgICAgIF92bS5uZXh0SXRlbSgkZXZlbnQpXFxuXFx0ICAgICAgfSwgZnVuY3Rpb24oJGV2ZW50KSB7XFxuXFx0ICAgICAgICBpZiAoX3ZtLl9rKCRldmVudC5rZXlDb2RlLCBcXFwiZW50ZXJcXFwiLCAxMykpIHsgcmV0dXJuOyB9XFxuXFx0ICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHQgICAgICB9LCBmdW5jdGlvbigkZXZlbnQpIHtcXG5cXHQgICAgICAgIGlmIChfdm0uX2soJGV2ZW50LmtleUNvZGUsIFxcXCJkZWxldGVcXFwiLCBbOCwgNDZdKSkgeyByZXR1cm47IH1cXG5cXHQgICAgICAgIF92bS5kZWxldGVUZXh0T3JMYXN0SXRlbSgkZXZlbnQpXFxuXFx0ICAgICAgfV0sXFxuXFx0ICAgICAgXFxcImlucHV0XFxcIjogZnVuY3Rpb24oJGV2ZW50KSB7XFxuXFx0ICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuOyB9XFxuXFx0ICAgICAgICBfdm0uc2VhcmNoVGV4dCA9ICRldmVudC50YXJnZXQudmFsdWVcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH0pLCBfdm0uX3YoXFxcIiBcXFwiKSwgX2MoJ2RpdicsIHtcXG5cXHQgICAgc3RhdGljQ2xhc3M6IFxcXCJ0ZXh0XFxcIixcXG5cXHQgICAgY2xhc3M6IF92bS50ZXh0Q2xhc3NcXG5cXHQgIH0sIFtfdm0uX3YoX3ZtLl9zKF92bS5pbnB1dFRleHQpICsgXFxcIlxcXFxuICBcXFwiKV0pLCBfdm0uX3YoXFxcIiBcXFwiKSwgX2MoJ2RpdicsIHtcXG5cXHQgICAgcmVmOiBcXFwibWVudVxcXCIsXFxuXFx0ICAgIHN0YXRpY0NsYXNzOiBcXFwibWVudVxcXCIsXFxuXFx0ICAgIGNsYXNzOiBfdm0ubWVudUNsYXNzLFxcblxcdCAgICBzdHlsZTogKF92bS5tZW51U3R5bGUpLFxcblxcdCAgICBhdHRyczoge1xcblxcdCAgICAgIFxcXCJ0YWJpbmRleFxcXCI6IFxcXCItMVxcXCJcXG5cXHQgICAgfSxcXG5cXHQgICAgb246IHtcXG5cXHQgICAgICBcXFwibW91c2Vkb3duXFxcIjogZnVuY3Rpb24oJGV2ZW50KSB7XFxuXFx0ICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH0sIFtfdm0uX2woKF92bS5maWx0ZXJlZE9wdGlvbnMpLCBmdW5jdGlvbihvcHRpb24sIGlkeCkge1xcblxcdCAgICByZXR1cm4gW19jKCdkaXYnLCB7XFxuXFx0ICAgICAgc3RhdGljQ2xhc3M6IFxcXCJpdGVtXFxcIixcXG5cXHQgICAgICBjbGFzczoge1xcblxcdCAgICAgICAgJ3NlbGVjdGVkJzogb3B0aW9uLnNlbGVjdGVkLCAnY3VycmVudCc6IF92bS5wb2ludGVyID09PSBpZHhcXG5cXHQgICAgICB9LFxcblxcdCAgICAgIGF0dHJzOiB7XFxuXFx0ICAgICAgICBcXFwiZGF0YS12c3MtY3VzdG9tLWF0dHJcXFwiOiBfdm0uY3VzdG9tQXR0cihvcHRpb24pXFxuXFx0ICAgICAgfSxcXG5cXHQgICAgICBvbjoge1xcblxcdCAgICAgICAgXFxcImNsaWNrXFxcIjogZnVuY3Rpb24oJGV2ZW50KSB7XFxuXFx0ICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXHQgICAgICAgICAgX3ZtLnNlbGVjdEl0ZW0ob3B0aW9uKVxcblxcdCAgICAgICAgfSxcXG5cXHQgICAgICAgIFxcXCJtb3VzZWRvd25cXFwiOiBfdm0ubW91c2Vkb3duSXRlbSxcXG5cXHQgICAgICAgIFxcXCJtb3VzZWVudGVyXFxcIjogZnVuY3Rpb24oJGV2ZW50KSB7XFxuXFx0ICAgICAgICAgIF92bS5wb2ludGVyU2V0KGlkeClcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9XFxuXFx0ICAgIH0sIFtfdm0uX3YoXFxcIlxcXFxuICAgICAgICBcXFwiICsgX3ZtLl9zKG9wdGlvbi50ZXh0KSArIFxcXCJcXFxcbiAgICAgIFxcXCIpXSldXFxuXFx0ICB9KV0sIDIpXSwgMilcXG5cXHR9LHN0YXRpY1JlbmRlckZuczogW119XFxuXFxuLyoqKi8gfSxcXG4vKiAxMDMgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xcblxcdFxcblxcdC8vIGxvYWQgdGhlIHN0eWxlc1xcblxcdHZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MCk7XFxuXFx0aWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XFxuXFx0Ly8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxcblxcdHZhciB1cGRhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpKGNvbnRlbnQsIHt9KTtcXG5cXHRpZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcXG5cXHQvLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XFxuXFx0aWYoZmFsc2UpIHt9XFxuXFxuLyoqKi8gfSxcXG4vKiAxMDQgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xcblxcdFxcblxcdC8vIGxvYWQgdGhlIHN0eWxlc1xcblxcdHZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MSk7XFxuXFx0aWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XFxuXFx0Ly8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxcblxcdHZhciB1cGRhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpKGNvbnRlbnQsIHt9KTtcXG5cXHRpZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcXG5cXHQvLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XFxuXFx0aWYoZmFsc2UpIHt9XFxuXFxuLyoqKi8gfSxcXG4vKiAxMDUgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xcblxcdFxcblxcdC8vIGxvYWQgdGhlIHN0eWxlc1xcblxcdHZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mik7XFxuXFx0aWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XFxuXFx0Ly8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxcblxcdHZhciB1cGRhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpKGNvbnRlbnQsIHt9KTtcXG5cXHRpZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcXG5cXHQvLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XFxuXFx0aWYoZmFsc2UpIHt9XFxuXFxuLyoqKi8gfSxcXG4vKiAxMDYgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xcblxcdFxcblxcdC8vIGxvYWQgdGhlIHN0eWxlc1xcblxcdHZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Myk7XFxuXFx0aWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XFxuXFx0Ly8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxcblxcdHZhciB1cGRhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpKGNvbnRlbnQsIHt9KTtcXG5cXHRpZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcXG5cXHQvLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XFxuXFx0aWYoZmFsc2UpIHt9XFxuXFxuLyoqKi8gfSxcXG4vKiAxMDcgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xcblxcdFxcblxcdC8vIGxvYWQgdGhlIHN0eWxlc1xcblxcdHZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NCk7XFxuXFx0aWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XFxuXFx0Ly8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxcblxcdHZhciB1cGRhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpKGNvbnRlbnQsIHt9KTtcXG5cXHRpZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcXG5cXHQvLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XFxuXFx0aWYoZmFsc2UpIHt9XFxuXFxuLyoqKi8gfSxcXG4vKiAxMDggKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xcblxcdFxcblxcdC8vIGxvYWQgdGhlIHN0eWxlc1xcblxcdHZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NSk7XFxuXFx0aWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XFxuXFx0Ly8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxcblxcdHZhciB1cGRhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpKGNvbnRlbnQsIHt9KTtcXG5cXHRpZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcXG5cXHQvLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XFxuXFx0aWYoZmFsc2UpIHt9XFxuXFxuLyoqKi8gfSxcXG4vKiAxMDkgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xcblxcdFxcblxcdC8vIGxvYWQgdGhlIHN0eWxlc1xcblxcdHZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Nik7XFxuXFx0aWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XFxuXFx0Ly8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxcblxcdHZhciB1cGRhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpKGNvbnRlbnQsIHt9KTtcXG5cXHRpZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcXG5cXHQvLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XFxuXFx0aWYoZmFsc2UpIHt9XFxuXFxuLyoqKi8gfVxcbi8qKioqKiovIF0pXFxufSk7XFxuO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZ1ZS1zZWFyY2gtc2VsZWN0LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtc2VhcmNoLXNlbGVjdC9wdWJsaXNoL3Z1ZS1zZWFyY2gtc2VsZWN0LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5lc20uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsLCBzZXRJbW1lZGlhdGUpIHsvKiFcXG4gKiBWdWUuanMgdjIuNi4xMFxcbiAqIChjKSAyMDE0LTIwMTkgRXZhbiBZb3VcXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXFxuICovXFxuLyogICovXFxuXFxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XFxuXFxuLy8gVGhlc2UgaGVscGVycyBwcm9kdWNlIGJldHRlciBWTSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXFxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZy5cXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XFxuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcXG59XFxuXFxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcXG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxcbn1cXG5cXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcXG4gIHJldHVybiB2ID09PSB0cnVlXFxufVxcblxcbmZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcXG4gIHJldHVybiB2ID09PSBmYWxzZVxcbn1cXG5cXG4vKipcXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmUuXFxuICovXFxuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XFxuICByZXR1cm4gKFxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHxcXG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcXG4gIClcXG59XFxuXFxuLyoqXFxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cXG4gKi9cXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XFxuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXFxufVxcblxcbi8qKlxcbiAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUsIGUuZy4sIFtvYmplY3QgT2JqZWN0XS5cXG4gKi9cXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcXG5cXG5mdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XFxuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKVxcbn1cXG5cXG4vKipcXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXFxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cXG4gKi9cXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcXG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xcbn1cXG5cXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJ1xcbn1cXG5cXG4vKipcXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cXG4gKi9cXG5mdW5jdGlvbiBpc1ZhbGlkQXJyYXlJbmRleCAodmFsKSB7XFxuICB2YXIgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcXG59XFxuXFxuZnVuY3Rpb24gaXNQcm9taXNlICh2YWwpIHtcXG4gIHJldHVybiAoXFxuICAgIGlzRGVmKHZhbCkgJiZcXG4gICAgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nICYmXFxuICAgIHR5cGVvZiB2YWwuY2F0Y2ggPT09ICdmdW5jdGlvbidcXG4gIClcXG59XFxuXFxuLyoqXFxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXFxuICovXFxuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xcbiAgcmV0dXJuIHZhbCA9PSBudWxsXFxuICAgID8gJydcXG4gICAgOiBBcnJheS5pc0FycmF5KHZhbCkgfHwgKGlzUGxhaW5PYmplY3QodmFsKSAmJiB2YWwudG9TdHJpbmcgPT09IF90b1N0cmluZylcXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcXG4gICAgICA6IFN0cmluZyh2YWwpXFxufVxcblxcbi8qKlxcbiAqIENvbnZlcnQgYW4gaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxcbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxcbiAqL1xcbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcXG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxcbn1cXG5cXG4vKipcXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcXG4gKiBpcyBpbiB0aGF0IG1hcC5cXG4gKi9cXG5mdW5jdGlvbiBtYWtlTWFwIChcXG4gIHN0cixcXG4gIGV4cGVjdHNMb3dlckNhc2VcXG4pIHtcXG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xcbiAgfVxcbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XFxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cXG59XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXFxuICovXFxudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxcbiAqL1xcbnZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXMnKTtcXG5cXG4vKipcXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5LlxcbiAqL1xcbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XFxuICBpZiAoYXJyLmxlbmd0aCkge1xcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcXG4gICAgaWYgKGluZGV4ID4gLTEpIHtcXG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxcbiAqL1xcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XFxuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXFxufVxcblxcbi8qKlxcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cXG4gKi9cXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XFxuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XFxuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcXG4gIH0pXFxufVxcblxcbi8qKlxcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXFxuICovXFxudmFyIGNhbWVsaXplUkUgPSAvLShcXFxcdykvZztcXG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXFxufSk7XFxuXFxuLyoqXFxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cXG4gKi9cXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XFxuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXFxufSk7XFxuXFxuLyoqXFxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cXG4gKi9cXG52YXIgaHlwaGVuYXRlUkUgPSAvXFxcXEIoW0EtWl0pL2c7XFxudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XFxuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpXFxufSk7XFxuXFxuLyoqXFxuICogU2ltcGxlIGJpbmQgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0LFxcbiAqIGUuZy4sIFBoYW50b21KUyAxLnguIFRlY2huaWNhbGx5LCB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZVxcbiAqIHNpbmNlIG5hdGl2ZSBiaW5kIGlzIG5vdyBwZXJmb3JtYW50IGVub3VnaCBpbiBtb3N0IGJyb3dzZXJzLlxcbiAqIEJ1dCByZW1vdmluZyBpdCB3b3VsZCBtZWFuIGJyZWFraW5nIGNvZGUgdGhhdCB3YXMgYWJsZSB0byBydW4gaW5cXG4gKiBQaGFudG9tSlMgMS54LCBzbyB0aGlzIG11c3QgYmUga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cXG4gKi9cXG5cXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xcbmZ1bmN0aW9uIHBvbHlmaWxsQmluZCAoZm4sIGN0eCkge1xcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XFxuICAgIHJldHVybiBsXFxuICAgICAgPyBsID4gMVxcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXFxuICAgICAgOiBmbi5jYWxsKGN0eClcXG4gIH1cXG5cXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcXG4gIHJldHVybiBib3VuZEZuXFxufVxcblxcbmZ1bmN0aW9uIG5hdGl2ZUJpbmQgKGZuLCBjdHgpIHtcXG4gIHJldHVybiBmbi5iaW5kKGN0eClcXG59XFxuXFxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxcbiAgPyBuYXRpdmVCaW5kXFxuICA6IHBvbHlmaWxsQmluZDtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cXG4gKi9cXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcXG4gIHdoaWxlIChpLS0pIHtcXG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xcbiAgfVxcbiAgcmV0dXJuIHJldFxcbn1cXG5cXG4vKipcXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXFxuICovXFxuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcXG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcXG4gIH1cXG4gIHJldHVybiB0b1xcbn1cXG5cXG4vKipcXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxcbiAqL1xcbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcXG4gIHZhciByZXMgPSB7fTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgIGlmIChhcnJbaV0pIHtcXG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gcmVzXFxufVxcblxcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXFxuXFxuLyoqXFxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXFxuICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXFxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pLlxcbiAqL1xcbmZ1bmN0aW9uIG5vb3AgKGEsIGIsIGMpIHt9XFxuXFxuLyoqXFxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cXG4gKi9cXG52YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XFxuXFxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xcblxcbi8qKlxcbiAqIFJldHVybiB0aGUgc2FtZSB2YWx1ZS5cXG4gKi9cXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcXG5cXG4vKipcXG4gKiBHZW5lcmF0ZSBhIHN0cmluZyBjb250YWluaW5nIHN0YXRpYyBrZXlzIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cXG4gKi9cXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XFxuICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcXG4gICAgcmV0dXJuIGtleXMuY29uY2F0KG0uc3RhdGljS2V5cyB8fCBbXSlcXG4gIH0sIFtdKS5qb2luKCcsJylcXG59XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xcbiAqL1xcbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcXG4gIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cXG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcXG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcXG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XFxuICAgIHRyeSB7XFxuICAgICAgdmFyIGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcXG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xcbiAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChlLCBpKSB7XFxuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXFxuICAgICAgICB9KVxcbiAgICAgIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUpIHtcXG4gICAgICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKClcXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcXG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XFxuICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSlcXG4gICAgICAgIH0pXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXFxuICAgICAgICByZXR1cm4gZmFsc2VcXG4gICAgICB9XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xcbiAgICAgIHJldHVybiBmYWxzZVxcbiAgICB9XFxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBmYWxzZVxcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm4gdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgbG9vc2VseSBlcXVhbCB2YWx1ZSBjYW4gYmVcXG4gKiBmb3VuZCBpbiB0aGUgYXJyYXkgKGlmIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGUgYXJyYXkgbXVzdFxcbiAqIGNvbnRhaW4gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHNoYXBlKSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXFxuICovXFxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cXG4gIH1cXG4gIHJldHVybiAtMVxcbn1cXG5cXG4vKipcXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxcbiAqL1xcbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XFxuICB2YXIgY2FsbGVkID0gZmFsc2U7XFxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoIWNhbGxlZCkge1xcbiAgICAgIGNhbGxlZCA9IHRydWU7XFxuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xcblxcbnZhciBBU1NFVF9UWVBFUyA9IFtcXG4gICdjb21wb25lbnQnLFxcbiAgJ2RpcmVjdGl2ZScsXFxuICAnZmlsdGVyJ1xcbl07XFxuXFxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcXG4gICdiZWZvcmVDcmVhdGUnLFxcbiAgJ2NyZWF0ZWQnLFxcbiAgJ2JlZm9yZU1vdW50JyxcXG4gICdtb3VudGVkJyxcXG4gICdiZWZvcmVVcGRhdGUnLFxcbiAgJ3VwZGF0ZWQnLFxcbiAgJ2JlZm9yZURlc3Ryb3knLFxcbiAgJ2Rlc3Ryb3llZCcsXFxuICAnYWN0aXZhdGVkJyxcXG4gICdkZWFjdGl2YXRlZCcsXFxuICAnZXJyb3JDYXB0dXJlZCcsXFxuICAnc2VydmVyUHJlZmV0Y2gnXFxuXTtcXG5cXG4vKiAgKi9cXG5cXG5cXG5cXG52YXIgY29uZmlnID0gKHtcXG4gIC8qKlxcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXFxuICAgKi9cXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxcbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxcblxcbiAgLyoqXFxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxcbiAgICovXFxuICBzaWxlbnQ6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xcbiAgICovXFxuICBwcm9kdWN0aW9uVGlwOiBcXFwiZGV2ZWxvcG1lbnRcXFwiICE9PSAncHJvZHVjdGlvbicsXFxuXFxuICAvKipcXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXFxuICAgKi9cXG4gIGRldnRvb2xzOiBcXFwiZGV2ZWxvcG1lbnRcXFwiICE9PSAncHJvZHVjdGlvbicsXFxuXFxuICAvKipcXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcXG4gICAqL1xcbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xcbiAgICovXFxuICBlcnJvckhhbmRsZXI6IG51bGwsXFxuXFxuICAvKipcXG4gICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xcbiAgICovXFxuICB3YXJuSGFuZGxlcjogbnVsbCxcXG5cXG4gIC8qKlxcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXFxuICAgKi9cXG4gIGlnbm9yZWRFbGVtZW50czogW10sXFxuXFxuICAvKipcXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXFxuICAgKi9cXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxcbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXFxuXFxuICAvKipcXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxcbiAgICovXFxuICBpc1Jlc2VydmVkVGFnOiBubyxcXG5cXG4gIC8qKlxcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcXG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXFxuICAgKi9cXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcXG5cXG4gIC8qKlxcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxcbiAgICovXFxuICBpc1Vua25vd25FbGVtZW50OiBubyxcXG5cXG4gIC8qKlxcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxcbiAgICovXFxuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXFxuXFxuICAvKipcXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXFxuICAgKi9cXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcXG5cXG4gIC8qKlxcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cXG4gICAqL1xcbiAgbXVzdFVzZVByb3A6IG5vLFxcblxcbiAgLyoqXFxuICAgKiBQZXJmb3JtIHVwZGF0ZXMgYXN5bmNocm9ub3VzbHkuIEludGVuZGVkIHRvIGJlIHVzZWQgYnkgVnVlIFRlc3QgVXRpbHNcXG4gICAqIFRoaXMgd2lsbCBzaWduaWZpY2FudGx5IHJlZHVjZSBwZXJmb3JtYW5jZSBpZiBzZXQgdG8gZmFsc2UuXFxuICAgKi9cXG4gIGFzeW5jOiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xcbiAgICovXFxuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xcbn0pO1xcblxcbi8qICAqL1xcblxcbi8qKlxcbiAqIHVuaWNvZGUgbGV0dGVycyB1c2VkIGZvciBwYXJzaW5nIGh0bWwgdGFncywgY29tcG9uZW50IG5hbWVzIGFuZCBwcm9wZXJ0eSBwYXRocy5cXG4gKiB1c2luZyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUzL3NlbWFudGljcy1zY3JpcHRpbmcuaHRtbCNwb3RlbnRpYWxjdXN0b21lbGVtZW50bmFtZVxcbiAqIHNraXBwaW5nIFxcXFx1MTAwMDAtXFxcXHVFRkZGRiBkdWUgdG8gaXQgZnJlZXppbmcgdXAgUGhhbnRvbUpTXFxuICovXFxudmFyIHVuaWNvZGVSZWdFeHAgPSAvYS16QS1aXFxcXHUwMEI3XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwM0YtXFxcXHUyMDQwXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkQvO1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xcbiAqL1xcbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XFxuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXFxufVxcblxcbi8qKlxcbiAqIERlZmluZSBhIHByb3BlcnR5LlxcbiAqL1xcbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XFxuICAgIHZhbHVlOiB2YWwsXFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcXG4gICAgd3JpdGFibGU6IHRydWUsXFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxcbiAqL1xcbnZhciBiYWlsUkUgPSBuZXcgUmVnRXhwKChcXFwiW15cXFwiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFxcXCIuJF9cXFxcXFxcXGRdXFxcIikpO1xcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XFxuICAgIHJldHVyblxcbiAgfVxcbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XFxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcXG4gICAgfVxcbiAgICByZXR1cm4gb2JqXFxuICB9XFxufVxcblxcbi8qICAqL1xcblxcbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xcbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xcblxcbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XFxudmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XFxudmFyIHdlZXhQbGF0Zm9ybSA9IGluV2VleCAmJiBXWEVudmlyb25tZW50LnBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7XFxudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XFxudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcXG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcXG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XFxudmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xcbnZhciBpc0lPUyA9IChVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpKSB8fCAod2VleFBsYXRmb3JtID09PSAnaW9zJyk7XFxudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcXFwvXFxcXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xcbnZhciBpc1BoYW50b21KUyA9IFVBICYmIC9waGFudG9tanMvLnRlc3QoVUEpO1xcbnZhciBpc0ZGID0gVUEgJiYgVUEubWF0Y2goL2ZpcmVmb3hcXFxcLyhcXFxcZCspLyk7XFxuXFxuLy8gRmlyZWZveCBoYXMgYSBcXFwid2F0Y2hcXFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cXG52YXIgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xcblxcbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcXG5pZiAoaW5Ccm93c2VyKSB7XFxuICB0cnkge1xcbiAgICB2YXIgb3B0cyA9IHt9O1xcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXFxuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xcbiAgICAgIH1cXG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcXG4gIH0gY2F0Y2ggKGUpIHt9XFxufVxcblxcbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXFxudmFyIF9pc1NlcnZlcjtcXG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XFxuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICAgIGlmICghaW5Ccm93c2VyICYmICFpbldlZXggJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXFxuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10gJiYgZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gX2lzU2VydmVyXFxufTtcXG5cXG4vLyBkZXRlY3QgZGV2dG9vbHNcXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XFxuXFxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXFxufVxcblxcbnZhciBoYXNTeW1ib2wgPVxcbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XFxuXFxudmFyIF9TZXQ7XFxuLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vICRmbG93LWRpc2FibGUtbGluZVxcbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XFxuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cXG4gIF9TZXQgPSBTZXQ7XFxufSBlbHNlIHtcXG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cXG4gIF9TZXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcXG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XFxuICAgIH1cXG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXFxuICAgIH07XFxuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcXG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcXG4gICAgfTtcXG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcXG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XFxuICAgIH07XFxuXFxuICAgIHJldHVybiBTZXQ7XFxuICB9KCkpO1xcbn1cXG5cXG4vKiAgKi9cXG5cXG52YXIgd2FybiA9IG5vb3A7XFxudmFyIHRpcCA9IG5vb3A7XFxudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcXG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChub29wKTtcXG5cXG5pZiAodHJ1ZSkge1xcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XFxuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcXFx3KS9nO1xcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXFxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXFxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcXG5cXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xcbiAgICB2YXIgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XFxuXFxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcXG4gICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XFxuICAgIH0gZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XFxuICAgICAgY29uc29sZS5lcnJvcigoXFxcIltWdWUgd2Fybl06IFxcXCIgKyBtc2cgKyB0cmFjZSkpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcXG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xcbiAgICAgIGNvbnNvbGUud2FybihcXFwiW1Z1ZSB0aXBdOiBcXFwiICsgbXNnICsgKFxcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXFxuICAgICAgKSk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XFxuICAgICAgcmV0dXJuICc8Um9vdD4nXFxuICAgIH1cXG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcXG4gICAgICA/IHZtLm9wdGlvbnNcXG4gICAgICA6IHZtLl9pc1Z1ZVxcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXFxuICAgICAgICA6IHZtO1xcbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSB8fCBvcHRpb25zLl9jb21wb25lbnRUYWc7XFxuICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XFxuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XFxuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxcXFxcXSspXFxcXC52dWUkLyk7XFxuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiAoXFxuICAgICAgKG5hbWUgPyAoXFxcIjxcXFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFxcXCI+XFxcIikgOiBcXFwiPEFub255bW91cz5cXFwiKSArXFxuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFxcXCIgYXQgXFxcIiArIGZpbGUpIDogJycpXFxuICAgIClcXG4gIH07XFxuXFxuICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xcbiAgICB2YXIgcmVzID0gJyc7XFxuICAgIHdoaWxlIChuKSB7XFxuICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cXG4gICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxcbiAgICAgIG4gPj49IDE7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc1xcbiAgfTtcXG5cXG4gIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcXG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XFxuICAgICAgdmFyIHRyZWUgPSBbXTtcXG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcXG4gICAgICB3aGlsZSAodm0pIHtcXG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XFxuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSsrO1xcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcXG4gICAgICAgICAgICBjb250aW51ZVxcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcXG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcXG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICB0cmVlLnB1c2godm0pO1xcbiAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gJ1xcXFxuXFxcXG5mb3VuZCBpblxcXFxuXFxcXG4nICsgdHJlZVxcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcXFwiXFxcIiArIChpID09PSAwID8gJy0tLT4gJyA6IHJlcGVhdCgnICcsIDUgKyBpICogMikpICsgKEFycmF5LmlzQXJyYXkodm0pXFxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFxcXCIuLi4gKFxcXCIgKyAodm1bMV0pICsgXFxcIiByZWN1cnNpdmUgY2FsbHMpXFxcIilcXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXFxuICAgICAgICAuam9pbignXFxcXG4nKVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiAoXFxcIlxcXFxuXFxcXG4oZm91bmQgaW4gXFxcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcXFwiKVxcXCIpXFxuICAgIH1cXG4gIH07XFxufVxcblxcbi8qICAqL1xcblxcbnZhciB1aWQgPSAwO1xcblxcbi8qKlxcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXFxuICovXFxudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XFxuICB0aGlzLmlkID0gdWlkKys7XFxuICB0aGlzLnN1YnMgPSBbXTtcXG59O1xcblxcbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcXG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XFxufTtcXG5cXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XFxuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xcbn07XFxuXFxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xcbiAgaWYgKERlcC50YXJnZXQpIHtcXG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XFxuICB9XFxufTtcXG5cXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XFxuICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcXG4gIGlmICggdHJ1ZSAmJiAhY29uZmlnLmFzeW5jKSB7XFxuICAgIC8vIHN1YnMgYXJlbid0IHNvcnRlZCBpbiBzY2hlZHVsZXIgaWYgbm90IHJ1bm5pbmcgYXN5bmNcXG4gICAgLy8gd2UgbmVlZCB0byBzb3J0IHRoZW0gbm93IHRvIG1ha2Ugc3VyZSB0aGV5IGZpcmUgaW4gY29ycmVjdFxcbiAgICAvLyBvcmRlclxcbiAgICBzdWJzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcXG4gIH1cXG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgc3Vic1tpXS51cGRhdGUoKTtcXG4gIH1cXG59O1xcblxcbi8vIFRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cXG4vLyBUaGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIG9ubHkgb25lIHdhdGNoZXJcXG4vLyBjYW4gYmUgZXZhbHVhdGVkIGF0IGEgdGltZS5cXG5EZXAudGFyZ2V0ID0gbnVsbDtcXG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcXG5cXG5mdW5jdGlvbiBwdXNoVGFyZ2V0ICh0YXJnZXQpIHtcXG4gIHRhcmdldFN0YWNrLnB1c2godGFyZ2V0KTtcXG4gIERlcC50YXJnZXQgPSB0YXJnZXQ7XFxufVxcblxcbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XFxuICB0YXJnZXRTdGFjay5wb3AoKTtcXG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFja1t0YXJnZXRTdGFjay5sZW5ndGggLSAxXTtcXG59XFxuXFxuLyogICovXFxuXFxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxcbiAgdGFnLFxcbiAgZGF0YSxcXG4gIGNoaWxkcmVuLFxcbiAgdGV4dCxcXG4gIGVsbSxcXG4gIGNvbnRleHQsXFxuICBjb21wb25lbnRPcHRpb25zLFxcbiAgYXN5bmNGYWN0b3J5XFxuKSB7XFxuICB0aGlzLnRhZyA9IHRhZztcXG4gIHRoaXMuZGF0YSA9IGRhdGE7XFxuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XFxuICB0aGlzLnRleHQgPSB0ZXh0O1xcbiAgdGhpcy5lbG0gPSBlbG07XFxuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcXG4gIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xcbiAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XFxuICB0aGlzLmZuU2NvcGVJZCA9IHVuZGVmaW5lZDtcXG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcXG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XFxuICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XFxuICB0aGlzLnJhdyA9IGZhbHNlO1xcbiAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcXG4gIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcXG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XFxuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcXG4gIHRoaXMuYXN5bmNNZXRhID0gdW5kZWZpbmVkO1xcbiAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcXG59O1xcblxcbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XFxuXFxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0Llxcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXFxucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXFxufTtcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcXG5cXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XFxuICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcXG5cXG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XFxuICBub2RlLnRleHQgPSB0ZXh0O1xcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xcbiAgcmV0dXJuIG5vZGVcXG59O1xcblxcbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XFxuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxcbn1cXG5cXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3NcXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcXG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxcbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XFxuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxcbiAgICB2bm9kZS50YWcsXFxuICAgIHZub2RlLmRhdGEsXFxuICAgIC8vICM3OTc1XFxuICAgIC8vIGNsb25lIGNoaWxkcmVuIGFycmF5IHRvIGF2b2lkIG11dGF0aW5nIG9yaWdpbmFsIGluIGNhc2Ugb2YgY2xvbmluZ1xcbiAgICAvLyBhIGNoaWxkLlxcbiAgICB2bm9kZS5jaGlsZHJlbiAmJiB2bm9kZS5jaGlsZHJlbi5zbGljZSgpLFxcbiAgICB2bm9kZS50ZXh0LFxcbiAgICB2bm9kZS5lbG0sXFxuICAgIHZub2RlLmNvbnRleHQsXFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxcbiAgKTtcXG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XFxuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcXG4gIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XFxuICBjbG9uZWQuZm5PcHRpb25zID0gdm5vZGUuZm5PcHRpb25zO1xcbiAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcXG4gIGNsb25lZC5hc3luY01ldGEgPSB2bm9kZS5hc3luY01ldGE7XFxuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xcbiAgcmV0dXJuIGNsb25lZFxcbn1cXG5cXG4vKlxcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxcbiAqL1xcblxcbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1xcblxcbnZhciBtZXRob2RzVG9QYXRjaCA9IFtcXG4gICdwdXNoJyxcXG4gICdwb3AnLFxcbiAgJ3NoaWZ0JyxcXG4gICd1bnNoaWZ0JyxcXG4gICdzcGxpY2UnLFxcbiAgJ3NvcnQnLFxcbiAgJ3JldmVyc2UnXFxuXTtcXG5cXG4vKipcXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcXG4gKi9cXG5tZXRob2RzVG9QYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcXG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcXG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcXG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcXG5cXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcXG4gICAgdmFyIGluc2VydGVkO1xcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xcbiAgICAgIGNhc2UgJ3B1c2gnOlxcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xcbiAgICAgICAgYnJlYWtcXG4gICAgICBjYXNlICdzcGxpY2UnOlxcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xcbiAgICAgICAgYnJlYWtcXG4gICAgfVxcbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxcbiAgICAvLyBub3RpZnkgY2hhbmdlXFxuICAgIG9iLmRlcC5ub3RpZnkoKTtcXG4gICAgcmV0dXJuIHJlc3VsdFxcbiAgfSk7XFxufSk7XFxuXFxuLyogICovXFxuXFxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XFxuXFxuLyoqXFxuICogSW4gc29tZSBjYXNlcyB3ZSBtYXkgd2FudCB0byBkaXNhYmxlIG9ic2VydmF0aW9uIGluc2lkZSBhIGNvbXBvbmVudCdzXFxuICogdXBkYXRlIGNvbXB1dGF0aW9uLlxcbiAqL1xcbnZhciBzaG91bGRPYnNlcnZlID0gdHJ1ZTtcXG5cXG5mdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcgKHZhbHVlKSB7XFxuICBzaG91bGRPYnNlcnZlID0gdmFsdWU7XFxufVxcblxcbi8qKlxcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgaXMgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcXG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaCB1cGRhdGVzLlxcbiAqL1xcbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XFxuICB0aGlzLnZtQ291bnQgPSAwO1xcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XFxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcXG4gICAgaWYgKGhhc1Byb3RvKSB7XFxuICAgICAgcHJvdG9BdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGNvcHlBdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XFxuICAgIH1cXG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xcbiAgfSBlbHNlIHtcXG4gICAgdGhpcy53YWxrKHZhbHVlKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIFdhbGsgdGhyb3VnaCBhbGwgcHJvcGVydGllcyBhbmQgY29udmVydCB0aGVtIGludG9cXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cXG4gKi9cXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XFxuICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cXG4gKi9cXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XFxuICB9XFxufTtcXG5cXG4vLyBoZWxwZXJzXFxuXFxuLyoqXFxuICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXFxuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cXG4gKi9cXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XFxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xcbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcXG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cXG59XFxuXFxuLyoqXFxuICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cXG4gKi9cXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xcbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcXG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXFxuICovXFxuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcXG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVk5vZGUpIHtcXG4gICAgcmV0dXJuXFxuICB9XFxuICB2YXIgb2I7XFxuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcXG4gICAgb2IgPSB2YWx1ZS5fX29iX187XFxuICB9IGVsc2UgaWYgKFxcbiAgICBzaG91bGRPYnNlcnZlICYmXFxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXFxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcXG4gICAgIXZhbHVlLl9pc1Z1ZVxcbiAgKSB7XFxuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcXG4gIH1cXG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XFxuICAgIG9iLnZtQ291bnQrKztcXG4gIH1cXG4gIHJldHVybiBvYlxcbn1cXG5cXG4vKipcXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXFxuICovXFxuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUkJDEgKFxcbiAgb2JqLFxcbiAga2V5LFxcbiAgdmFsLFxcbiAgY3VzdG9tU2V0dGVyLFxcbiAgc2hhbGxvd1xcbikge1xcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcXG5cXG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcXG4gICAgcmV0dXJuXFxuICB9XFxuXFxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XFxuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xcbiAgaWYgKCghZ2V0dGVyIHx8IHNldHRlcikgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xcbiAgICB2YWwgPSBvYmpba2V5XTtcXG4gIH1cXG5cXG4gIHZhciBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZSh2YWwpO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XFxuICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XFxuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcXG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcXG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XFxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdmFsdWVcXG4gICAgfSxcXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XFxuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xcbiAgICAgICAgcmV0dXJuXFxuICAgICAgfVxcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXFxuICAgICAgaWYgKCB0cnVlICYmIGN1c3RvbVNldHRlcikge1xcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XFxuICAgICAgfVxcbiAgICAgIC8vICM3OTgxOiBmb3IgYWNjZXNzb3IgcHJvcGVydGllcyB3aXRob3V0IHNldHRlclxcbiAgICAgIGlmIChnZXR0ZXIgJiYgIXNldHRlcikgeyByZXR1cm4gfVxcbiAgICAgIGlmIChzZXR0ZXIpIHtcXG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFsID0gbmV3VmFsO1xcbiAgICAgIH1cXG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xcbiAgICAgIGRlcC5ub3RpZnkoKTtcXG4gICAgfVxcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcXG4gKiBhbHJlYWR5IGV4aXN0LlxcbiAqL1xcbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xcbiAgaWYgKCB0cnVlICYmXFxuICAgIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSlcXG4gICkge1xcbiAgICB3YXJuKChcXFwiQ2Fubm90IHNldCByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXFxcIiArICgodGFyZ2V0KSkpKTtcXG4gIH1cXG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcXG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XFxuICAgIHJldHVybiB2YWxcXG4gIH1cXG4gIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XFxuICAgIHRhcmdldFtrZXldID0gdmFsO1xcbiAgICByZXR1cm4gdmFsXFxuICB9XFxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XFxuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcXG4gICAgIHRydWUgJiYgd2FybihcXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXFxuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcXG4gICAgKTtcXG4gICAgcmV0dXJuIHZhbFxcbiAgfVxcbiAgaWYgKCFvYikge1xcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcXG4gICAgcmV0dXJuIHZhbFxcbiAgfVxcbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcXG4gIG9iLmRlcC5ub3RpZnkoKTtcXG4gIHJldHVybiB2YWxcXG59XFxuXFxuLyoqXFxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cXG4gKi9cXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XFxuICBpZiAoIHRydWUgJiZcXG4gICAgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKVxcbiAgKSB7XFxuICAgIHdhcm4oKFxcXCJDYW5ub3QgZGVsZXRlIHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcXFwiICsgKCh0YXJnZXQpKSkpO1xcbiAgfVxcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XFxuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcXG4gICAgcmV0dXJuXFxuICB9XFxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XFxuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcXG4gICAgIHRydWUgJiYgd2FybihcXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcXG4gICAgKTtcXG4gICAgcmV0dXJuXFxuICB9XFxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcXG4gICAgcmV0dXJuXFxuICB9XFxuICBkZWxldGUgdGFyZ2V0W2tleV07XFxuICBpZiAoIW9iKSB7XFxuICAgIHJldHVyblxcbiAgfVxcbiAgb2IuZGVwLm5vdGlmeSgpO1xcbn1cXG5cXG4vKipcXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxcbiAqL1xcbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICBlID0gdmFsdWVbaV07XFxuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xcbiAgICB9XFxuICB9XFxufVxcblxcbi8qICAqL1xcblxcbi8qKlxcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxcbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxcbiAqL1xcbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xcblxcbi8qKlxcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcXG4gKi9cXG5pZiAodHJ1ZSkge1xcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XFxuICAgIGlmICghdm0pIHtcXG4gICAgICB3YXJuKFxcbiAgICAgICAgXFxcIm9wdGlvbiBcXFxcXFxcIlxcXCIgKyBrZXkgKyBcXFwiXFxcXFxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXFxcIiArXFxuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXFxuICAgICAgKTtcXG4gICAgfVxcbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXFxuICB9O1xcbn1cXG5cXG4vKipcXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cXG4gKi9cXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XFxuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cXG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xcblxcbiAgdmFyIGtleXMgPSBoYXNTeW1ib2xcXG4gICAgPyBSZWZsZWN0Lm93bktleXMoZnJvbSlcXG4gICAgOiBPYmplY3Qua2V5cyhmcm9tKTtcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xcbiAgICBrZXkgPSBrZXlzW2ldO1xcbiAgICAvLyBpbiBjYXNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBvYnNlcnZlZC4uLlxcbiAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgeyBjb250aW51ZSB9XFxuICAgIHRvVmFsID0gdG9ba2V5XTtcXG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcXG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcXG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XFxuICAgIH0gZWxzZSBpZiAoXFxuICAgICAgdG9WYWwgIT09IGZyb21WYWwgJiZcXG4gICAgICBpc1BsYWluT2JqZWN0KHRvVmFsKSAmJlxcbiAgICAgIGlzUGxhaW5PYmplY3QoZnJvbVZhbClcXG4gICAgKSB7XFxuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHRvXFxufVxcblxcbi8qKlxcbiAqIERhdGFcXG4gKi9cXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcXG4gIHBhcmVudFZhbCxcXG4gIGNoaWxkVmFsLFxcbiAgdm1cXG4pIHtcXG4gIGlmICghdm0pIHtcXG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcXG4gICAgaWYgKCFjaGlsZFZhbCkge1xcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcXG4gICAgfVxcbiAgICBpZiAoIXBhcmVudFZhbCkge1xcbiAgICAgIHJldHVybiBjaGlsZFZhbFxcbiAgICB9XFxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXFxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xcbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXFxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXFxuICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogY2hpbGRWYWwsXFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcXG4gICAgICApXFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XFxuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXFxuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKVxcbiAgICAgICAgOiBjaGlsZFZhbDtcXG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXFxuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcXG4gICAgICAgIDogcGFyZW50VmFsO1xcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcXG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxcbiAgcGFyZW50VmFsLFxcbiAgY2hpbGRWYWwsXFxuICB2bVxcbikge1xcbiAgaWYgKCF2bSkge1xcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgIHRydWUgJiYgd2FybihcXG4gICAgICAgICdUaGUgXFxcImRhdGFcXFwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXFxuICAgICAgICB2bVxcbiAgICAgICk7XFxuXFxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxcbiAgICB9XFxuICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpXFxuICB9XFxuXFxuICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSlcXG59O1xcblxcbi8qKlxcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cXG4gKi9cXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxcbiAgcGFyZW50VmFsLFxcbiAgY2hpbGRWYWxcXG4pIHtcXG4gIHZhciByZXMgPSBjaGlsZFZhbFxcbiAgICA/IHBhcmVudFZhbFxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXFxuICAgICAgICA/IGNoaWxkVmFsXFxuICAgICAgICA6IFtjaGlsZFZhbF1cXG4gICAgOiBwYXJlbnRWYWw7XFxuICByZXR1cm4gcmVzXFxuICAgID8gZGVkdXBlSG9va3MocmVzKVxcbiAgICA6IHJlc1xcbn1cXG5cXG5mdW5jdGlvbiBkZWR1cGVIb29rcyAoaG9va3MpIHtcXG4gIHZhciByZXMgPSBbXTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcXG4gICAgaWYgKHJlcy5pbmRleE9mKGhvb2tzW2ldKSA9PT0gLTEpIHtcXG4gICAgICByZXMucHVzaChob29rc1tpXSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiByZXNcXG59XFxuXFxuTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcXG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcXG59KTtcXG5cXG4vKipcXG4gKiBBc3NldHNcXG4gKlxcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXFxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXFxuICovXFxuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxcbiAgcGFyZW50VmFsLFxcbiAgY2hpbGRWYWwsXFxuICB2bSxcXG4gIGtleVxcbikge1xcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xcbiAgaWYgKGNoaWxkVmFsKSB7XFxuICAgICB0cnVlICYmIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xcbiAgICByZXR1cm4gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gcmVzXFxuICB9XFxufVxcblxcbkFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcXG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xcbn0pO1xcblxcbi8qKlxcbiAqIFdhdGNoZXJzLlxcbiAqXFxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxcbiAqL1xcbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChcXG4gIHBhcmVudFZhbCxcXG4gIGNoaWxkVmFsLFxcbiAgdm0sXFxuICBrZXlcXG4pIHtcXG4gIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXFxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cXG4gIGlmIChjaGlsZFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHsgY2hpbGRWYWwgPSB1bmRlZmluZWQ7IH1cXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxcbiAgaWYgKHRydWUpIHtcXG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XFxuICB9XFxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxcbiAgdmFyIHJldCA9IHt9O1xcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcXG4gIGZvciAodmFyIGtleSQxIGluIGNoaWxkVmFsKSB7XFxuICAgIHZhciBwYXJlbnQgPSByZXRba2V5JDFdO1xcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXkkMV07XFxuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xcbiAgICB9XFxuICAgIHJldFtrZXkkMV0gPSBwYXJlbnRcXG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXFxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcXG4gIH1cXG4gIHJldHVybiByZXRcXG59O1xcblxcbi8qKlxcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXFxuICovXFxuc3RyYXRzLnByb3BzID1cXG5zdHJhdHMubWV0aG9kcyA9XFxuc3RyYXRzLmluamVjdCA9XFxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxcbiAgcGFyZW50VmFsLFxcbiAgY2hpbGRWYWwsXFxuICB2bSxcXG4gIGtleVxcbikge1xcbiAgaWYgKGNoaWxkVmFsICYmIFxcXCJkZXZlbG9wbWVudFxcXCIgIT09ICdwcm9kdWN0aW9uJykge1xcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcXG4gIH1cXG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XFxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcXG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XFxuICBpZiAoY2hpbGRWYWwpIHsgZXh0ZW5kKHJldCwgY2hpbGRWYWwpOyB9XFxuICByZXR1cm4gcmV0XFxufTtcXG5zdHJhdHMucHJvdmlkZSA9IG1lcmdlRGF0YU9yRm47XFxuXFxuLyoqXFxuICogRGVmYXVsdCBzdHJhdGVneS5cXG4gKi9cXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcXG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXFxuICAgID8gcGFyZW50VmFsXFxuICAgIDogY2hpbGRWYWxcXG59O1xcblxcbi8qKlxcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xcbiAqL1xcbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xcbiAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoa2V5KTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XFxuICBpZiAoIW5ldyBSZWdFeHAoKFxcXCJeW2EtekEtWl1bXFxcXFxcXFwtXFxcXFxcXFwuMC05X1xcXCIgKyAodW5pY29kZVJlZ0V4cC5zb3VyY2UpICsgXFxcIl0qJFxcXCIpKS50ZXN0KG5hbWUpKSB7XFxuICAgIHdhcm4oXFxuICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFxcXCInICsgbmFtZSArICdcXFwiLiBDb21wb25lbnQgbmFtZXMgJyArXFxuICAgICAgJ3Nob3VsZCBjb25mb3JtIHRvIHZhbGlkIGN1c3RvbSBlbGVtZW50IG5hbWUgaW4gaHRtbDUgc3BlY2lmaWNhdGlvbi4nXFxuICAgICk7XFxuICB9XFxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XFxuICAgIHdhcm4oXFxuICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXFxuICAgICAgJ2lkOiAnICsgbmFtZVxcbiAgICApO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxcbiAqL1xcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcXG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cXG4gIHZhciByZXMgPSB7fTtcXG4gIHZhciBpLCB2YWwsIG5hbWU7XFxuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcXG4gICAgaSA9IHByb3BzLmxlbmd0aDtcXG4gICAgd2hpbGUgKGktLSkge1xcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XFxuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcXG4gICAgICB9IGVsc2UgaWYgKHRydWUpIHtcXG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XFxuICAgICAgdmFsID0gcHJvcHNba2V5XTtcXG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcXG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcXG4gICAgICAgID8gdmFsXFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XFxuICAgIH1cXG4gIH0gZWxzZSBpZiAodHJ1ZSkge1xcbiAgICB3YXJuKFxcbiAgICAgIFxcXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcXFxcXCJwcm9wc1xcXFxcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFxcXCIgK1xcbiAgICAgIFxcXCJidXQgZ290IFxcXCIgKyAodG9SYXdUeXBlKHByb3BzKSkgKyBcXFwiLlxcXCIsXFxuICAgICAgdm1cXG4gICAgKTtcXG4gIH1cXG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XFxufVxcblxcbi8qKlxcbiAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcXG4gKi9cXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XFxuICB2YXIgaW5qZWN0ID0gb3B0aW9ucy5pbmplY3Q7XFxuICBpZiAoIWluamVjdCkgeyByZXR1cm4gfVxcbiAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5qZWN0KSkge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XFxuICAgIH1cXG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChpbmplY3QpKSB7XFxuICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcXG4gICAgICB2YXIgdmFsID0gaW5qZWN0W2tleV07XFxuICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXFxuICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXFxuICAgICAgICA6IHsgZnJvbTogdmFsIH07XFxuICAgIH1cXG4gIH0gZWxzZSBpZiAodHJ1ZSkge1xcbiAgICB3YXJuKFxcbiAgICAgIFxcXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcXFxcXCJpbmplY3RcXFxcXFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcXFwiICtcXG4gICAgICBcXFwiYnV0IGdvdCBcXFwiICsgKHRvUmF3VHlwZShpbmplY3QpKSArIFxcXCIuXFxcIixcXG4gICAgICB2bVxcbiAgICApO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxcbiAqL1xcbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcXG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xcbiAgaWYgKGRpcnMpIHtcXG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcXG4gICAgICB2YXIgZGVmJCQxID0gZGlyc1trZXldO1xcbiAgICAgIGlmICh0eXBlb2YgZGVmJCQxID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiQkMSwgdXBkYXRlOiBkZWYkJDEgfTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZSAobmFtZSwgdmFsdWUsIHZtKSB7XFxuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XFxuICAgIHdhcm4oXFxuICAgICAgXFxcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFxcXFxcIlxcXCIgKyBuYW1lICsgXFxcIlxcXFxcXFwiOiBleHBlY3RlZCBhbiBPYmplY3QsIFxcXCIgK1xcbiAgICAgIFxcXCJidXQgZ290IFxcXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcXFwiLlxcXCIsXFxuICAgICAgdm1cXG4gICAgKTtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxcbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXFxuICovXFxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcXG4gIHBhcmVudCxcXG4gIGNoaWxkLFxcbiAgdm1cXG4pIHtcXG4gIGlmICh0cnVlKSB7XFxuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XFxuICB9XFxuXFxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcXG4gIH1cXG5cXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkLCB2bSk7XFxuICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcXG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xcblxcbiAgLy8gQXBwbHkgZXh0ZW5kcyBhbmQgbWl4aW5zIG9uIHRoZSBjaGlsZCBvcHRpb25zLFxcbiAgLy8gYnV0IG9ubHkgaWYgaXQgaXMgYSByYXcgb3B0aW9ucyBvYmplY3QgdGhhdCBpc24ndFxcbiAgLy8gdGhlIHJlc3VsdCBvZiBhbm90aGVyIG1lcmdlT3B0aW9ucyBjYWxsLlxcbiAgLy8gT25seSBtZXJnZWQgb3B0aW9ucyBoYXMgdGhlIF9iYXNlIHByb3BlcnR5LlxcbiAgaWYgKCFjaGlsZC5fYmFzZSkge1xcbiAgICBpZiAoY2hpbGQuZXh0ZW5kcykge1xcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLmV4dGVuZHMsIHZtKTtcXG4gICAgfVxcbiAgICBpZiAoY2hpbGQubWl4aW5zKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBvcHRpb25zID0ge307XFxuICB2YXIga2V5O1xcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XFxuICAgIG1lcmdlRmllbGQoa2V5KTtcXG4gIH1cXG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XFxuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcXG4gICAgfVxcbiAgfVxcbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XFxuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcXG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xcbiAgfVxcbiAgcmV0dXJuIG9wdGlvbnNcXG59XFxuXFxuLyoqXFxuICogUmVzb2x2ZSBhbiBhc3NldC5cXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXFxuICovXFxuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcXG4gIG9wdGlvbnMsXFxuICB0eXBlLFxcbiAgaWQsXFxuICB3YXJuTWlzc2luZ1xcbikge1xcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xcbiAgICByZXR1cm5cXG4gIH1cXG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcXG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxcbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XFxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XFxuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxcbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXFxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xcbiAgaWYgKCB0cnVlICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcXG4gICAgd2FybihcXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxcbiAgICAgIG9wdGlvbnNcXG4gICAgKTtcXG4gIH1cXG4gIHJldHVybiByZXNcXG59XFxuXFxuLyogICovXFxuXFxuXFxuXFxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcXG4gIGtleSxcXG4gIHByb3BPcHRpb25zLFxcbiAgcHJvcHNEYXRhLFxcbiAgdm1cXG4pIHtcXG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcXG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcXG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xcbiAgLy8gYm9vbGVhbiBjYXN0aW5nXFxuICB2YXIgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XFxuICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcXG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcXG4gICAgICB2YWx1ZSA9IGZhbHNlO1xcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpIHtcXG4gICAgICAvLyBvbmx5IGNhc3QgZW1wdHkgc3RyaW5nIC8gc2FtZSBuYW1lIHRvIGJvb2xlYW4gaWZcXG4gICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcXG4gICAgICB2YXIgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xcbiAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcXG4gICAgICAgIHZhbHVlID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcXG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cXG4gICAgdmFyIHByZXZTaG91bGRPYnNlcnZlID0gc2hvdWxkT2JzZXJ2ZTtcXG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xcbiAgICBvYnNlcnZlKHZhbHVlKTtcXG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHByZXZTaG91bGRPYnNlcnZlKTtcXG4gIH1cXG4gIGlmIChcXG4gICAgdHJ1ZVxcbiAgKSB7XFxuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XFxuICB9XFxuICByZXR1cm4gdmFsdWVcXG59XFxuXFxuLyoqXFxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cXG4gKi9cXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XFxuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XFxuICAgIHJldHVybiB1bmRlZmluZWRcXG4gIH1cXG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XFxuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XFxuICBpZiAoIHRydWUgJiYgaXNPYmplY3QoZGVmKSkge1xcbiAgICB3YXJuKFxcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXFxcIicgKyBrZXkgKyAnXFxcIjogJyArXFxuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcXG4gICAgICB2bVxcbiAgICApO1xcbiAgfVxcbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXFxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcXG4gICkge1xcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cXG4gIH1cXG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXFxuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcXG4gICAgPyBkZWYuY2FsbCh2bSlcXG4gICAgOiBkZWZcXG59XFxuXFxuLyoqXFxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxcbiAqL1xcbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxcbiAgcHJvcCxcXG4gIG5hbWUsXFxuICB2YWx1ZSxcXG4gIHZtLFxcbiAgYWJzZW50XFxuKSB7XFxuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcXG4gICAgd2FybihcXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcXFwiJyArIG5hbWUgKyAnXFxcIicsXFxuICAgICAgdm1cXG4gICAgKTtcXG4gICAgcmV0dXJuXFxuICB9XFxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xcbiAgICByZXR1cm5cXG4gIH1cXG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcXG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XFxuICBpZiAodHlwZSkge1xcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcXG4gICAgICB0eXBlID0gW3R5cGVdO1xcbiAgICB9XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcXG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XFxuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xcbiAgICB9XFxuICB9XFxuXFxuICBpZiAoIXZhbGlkKSB7XFxuICAgIHdhcm4oXFxuICAgICAgZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSxcXG4gICAgICB2bVxcbiAgICApO1xcbiAgICByZXR1cm5cXG4gIH1cXG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcXG4gIGlmICh2YWxpZGF0b3IpIHtcXG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XFxuICAgICAgd2FybihcXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFxcXCInICsgbmFtZSArICdcXFwiLicsXFxuICAgICAgICB2bVxcbiAgICAgICk7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxudmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sKSQvO1xcblxcbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XFxuICB2YXIgdmFsaWQ7XFxuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcXG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xcbiAgICB2YXIgdCA9IHR5cGVvZiB2YWx1ZTtcXG4gICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcXG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcXG4gICAgaWYgKCF2YWxpZCAmJiB0ID09PSAnb2JqZWN0Jykge1xcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xcbiAgICB9XFxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcXG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcXG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XFxuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XFxuICB9IGVsc2Uge1xcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcXG4gIH1cXG4gIHJldHVybiB7XFxuICAgIHZhbGlkOiB2YWxpZCxcXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cXG4gKi9cXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxcXFxzKmZ1bmN0aW9uIChcXFxcdyspLyk7XFxuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXFxufVxcblxcbmZ1bmN0aW9uIGlzU2FtZVR5cGUgKGEsIGIpIHtcXG4gIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpXFxufVxcblxcbmZ1bmN0aW9uIGdldFR5cGVJbmRleCAodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XFxuICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xXFxuICB9XFxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXhwZWN0ZWRUeXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xcbiAgICAgIHJldHVybiBpXFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiAtMVxcbn1cXG5cXG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UgKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XFxuICB2YXIgbWVzc2FnZSA9IFxcXCJJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFxcXFxcXFwiXFxcIiArIG5hbWUgKyBcXFwiXFxcXFxcXCIuXFxcIiArXFxuICAgIFxcXCIgRXhwZWN0ZWQgXFxcIiArIChleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpKTtcXG4gIHZhciBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xcbiAgdmFyIHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XFxuICB2YXIgZXhwZWN0ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIGV4cGVjdGVkVHlwZSk7XFxuICB2YXIgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XFxuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcXG4gIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJlxcbiAgICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXFxuICAgICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcXG4gICAgbWVzc2FnZSArPSBcXFwiIHdpdGggdmFsdWUgXFxcIiArIGV4cGVjdGVkVmFsdWU7XFxuICB9XFxuICBtZXNzYWdlICs9IFxcXCIsIGdvdCBcXFwiICsgcmVjZWl2ZWRUeXBlICsgXFxcIiBcXFwiO1xcbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IHJlY2VpdmVkIHZhbHVlXFxuICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcXG4gICAgbWVzc2FnZSArPSBcXFwid2l0aCB2YWx1ZSBcXFwiICsgcmVjZWl2ZWRWYWx1ZSArIFxcXCIuXFxcIjtcXG4gIH1cXG4gIHJldHVybiBtZXNzYWdlXFxufVxcblxcbmZ1bmN0aW9uIHN0eWxlVmFsdWUgKHZhbHVlLCB0eXBlKSB7XFxuICBpZiAodHlwZSA9PT0gJ1N0cmluZycpIHtcXG4gICAgcmV0dXJuIChcXFwiXFxcXFxcXCJcXFwiICsgdmFsdWUgKyBcXFwiXFxcXFxcXCJcXFwiKVxcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnTnVtYmVyJykge1xcbiAgICByZXR1cm4gKFxcXCJcXFwiICsgKE51bWJlcih2YWx1ZSkpKVxcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIChcXFwiXFxcIiArIHZhbHVlKVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBpc0V4cGxpY2FibGUgKHZhbHVlKSB7XFxuICB2YXIgZXhwbGljaXRUeXBlcyA9IFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ107XFxuICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtOyB9KVxcbn1cXG5cXG5mdW5jdGlvbiBpc0Jvb2xlYW4gKCkge1xcbiAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcXG4gIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XFxuXFxuICByZXR1cm4gYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJzsgfSlcXG59XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcXG4gIC8vIERlYWN0aXZhdGUgZGVwcyB0cmFja2luZyB3aGlsZSBwcm9jZXNzaW5nIGVycm9yIGhhbmRsZXIgdG8gYXZvaWQgcG9zc2libGUgaW5maW5pdGUgcmVuZGVyaW5nLlxcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVleC9pc3N1ZXMvMTUwNVxcbiAgcHVzaFRhcmdldCgpO1xcbiAgdHJ5IHtcXG4gICAgaWYgKHZtKSB7XFxuICAgICAgdmFyIGN1ciA9IHZtO1xcbiAgICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XFxuICAgICAgICB2YXIgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcXG4gICAgICAgIGlmIChob29rcykge1xcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgIHZhciBjYXB0dXJlID0gaG9va3NbaV0uY2FsbChjdXIsIGVyciwgdm0sIGluZm8pID09PSBmYWxzZTtcXG4gICAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7IHJldHVybiB9XFxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgZ2xvYmFsSGFuZGxlRXJyb3IoZSwgY3VyLCAnZXJyb3JDYXB0dXJlZCBob29rJyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pO1xcbiAgfSBmaW5hbGx5IHtcXG4gICAgcG9wVGFyZ2V0KCk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGludm9rZVdpdGhFcnJvckhhbmRsaW5nIChcXG4gIGhhbmRsZXIsXFxuICBjb250ZXh0LFxcbiAgYXJncyxcXG4gIHZtLFxcbiAgaW5mb1xcbikge1xcbiAgdmFyIHJlcztcXG4gIHRyeSB7XFxuICAgIHJlcyA9IGFyZ3MgPyBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpIDogaGFuZGxlci5jYWxsKGNvbnRleHQpO1xcbiAgICBpZiAocmVzICYmICFyZXMuX2lzVnVlICYmIGlzUHJvbWlzZShyZXMpICYmICFyZXMuX2hhbmRsZWQpIHtcXG4gICAgICByZXMuY2F0Y2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvICsgXFxcIiAoUHJvbWlzZS9hc3luYylcXFwiKTsgfSk7XFxuICAgICAgLy8gaXNzdWUgIzk1MTFcXG4gICAgICAvLyBhdm9pZCBjYXRjaCB0cmlnZ2VyaW5nIG11bHRpcGxlIHRpbWVzIHdoZW4gbmVzdGVkIGNhbGxzXFxuICAgICAgcmVzLl9oYW5kbGVkID0gdHJ1ZTtcXG4gICAgfVxcbiAgfSBjYXRjaCAoZSkge1xcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgaW5mbyk7XFxuICB9XFxuICByZXR1cm4gcmVzXFxufVxcblxcbmZ1bmN0aW9uIGdsb2JhbEhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XFxuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xcbiAgICB0cnkge1xcbiAgICAgIHJldHVybiBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbylcXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgIC8vIGlmIHRoZSB1c2VyIGludGVudGlvbmFsbHkgdGhyb3dzIHRoZSBvcmlnaW5hbCBlcnJvciBpbiB0aGUgaGFuZGxlcixcXG4gICAgICAvLyBkbyBub3QgbG9nIGl0IHR3aWNlXFxuICAgICAgaWYgKGUgIT09IGVycikge1xcbiAgICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xcbn1cXG5cXG5mdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xcbiAgaWYgKHRydWUpIHtcXG4gICAgd2FybigoXFxcIkVycm9yIGluIFxcXCIgKyBpbmZvICsgXFxcIjogXFxcXFxcXCJcXFwiICsgKGVyci50b1N0cmluZygpKSArIFxcXCJcXFxcXFxcIlxcXCIpLCB2bSk7XFxuICB9XFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xcbiAgaWYgKChpbkJyb3dzZXIgfHwgaW5XZWV4KSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xcbiAgfSBlbHNlIHtcXG4gICAgdGhyb3cgZXJyXFxuICB9XFxufVxcblxcbi8qICAqL1xcblxcbnZhciBpc1VzaW5nTWljcm9UYXNrID0gZmFsc2U7XFxuXFxudmFyIGNhbGxiYWNrcyA9IFtdO1xcbnZhciBwZW5kaW5nID0gZmFsc2U7XFxuXFxuZnVuY3Rpb24gZmx1c2hDYWxsYmFja3MgKCkge1xcbiAgcGVuZGluZyA9IGZhbHNlO1xcbiAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcXG4gIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgY29waWVzW2ldKCk7XFxuICB9XFxufVxcblxcbi8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgbWljcm90YXNrcy5cXG4vLyBJbiAyLjUgd2UgdXNlZCAobWFjcm8pIHRhc2tzIChpbiBjb21iaW5hdGlvbiB3aXRoIG1pY3JvdGFza3MpLlxcbi8vIEhvd2V2ZXIsIGl0IGhhcyBzdWJ0bGUgcHJvYmxlbXMgd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50XFxuLy8gKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXFxuLy8gQWxzbywgdXNpbmcgKG1hY3JvKSB0YXNrcyBpbiBldmVudCBoYW5kbGVyIHdvdWxkIGNhdXNlIHNvbWUgd2VpcmQgYmVoYXZpb3JzXFxuLy8gdGhhdCBjYW5ub3QgYmUgY2lyY3VtdmVudGVkIChlLmcuICM3MTA5LCAjNzE1MywgIzc1NDYsICM3ODM0LCAjODEwOSkuXFxuLy8gU28gd2Ugbm93IHVzZSBtaWNyb3Rhc2tzIGV2ZXJ5d2hlcmUsIGFnYWluLlxcbi8vIEEgbWFqb3IgZHJhd2JhY2sgb2YgdGhpcyB0cmFkZW9mZiBpcyB0aGF0IHRoZXJlIGFyZSBzb21lIHNjZW5hcmlvc1xcbi8vIHdoZXJlIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxcbi8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCwgd2hpY2ggaGF2ZSB3b3JrYXJvdW5kcylcXG4vLyBvciBldmVuIGJldHdlZW4gYnViYmxpbmcgb2YgdGhlIHNhbWUgZXZlbnQgKCM2NTY2KS5cXG52YXIgdGltZXJGdW5jO1xcblxcbi8vIFRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXFxuLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXFxuLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXFxuLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcXG4vLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXFxuLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0Olxcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0LCAkZmxvdy1kaXNhYmxlLWxpbmUgKi9cXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XFxuICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xcbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xcbiAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xcbiAgICAvLyBJbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcXG4gICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXFxuICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXFxuICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxcbiAgICAvLyBcXFwiZm9yY2VcXFwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXFxuICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XFxuICB9O1xcbiAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XFxufSBlbHNlIGlmICghaXNJRSAmJiB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxcbiAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcXG4gIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxcbiAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xcbikpIHtcXG4gIC8vIFVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXFxuICAvLyBlLmcuIFBoYW50b21KUywgaU9TNywgQW5kcm9pZCA0LjRcXG4gIC8vICgjNjQ2NiBNdXRhdGlvbk9ic2VydmVyIGlzIHVucmVsaWFibGUgaW4gSUUxMSlcXG4gIHZhciBjb3VudGVyID0gMTtcXG4gIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZsdXNoQ2FsbGJhY2tzKTtcXG4gIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XFxuICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XFxuICAgIGNoYXJhY3RlckRhdGE6IHRydWVcXG4gIH0pO1xcbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xcbiAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XFxuICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XFxuICB9O1xcbiAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XFxufSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShzZXRJbW1lZGlhdGUpKSB7XFxuICAvLyBGYWxsYmFjayB0byBzZXRJbW1lZGlhdGUuXFxuICAvLyBUZWNoaW5pY2FsbHkgaXQgbGV2ZXJhZ2VzIHRoZSAobWFjcm8pIHRhc2sgcXVldWUsXFxuICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cXG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcXG4gIH07XFxufSBlbHNlIHtcXG4gIC8vIEZhbGxiYWNrIHRvIHNldFRpbWVvdXQuXFxuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHNldFRpbWVvdXQoZmx1c2hDYWxsYmFja3MsIDApO1xcbiAgfTtcXG59XFxuXFxuZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcXG4gIHZhciBfcmVzb2x2ZTtcXG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKGNiKSB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGNiLmNhbGwoY3R4KTtcXG4gICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xcbiAgICAgIF9yZXNvbHZlKGN0eCk7XFxuICAgIH1cXG4gIH0pO1xcbiAgaWYgKCFwZW5kaW5nKSB7XFxuICAgIHBlbmRpbmcgPSB0cnVlO1xcbiAgICB0aW1lckZ1bmMoKTtcXG4gIH1cXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxcbiAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XFxuICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xcbiAgICB9KVxcbiAgfVxcbn1cXG5cXG4vKiAgKi9cXG5cXG52YXIgbWFyaztcXG52YXIgbWVhc3VyZTtcXG5cXG5pZiAodHJ1ZSkge1xcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICBpZiAoXFxuICAgIHBlcmYgJiZcXG4gICAgcGVyZi5tYXJrICYmXFxuICAgIHBlcmYubWVhc3VyZSAmJlxcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXFxuICApIHtcXG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcXG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XFxuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcXG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcXG4gICAgICAvLyBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSlcXG4gICAgfTtcXG4gIH1cXG59XFxuXFxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXFxuXFxudmFyIGluaXRQcm94eTtcXG5cXG5pZiAodHJ1ZSkge1xcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXFxuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcXG4gICk7XFxuXFxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcXG4gICAgd2FybihcXG4gICAgICBcXFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXFxcXFwiXFxcIiArIGtleSArIFxcXCJcXFxcXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFxcXCIgK1xcbiAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xcbiAgICAgICdlaXRoZXIgaW4gdGhlIGRhdGEgb3B0aW9uLCBvciBmb3IgY2xhc3MtYmFzZWQgY29tcG9uZW50cywgYnkgJyArXFxuICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLFxcbiAgICAgIHRhcmdldFxcbiAgICApO1xcbiAgfTtcXG5cXG4gIHZhciB3YXJuUmVzZXJ2ZWRQcmVmaXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcXG4gICAgd2FybihcXG4gICAgICBcXFwiUHJvcGVydHkgXFxcXFxcXCJcXFwiICsga2V5ICsgXFxcIlxcXFxcXFwiIG11c3QgYmUgYWNjZXNzZWQgd2l0aCBcXFxcXFxcIiRkYXRhLlxcXCIgKyBrZXkgKyBcXFwiXFxcXFxcXCIgYmVjYXVzZSBcXFwiICtcXG4gICAgICAncHJvcGVydGllcyBzdGFydGluZyB3aXRoIFxcXCIkXFxcIiBvciBcXFwiX1xcXCIgYXJlIG5vdCBwcm94aWVkIGluIHRoZSBWdWUgaW5zdGFuY2UgdG8gJyArXFxuICAgICAgJ3ByZXZlbnQgY29uZmxpY3RzIHdpdGggVnVlIGludGVybmFscycgK1xcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2FwaS8jZGF0YScsXFxuICAgICAgdGFyZ2V0XFxuICAgICk7XFxuICB9O1xcblxcbiAgdmFyIGhhc1Byb3h5ID1cXG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XFxuXFxuICBpZiAoaGFzUHJveHkpIHtcXG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCcpO1xcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcXG4gICAgICAgICAgd2FybigoXFxcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlxcXCIgKyBrZXkpKTtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxuXFxuICB2YXIgaGFzSGFuZGxlciA9IHtcXG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XFxuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XFxuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcXG4gICAgICAgICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkuY2hhckF0KDApID09PSAnXycgJiYgIShrZXkgaW4gdGFyZ2V0LiRkYXRhKSk7XFxuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHsgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTsgfVxcbiAgICAgICAgZWxzZSB7IHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTsgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcXG4gICAgfVxcbiAgfTtcXG5cXG4gIHZhciBnZXRIYW5kbGVyID0ge1xcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcXG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHsgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTsgfVxcbiAgICAgICAgZWxzZSB7IHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTsgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cXG4gICAgfVxcbiAgfTtcXG5cXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcXG4gICAgaWYgKGhhc1Byb3h5KSB7XFxuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXFxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcXG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXFxuICAgICAgICA/IGdldEhhbmRsZXJcXG4gICAgICAgIDogaGFzSGFuZGxlcjtcXG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcXG4gICAgfVxcbiAgfTtcXG59XFxuXFxuLyogICovXFxuXFxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcXG5cXG4vKipcXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XFxuICogaXMgY29sbGVjdGVkIGFzIGEgXFxcImRlZXBcXFwiIGRlcGVuZGVuY3kuXFxuICovXFxuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcXG59XFxuXFxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcXG4gIHZhciBpLCBrZXlzO1xcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcXG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgT2JqZWN0LmlzRnJvemVuKHZhbCkgfHwgdmFsIGluc3RhbmNlb2YgVk5vZGUpIHtcXG4gICAgcmV0dXJuXFxuICB9XFxuICBpZiAodmFsLl9fb2JfXykge1xcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcXG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xcbiAgICAgIHJldHVyblxcbiAgICB9XFxuICAgIHNlZW4uYWRkKGRlcElkKTtcXG4gIH1cXG4gIGlmIChpc0EpIHtcXG4gICAgaSA9IHZhbC5sZW5ndGg7XFxuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7IH1cXG4gIH0gZWxzZSB7XFxuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xcbiAgICBpID0ga2V5cy5sZW5ndGg7XFxuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cXG4gIH1cXG59XFxuXFxuLyogICovXFxuXFxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XFxuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XFxuICBuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xcbiAgdmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcXG4gIHJldHVybiB7XFxuICAgIG5hbWU6IG5hbWUsXFxuICAgIG9uY2U6IG9uY2UkJDEsXFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXFxuICAgIHBhc3NpdmU6IHBhc3NpdmVcXG4gIH1cXG59KTtcXG5cXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucywgdm0pIHtcXG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XFxuXFxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2xvbmVkW2ldLCBudWxsLCBhcmd1bWVudHMkMSwgdm0sIFxcXCJ2LW9uIGhhbmRsZXJcXFwiKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcXG4gICAgICByZXR1cm4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm5zLCBudWxsLCBhcmd1bWVudHMsIHZtLCBcXFwidi1vbiBoYW5kbGVyXFxcIilcXG4gICAgfVxcbiAgfVxcbiAgaW52b2tlci5mbnMgPSBmbnM7XFxuICByZXR1cm4gaW52b2tlclxcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxcbiAgb24sXFxuICBvbGRPbixcXG4gIGFkZCxcXG4gIHJlbW92ZSQkMSxcXG4gIGNyZWF0ZU9uY2VIYW5kbGVyLFxcbiAgdm1cXG4pIHtcXG4gIHZhciBuYW1lLCBkZWYkJDEsIGN1ciwgb2xkLCBldmVudDtcXG4gIGZvciAobmFtZSBpbiBvbikge1xcbiAgICBkZWYkJDEgPSBjdXIgPSBvbltuYW1lXTtcXG4gICAgb2xkID0gb2xkT25bbmFtZV07XFxuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XFxuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcXG4gICAgICAgdHJ1ZSAmJiB3YXJuKFxcbiAgICAgICAgXFxcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcXFxcXCJcXFwiICsgKGV2ZW50Lm5hbWUpICsgXFxcIlxcXFxcXFwiOiBnb3QgXFxcIiArIFN0cmluZyhjdXIpLFxcbiAgICAgICAgdm1cXG4gICAgICApO1xcbiAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XFxuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIsIHZtKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGlzVHJ1ZShldmVudC5vbmNlKSkge1xcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVPbmNlSGFuZGxlcihldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUpO1xcbiAgICAgIH1cXG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlLCBldmVudC5wYXJhbXMpO1xcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XFxuICAgICAgb2xkLmZucyA9IGN1cjtcXG4gICAgICBvbltuYW1lXSA9IG9sZDtcXG4gICAgfVxcbiAgfVxcbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XFxuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XFxuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vKiAgKi9cXG5cXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XFxuICBpZiAoZGVmIGluc3RhbmNlb2YgVk5vZGUpIHtcXG4gICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcXG4gIH1cXG4gIHZhciBpbnZva2VyO1xcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XFxuXFxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XFxuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcXG4gIH1cXG5cXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XFxuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcXG4gIH0gZWxzZSB7XFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcXG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcXG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXFxuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcXG59XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXFxuICBkYXRhLFxcbiAgQ3RvcixcXG4gIHRhZ1xcbikge1xcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXFxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXFxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XFxuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcXG4gICAgcmV0dXJuXFxuICB9XFxuICB2YXIgcmVzID0ge307XFxuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcXG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XFxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcXG4gICAgICBpZiAodHJ1ZSkge1xcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XFxuICAgICAgICBpZiAoXFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcXG4gICAgICAgICkge1xcbiAgICAgICAgICB0aXAoXFxuICAgICAgICAgICAgXFxcIlByb3AgXFxcXFxcXCJcXFwiICsga2V5SW5Mb3dlckNhc2UgKyBcXFwiXFxcXFxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcXFwiICtcXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXFxcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcXFwiICtcXG4gICAgICAgICAgICBcXFwiIFxcXFxcXFwiXFxcIiArIGtleSArIFxcXCJcXFxcXFxcIi4gXFxcIiArXFxuICAgICAgICAgICAgXFxcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXFxcIiArXFxuICAgICAgICAgICAgXFxcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXFxcIiArXFxuICAgICAgICAgICAgXFxcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcXFxcXCJcXFwiICsgYWx0S2V5ICsgXFxcIlxcXFxcXFwiIGluc3RlYWQgb2YgXFxcXFxcXCJcXFwiICsga2V5ICsgXFxcIlxcXFxcXFwiLlxcXCJcXG4gICAgICAgICAgKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gcmVzXFxufVxcblxcbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXFxuICByZXMsXFxuICBoYXNoLFxcbiAga2V5LFxcbiAgYWx0S2V5LFxcbiAgcHJlc2VydmVcXG4pIHtcXG4gIGlmIChpc0RlZihoYXNoKSkge1xcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcXG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcXG4gICAgICBpZiAoIXByZXNlcnZlKSB7XFxuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdHJ1ZVxcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XFxuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XFxuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHRydWVcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGZhbHNlXFxufVxcblxcbi8qICAqL1xcblxcbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXFxuLy9cXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XFxuXFxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXFxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XFxuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGNoaWxkcmVuXFxufVxcblxcbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXFxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxcbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxcbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXFxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxcbiAgICAgIDogdW5kZWZpbmVkXFxufVxcblxcbmZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcXG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXFxufVxcblxcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xcbiAgdmFyIHJlcyA9IFtdO1xcbiAgdmFyIGksIGMsIGxhc3RJbmRleCwgbGFzdDtcXG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xcbiAgICBjID0gY2hpbGRyZW5baV07XFxuICAgIGlmIChpc1VuZGVmKGMpIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpIHsgY29udGludWUgfVxcbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcXG4gICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xcbiAgICAvLyAgbmVzdGVkXFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XFxuICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xcbiAgICAgICAgYyA9IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgKChuZXN0ZWRJbmRleCB8fCAnJykgKyBcXFwiX1xcXCIgKyBpKSk7XFxuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXFxuICAgICAgICBpZiAoaXNUZXh0Tm9kZShjWzBdKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XFxuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcXG4gICAgICAgICAgYy5zaGlmdCgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcXG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xcbiAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIFNTUiBoeWRyYXRpb24gYmVjYXVzZSB0ZXh0IG5vZGVzIGFyZVxcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXFxuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcXG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XFxuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXFxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxcbiAgICAgICAgICBpc1VuZGVmKGMua2V5KSAmJlxcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcXG4gICAgICAgICAgYy5rZXkgPSBcXFwiX192bGlzdFxcXCIgKyBuZXN0ZWRJbmRleCArIFxcXCJfXFxcIiArIGkgKyBcXFwiX19cXFwiO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmVzLnB1c2goYyk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gcmVzXFxufVxcblxcbi8qICAqL1xcblxcbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xcbiAgaWYgKHByb3ZpZGUpIHtcXG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcXG4gICAgICA6IHByb3ZpZGU7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xcbiAgdmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XFxuICBpZiAocmVzdWx0KSB7XFxuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XFxuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cXG4gICAgICBpZiAodHJ1ZSkge1xcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgd2FybihcXG4gICAgICAgICAgICBcXFwiQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBcXFwiICtcXG4gICAgICAgICAgICBcXFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcXFwiICtcXG4gICAgICAgICAgICBcXFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXFxcXFwiXFxcIiArIGtleSArIFxcXCJcXFxcXFxcIlxcXCIsXFxuICAgICAgICAgICAgdm1cXG4gICAgICAgICAgKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSB7fVxcbiAgICB9KTtcXG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XFxuICBpZiAoaW5qZWN0KSB7XFxuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXFxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcbiAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcXG4gICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xcbiAgICAgIC8vICM2NTc0IGluIGNhc2UgdGhlIGluamVjdCBvYmplY3QgaXMgb2JzZXJ2ZWQuLi5cXG4gICAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgeyBjb250aW51ZSB9XFxuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XS5mcm9tO1xcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcXG4gICAgICB3aGlsZSAoc291cmNlKSB7XFxuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBoYXNPd24oc291cmNlLl9wcm92aWRlZCwgcHJvdmlkZUtleSkpIHtcXG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xcbiAgICAgICAgICBicmVha1xcbiAgICAgICAgfVxcbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XFxuICAgICAgfVxcbiAgICAgIGlmICghc291cmNlKSB7XFxuICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XFxuICAgICAgICAgIHZhciBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XFxuICAgICAgICAgIHJlc3VsdFtrZXldID0gdHlwZW9mIHByb3ZpZGVEZWZhdWx0ID09PSAnZnVuY3Rpb24nXFxuICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxcbiAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XFxuICAgICAgICB9IGVsc2UgaWYgKHRydWUpIHtcXG4gICAgICAgICAgd2FybigoXFxcIkluamVjdGlvbiBcXFxcXFxcIlxcXCIgKyBrZXkgKyBcXFwiXFxcXFxcXCIgbm90IGZvdW5kXFxcIiksIHZtKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3VsdFxcbiAgfVxcbn1cXG5cXG4vKiAgKi9cXG5cXG5cXG5cXG4vKipcXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxcbiAqL1xcbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXFxuICBjaGlsZHJlbixcXG4gIGNvbnRleHRcXG4pIHtcXG4gIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xcbiAgICByZXR1cm4ge31cXG4gIH1cXG4gIHZhciBzbG90cyA9IHt9O1xcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XFxuICAgIHZhciBkYXRhID0gY2hpbGQuZGF0YTtcXG4gICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xcbiAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XFxuICAgIH1cXG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXFxuICAgIC8vIHNhbWUgY29udGV4dC5cXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZuQ29udGV4dCA9PT0gY29udGV4dCkgJiZcXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXFxuICAgICkge1xcbiAgICAgIHZhciBuYW1lID0gZGF0YS5zbG90O1xcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XFxuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuIHx8IFtdKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgKHNsb3RzLmRlZmF1bHQgfHwgKHNsb3RzLmRlZmF1bHQgPSBbXSkpLnB1c2goY2hpbGQpO1xcbiAgICB9XFxuICB9XFxuICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcXG4gIGZvciAodmFyIG5hbWUkMSBpbiBzbG90cykge1xcbiAgICBpZiAoc2xvdHNbbmFtZSQxXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XFxuICAgICAgZGVsZXRlIHNsb3RzW25hbWUkMV07XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBzbG90c1xcbn1cXG5cXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcXG4gIHJldHVybiAobm9kZS5pc0NvbW1lbnQgJiYgIW5vZGUuYXN5bmNGYWN0b3J5KSB8fCBub2RlLnRleHQgPT09ICcgJ1xcbn1cXG5cXG4vKiAgKi9cXG5cXG5mdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90cyAoXFxuICBzbG90cyxcXG4gIG5vcm1hbFNsb3RzLFxcbiAgcHJldlNsb3RzXFxuKSB7XFxuICB2YXIgcmVzO1xcbiAgdmFyIGhhc05vcm1hbFNsb3RzID0gT2JqZWN0LmtleXMobm9ybWFsU2xvdHMpLmxlbmd0aCA+IDA7XFxuICB2YXIgaXNTdGFibGUgPSBzbG90cyA/ICEhc2xvdHMuJHN0YWJsZSA6ICFoYXNOb3JtYWxTbG90cztcXG4gIHZhciBrZXkgPSBzbG90cyAmJiBzbG90cy4ka2V5O1xcbiAgaWYgKCFzbG90cykge1xcbiAgICByZXMgPSB7fTtcXG4gIH0gZWxzZSBpZiAoc2xvdHMuX25vcm1hbGl6ZWQpIHtcXG4gICAgLy8gZmFzdCBwYXRoIDE6IGNoaWxkIGNvbXBvbmVudCByZS1yZW5kZXIgb25seSwgcGFyZW50IGRpZCBub3QgY2hhbmdlXFxuICAgIHJldHVybiBzbG90cy5fbm9ybWFsaXplZFxcbiAgfSBlbHNlIGlmIChcXG4gICAgaXNTdGFibGUgJiZcXG4gICAgcHJldlNsb3RzICYmXFxuICAgIHByZXZTbG90cyAhPT0gZW1wdHlPYmplY3QgJiZcXG4gICAga2V5ID09PSBwcmV2U2xvdHMuJGtleSAmJlxcbiAgICAhaGFzTm9ybWFsU2xvdHMgJiZcXG4gICAgIXByZXZTbG90cy4kaGFzTm9ybWFsXFxuICApIHtcXG4gICAgLy8gZmFzdCBwYXRoIDI6IHN0YWJsZSBzY29wZWQgc2xvdHMgdy8gbm8gbm9ybWFsIHNsb3RzIHRvIHByb3h5LFxcbiAgICAvLyBvbmx5IG5lZWQgdG8gbm9ybWFsaXplIG9uY2VcXG4gICAgcmV0dXJuIHByZXZTbG90c1xcbiAgfSBlbHNlIHtcXG4gICAgcmVzID0ge307XFxuICAgIGZvciAodmFyIGtleSQxIGluIHNsb3RzKSB7XFxuICAgICAgaWYgKHNsb3RzW2tleSQxXSAmJiBrZXkkMVswXSAhPT0gJyQnKSB7XFxuICAgICAgICByZXNba2V5JDFdID0gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5JDEsIHNsb3RzW2tleSQxXSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICAvLyBleHBvc2Ugbm9ybWFsIHNsb3RzIG9uIHNjb3BlZFNsb3RzXFxuICBmb3IgKHZhciBrZXkkMiBpbiBub3JtYWxTbG90cykge1xcbiAgICBpZiAoIShrZXkkMiBpbiByZXMpKSB7XFxuICAgICAgcmVzW2tleSQyXSA9IHByb3h5Tm9ybWFsU2xvdChub3JtYWxTbG90cywga2V5JDIpO1xcbiAgICB9XFxuICB9XFxuICAvLyBhdm9yaWF6IHNlZW1zIHRvIG1vY2sgYSBub24tZXh0ZW5zaWJsZSAkc2NvcGVkU2xvdHMgb2JqZWN0XFxuICAvLyBhbmQgd2hlbiB0aGF0IGlzIHBhc3NlZCBkb3duIHRoaXMgd291bGQgY2F1c2UgYW4gZXJyb3JcXG4gIGlmIChzbG90cyAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHNsb3RzKSkge1xcbiAgICAoc2xvdHMpLl9ub3JtYWxpemVkID0gcmVzO1xcbiAgfVxcbiAgZGVmKHJlcywgJyRzdGFibGUnLCBpc1N0YWJsZSk7XFxuICBkZWYocmVzLCAnJGtleScsIGtleSk7XFxuICBkZWYocmVzLCAnJGhhc05vcm1hbCcsIGhhc05vcm1hbFNsb3RzKTtcXG4gIHJldHVybiByZXNcXG59XFxuXFxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5LCBmbikge1xcbiAgdmFyIG5vcm1hbGl6ZWQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID8gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKSA6IGZuKHt9KTtcXG4gICAgcmVzID0gcmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHJlcylcXG4gICAgICA/IFtyZXNdIC8vIHNpbmdsZSB2bm9kZVxcbiAgICAgIDogbm9ybWFsaXplQ2hpbGRyZW4ocmVzKTtcXG4gICAgcmV0dXJuIHJlcyAmJiAoXFxuICAgICAgcmVzLmxlbmd0aCA9PT0gMCB8fFxcbiAgICAgIChyZXMubGVuZ3RoID09PSAxICYmIHJlc1swXS5pc0NvbW1lbnQpIC8vICM5NjU4XFxuICAgICkgPyB1bmRlZmluZWRcXG4gICAgICA6IHJlc1xcbiAgfTtcXG4gIC8vIHRoaXMgaXMgYSBzbG90IHVzaW5nIHRoZSBuZXcgdi1zbG90IHN5bnRheCB3aXRob3V0IHNjb3BlLiBhbHRob3VnaCBpdCBpc1xcbiAgLy8gY29tcGlsZWQgYXMgYSBzY29wZWQgc2xvdCwgcmVuZGVyIGZuIHVzZXJzIHdvdWxkIGV4cGVjdCBpdCB0byBiZSBwcmVzZW50XFxuICAvLyBvbiB0aGlzLiRzbG90cyBiZWNhdXNlIHRoZSB1c2FnZSBpcyBzZW1hbnRpY2FsbHkgYSBub3JtYWwgc2xvdC5cXG4gIGlmIChmbi5wcm94eSkge1xcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9ybWFsU2xvdHMsIGtleSwge1xcbiAgICAgIGdldDogbm9ybWFsaXplZCxcXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxcbiAgICB9KTtcXG4gIH1cXG4gIHJldHVybiBub3JtYWxpemVkXFxufVxcblxcbmZ1bmN0aW9uIHByb3h5Tm9ybWFsU2xvdChzbG90cywga2V5KSB7XFxuICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2xvdHNba2V5XTsgfVxcbn1cXG5cXG4vKiAgKi9cXG5cXG4vKipcXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxcbiAqL1xcbmZ1bmN0aW9uIHJlbmRlckxpc3QgKFxcbiAgdmFsLFxcbiAgcmVuZGVyXFxuKSB7XFxuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XFxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XFxuICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcXG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcXG4gICAgfVxcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcXG4gICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XFxuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcXG4gICAgfVxcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XFxuICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcXG4gICAgICByZXQgPSBbXTtcXG4gICAgICB2YXIgaXRlcmF0b3IgPSB2YWxbU3ltYm9sLml0ZXJhdG9yXSgpO1xcbiAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XFxuICAgICAgd2hpbGUgKCFyZXN1bHQuZG9uZSkge1xcbiAgICAgICAgcmV0LnB1c2gocmVuZGVyKHJlc3VsdC52YWx1ZSwgcmV0Lmxlbmd0aCkpO1xcbiAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcXG4gICAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcXG4gICAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIGlmICghaXNEZWYocmV0KSkge1xcbiAgICByZXQgPSBbXTtcXG4gIH1cXG4gIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcXG4gIHJldHVybiByZXRcXG59XFxuXFxuLyogICovXFxuXFxuLyoqXFxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cXG4gKi9cXG5mdW5jdGlvbiByZW5kZXJTbG90IChcXG4gIG5hbWUsXFxuICBmYWxsYmFjayxcXG4gIHByb3BzLFxcbiAgYmluZE9iamVjdFxcbikge1xcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xcbiAgdmFyIG5vZGVzO1xcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xcbiAgICBpZiAoYmluZE9iamVjdCkge1xcbiAgICAgIGlmICggdHJ1ZSAmJiAhaXNPYmplY3QoYmluZE9iamVjdCkpIHtcXG4gICAgICAgIHdhcm4oXFxuICAgICAgICAgICdzbG90IHYtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0JyxcXG4gICAgICAgICAgdGhpc1xcbiAgICAgICAgKTtcXG4gICAgICB9XFxuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xcbiAgICB9XFxuICAgIG5vZGVzID0gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFjaztcXG4gIH0gZWxzZSB7XFxuICAgIG5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV0gfHwgZmFsbGJhY2s7XFxuICB9XFxuXFxuICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcXG4gIGlmICh0YXJnZXQpIHtcXG4gICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJywgeyBzbG90OiB0YXJnZXQgfSwgbm9kZXMpXFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gbm9kZXNcXG4gIH1cXG59XFxuXFxuLyogICovXFxuXFxuLyoqXFxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXFxuICovXFxuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcXG4gIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHlcXG59XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gaXNLZXlOb3RNYXRjaCAoZXhwZWN0LCBhY3R1YWwpIHtcXG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdCkpIHtcXG4gICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xXFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gZXhwZWN0ICE9PSBhY3R1YWxcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxcbiAqIGV4cG9zZWQgYXMgVnVlLnByb3RvdHlwZS5fa1xcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxcbiAqL1xcbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxcbiAgZXZlbnRLZXlDb2RlLFxcbiAga2V5LFxcbiAgYnVpbHRJbktleUNvZGUsXFxuICBldmVudEtleU5hbWUsXFxuICBidWlsdEluS2V5TmFtZVxcbikge1xcbiAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcXG4gIGlmIChidWlsdEluS2V5TmFtZSAmJiBldmVudEtleU5hbWUgJiYgIWNvbmZpZy5rZXlDb2Rlc1trZXldKSB7XFxuICAgIHJldHVybiBpc0tleU5vdE1hdGNoKGJ1aWx0SW5LZXlOYW1lLCBldmVudEtleU5hbWUpXFxuICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcXG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2gobWFwcGVkS2V5Q29kZSwgZXZlbnRLZXlDb2RlKVxcbiAgfSBlbHNlIGlmIChldmVudEtleU5hbWUpIHtcXG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcXG4gIH1cXG59XFxuXFxuLyogICovXFxuXFxuLyoqXFxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVxcXCJvYmplY3RcXFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXFxuICovXFxuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcXG4gIGRhdGEsXFxuICB0YWcsXFxuICB2YWx1ZSxcXG4gIGFzUHJvcCxcXG4gIGlzU3luY1xcbikge1xcbiAgaWYgKHZhbHVlKSB7XFxuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XFxuICAgICAgIHRydWUgJiYgd2FybihcXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXFxuICAgICAgICB0aGlzXFxuICAgICAgKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcXG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xcbiAgICAgIH1cXG4gICAgICB2YXIgaGFzaDtcXG4gICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xcbiAgICAgICAgaWYgKFxcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcXG4gICAgICAgICAga2V5ID09PSAnc3R5bGUnIHx8XFxuICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxcbiAgICAgICAgKSB7XFxuICAgICAgICAgIGhhc2ggPSBkYXRhO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcXG4gICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXFxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXFxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGNhbWVsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XFxuICAgICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xcbiAgICAgICAgaWYgKCEoY2FtZWxpemVkS2V5IGluIGhhc2gpICYmICEoaHlwaGVuYXRlZEtleSBpbiBoYXNoKSkge1xcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xcblxcbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XFxuICAgICAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcXG4gICAgICAgICAgICBvblsoXFxcInVwZGF0ZTpcXFwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XFxuICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gJGV2ZW50O1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9O1xcblxcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgbG9vcCgga2V5ICk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBkYXRhXFxufVxcblxcbi8qICAqL1xcblxcbi8qKlxcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxcbiAqL1xcbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXFxuICBpbmRleCxcXG4gIGlzSW5Gb3JcXG4pIHtcXG4gIHZhciBjYWNoZWQgPSB0aGlzLl9zdGF0aWNUcmVlcyB8fCAodGhpcy5fc3RhdGljVHJlZXMgPSBbXSk7XFxuICB2YXIgdHJlZSA9IGNhY2hlZFtpbmRleF07XFxuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlLlxcbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcXG4gICAgcmV0dXJuIHRyZWVcXG4gIH1cXG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cXG4gIHRyZWUgPSBjYWNoZWRbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwoXFxuICAgIHRoaXMuX3JlbmRlclByb3h5LFxcbiAgICBudWxsLFxcbiAgICB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXFxuICApO1xcbiAgbWFya1N0YXRpYyh0cmVlLCAoXFxcIl9fc3RhdGljX19cXFwiICsgaW5kZXgpLCBmYWxzZSk7XFxuICByZXR1cm4gdHJlZVxcbn1cXG5cXG4vKipcXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxcbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxcbiAqL1xcbmZ1bmN0aW9uIG1hcmtPbmNlIChcXG4gIHRyZWUsXFxuICBpbmRleCxcXG4gIGtleVxcbikge1xcbiAgbWFya1N0YXRpYyh0cmVlLCAoXFxcIl9fb25jZV9fXFxcIiArIGluZGV4ICsgKGtleSA/IChcXFwiX1xcXCIgKyBrZXkpIDogXFxcIlxcXCIpKSwgdHJ1ZSk7XFxuICByZXR1cm4gdHJlZVxcbn1cXG5cXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcXG4gIHRyZWUsXFxuICBrZXksXFxuICBpc09uY2VcXG4pIHtcXG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFxcXCJfXFxcIiArIGkpLCBpc09uY2UpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcXG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xcbiAgbm9kZS5rZXkgPSBrZXk7XFxuICBub2RlLmlzT25jZSA9IGlzT25jZTtcXG59XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcXG4gIGlmICh2YWx1ZSkge1xcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XFxuICAgICAgIHRydWUgJiYgd2FybihcXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxcbiAgICAgICAgdGhpc1xcbiAgICAgICk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIG9uID0gZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge307XFxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XFxuICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xcbiAgICAgICAgdmFyIG91cnMgPSB2YWx1ZVtrZXldO1xcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBvdXJzKSA6IG91cnM7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gZGF0YVxcbn1cXG5cXG4vKiAgKi9cXG5cXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxcbiAgcmVzLFxcbiAgLy8gdGhlIGZvbGxvd2luZyBhcmUgYWRkZWQgaW4gMi42XFxuICBoYXNEeW5hbWljS2V5cyxcXG4gIGNvbnRlbnRIYXNoS2V5XFxuKSB7XFxuICByZXMgPSByZXMgfHwgeyAkc3RhYmxlOiAhaGFzRHluYW1pY0tleXMgfTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBzbG90ID0gZm5zW2ldO1xcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzbG90KSkge1xcbiAgICAgIHJlc29sdmVTY29wZWRTbG90cyhzbG90LCByZXMsIGhhc0R5bmFtaWNLZXlzKTtcXG4gICAgfSBlbHNlIGlmIChzbG90KSB7XFxuICAgICAgLy8gbWFya2VyIGZvciByZXZlcnNlIHByb3h5aW5nIHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXFxuICAgICAgaWYgKHNsb3QucHJveHkpIHtcXG4gICAgICAgIHNsb3QuZm4ucHJveHkgPSB0cnVlO1xcbiAgICAgIH1cXG4gICAgICByZXNbc2xvdC5rZXldID0gc2xvdC5mbjtcXG4gICAgfVxcbiAgfVxcbiAgaWYgKGNvbnRlbnRIYXNoS2V5KSB7XFxuICAgIChyZXMpLiRrZXkgPSBjb250ZW50SGFzaEtleTtcXG4gIH1cXG4gIHJldHVybiByZXNcXG59XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gYmluZER5bmFtaWNLZXlzIChiYXNlT2JqLCB2YWx1ZXMpIHtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSArPSAyKSB7XFxuICAgIHZhciBrZXkgPSB2YWx1ZXNbaV07XFxuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkpIHtcXG4gICAgICBiYXNlT2JqW3ZhbHVlc1tpXV0gPSB2YWx1ZXNbaSArIDFdO1xcbiAgICB9IGVsc2UgaWYgKCB0cnVlICYmIGtleSAhPT0gJycgJiYga2V5ICE9PSBudWxsKSB7XFxuICAgICAgLy8gbnVsbCBpcyBhIHNwZWljYWwgdmFsdWUgZm9yIGV4cGxpY2l0bHkgcmVtb3ZpbmcgYSBiaW5kaW5nXFxuICAgICAgd2FybihcXG4gICAgICAgIChcXFwiSW52YWxpZCB2YWx1ZSBmb3IgZHluYW1pYyBkaXJlY3RpdmUgYXJndW1lbnQgKGV4cGVjdGVkIHN0cmluZyBvciBudWxsKTogXFxcIiArIGtleSksXFxuICAgICAgICB0aGlzXFxuICAgICAgKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGJhc2VPYmpcXG59XFxuXFxuLy8gaGVscGVyIHRvIGR5bmFtaWNhbGx5IGFwcGVuZCBtb2RpZmllciBydW50aW1lIG1hcmtlcnMgdG8gZXZlbnQgbmFtZXMuXFxuLy8gZW5zdXJlIG9ubHkgYXBwZW5kIHdoZW4gdmFsdWUgaXMgYWxyZWFkeSBzdHJpbmcsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGNhc3RcXG4vLyB0byBzdHJpbmcgYW5kIGNhdXNlIHRoZSB0eXBlIGNoZWNrIHRvIG1pc3MuXFxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyICh2YWx1ZSwgc3ltYm9sKSB7XFxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHN5bWJvbCArIHZhbHVlIDogdmFsdWVcXG59XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xcbiAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XFxuICB0YXJnZXQuX24gPSB0b051bWJlcjtcXG4gIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xcbiAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcXG4gIHRhcmdldC5fdCA9IHJlbmRlclNsb3Q7XFxuICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xcbiAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xcbiAgdGFyZ2V0Ll9tID0gcmVuZGVyU3RhdGljO1xcbiAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcXG4gIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XFxuICB0YXJnZXQuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XFxuICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XFxuICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xcbiAgdGFyZ2V0Ll91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xcbiAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcXG4gIHRhcmdldC5fZCA9IGJpbmREeW5hbWljS2V5cztcXG4gIHRhcmdldC5fcCA9IHByZXBlbmRNb2RpZmllcjtcXG59XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgKFxcbiAgZGF0YSxcXG4gIHByb3BzLFxcbiAgY2hpbGRyZW4sXFxuICBwYXJlbnQsXFxuICBDdG9yXFxuKSB7XFxuICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xcbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xcbiAgdmFyIGNvbnRleHRWbTtcXG4gIGlmIChoYXNPd24ocGFyZW50LCAnX3VpZCcpKSB7XFxuICAgIGNvbnRleHRWbSA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXFxuICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XFxuICB9IGVsc2Uge1xcbiAgICAvLyB0aGUgY29udGV4dCB2bSBwYXNzZWQgaW4gaXMgYSBmdW5jdGlvbmFsIGNvbnRleHQgYXMgd2VsbC5cXG4gICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFyZSBhYmxlIHRvIGdldCBhIGhvbGQgdG8gdGhlXFxuICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cXG4gICAgY29udGV4dFZtID0gcGFyZW50O1xcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcXG4gICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcXG4gIH1cXG4gIHZhciBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcXG4gIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xcblxcbiAgdGhpcy5kYXRhID0gZGF0YTtcXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcXG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcXG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xcbiAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xcbiAgdGhpcy5pbmplY3Rpb25zID0gcmVzb2x2ZUluamVjdChvcHRpb25zLmluamVjdCwgcGFyZW50KTtcXG4gIHRoaXMuc2xvdHMgPSBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICghdGhpcyQxLiRzbG90cykge1xcbiAgICAgIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKFxcbiAgICAgICAgZGF0YS5zY29wZWRTbG90cyxcXG4gICAgICAgIHRoaXMkMS4kc2xvdHMgPSByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudClcXG4gICAgICApO1xcbiAgICB9XFxuICAgIHJldHVybiB0aGlzJDEuJHNsb3RzXFxuICB9O1xcblxcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY29wZWRTbG90cycsICh7XFxuICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcXG4gICAgICByZXR1cm4gbm9ybWFsaXplU2NvcGVkU2xvdHMoZGF0YS5zY29wZWRTbG90cywgdGhpcy5zbG90cygpKVxcbiAgICB9XFxuICB9KSk7XFxuXFxuICAvLyBzdXBwb3J0IGZvciBjb21waWxlZCBmdW5jdGlvbmFsIHRlbXBsYXRlXFxuICBpZiAoaXNDb21waWxlZCkge1xcbiAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcXG4gICAgdGhpcy4kb3B0aW9ucyA9IG9wdGlvbnM7XFxuICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcXG4gICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XFxuICAgIHRoaXMuJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMoZGF0YS5zY29wZWRTbG90cywgdGhpcy4kc2xvdHMpO1xcbiAgfVxcblxcbiAgaWYgKG9wdGlvbnMuX3Njb3BlSWQpIHtcXG4gICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XFxuICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcXG4gICAgICBpZiAodm5vZGUgJiYgIUFycmF5LmlzQXJyYXkodm5vZGUpKSB7XFxuICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdm5vZGVcXG4gICAgfTtcXG4gIH0gZWxzZSB7XFxuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTsgfTtcXG4gIH1cXG59XFxuXFxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcXG5cXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcXG4gIEN0b3IsXFxuICBwcm9wc0RhdGEsXFxuICBkYXRhLFxcbiAgY29udGV4dFZtLFxcbiAgY2hpbGRyZW5cXG4pIHtcXG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xcbiAgdmFyIHByb3BzID0ge307XFxuICB2YXIgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcXG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxcbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cXG4gIH1cXG5cXG4gIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxcbiAgICBkYXRhLFxcbiAgICBwcm9wcyxcXG4gICAgY2hpbGRyZW4sXFxuICAgIGNvbnRleHRWbSxcXG4gICAgQ3RvclxcbiAgKTtcXG5cXG4gIHZhciB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XFxuXFxuICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xcbiAgICByZXR1cm4gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpXFxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XFxuICAgIHZhciB2bm9kZXMgPSBub3JtYWxpemVDaGlsZHJlbih2bm9kZSkgfHwgW107XFxuICAgIHZhciByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgcmVzW2ldID0gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZXNbaV0sIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmVzXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQgKHZub2RlLCBkYXRhLCBjb250ZXh0Vm0sIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpIHtcXG4gIC8vICM3ODE3IGNsb25lIG5vZGUgYmVmb3JlIHNldHRpbmcgZm5Db250ZXh0LCBvdGhlcndpc2UgaWYgdGhlIG5vZGUgaXMgcmV1c2VkXFxuICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcXG4gIC8vIHRoYXQgc2hvdWxkIG5vdCBiZSBtYXRjaGVkIHRvIG1hdGNoLlxcbiAgdmFyIGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XFxuICBjbG9uZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XFxuICBjbG9uZS5mbk9wdGlvbnMgPSBvcHRpb25zO1xcbiAgaWYgKHRydWUpIHtcXG4gICAgKGNsb25lLmRldnRvb2xzTWV0YSA9IGNsb25lLmRldnRvb2xzTWV0YSB8fCB7fSkucmVuZGVyQ29udGV4dCA9IHJlbmRlckNvbnRleHQ7XFxuICB9XFxuICBpZiAoZGF0YS5zbG90KSB7XFxuICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xcbiAgfVxcbiAgcmV0dXJuIGNsb25lXFxufVxcblxcbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XFxuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcXG4gIH1cXG59XFxuXFxuLyogICovXFxuXFxuLyogICovXFxuXFxuLyogICovXFxuXFxuLyogICovXFxuXFxuLy8gaW5saW5lIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKHZub2RlLCBoeWRyYXRpbmcpIHtcXG4gICAgaWYgKFxcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXFxuICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxcbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlXFxuICAgICkge1xcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxcbiAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XFxuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcXG4gICAgICAgIHZub2RlLFxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VcXG4gICAgICApO1xcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XFxuICAgIH1cXG4gIH0sXFxuXFxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XFxuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XFxuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxcbiAgICAgIGNoaWxkLFxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXFxuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXFxuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxcbiAgICApO1xcbiAgfSxcXG5cXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xcbiAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XFxuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcXG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcXG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcXG4gICAgfVxcbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcXG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XFxuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcXG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxcbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LFxcblxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcXG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XFxuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XFxuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufTtcXG5cXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XFxuXFxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcXG4gIEN0b3IsXFxuICBkYXRhLFxcbiAgY29udGV4dCxcXG4gIGNoaWxkcmVuLFxcbiAgdGFnXFxuKSB7XFxuICBpZiAoaXNVbmRlZihDdG9yKSkge1xcbiAgICByZXR1cm5cXG4gIH1cXG5cXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XFxuXFxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xcbiAgfVxcblxcbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxcbiAgLy8gcmVqZWN0LlxcbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XFxuICAgIGlmICh0cnVlKSB7XFxuICAgICAgd2FybigoXFxcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFxcXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xcbiAgICB9XFxuICAgIHJldHVyblxcbiAgfVxcblxcbiAgLy8gYXN5bmMgY29tcG9uZW50XFxuICB2YXIgYXN5bmNGYWN0b3J5O1xcbiAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XFxuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XFxuICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoYXN5bmNGYWN0b3J5LCBiYXNlQ3Rvcik7XFxuICAgIGlmIChDdG9yID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXFxuICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXFxuICAgICAgLy8gdGhlIGluZm9ybWF0aW9uIHdpbGwgYmUgdXNlZCBmb3IgYXN5bmMgc2VydmVyLXJlbmRlcmluZyBhbmQgaHlkcmF0aW9uLlxcbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxcbiAgICAgICAgYXN5bmNGYWN0b3J5LFxcbiAgICAgICAgZGF0YSxcXG4gICAgICAgIGNvbnRleHQsXFxuICAgICAgICBjaGlsZHJlbixcXG4gICAgICAgIHRhZ1xcbiAgICAgIClcXG4gICAgfVxcbiAgfVxcblxcbiAgZGF0YSA9IGRhdGEgfHwge307XFxuXFxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXFxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XFxuXFxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXFxuICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcXG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcXG4gIH1cXG5cXG4gIC8vIGV4dHJhY3QgcHJvcHNcXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XFxuXFxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcXG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcXG4gIH1cXG5cXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXFxuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XFxuICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXFxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcXG5cXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXFxuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XFxuXFxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcXG4gICAgdmFyIHNsb3QgPSBkYXRhLnNsb3Q7XFxuICAgIGRhdGEgPSB7fTtcXG4gICAgaWYgKHNsb3QpIHtcXG4gICAgICBkYXRhLnNsb3QgPSBzbG90O1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcXG4gIGluc3RhbGxDb21wb25lbnRIb29rcyhkYXRhKTtcXG5cXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXFxuICB2YXIgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcXG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcXG4gICAgKFxcXCJ2dWUtY29tcG9uZW50LVxcXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXFxcIi1cXFwiICsgbmFtZSkgOiAnJykpLFxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxcbiAgICB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9LFxcbiAgICBhc3luY0ZhY3RvcnlcXG4gICk7XFxuXFxuICByZXR1cm4gdm5vZGVcXG59XFxuXFxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XFxuICBwYXJlbnQgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXFxuKSB7XFxuICB2YXIgb3B0aW9ucyA9IHtcXG4gICAgX2lzQ29tcG9uZW50OiB0cnVlLFxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxcbiAgICBwYXJlbnQ6IHBhcmVudFxcbiAgfTtcXG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXFxuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XFxuICB9XFxuICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxcbn1cXG5cXG5mdW5jdGlvbiBpbnN0YWxsQ29tcG9uZW50SG9va3MgKGRhdGEpIHtcXG4gIHZhciBob29rcyA9IGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcXG4gICAgdmFyIGV4aXN0aW5nID0gaG9va3Nba2V5XTtcXG4gICAgdmFyIHRvTWVyZ2UgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XFxuICAgIGlmIChleGlzdGluZyAhPT0gdG9NZXJnZSAmJiAhKGV4aXN0aW5nICYmIGV4aXN0aW5nLl9tZXJnZWQpKSB7XFxuICAgICAgaG9va3Nba2V5XSA9IGV4aXN0aW5nID8gbWVyZ2VIb29rJDEodG9NZXJnZSwgZXhpc3RpbmcpIDogdG9NZXJnZTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAoZjEsIGYyKSB7XFxuICB2YXIgbWVyZ2VkID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgLy8gZmxvdyBjb21wbGFpbnMgYWJvdXQgZXh0cmEgYXJncyB3aGljaCBpcyB3aHkgd2UgdXNlIGFueVxcbiAgICBmMShhLCBiKTtcXG4gICAgZjIoYSwgYik7XFxuICB9O1xcbiAgbWVyZ2VkLl9tZXJnZWQgPSB0cnVlO1xcbiAgcmV0dXJuIG1lcmdlZFxcbn1cXG5cXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXFxuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXFxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcXG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0J1xcbiAgOyhkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XFxuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xcbiAgdmFyIGV4aXN0aW5nID0gb25bZXZlbnRdO1xcbiAgdmFyIGNhbGxiYWNrID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcXG4gIGlmIChpc0RlZihleGlzdGluZykpIHtcXG4gICAgaWYgKFxcbiAgICAgIEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpXFxuICAgICAgICA/IGV4aXN0aW5nLmluZGV4T2YoY2FsbGJhY2spID09PSAtMVxcbiAgICAgICAgOiBleGlzdGluZyAhPT0gY2FsbGJhY2tcXG4gICAgKSB7XFxuICAgICAgb25bZXZlbnRdID0gW2NhbGxiYWNrXS5jb25jYXQoZXhpc3RpbmcpO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBvbltldmVudF0gPSBjYWxsYmFjaztcXG4gIH1cXG59XFxuXFxuLyogICovXFxuXFxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcXG5cXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxcbiAgY29udGV4dCxcXG4gIHRhZyxcXG4gIGRhdGEsXFxuICBjaGlsZHJlbixcXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxcbiAgYWx3YXlzTm9ybWFsaXplXFxuKSB7XFxuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xcbiAgICBjaGlsZHJlbiA9IGRhdGE7XFxuICAgIGRhdGEgPSB1bmRlZmluZWQ7XFxuICB9XFxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcXG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xcbiAgfVxcbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxcbn1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXFxuICBjb250ZXh0LFxcbiAgdGFnLFxcbiAgZGF0YSxcXG4gIGNoaWxkcmVuLFxcbiAgbm9ybWFsaXphdGlvblR5cGVcXG4pIHtcXG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoZGF0YSkuX19vYl9fKSkge1xcbiAgICAgdHJ1ZSAmJiB3YXJuKFxcbiAgICAgIFxcXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcXFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFxcXCJcXFxcblxcXCIgK1xcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxcbiAgICAgIGNvbnRleHRcXG4gICAgKTtcXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxcbiAgfVxcbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcXG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xcbiAgICB0YWcgPSBkYXRhLmlzO1xcbiAgfVxcbiAgaWYgKCF0YWcpIHtcXG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXFxuICB9XFxuICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcXG4gIGlmICggdHJ1ZSAmJlxcbiAgICBpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmtleSkgJiYgIWlzUHJpbWl0aXZlKGRhdGEua2V5KVxcbiAgKSB7XFxuICAgIHtcXG4gICAgICB3YXJuKFxcbiAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcXG4gICAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXFxuICAgICAgICBjb250ZXh0XFxuICAgICAgKTtcXG4gICAgfVxcbiAgfVxcbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXFxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xcbiAgKSB7XFxuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xcbiAgfVxcbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XFxuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcXG4gIH1cXG4gIHZhciB2bm9kZSwgbnM7XFxuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcXG4gICAgdmFyIEN0b3I7XFxuICAgIG5zID0gKGNvbnRleHQuJHZub2RlICYmIGNvbnRleHQuJHZub2RlLm5zKSB8fCBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XFxuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XFxuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XFxuICAgICAgKTtcXG4gICAgfSBlbHNlIGlmICgoIWRhdGEgfHwgIWRhdGEucHJlKSAmJiBpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcXG4gICAgICAvLyBjb21wb25lbnRcXG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXFxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcXG4gICAgICApO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcXG4gIH1cXG4gIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xcbiAgICByZXR1cm4gdm5vZGVcXG4gIH0gZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XFxuICAgIGlmIChpc0RlZihucykpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XFxuICAgIGlmIChpc0RlZihkYXRhKSkgeyByZWdpc3RlckRlZXBCaW5kaW5ncyhkYXRhKTsgfVxcbiAgICByZXR1cm4gdm5vZGVcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zLCBmb3JjZSkge1xcbiAgdm5vZGUubnMgPSBucztcXG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcXG4gICAgbnMgPSB1bmRlZmluZWQ7XFxuICAgIGZvcmNlID0gdHJ1ZTtcXG4gIH1cXG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcXG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoXFxuICAgICAgICBpc1VuZGVmKGNoaWxkLm5zKSB8fCAoaXNUcnVlKGZvcmNlKSAmJiBjaGlsZC50YWcgIT09ICdzdmcnKSkpIHtcXG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zLCBmb3JjZSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbi8vIHJlZiAjNTMxOFxcbi8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXFxuLy8gOmNsYXNzIGFyZSB1c2VkIG9uIHNsb3Qgbm9kZXNcXG5mdW5jdGlvbiByZWdpc3RlckRlZXBCaW5kaW5ncyAoZGF0YSkge1xcbiAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XFxuICAgIHRyYXZlcnNlKGRhdGEuc3R5bGUpO1xcbiAgfVxcbiAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XFxuICAgIHRyYXZlcnNlKGRhdGEuY2xhc3MpO1xcbiAgfVxcbn1cXG5cXG4vKiAgKi9cXG5cXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcXG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XFxuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcXG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XFxuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcXG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXFxuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XFxuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxcbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XFxuXFxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxcbiAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxcbiAgdmFyIHBhcmVudERhdGEgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5kYXRhO1xcblxcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cXG4gIGlmICh0cnVlKSB7XFxuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFxcXCIkYXR0cnMgaXMgcmVhZG9ubHkuXFxcIiwgdm0pO1xcbiAgICB9LCB0cnVlKTtcXG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFxcXCIkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LlxcXCIsIHZtKTtcXG4gICAgfSwgdHJ1ZSk7XFxuICB9IGVsc2Uge31cXG59XFxuXFxudmFyIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XFxuXFxuZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xcbiAgLy8gaW5zdGFsbCBydW50aW1lIGNvbnZlbmllbmNlIGhlbHBlcnNcXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xcblxcbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcXG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxcbiAgfTtcXG5cXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHZtID0gdGhpcztcXG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcXG4gICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XFxuXFxuICAgIGlmIChfcGFyZW50Vm5vZGUpIHtcXG4gICAgICB2bS4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhcXG4gICAgICAgIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzLFxcbiAgICAgICAgdm0uJHNsb3RzLFxcbiAgICAgICAgdm0uJHNjb3BlZFNsb3RzXFxuICAgICAgKTtcXG4gICAgfVxcblxcbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXFxuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxcbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XFxuICAgIC8vIHJlbmRlciBzZWxmXFxuICAgIHZhciB2bm9kZTtcXG4gICAgdHJ5IHtcXG4gICAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gbWFpbnRhaW4gYSBzdGFjayBiZWNhdWVzIGFsbCByZW5kZXIgZm5zIGFyZSBjYWxsZWRcXG4gICAgICAvLyBzZXBhcmF0ZWx5IGZyb20gb25lIGFub3RoZXIuIE5lc3RlZCBjb21wb25lbnQncyByZW5kZXIgZm5zIGFyZSBjYWxsZWRcXG4gICAgICAvLyB3aGVuIHBhcmVudCBjb21wb25lbnQgaXMgcGF0Y2hlZC5cXG4gICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSB2bTtcXG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFxcXCJyZW5kZXJcXFwiKTtcXG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXFxuICAgICAgaWYgKCB0cnVlICYmIHZtLiRvcHRpb25zLnJlbmRlckVycm9yKSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSk7XFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcXFwicmVuZGVyRXJyb3JcXFwiKTtcXG4gICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xcbiAgICAgIH1cXG4gICAgfSBmaW5hbGx5IHtcXG4gICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xcbiAgICB9XFxuICAgIC8vIGlmIHRoZSByZXR1cm5lZCBhcnJheSBjb250YWlucyBvbmx5IGEgc2luZ2xlIG5vZGUsIGFsbG93IGl0XFxuICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSAmJiB2bm9kZS5sZW5ndGggPT09IDEpIHtcXG4gICAgICB2bm9kZSA9IHZub2RlWzBdO1xcbiAgICB9XFxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcXG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcXG4gICAgICBpZiAoIHRydWUgJiYgQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcXG4gICAgICAgIHdhcm4oXFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXFxuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxcbiAgICAgICAgICB2bVxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XFxuICAgIH1cXG4gICAgLy8gc2V0IHBhcmVudFxcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XFxuICAgIHJldHVybiB2bm9kZVxcbiAgfTtcXG59XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xcbiAgaWYgKFxcbiAgICBjb21wLl9fZXNNb2R1bGUgfHxcXG4gICAgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxcbiAgKSB7XFxuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XFxuICB9XFxuICByZXR1cm4gaXNPYmplY3QoY29tcClcXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxcbiAgICA6IGNvbXBcXG59XFxuXFxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlciAoXFxuICBmYWN0b3J5LFxcbiAgZGF0YSxcXG4gIGNvbnRleHQsXFxuICBjaGlsZHJlbixcXG4gIHRhZ1xcbikge1xcbiAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XFxuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XFxuICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YTogZGF0YSwgY29udGV4dDogY29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0YWc6IHRhZyB9O1xcbiAgcmV0dXJuIG5vZGVcXG59XFxuXFxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcXG4gIGZhY3RvcnksXFxuICBiYXNlQ3Rvclxcbikge1xcbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcXG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXFxuICB9XFxuXFxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcXG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcXG4gIH1cXG5cXG4gIHZhciBvd25lciA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcXG4gIGlmIChvd25lciAmJiBpc0RlZihmYWN0b3J5Lm93bmVycykgJiYgZmFjdG9yeS5vd25lcnMuaW5kZXhPZihvd25lcikgPT09IC0xKSB7XFxuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xcbiAgICBmYWN0b3J5Lm93bmVycy5wdXNoKG93bmVyKTtcXG4gIH1cXG5cXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxcbiAgfVxcblxcbiAgaWYgKG93bmVyICYmICFpc0RlZihmYWN0b3J5Lm93bmVycykpIHtcXG4gICAgdmFyIG93bmVycyA9IGZhY3Rvcnkub3duZXJzID0gW293bmVyXTtcXG4gICAgdmFyIHN5bmMgPSB0cnVlO1xcbiAgICB2YXIgdGltZXJMb2FkaW5nID0gbnVsbDtcXG4gICAgdmFyIHRpbWVyVGltZW91dCA9IG51bGxcXG5cXG4gICAgOyhvd25lcikuJG9uKCdob29rOmRlc3Ryb3llZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlbW92ZShvd25lcnMsIG93bmVyKTsgfSk7XFxuXFxuICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uIChyZW5kZXJDb21wbGV0ZWQpIHtcXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG93bmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICAgIChvd25lcnNbaV0pLiRmb3JjZVVwZGF0ZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAocmVuZGVyQ29tcGxldGVkKSB7XFxuICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcXG4gICAgICAgIGlmICh0aW1lckxvYWRpbmcgIT09IG51bGwpIHtcXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyTG9hZGluZyk7XFxuICAgICAgICAgIHRpbWVyTG9hZGluZyA9IG51bGw7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodGltZXJUaW1lb3V0ICE9PSBudWxsKSB7XFxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lclRpbWVvdXQpO1xcbiAgICAgICAgICB0aW1lclRpbWVvdXQgPSBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcXG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcXG4gICAgICBpZiAoIXN5bmMpIHtcXG4gICAgICAgIGZvcmNlUmVuZGVyKHRydWUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XFxuICAgICAgIHRydWUgJiYgd2FybihcXG4gICAgICAgIFxcXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFxcXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXFxuICAgICAgICAocmVhc29uID8gKFxcXCJcXFxcblJlYXNvbjogXFxcIiArIHJlYXNvbikgOiAnJylcXG4gICAgICApO1xcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcXG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xcbiAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcXG5cXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcXG4gICAgICBpZiAoaXNQcm9taXNlKHJlcykpIHtcXG4gICAgICAgIC8vICgpID0+IFByb21pc2VcXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XFxuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmIChpc1Byb21pc2UocmVzLmNvbXBvbmVudCkpIHtcXG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xcblxcbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcXG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XFxuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIHRpbWVyTG9hZGluZyA9IG51bGw7XFxuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XFxuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XFxuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKGZhbHNlKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xcbiAgICAgICAgICB0aW1lclRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB0aW1lclRpbWVvdXQgPSBudWxsO1xcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XFxuICAgICAgICAgICAgICByZWplY3QoXFxuICAgICAgICAgICAgICAgICB0cnVlXFxuICAgICAgICAgICAgICAgICAgPyAoXFxcInRpbWVvdXQgKFxcXCIgKyAocmVzLnRpbWVvdXQpICsgXFxcIm1zKVxcXCIpXFxuICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWRcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHN5bmMgPSBmYWxzZTtcXG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXFxuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXFxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXFxuICB9XFxufVxcblxcbi8qICAqL1xcblxcbmZ1bmN0aW9uIGlzQXN5bmNQbGFjZWhvbGRlciAobm9kZSkge1xcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XFxufVxcblxcbi8qICAqL1xcblxcbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XFxuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcXG4gICAgICAgIHJldHVybiBjXFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbi8qICAqL1xcblxcbi8qICAqL1xcblxcbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XFxuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcXG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcXG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XFxuICBpZiAobGlzdGVuZXJzKSB7XFxuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcXG4gIH1cXG59XFxuXFxudmFyIHRhcmdldDtcXG5cXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbikge1xcbiAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xcbn1cXG5cXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XFxuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xcbn1cXG5cXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoZXZlbnQsIGZuKSB7XFxuICB2YXIgX3RhcmdldCA9IHRhcmdldDtcXG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XFxuICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XFxuICAgICAgX3RhcmdldC4kb2ZmKGV2ZW50LCBvbmNlSGFuZGxlcik7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcXG4gIHZtLFxcbiAgbGlzdGVuZXJzLFxcbiAgb2xkTGlzdGVuZXJzXFxuKSB7XFxuICB0YXJnZXQgPSB2bTtcXG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgY3JlYXRlT25jZUhhbmRsZXIsIHZtKTtcXG4gIHRhcmdldCA9IHVuZGVmaW5lZDtcXG59XFxuXFxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xcbiAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XFxuICAgIHZhciB2bSA9IHRoaXM7XFxuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgICB2bS4kb24oZXZlbnRbaV0sIGZuKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XFxuICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XFxuICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHZtXFxuICB9O1xcblxcbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcXG4gICAgdmFyIHZtID0gdGhpcztcXG4gICAgZnVuY3Rpb24gb24gKCkge1xcbiAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcXG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcXG4gICAgfVxcbiAgICBvbi5mbiA9IGZuO1xcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcXG4gICAgcmV0dXJuIHZtXFxuICB9O1xcblxcbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xcbiAgICB2YXIgdm0gPSB0aGlzO1xcbiAgICAvLyBhbGxcXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XFxuICAgICAgcmV0dXJuIHZtXFxuICAgIH1cXG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXFxuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xcbiAgICAgIGZvciAodmFyIGkkMSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkkMSA8IGw7IGkkMSsrKSB7XFxuICAgICAgICB2bS4kb2ZmKGV2ZW50W2kkMV0sIGZuKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHZtXFxuICAgIH1cXG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcXG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xcbiAgICBpZiAoIWNicykge1xcbiAgICAgIHJldHVybiB2bVxcbiAgICB9XFxuICAgIGlmICghZm4pIHtcXG4gICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XFxuICAgICAgcmV0dXJuIHZtXFxuICAgIH1cXG4gICAgLy8gc3BlY2lmaWMgaGFuZGxlclxcbiAgICB2YXIgY2I7XFxuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcXG4gICAgd2hpbGUgKGktLSkge1xcbiAgICAgIGNiID0gY2JzW2ldO1xcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XFxuICAgICAgICBjYnMuc3BsaWNlKGksIDEpO1xcbiAgICAgICAgYnJlYWtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHZtXFxuICB9O1xcblxcbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xcbiAgICB2YXIgdm0gPSB0aGlzO1xcbiAgICBpZiAodHJ1ZSkge1xcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XFxuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xcbiAgICAgICAgdGlwKFxcbiAgICAgICAgICBcXFwiRXZlbnQgXFxcXFxcXCJcXFwiICsgbG93ZXJDYXNlRXZlbnQgKyBcXFwiXFxcXFxcXCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgXFxcIiArXFxuICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcXFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFxcXFxcIlxcXCIgKyBldmVudCArIFxcXCJcXFxcXFxcIi4gXFxcIiArXFxuICAgICAgICAgIFxcXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcXFwiICtcXG4gICAgICAgICAgXFxcInYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBcXFwiICtcXG4gICAgICAgICAgXFxcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXFxcXFwiXFxcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFxcXCJcXFxcXFxcIiBpbnN0ZWFkIG9mIFxcXFxcXFwiXFxcIiArIGV2ZW50ICsgXFxcIlxcXFxcXFwiLlxcXCJcXG4gICAgICAgICk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcXG4gICAgaWYgKGNicykge1xcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xcbiAgICAgIHZhciBpbmZvID0gXFxcImV2ZW50IGhhbmRsZXIgZm9yIFxcXFxcXFwiXFxcIiArIGV2ZW50ICsgXFxcIlxcXFxcXFwiXFxcIjtcXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNic1tpXSwgdm0sIGFyZ3MsIHZtLCBpbmZvKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHZtXFxuICB9O1xcbn1cXG5cXG4vKiAgKi9cXG5cXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcXG5cXG5mdW5jdGlvbiBzZXRBY3RpdmVJbnN0YW5jZSh2bSkge1xcbiAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xcbiAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcXG5cXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XFxuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XFxuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcXG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcXG4gICAgfVxcbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xcbiAgfVxcblxcbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcXG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XFxuXFxuICB2bS4kY2hpbGRyZW4gPSBbXTtcXG4gIHZtLiRyZWZzID0ge307XFxuXFxuICB2bS5fd2F0Y2hlciA9IG51bGw7XFxuICB2bS5faW5hY3RpdmUgPSBudWxsO1xcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XFxuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XFxuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcXG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XFxufVxcblxcbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcXG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XFxuICAgIHZhciB2bSA9IHRoaXM7XFxuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XFxuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XFxuICAgIHZhciByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh2bSk7XFxuICAgIHZtLl92bm9kZSA9IHZub2RlO1xcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXFxuICAgIGlmICghcHJldlZub2RlKSB7XFxuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18odm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyB1cGRhdGVzXFxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xcbiAgICB9XFxuICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcXG4gICAgaWYgKHByZXZFbCkge1xcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcXG4gICAgfVxcbiAgICBpZiAodm0uJGVsKSB7XFxuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcXG4gICAgfVxcbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XFxuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XFxuICAgIH1cXG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxcbiAgfTtcXG5cXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgdm0gPSB0aGlzO1xcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcXG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciB2bSA9IHRoaXM7XFxuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xcbiAgICAgIHJldHVyblxcbiAgICB9XFxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XFxuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XFxuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcXG4gICAgfVxcbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcXG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xcbiAgICB9XFxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcXG4gICAgd2hpbGUgKGktLSkge1xcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xcbiAgICB9XFxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXFxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxcbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XFxuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcXG4gICAgfVxcbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcXG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXFxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXFxuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XFxuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXFxuICAgIHZtLiRvZmYoKTtcXG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXFxuICAgIGlmICh2bS4kZWwpIHtcXG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XFxuICAgIH1cXG4gICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxcbiAgICBpZiAodm0uJHZub2RlKSB7XFxuICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XFxuICAgIH1cXG4gIH07XFxufVxcblxcbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcXG4gIHZtLFxcbiAgZWwsXFxuICBoeWRyYXRpbmdcXG4pIHtcXG4gIHZtLiRlbCA9IGVsO1xcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcXG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcXG4gICAgaWYgKHRydWUpIHtcXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcXG4gICAgICAgIHdhcm4oXFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXFxuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXFxuICAgICAgICAgIHZtXFxuICAgICAgICApO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB3YXJuKFxcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXFxuICAgICAgICAgIHZtXFxuICAgICAgICApO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xcblxcbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgaWYgKCB0cnVlICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XFxuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XFxuICAgICAgdmFyIHN0YXJ0VGFnID0gXFxcInZ1ZS1wZXJmLXN0YXJ0OlxcXCIgKyBpZDtcXG4gICAgICB2YXIgZW5kVGFnID0gXFxcInZ1ZS1wZXJmLWVuZDpcXFwiICsgaWQ7XFxuXFxuICAgICAgbWFyayhzdGFydFRhZyk7XFxuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xcbiAgICAgIG1hcmsoZW5kVGFnKTtcXG4gICAgICBtZWFzdXJlKChcXFwidnVlIFxcXCIgKyBuYW1lICsgXFxcIiByZW5kZXJcXFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XFxuXFxuICAgICAgbWFyayhzdGFydFRhZyk7XFxuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcXG4gICAgICBtYXJrKGVuZFRhZyk7XFxuICAgICAgbWVhc3VyZSgoXFxcInZ1ZSBcXFwiICsgbmFtZSArIFxcXCIgcGF0Y2hcXFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XFxuICAgIH07XFxuICB9IGVsc2Uge1xcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XFxuICAgIH07XFxuICB9XFxuXFxuICAvLyB3ZSBzZXQgdGhpcyB0byB2bS5fd2F0Y2hlciBpbnNpZGUgdGhlIHdhdGNoZXIncyBjb25zdHJ1Y3RvclxcbiAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcXG4gIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcXG4gIG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3AsIHtcXG4gICAgYmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUgKCkge1xcbiAgICAgIGlmICh2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcXG4gICAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XFxuICBoeWRyYXRpbmcgPSBmYWxzZTtcXG5cXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXFxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xcbiAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XFxuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcXG4gIH1cXG4gIHJldHVybiB2bVxcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXFxuICB2bSxcXG4gIHByb3BzRGF0YSxcXG4gIGxpc3RlbmVycyxcXG4gIHBhcmVudFZub2RlLFxcbiAgcmVuZGVyQ2hpbGRyZW5cXG4pIHtcXG4gIGlmICh0cnVlKSB7XFxuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IHRydWU7XFxuICB9XFxuXFxuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLlxcblxcbiAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGR5bmFtaWMgc2NvcGVkU2xvdHMgKGhhbmQtd3JpdHRlbiBvciBjb21waWxlZCBidXQgd2l0aFxcbiAgLy8gZHluYW1pYyBzbG90IG5hbWVzKS4gU3RhdGljIHNjb3BlZCBzbG90cyBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGhhcyB0aGVcXG4gIC8vIFxcXCIkc3RhYmxlXFxcIiBtYXJrZXIuXFxuICB2YXIgbmV3U2NvcGVkU2xvdHMgPSBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzO1xcbiAgdmFyIG9sZFNjb3BlZFNsb3RzID0gdm0uJHNjb3BlZFNsb3RzO1xcbiAgdmFyIGhhc0R5bmFtaWNTY29wZWRTbG90ID0gISEoXFxuICAgIChuZXdTY29wZWRTbG90cyAmJiAhbmV3U2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcXG4gICAgKG9sZFNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAmJiAhb2xkU2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcXG4gICAgKG5ld1Njb3BlZFNsb3RzICYmIHZtLiRzY29wZWRTbG90cy4ka2V5ICE9PSBuZXdTY29wZWRTbG90cy4ka2V5KVxcbiAgKTtcXG5cXG4gIC8vIEFueSBzdGF0aWMgc2xvdCBjaGlsZHJlbiBmcm9tIHRoZSBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBkdXJpbmcgcGFyZW50J3NcXG4gIC8vIHVwZGF0ZS4gRHluYW1pYyBzY29wZWQgc2xvdHMgbWF5IGFsc28gaGF2ZSBjaGFuZ2VkLiBJbiBzdWNoIGNhc2VzLCBhIGZvcmNlZFxcbiAgLy8gdXBkYXRlIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgY29ycmVjdG5lc3MuXFxuICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9ICEhKFxcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXFxuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcXG4gICAgaGFzRHluYW1pY1Njb3BlZFNsb3RcXG4gICk7XFxuXFxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcXG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXFxuXFxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcXG4gIH1cXG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xcblxcbiAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXFxuICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcXG4gIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXFxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xcbiAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcXG5cXG4gIC8vIHVwZGF0ZSBwcm9wc1xcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XFxuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcXG4gICAgICB2YXIgcHJvcE9wdGlvbnMgPSB2bS4kb3B0aW9ucy5wcm9wczsgLy8gd3RmIGZsb3c/XFxuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcXG4gICAgfVxcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XFxuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xcbiAgfVxcblxcbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xcbiAgbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xcbiAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XFxuICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xcbiAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XFxuXFxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxcbiAgaWYgKG5lZWRzRm9yY2VVcGRhdGUpIHtcXG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcXG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XFxuICB9XFxuXFxuICBpZiAodHJ1ZSkge1xcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcXG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cXG4gIH1cXG4gIHJldHVybiBmYWxzZVxcbn1cXG5cXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XFxuICBpZiAoZGlyZWN0KSB7XFxuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcXG4gICAgICByZXR1cm5cXG4gICAgfVxcbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcXG4gICAgcmV0dXJuXFxuICB9XFxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcXG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XFxuICAgIH1cXG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XFxuICBpZiAoZGlyZWN0KSB7XFxuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XFxuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xcbiAgICAgIHJldHVyblxcbiAgICB9XFxuICB9XFxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xcbiAgICB9XFxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XFxuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgbGlmZWN5Y2xlIGhvb2tzXFxuICBwdXNoVGFyZ2V0KCk7XFxuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcXG4gIHZhciBpbmZvID0gaG9vayArIFxcXCIgaG9va1xcXCI7XFxuICBpZiAoaGFuZGxlcnMpIHtcXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhoYW5kbGVyc1tpXSwgdm0sIG51bGwsIHZtLCBpbmZvKTtcXG4gICAgfVxcbiAgfVxcbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcXG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xcbiAgfVxcbiAgcG9wVGFyZ2V0KCk7XFxufVxcblxcbi8qICAqL1xcblxcbnZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xcblxcbnZhciBxdWV1ZSA9IFtdO1xcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xcbnZhciBoYXMgPSB7fTtcXG52YXIgY2lyY3VsYXIgPSB7fTtcXG52YXIgd2FpdGluZyA9IGZhbHNlO1xcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xcbnZhciBpbmRleCA9IDA7XFxuXFxuLyoqXFxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxcbiAqL1xcbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xcbiAgaGFzID0ge307XFxuICBpZiAodHJ1ZSkge1xcbiAgICBjaXJjdWxhciA9IHt9O1xcbiAgfVxcbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XFxufVxcblxcbi8vIEFzeW5jIGVkZ2UgY2FzZSAjNjU2NiByZXF1aXJlcyBzYXZpbmcgdGhlIHRpbWVzdGFtcCB3aGVuIGV2ZW50IGxpc3RlbmVycyBhcmVcXG4vLyBhdHRhY2hlZC4gSG93ZXZlciwgY2FsbGluZyBwZXJmb3JtYW5jZS5ub3coKSBoYXMgYSBwZXJmIG92ZXJoZWFkIGVzcGVjaWFsbHlcXG4vLyBpZiB0aGUgcGFnZSBoYXMgdGhvdXNhbmRzIG9mIGV2ZW50IGxpc3RlbmVycy4gSW5zdGVhZCwgd2UgdGFrZSBhIHRpbWVzdGFtcFxcbi8vIGV2ZXJ5IHRpbWUgdGhlIHNjaGVkdWxlciBmbHVzaGVzIGFuZCB1c2UgdGhhdCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVyc1xcbi8vIGF0dGFjaGVkIGR1cmluZyB0aGF0IGZsdXNoLlxcbnZhciBjdXJyZW50Rmx1c2hUaW1lc3RhbXAgPSAwO1xcblxcbi8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXFxudmFyIGdldE5vdyA9IERhdGUubm93O1xcblxcbi8vIERldGVybWluZSB3aGF0IGV2ZW50IHRpbWVzdGFtcCB0aGUgYnJvd3NlciBpcyB1c2luZy4gQW5ub3lpbmdseSwgdGhlXFxuLy8gdGltZXN0YW1wIGNhbiBlaXRoZXIgYmUgaGktcmVzIChyZWxhdGl2ZSB0byBwYWdlIGxvYWQpIG9yIGxvdy1yZXNcXG4vLyAocmVsYXRpdmUgdG8gVU5JWCBlcG9jaCksIHNvIGluIG9yZGVyIHRvIGNvbXBhcmUgdGltZSB3ZSBoYXZlIHRvIHVzZSB0aGVcXG4vLyBzYW1lIHRpbWVzdGFtcCB0eXBlIHdoZW4gc2F2aW5nIHRoZSBmbHVzaCB0aW1lc3RhbXAuXFxuLy8gQWxsIElFIHZlcnNpb25zIHVzZSBsb3ctcmVzIGV2ZW50IHRpbWVzdGFtcHMsIGFuZCBoYXZlIHByb2JsZW1hdGljIGNsb2NrXFxuLy8gaW1wbGVtZW50YXRpb25zICgjOTYzMilcXG5pZiAoaW5Ccm93c2VyICYmICFpc0lFKSB7XFxuICB2YXIgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2U7XFxuICBpZiAoXFxuICAgIHBlcmZvcm1hbmNlICYmXFxuICAgIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbicgJiZcXG4gICAgZ2V0Tm93KCkgPiBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKS50aW1lU3RhbXBcXG4gICkge1xcbiAgICAvLyBpZiB0aGUgZXZlbnQgdGltZXN0YW1wLCBhbHRob3VnaCBldmFsdWF0ZWQgQUZURVIgdGhlIERhdGUubm93KCksIGlzXFxuICAgIC8vIHNtYWxsZXIgdGhhbiBpdCwgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXIgdGltZXN0YW1wcyBhc1xcbiAgICAvLyB3ZWxsLlxcbiAgICBnZXROb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfTtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXFxuICovXFxuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XFxuICBjdXJyZW50Rmx1c2hUaW1lc3RhbXAgPSBnZXROb3coKTtcXG4gIGZsdXNoaW5nID0gdHJ1ZTtcXG4gIHZhciB3YXRjaGVyLCBpZDtcXG5cXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxcbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XFxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXFxuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXFxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXFxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXFxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxcbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xcblxcbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xcbiAgICBpZiAod2F0Y2hlci5iZWZvcmUpIHtcXG4gICAgICB3YXRjaGVyLmJlZm9yZSgpO1xcbiAgICB9XFxuICAgIGlkID0gd2F0Y2hlci5pZDtcXG4gICAgaGFzW2lkXSA9IG51bGw7XFxuICAgIHdhdGNoZXIucnVuKCk7XFxuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cXG4gICAgaWYgKCB0cnVlICYmIGhhc1tpZF0gIT0gbnVsbCkge1xcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XFxuICAgICAgICB3YXJuKFxcbiAgICAgICAgICAnWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgKyAoXFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXFxuICAgICAgICAgICAgICA/IChcXFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcXFxcXCJcXFwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcXFwiXFxcXFxcXCJcXFwiKVxcbiAgICAgICAgICAgICAgOiBcXFwiaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLlxcXCJcXG4gICAgICAgICAgKSxcXG4gICAgICAgICAgd2F0Y2hlci52bVxcbiAgICAgICAgKTtcXG4gICAgICAgIGJyZWFrXFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXFxuICB2YXIgYWN0aXZhdGVkUXVldWUgPSBhY3RpdmF0ZWRDaGlsZHJlbi5zbGljZSgpO1xcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XFxuXFxuICByZXNldFNjaGVkdWxlclN0YXRlKCk7XFxuXFxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcXG4gIGNhbGxBY3RpdmF0ZWRIb29rcyhhY3RpdmF0ZWRRdWV1ZSk7XFxuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XFxuXFxuICAvLyBkZXZ0b29sIGhvb2tcXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xcbiAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XFxuICB3aGlsZSAoaS0tKSB7XFxuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XFxuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XFxuICAgIGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcXG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXFxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxcbiAqL1xcbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxcbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcXG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XFxufVxcblxcbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcXG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcXG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cXG4gKi9cXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcXG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XFxuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XFxuICAgIGhhc1tpZF0gPSB0cnVlO1xcbiAgICBpZiAoIWZsdXNoaW5nKSB7XFxuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XFxuICAgICAgd2hpbGUgKGkgPiBpbmRleCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcXG4gICAgICAgIGktLTtcXG4gICAgICB9XFxuICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcXG4gICAgfVxcbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcXG4gICAgaWYgKCF3YWl0aW5nKSB7XFxuICAgICAgd2FpdGluZyA9IHRydWU7XFxuXFxuICAgICAgaWYgKCB0cnVlICYmICFjb25maWcuYXN5bmMpIHtcXG4gICAgICAgIGZsdXNoU2NoZWR1bGVyUXVldWUoKTtcXG4gICAgICAgIHJldHVyblxcbiAgICAgIH1cXG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vKiAgKi9cXG5cXG5cXG5cXG52YXIgdWlkJDIgPSAwO1xcblxcbi8qKlxcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXFxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXFxuICovXFxudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcXG4gIHZtLFxcbiAgZXhwT3JGbixcXG4gIGNiLFxcbiAgb3B0aW9ucyxcXG4gIGlzUmVuZGVyV2F0Y2hlclxcbikge1xcbiAgdGhpcy52bSA9IHZtO1xcbiAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xcbiAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XFxuICB9XFxuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcXG4gIC8vIG9wdGlvbnNcXG4gIGlmIChvcHRpb25zKSB7XFxuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcXG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XFxuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xcbiAgICB0aGlzLmJlZm9yZSA9IG9wdGlvbnMuYmVmb3JlO1xcbiAgfSBlbHNlIHtcXG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XFxuICB9XFxuICB0aGlzLmNiID0gY2I7XFxuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcXG4gIHRoaXMuZGVwcyA9IFtdO1xcbiAgdGhpcy5uZXdEZXBzID0gW107XFxuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XFxuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XFxuICB0aGlzLmV4cHJlc3Npb24gPSAgdHJ1ZVxcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxcbiAgICA6IHVuZGVmaW5lZDtcXG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcXG4gIH0gZWxzZSB7XFxuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XFxuICAgICAgdGhpcy5nZXR0ZXIgPSBub29wO1xcbiAgICAgICB0cnVlICYmIHdhcm4oXFxuICAgICAgICBcXFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXFxcXFwiXFxcIiArIGV4cE9yRm4gKyBcXFwiXFxcXFxcXCIgXFxcIiArXFxuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcXG4gICAgICAgIHZtXFxuICAgICAgKTtcXG4gICAgfVxcbiAgfVxcbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxcbiAgICA/IHVuZGVmaW5lZFxcbiAgICA6IHRoaXMuZ2V0KCk7XFxufTtcXG5cXG4vKipcXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXFxuICovXFxuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcXG4gIHB1c2hUYXJnZXQodGhpcyk7XFxuICB2YXIgdmFsdWU7XFxuICB2YXIgdm0gPSB0aGlzLnZtO1xcbiAgdHJ5IHtcXG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XFxuICB9IGNhdGNoIChlKSB7XFxuICAgIGlmICh0aGlzLnVzZXIpIHtcXG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFxcXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcXFxcXCJcXFwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcXFwiXFxcXFxcXCJcXFwiKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhyb3cgZVxcbiAgICB9XFxuICB9IGZpbmFsbHkge1xcbiAgICAvLyBcXFwidG91Y2hcXFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXFxuICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xcbiAgICBpZiAodGhpcy5kZWVwKSB7XFxuICAgICAgdHJhdmVyc2UodmFsdWUpO1xcbiAgICB9XFxuICAgIHBvcFRhcmdldCgpO1xcbiAgICB0aGlzLmNsZWFudXBEZXBzKCk7XFxuICB9XFxuICByZXR1cm4gdmFsdWVcXG59O1xcblxcbi8qKlxcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXFxuICovXFxuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcXG4gIHZhciBpZCA9IGRlcC5pZDtcXG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcXG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xcbiAgICB9XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxcbiAqL1xcbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xcbiAgd2hpbGUgKGktLSkge1xcbiAgICB2YXIgZGVwID0gdGhpcy5kZXBzW2ldO1xcbiAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XFxuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzKTtcXG4gICAgfVxcbiAgfVxcbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcXG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcXG4gIHRtcCA9IHRoaXMuZGVwcztcXG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcXG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcXG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xcbn07XFxuXFxuLyoqXFxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXFxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cXG4gKi9cXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cXG4gIGlmICh0aGlzLmxhenkpIHtcXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XFxuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xcbiAgICB0aGlzLnJ1bigpO1xcbiAgfSBlbHNlIHtcXG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXFxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cXG4gKi9cXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XFxuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XFxuICAgIGlmIChcXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxcbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcXG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXFxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XFxuICAgICAgdGhpcy5kZWVwXFxuICAgICkge1xcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcXG4gICAgICBpZiAodGhpcy51c2VyKSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFxcXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFxcXFxcIlxcXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFxcXCJcXFxcXFxcIlxcXCIpKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXFxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxcbiAqL1xcbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XFxuICB0aGlzLmRpcnR5ID0gZmFsc2U7XFxufTtcXG5cXG4vKipcXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cXG4gKi9cXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xcbiAgd2hpbGUgKGktLSkge1xcbiAgICB0aGlzLmRlcHNbaV0uZGVwZW5kKCk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cXG4gKi9cXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcXG4gIGlmICh0aGlzLmFjdGl2ZSkge1xcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcXG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XFxuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcXG4gICAgfVxcbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XFxuICAgIHdoaWxlIChpLS0pIHtcXG4gICAgICB0aGlzLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMpO1xcbiAgICB9XFxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XFxuICB9XFxufTtcXG5cXG4vKiAgKi9cXG5cXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xcbiAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gIGdldDogbm9vcCxcXG4gIHNldDogbm9vcFxcbn07XFxuXFxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcXG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XFxuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxcbiAgfTtcXG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XFxuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xcbiAgfTtcXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcXG59XFxuXFxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xcbiAgdm0uX3dhdGNoZXJzID0gW107XFxuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xcbiAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxcbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxcbiAgaWYgKG9wdHMuZGF0YSkge1xcbiAgICBpbml0RGF0YSh2bSk7XFxuICB9IGVsc2Uge1xcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XFxuICB9XFxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XFxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xcbiAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcXG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XFxuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcXG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XFxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XFxuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XFxuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcXG4gIGlmICghaXNSb290KSB7XFxuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XFxuICB9XFxuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xcbiAgICBrZXlzLnB1c2goa2V5KTtcXG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cXG4gICAgaWYgKHRydWUpIHtcXG4gICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XFxuICAgICAgICAgIGNvbmZpZy5pc1Jlc2VydmVkQXR0cihoeXBoZW5hdGVkS2V5KSkge1xcbiAgICAgICAgd2FybihcXG4gICAgICAgICAgKFxcXCJcXFxcXFxcIlxcXCIgKyBoeXBoZW5hdGVkS2V5ICsgXFxcIlxcXFxcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cXFwiKSxcXG4gICAgICAgICAgdm1cXG4gICAgICAgICk7XFxuICAgICAgfVxcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAoIWlzUm9vdCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XFxuICAgICAgICAgIHdhcm4oXFxuICAgICAgICAgICAgXFxcIkF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBcXFwiICtcXG4gICAgICAgICAgICBcXFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXFxcIiArXFxuICAgICAgICAgICAgXFxcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcXFwiICtcXG4gICAgICAgICAgICBcXFwidmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXFxcXFxcXCJcXFwiICsga2V5ICsgXFxcIlxcXFxcXFwiXFxcIixcXG4gICAgICAgICAgICB2bVxcbiAgICAgICAgICApO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9IGVsc2Uge31cXG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxcbiAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXFxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcXG4gICAgICBwcm94eSh2bSwgXFxcIl9wcm9wc1xcXCIsIGtleSk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcXG4gIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcXG59XFxuXFxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XFxuICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XFxuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXFxuICAgIDogZGF0YSB8fCB7fTtcXG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xcbiAgICBkYXRhID0ge307XFxuICAgICB0cnVlICYmIHdhcm4oXFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcXFxuJyArXFxuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXFxuICAgICAgdm1cXG4gICAgKTtcXG4gIH1cXG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XFxuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcXG4gIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcXG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XFxuICB3aGlsZSAoaS0tKSB7XFxuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xcbiAgICBpZiAodHJ1ZSkge1xcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XFxuICAgICAgICB3YXJuKFxcbiAgICAgICAgICAoXFxcIk1ldGhvZCBcXFxcXFxcIlxcXCIgKyBrZXkgKyBcXFwiXFxcXFxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgZGF0YSBwcm9wZXJ0eS5cXFwiKSxcXG4gICAgICAgICAgdm1cXG4gICAgICAgICk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcXG4gICAgICAgdHJ1ZSAmJiB3YXJuKFxcbiAgICAgICAgXFxcIlRoZSBkYXRhIHByb3BlcnR5IFxcXFxcXFwiXFxcIiArIGtleSArIFxcXCJcXFxcXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXFxcIiArXFxuICAgICAgICBcXFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlxcXCIsXFxuICAgICAgICB2bVxcbiAgICAgICk7XFxuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xcbiAgICAgIHByb3h5KHZtLCBcXFwiX2RhdGFcXFwiLCBrZXkpO1xcbiAgICB9XFxuICB9XFxuICAvLyBvYnNlcnZlIGRhdGFcXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcXG59XFxuXFxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcXG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcXG4gIHB1c2hUYXJnZXQoKTtcXG4gIHRyeSB7XFxuICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKVxcbiAgfSBjYXRjaCAoZSkge1xcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXFxcImRhdGEoKVxcXCIpO1xcbiAgICByZXR1cm4ge31cXG4gIH0gZmluYWxseSB7XFxuICAgIHBvcFRhcmdldCgpO1xcbiAgfVxcbn1cXG5cXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xcblxcbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XFxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcXG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcXG4gIC8vIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGp1c3QgZ2V0dGVycyBkdXJpbmcgU1NSXFxuICB2YXIgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xcblxcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XFxuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcXG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xcbiAgICBpZiAoIHRydWUgJiYgZ2V0dGVyID09IG51bGwpIHtcXG4gICAgICB3YXJuKFxcbiAgICAgICAgKFxcXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcXFxcXCJcXFwiICsga2V5ICsgXFxcIlxcXFxcXFwiLlxcXCIpLFxcbiAgICAgICAgdm1cXG4gICAgICApO1xcbiAgICB9XFxuXFxuICAgIGlmICghaXNTU1IpIHtcXG4gICAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxcbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcXG4gICAgICAgIHZtLFxcbiAgICAgICAgZ2V0dGVyIHx8IG5vb3AsXFxuICAgICAgICBub29wLFxcbiAgICAgICAgY29tcHV0ZWRXYXRjaGVyT3B0aW9uc1xcbiAgICAgICk7XFxuICAgIH1cXG5cXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXFxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcXG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcXG4gICAgfSBlbHNlIGlmICh0cnVlKSB7XFxuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xcbiAgICAgICAgd2FybigoXFxcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFxcXFxcIlxcXCIgKyBrZXkgKyBcXFwiXFxcXFxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXFxcIiksIHZtKTtcXG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xcbiAgICAgICAgd2FybigoXFxcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFxcXFxcIlxcXCIgKyBrZXkgKyBcXFwiXFxcXFxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cXFwiKSwgdm0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAoXFxuICB0YXJnZXQsXFxuICBrZXksXFxuICB1c2VyRGVmXFxuKSB7XFxuICB2YXIgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcXG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcXG4gICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcXG4gICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZik7XFxuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xcbiAgfSBlbHNlIHtcXG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XFxuICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXFxuICAgICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZi5nZXQpXFxuICAgICAgOiBub29wO1xcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXQgfHwgbm9vcDtcXG4gIH1cXG4gIGlmICggdHJ1ZSAmJlxcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcXG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICB3YXJuKFxcbiAgICAgICAgKFxcXCJDb21wdXRlZCBwcm9wZXJ0eSBcXFxcXFxcIlxcXCIgKyBrZXkgKyBcXFwiXFxcXFxcXCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLlxcXCIpLFxcbiAgICAgICAgdGhpc1xcbiAgICAgICk7XFxuICAgIH07XFxuICB9XFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcXG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XFxuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XFxuICAgIGlmICh3YXRjaGVyKSB7XFxuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcXG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcXG4gICAgICB9XFxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcXG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gY3JlYXRlR2V0dGVySW52b2tlcihmbikge1xcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcXG4gICAgcmV0dXJuIGZuLmNhbGwodGhpcywgdGhpcylcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XFxuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcXG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XFxuICAgIGlmICh0cnVlKSB7XFxuICAgICAgaWYgKHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIHdhcm4oXFxuICAgICAgICAgIFxcXCJNZXRob2QgXFxcXFxcXCJcXFwiICsga2V5ICsgXFxcIlxcXFxcXFwiIGhhcyB0eXBlIFxcXFxcXFwiXFxcIiArICh0eXBlb2YgbWV0aG9kc1trZXldKSArIFxcXCJcXFxcXFxcIiBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFxcXCIgK1xcbiAgICAgICAgICBcXFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cXFwiLFxcbiAgICAgICAgICB2bVxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xcbiAgICAgICAgd2FybihcXG4gICAgICAgICAgKFxcXCJNZXRob2QgXFxcXFxcXCJcXFwiICsga2V5ICsgXFxcIlxcXFxcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXFxcIiksXFxuICAgICAgICAgIHZtXFxuICAgICAgICApO1xcbiAgICAgIH1cXG4gICAgICBpZiAoKGtleSBpbiB2bSkgJiYgaXNSZXNlcnZlZChrZXkpKSB7XFxuICAgICAgICB3YXJuKFxcbiAgICAgICAgICBcXFwiTWV0aG9kIFxcXFxcXFwiXFxcIiArIGtleSArIFxcXCJcXFxcXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcXFwiICtcXG4gICAgICAgICAgXFxcIkF2b2lkIGRlZmluaW5nIGNvbXBvbmVudCBtZXRob2RzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQuXFxcIlxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgdm1ba2V5XSA9IHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcXG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xcbiAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XFxuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxcbiAgdm0sXFxuICBleHBPckZuLFxcbiAgaGFuZGxlcixcXG4gIG9wdGlvbnNcXG4pIHtcXG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XFxuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XFxuICB9XFxuICByZXR1cm4gdm0uJHdhdGNoKGV4cE9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXFxufVxcblxcbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cXG4gIHZhciBkYXRhRGVmID0ge307XFxuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcXG4gIHZhciBwcm9wc0RlZiA9IHt9O1xcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcXG4gIGlmICh0cnVlKSB7XFxuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHdhcm4oXFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcXG4gICAgICAgIHRoaXNcXG4gICAgICApO1xcbiAgICB9O1xcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgd2FybihcXFwiJHByb3BzIGlzIHJlYWRvbmx5LlxcXCIsIHRoaXMpO1xcbiAgICB9O1xcbiAgfVxcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XFxuXFxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XFxuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XFxuXFxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcXG4gICAgZXhwT3JGbixcXG4gICAgY2IsXFxuICAgIG9wdGlvbnNcXG4gICkge1xcbiAgICB2YXIgdm0gPSB0aGlzO1xcbiAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcXG4gICAgICByZXR1cm4gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpXFxuICAgIH1cXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XFxuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcXG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgICAgICBoYW5kbGVFcnJvcihlcnJvciwgdm0sIChcXFwiY2FsbGJhY2sgZm9yIGltbWVkaWF0ZSB3YXRjaGVyIFxcXFxcXFwiXFxcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXFxcIlxcXFxcXFwiXFxcIikpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcXG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XFxuICAgIH1cXG4gIH07XFxufVxcblxcbi8qICAqL1xcblxcbnZhciB1aWQkMyA9IDA7XFxuXFxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xcbiAgICB2YXIgdm0gPSB0aGlzO1xcbiAgICAvLyBhIHVpZFxcbiAgICB2bS5fdWlkID0gdWlkJDMrKztcXG5cXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgICBpZiAoIHRydWUgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcXG4gICAgICBzdGFydFRhZyA9IFxcXCJ2dWUtcGVyZi1zdGFydDpcXFwiICsgKHZtLl91aWQpO1xcbiAgICAgIGVuZFRhZyA9IFxcXCJ2dWUtcGVyZi1lbmQ6XFxcIiArICh2bS5fdWlkKTtcXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcXG4gICAgfVxcblxcbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xcbiAgICAvLyBtZXJnZSBvcHRpb25zXFxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XFxuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXFxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXFxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcXG4gICAgICAgIHZtXFxuICAgICAgKTtcXG4gICAgfVxcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xcbiAgICBpZiAodHJ1ZSkge1xcbiAgICAgIGluaXRQcm94eSh2bSk7XFxuICAgIH0gZWxzZSB7fVxcbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXFxuICAgIHZtLl9zZWxmID0gdm07XFxuICAgIGluaXRMaWZlY3ljbGUodm0pO1xcbiAgICBpbml0RXZlbnRzKHZtKTtcXG4gICAgaW5pdFJlbmRlcih2bSk7XFxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XFxuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXFxuICAgIGluaXRTdGF0ZSh2bSk7XFxuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XFxuXFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgICBpZiAoIHRydWUgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcXG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcXG4gICAgICBtYXJrKGVuZFRhZyk7XFxuICAgICAgbWVhc3VyZSgoXFxcInZ1ZSBcXFwiICsgKHZtLl9uYW1lKSArIFxcXCIgaW5pdFxcXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcXG4gICAgfVxcblxcbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcXG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xcbiAgICB9XFxuICB9O1xcbn1cXG5cXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XFxuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcXG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXFxuICB2YXIgcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcXG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XFxuICBvcHRzLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xcblxcbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHBhcmVudFZub2RlLmNvbXBvbmVudE9wdGlvbnM7XFxuICBvcHRzLnByb3BzRGF0YSA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGE7XFxuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XFxuICBvcHRzLl9jb21wb25lbnRUYWcgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnO1xcblxcbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XFxuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XFxuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcXG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcXG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XFxuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcXG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XFxuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxcbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcXG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcXG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XFxuICAgICAgfVxcbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcXG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBvcHRpb25zXFxufVxcblxcbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcXG4gIHZhciBtb2RpZmllZDtcXG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XFxuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XFxuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XFxuICAgICAgbW9kaWZpZWRba2V5XSA9IGxhdGVzdFtrZXldO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbW9kaWZpZWRcXG59XFxuXFxuZnVuY3Rpb24gVnVlIChvcHRpb25zKSB7XFxuICBpZiAoIHRydWUgJiZcXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlKVxcbiAgKSB7XFxuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcXG4gIH1cXG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XFxufVxcblxcbmluaXRNaXhpbihWdWUpO1xcbnN0YXRlTWl4aW4oVnVlKTtcXG5ldmVudHNNaXhpbihWdWUpO1xcbmxpZmVjeWNsZU1peGluKFZ1ZSk7XFxucmVuZGVyTWl4aW4oVnVlKTtcXG5cXG4vKiAgKi9cXG5cXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcXG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XFxuICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xcbiAgICAgIHJldHVybiB0aGlzXFxuICAgIH1cXG5cXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXFxuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XFxuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XFxuICAgIH1cXG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XFxuICAgIHJldHVybiB0aGlzXFxuICB9O1xcbn1cXG5cXG4vKiAgKi9cXG5cXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XFxuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcXG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xcbiAgICByZXR1cm4gdGhpc1xcbiAgfTtcXG59XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XFxuICAvKipcXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXFxcImNoaWxkXFxuICAgKiBjb25zdHJ1Y3RvcnNcXFwiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxcbiAgICovXFxuICBWdWUuY2lkID0gMDtcXG4gIHZhciBjaWQgPSAxO1xcblxcbiAgLyoqXFxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxcbiAgICovXFxuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcXG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XFxuICAgIHZhciBTdXBlciA9IHRoaXM7XFxuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcXG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cXG4gICAgfVxcblxcbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XFxuICAgIGlmICggdHJ1ZSAmJiBuYW1lKSB7XFxuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUpO1xcbiAgICB9XFxuXFxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xcbiAgICB9O1xcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xcbiAgICBTdWIuY2lkID0gY2lkKys7XFxuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxcbiAgICAgIFN1cGVyLm9wdGlvbnMsXFxuICAgICAgZXh0ZW5kT3B0aW9uc1xcbiAgICApO1xcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcXG5cXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxcbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcXG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xcbiAgICB9XFxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XFxuICAgIH1cXG5cXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXFxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XFxuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xcblxcbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXFxuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xcbiAgICB9KTtcXG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxcbiAgICBpZiAobmFtZSkge1xcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XFxuICAgIH1cXG5cXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxcbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcXG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xcblxcbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcXG4gICAgcmV0dXJuIFN1YlxcbiAgfTtcXG59XFxuXFxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcXG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcXG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXFxcIl9wcm9wc1xcXCIsIGtleSk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XFxuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XFxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcXG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XFxuICB9XFxufVxcblxcbi8qICAqL1xcblxcbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XFxuICAvKipcXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cXG4gICAqL1xcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXFxuICAgICAgaWQsXFxuICAgICAgZGVmaW5pdGlvblxcbiAgICApIHtcXG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgICAgICAgaWYgKCB0cnVlICYmIHR5cGUgPT09ICdjb21wb25lbnQnKSB7XFxuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XFxuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XFxuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxcbiAgICAgIH1cXG4gICAgfTtcXG4gIH0pO1xcbn1cXG5cXG4vKiAgKi9cXG5cXG5cXG5cXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XFxuICByZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcXG59XFxuXFxuZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcXG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXFxuICB9IGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXFxuICB9XFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xcbiAgcmV0dXJuIGZhbHNlXFxufVxcblxcbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcXG4gIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlO1xcbiAgdmFyIGtleXMgPSBrZWVwQWxpdmVJbnN0YW5jZS5rZXlzO1xcbiAgdmFyIF92bm9kZSA9IGtlZXBBbGl2ZUluc3RhbmNlLl92bm9kZTtcXG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XFxuICAgIGlmIChjYWNoZWROb2RlKSB7XFxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XFxuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xcbiAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXksIGtleXMsIF92bm9kZSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAoXFxuICBjYWNoZSxcXG4gIGtleSxcXG4gIGtleXMsXFxuICBjdXJyZW50XFxuKSB7XFxuICB2YXIgY2FjaGVkJCQxID0gY2FjaGVba2V5XTtcXG4gIGlmIChjYWNoZWQkJDEgJiYgKCFjdXJyZW50IHx8IGNhY2hlZCQkMS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xcbiAgICBjYWNoZWQkJDEuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcXG4gIH1cXG4gIGNhY2hlW2tleV0gPSBudWxsO1xcbiAgcmVtb3ZlKGtleXMsIGtleSk7XFxufVxcblxcbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XTtcXG5cXG52YXIgS2VlcEFsaXZlID0ge1xcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxcbiAgYWJzdHJhY3Q6IHRydWUsXFxuXFxuICBwcm9wczoge1xcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlcyxcXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXFxuICB9LFxcblxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XFxuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcbiAgICB0aGlzLmtleXMgPSBbXTtcXG4gIH0sXFxuXFxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XFxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNhY2hlKSB7XFxuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMuY2FjaGUsIGtleSwgdGhpcy5rZXlzKTtcXG4gICAgfVxcbiAgfSxcXG5cXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XFxuICAgICAgcHJ1bmVDYWNoZSh0aGlzJDEsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xcbiAgICB9KTtcXG4gICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XFxuICAgICAgcHJ1bmVDYWNoZSh0aGlzJDEsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcXG4gICAgfSk7XFxuICB9LFxcblxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xcbiAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XFxuICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoc2xvdCk7XFxuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcXG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcXG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXFxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xcbiAgICAgIHZhciByZWYgPSB0aGlzO1xcbiAgICAgIHZhciBpbmNsdWRlID0gcmVmLmluY2x1ZGU7XFxuICAgICAgdmFyIGV4Y2x1ZGUgPSByZWYuZXhjbHVkZTtcXG4gICAgICBpZiAoXFxuICAgICAgICAvLyBub3QgaW5jbHVkZWRcXG4gICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XFxuICAgICAgICAvLyBleGNsdWRlZFxcbiAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKVxcbiAgICAgICkge1xcbiAgICAgICAgcmV0dXJuIHZub2RlXFxuICAgICAgfVxcblxcbiAgICAgIHZhciByZWYkMSA9IHRoaXM7XFxuICAgICAgdmFyIGNhY2hlID0gcmVmJDEuY2FjaGU7XFxuICAgICAgdmFyIGtleXMgPSByZWYkMS5rZXlzO1xcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcXFwiOjpcXFwiICsgKGNvbXBvbmVudE9wdGlvbnMudGFnKSkgOiAnJylcXG4gICAgICAgIDogdm5vZGUua2V5O1xcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XFxuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XFxuICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XFxuICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcXG4gICAgICAgIGtleXMucHVzaChrZXkpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBjYWNoZVtrZXldID0gdm5vZGU7XFxuICAgICAgICBrZXlzLnB1c2goa2V5KTtcXG4gICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxcbiAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XFxuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5c1swXSwga2V5cywgdGhpcy5fdm5vZGUpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XFxuICAgIH1cXG4gICAgcmV0dXJuIHZub2RlIHx8IChzbG90ICYmIHNsb3RbMF0pXFxuICB9XFxufTtcXG5cXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XFxuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxcbn07XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XFxuICAvLyBjb25maWdcXG4gIHZhciBjb25maWdEZWYgPSB7fTtcXG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XFxuICBpZiAodHJ1ZSkge1xcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHdhcm4oXFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXFxuICAgICAgKTtcXG4gICAgfTtcXG4gIH1cXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xcblxcbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXFxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXFxuICBWdWUudXRpbCA9IHtcXG4gICAgd2Fybjogd2FybixcXG4gICAgZXh0ZW5kOiBleHRlbmQsXFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcXG4gIH07XFxuXFxuICBWdWUuc2V0ID0gc2V0O1xcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcXG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xcblxcbiAgLy8gMi42IGV4cGxpY2l0IG9ic2VydmFibGUgQVBJXFxuICBWdWUub2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYmopIHtcXG4gICAgb2JzZXJ2ZShvYmopO1xcbiAgICByZXR1cm4gb2JqXFxuICB9O1xcblxcbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XFxuICB9KTtcXG5cXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXFxcImJhc2VcXFwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xcblxcbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcXG5cXG4gIGluaXRVc2UoVnVlKTtcXG4gIGluaXRNaXhpbiQxKFZ1ZSk7XFxuICBpbml0RXh0ZW5kKFZ1ZSk7XFxuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcXG59XFxuXFxuaW5pdEdsb2JhbEFQSShWdWUpO1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xcbn0pO1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XFxuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXFxuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XFxuICB9XFxufSk7XFxuXFxuLy8gZXhwb3NlIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IGZvciBzc3IgcnVudGltZSBoZWxwZXIgaW5zdGFsbGF0aW9uXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ0Z1bmN0aW9uYWxSZW5kZXJDb250ZXh0Jywge1xcbiAgdmFsdWU6IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0XFxufSk7XFxuXFxuVnVlLnZlcnNpb24gPSAnMi42LjEwJztcXG5cXG4vKiAgKi9cXG5cXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcXG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cXG52YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xcblxcbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcXG52YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0LHByb2dyZXNzJyk7XFxudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xcbiAgcmV0dXJuIChcXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcXG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcXG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcXG4gIClcXG59O1xcblxcbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XFxuXFxudmFyIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSA9IG1ha2VNYXAoJ2V2ZW50cyxjYXJldCx0eXBpbmcscGxhaW50ZXh0LW9ubHknKTtcXG5cXG52YXIgY29udmVydEVudW1lcmF0ZWRWYWx1ZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XFxuICByZXR1cm4gaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZSdcXG4gICAgPyAnZmFsc2UnXFxuICAgIC8vIGFsbG93IGFyYml0cmFyeSBzdHJpbmcgdmFsdWUgZm9yIGNvbnRlbnRlZGl0YWJsZVxcbiAgICA6IGtleSA9PT0gJ2NvbnRlbnRlZGl0YWJsZScgJiYgaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlKHZhbHVlKVxcbiAgICAgID8gdmFsdWVcXG4gICAgICA6ICd0cnVlJ1xcbn07XFxuXFxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXFxuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXFxuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXFxuKTtcXG5cXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcXG5cXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XFxuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXFxufTtcXG5cXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcXG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xcbn07XFxuXFxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XFxuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxcbn07XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcXG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XFxuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XFxuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xcbiAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhKSB7XFxuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcXG4gICAgfVxcbiAgfVxcbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcXG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XFxuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxcbn1cXG5cXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xcbiAgcmV0dXJuIHtcXG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcXG4gICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXFxuICAgICAgOiBwYXJlbnQuY2xhc3NcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gcmVuZGVyQ2xhc3MgKFxcbiAgc3RhdGljQ2xhc3MsXFxuICBkeW5hbWljQ2xhc3NcXG4pIHtcXG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxcbiAgfVxcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cXG4gIHJldHVybiAnJ1xcbn1cXG5cXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcXG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXFxufVxcblxcbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XFxuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcXG4gIH1cXG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcXG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcXG4gIH1cXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XFxuICAgIHJldHVybiB2YWx1ZVxcbiAgfVxcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cXG4gIHJldHVybiAnJ1xcbn1cXG5cXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcXG4gIHZhciByZXMgPSAnJztcXG4gIHZhciBzdHJpbmdpZmllZDtcXG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XFxuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XFxuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gcmVzXFxufVxcblxcbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcXG4gIHZhciByZXMgPSAnJztcXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xcbiAgICBpZiAodmFsdWVba2V5XSkge1xcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxcbiAgICAgIHJlcyArPSBrZXk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiByZXNcXG59XFxuXFxuLyogICovXFxuXFxudmFyIG5hbWVzcGFjZU1hcCA9IHtcXG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xcbn07XFxuXFxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXFxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXFxuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXFxuKTtcXG5cXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcXG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxcbnZhciBpc1NWRyA9IG1ha2VNYXAoXFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxcbiAgdHJ1ZVxcbik7XFxuXFxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcXG5cXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcXG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXFxufTtcXG5cXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xcbiAgaWYgKGlzU1ZHKHRhZykpIHtcXG4gICAgcmV0dXJuICdzdmcnXFxuICB9XFxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xcbiAgICByZXR1cm4gJ21hdGgnXFxuICB9XFxufVxcblxcbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcXG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgaWYgKCFpbkJyb3dzZXIpIHtcXG4gICAgcmV0dXJuIHRydWVcXG4gIH1cXG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcXG4gICAgcmV0dXJuIGZhbHNlXFxuICB9XFxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XFxuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cXG4gIH1cXG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcXG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcXG4gICAgKSlcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcXG4gIH1cXG59XFxuXFxudmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XFxuXFxuLyogICovXFxuXFxuLyoqXFxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXFxuICovXFxuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XFxuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcXG4gICAgaWYgKCFzZWxlY3RlZCkge1xcbiAgICAgICB0cnVlICYmIHdhcm4oXFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXFxuICAgICAgKTtcXG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcXG4gICAgfVxcbiAgICByZXR1cm4gc2VsZWN0ZWRcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBlbFxcbiAgfVxcbn1cXG5cXG4vKiAgKi9cXG5cXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XFxuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcXG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xcbiAgICByZXR1cm4gZWxtXFxuICB9XFxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcXG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcXG4gIH1cXG4gIHJldHVybiBlbG1cXG59XFxuXFxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcXG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XFxuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcXG59XFxuXFxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcXG59XFxuXFxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XFxuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcXG59XFxuXFxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XFxuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcXG59XFxuXFxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XFxuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcXG59XFxuXFxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxcbn1cXG5cXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcXG59XFxuXFxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxcbn1cXG5cXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XFxufVxcblxcbmZ1bmN0aW9uIHNldFN0eWxlU2NvcGUgKG5vZGUsIHNjb3BlSWQpIHtcXG4gIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcXG59XFxuXFxudmFyIG5vZGVPcHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XFxuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXFxuICBjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcXG4gIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcXG4gIGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXFxuICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcXG4gIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcXG4gIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcXG4gIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXFxuICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXFxuICB0YWdOYW1lOiB0YWdOYW1lLFxcbiAgc2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxcbiAgc2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxcbn0pO1xcblxcbi8qICAqL1xcblxcbnZhciByZWYgPSB7XFxuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcXG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xcbiAgfSxcXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcXG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XFxuICAgIH1cXG4gIH0sXFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XFxuICB9XFxufTtcXG5cXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xcbiAgaWYgKCFpc0RlZihrZXkpKSB7IHJldHVybiB9XFxuXFxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcXG4gIHZhciByZWZzID0gdm0uJHJlZnM7XFxuICBpZiAoaXNSZW1vdmFsKSB7XFxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcXG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XFxuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XFxuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcXG4gICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XFxuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcXG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXFxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXFxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXFxuICpcXG4gKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcXG4gKlxcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcXG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cXG4gKi9cXG5cXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xcblxcbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xcblxcbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xcbiAgcmV0dXJuIChcXG4gICAgYS5rZXkgPT09IGIua2V5ICYmIChcXG4gICAgICAoXFxuICAgICAgICBhLnRhZyA9PT0gYi50YWcgJiZcXG4gICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxcbiAgICAgICAgc2FtZUlucHV0VHlwZShhLCBiKVxcbiAgICAgICkgfHwgKFxcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxcbiAgICAgICAgYS5hc3luY0ZhY3RvcnkgPT09IGIuYXN5bmNGYWN0b3J5ICYmXFxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxcbiAgICAgIClcXG4gICAgKVxcbiAgKVxcbn1cXG5cXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XFxuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxcbiAgdmFyIGk7XFxuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcXG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUIgfHwgaXNUZXh0SW5wdXRUeXBlKHR5cGVBKSAmJiBpc1RleHRJbnB1dFR5cGUodHlwZUIpXFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xcbiAgdmFyIGksIGtleTtcXG4gIHZhciBtYXAgPSB7fTtcXG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XFxuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcXG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XFxuICB9XFxuICByZXR1cm4gbWFwXFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcXG4gIHZhciBpLCBqO1xcbiAgdmFyIGNicyA9IHt9O1xcblxcbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XFxuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcXG5cXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xcbiAgICBjYnNbaG9va3NbaV1dID0gW107XFxuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XFxuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xcbiAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcXG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcXG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xcbiAgICByZXR1cm4gcmVtb3ZlJCQxXFxuICB9XFxuXFxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcXG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XFxuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCQkMSAodm5vZGUsIGluVlByZSkge1xcbiAgICByZXR1cm4gKFxcbiAgICAgICFpblZQcmUgJiZcXG4gICAgICAhdm5vZGUubnMgJiZcXG4gICAgICAhKFxcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShmdW5jdGlvbiAoaWdub3JlKSB7XFxuICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXFxuICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXFxuICAgICAgICAgICAgOiBpZ25vcmUgPT09IHZub2RlLnRhZ1xcbiAgICAgICAgfSlcXG4gICAgICApICYmXFxuICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodm5vZGUudGFnKVxcbiAgICApXFxuICB9XFxuXFxuICB2YXIgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xcblxcbiAgZnVuY3Rpb24gY3JlYXRlRWxtIChcXG4gICAgdm5vZGUsXFxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcXG4gICAgcGFyZW50RWxtLFxcbiAgICByZWZFbG0sXFxuICAgIG5lc3RlZCxcXG4gICAgb3duZXJBcnJheSxcXG4gICAgaW5kZXhcXG4gICkge1xcbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xcbiAgICAgIC8vIFRoaXMgdm5vZGUgd2FzIHVzZWQgaW4gYSBwcmV2aW91cyByZW5kZXIhXFxuICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXFxuICAgICAgLy8gcG90ZW50aWFsIHBhdGNoIGVycm9ycyBkb3duIHRoZSByb2FkIHdoZW4gaXQncyB1c2VkIGFzIGFuIGluc2VydGlvblxcbiAgICAgIC8vIHJlZmVyZW5jZSBub2RlLiBJbnN0ZWFkLCB3ZSBjbG9uZSB0aGUgbm9kZSBvbi1kZW1hbmQgYmVmb3JlIGNyZWF0aW5nXFxuICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXFxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xcbiAgICB9XFxuXFxuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXFxuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XFxuICAgICAgcmV0dXJuXFxuICAgIH1cXG5cXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcXG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcXG4gICAgaWYgKGlzRGVmKHRhZykpIHtcXG4gICAgICBpZiAodHJ1ZSkge1xcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcXG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcXG4gICAgICAgICAgd2FybihcXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXFxuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXFxcIm5hbWVcXFwiIG9wdGlvbi4nLFxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcXG4gICAgICAgICAgKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcXG5cXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gICAgICB7XFxuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XFxuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcXG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XFxuICAgICAgICB9XFxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICggdHJ1ZSAmJiBkYXRhICYmIGRhdGEucHJlKSB7XFxuICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcXG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcXG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcXG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xcbiAgICBpZiAoaXNEZWYoaSkpIHtcXG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcXG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcXG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLyk7XFxuICAgICAgfVxcbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXFxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XFxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB0cnVlXFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XFxuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XFxuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XFxuICAgIH1cXG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XFxuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XFxuICAgICAgc2V0U2NvcGUodm5vZGUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxcbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XFxuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XFxuICAgIHZhciBpO1xcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXFxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXFxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcXG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XFxuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XFxuICAgICAgICBicmVha1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XFxuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcXG4gICAgICAgIGlmIChub2RlT3BzLnBhcmVudE5vZGUocmVmJCQxKSA9PT0gcGFyZW50KSB7XFxuICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYkJDEpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcXG4gICAgICBpZiAodHJ1ZSkge1xcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcXG4gICAgICB9XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSwgY2hpbGRyZW4sIGkpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKFN0cmluZyh2bm9kZS50ZXh0KSkpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcXG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XFxuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XFxuICAgIH1cXG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XFxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcXG4gICAgfVxcbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxcbiAgICBpZiAoaXNEZWYoaSkpIHtcXG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XFxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXFxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcXG4gICAgdmFyIGk7XFxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuZm5TY29wZUlkKSkge1xcbiAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xcbiAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcXG4gICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XFxuICAgICAgICB9XFxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxcbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxcbiAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcXG4gICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZClcXG4gICAgKSB7XFxuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XFxuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcXG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcXG4gICAgdmFyIGksIGo7XFxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcXG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XFxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XFxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxcbiAgICB9XFxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XFxuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XFxuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XFxuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcXG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcXG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XFxuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XFxuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XFxuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcXG4gICAgICB2YXIgaTtcXG4gICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xcbiAgICAgIGlmIChpc0RlZihybSkpIHtcXG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xcbiAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XFxuICAgICAgfVxcbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGludm9rZSBob29rcyBvbiBjaGlsZCBjb21wb25lbnQgcm9vdCBub2RlXFxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XFxuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcXG4gICAgICB9XFxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcXG4gICAgICAgIGkodm5vZGUsIHJtKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcm0oKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcXG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcXG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcXG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XFxuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XFxuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XFxuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XFxuXFxuICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxcbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXFxuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXFxuICAgIHZhciBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XFxuXFxuICAgIGlmICh0cnVlKSB7XFxuICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKG5ld0NoKTtcXG4gICAgfVxcblxcbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XFxuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcXG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XFxuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcXG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XFxuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XFxuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XFxuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XFxuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcXG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3RW5kSWR4KTtcXG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcXG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcXG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XFxuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XFxuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcXG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XFxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxcbiAgICAgICAgICA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XVxcbiAgICAgICAgICA6IGZpbmRJZHhJbk9sZChuZXdTdGFydFZub2RlLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XFxuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcXG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcXG4gICAgICAgICAgaWYgKHNhbWVWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcXG4gICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XFxuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XFxuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XFxuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcXG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNoZWNrRHVwbGljYXRlS2V5cyAoY2hpbGRyZW4pIHtcXG4gICAgdmFyIHNlZW5LZXlzID0ge307XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgdm5vZGUgPSBjaGlsZHJlbltpXTtcXG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xcbiAgICAgIGlmIChpc0RlZihrZXkpKSB7XFxuICAgICAgICBpZiAoc2VlbktleXNba2V5XSkge1xcbiAgICAgICAgICB3YXJuKFxcbiAgICAgICAgICAgIChcXFwiRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICdcXFwiICsga2V5ICsgXFxcIicuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5cXFwiKSxcXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XFxuICAgICAgICAgICk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZCAobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcXG4gICAgICB2YXIgYyA9IG9sZENoW2ldO1xcbiAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpIHsgcmV0dXJuIGkgfVxcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChcXG4gICAgb2xkVm5vZGUsXFxuICAgIHZub2RlLFxcbiAgICBpbnNlcnRlZFZub2RlUXVldWUsXFxuICAgIG93bmVyQXJyYXksXFxuICAgIGluZGV4LFxcbiAgICByZW1vdmVPbmx5XFxuICApIHtcXG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xcbiAgICAgIHJldHVyblxcbiAgICB9XFxuXFxuICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XFxuICAgICAgLy8gY2xvbmUgcmV1c2VkIHZub2RlXFxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xcbiAgICB9XFxuXFxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XFxuXFxuICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xcbiAgICAgIGlmIChpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpKSB7XFxuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XFxuICAgICAgfVxcbiAgICAgIHJldHVyblxcbiAgICB9XFxuXFxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXFxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxcbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxcbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxcbiAgICApIHtcXG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xcbiAgICAgIHJldHVyblxcbiAgICB9XFxuXFxuICAgIHZhciBpO1xcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XFxuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcXG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XFxuICAgIH1cXG5cXG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XFxuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XFxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XFxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XFxuICAgIH1cXG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcXG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XFxuICAgICAgICBpZiAodHJ1ZSkge1xcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2gpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cXG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XFxuICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XFxuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcXG4gICAgfVxcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcXG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XFxuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcXG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgaHlkcmF0aW9uQmFpbGVkID0gZmFsc2U7XFxuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cXG4gIC8vIE5vdGU6IHN0eWxlIGlzIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGluaXRpYWwgY2xvbmUgZm9yIGZ1dHVyZVxcbiAgLy8gZGVlcCB1cGRhdGVzICgjNzA2MykuXFxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xcblxcbiAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XFxuICAgIHZhciBpO1xcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XFxuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xcbiAgICBpblZQcmUgPSBpblZQcmUgfHwgKGRhdGEgJiYgZGF0YS5wcmUpO1xcbiAgICB2bm9kZS5lbG0gPSBlbG07XFxuXFxuICAgIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSAmJiBpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkpKSB7XFxuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcXG4gICAgICByZXR1cm4gdHJ1ZVxcbiAgICB9XFxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXFxuICAgIGlmICh0cnVlKSB7XFxuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSwgaW5WUHJlKSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlXFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChpc0RlZihkYXRhKSkge1xcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXFxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xcbiAgICAgICAgcmV0dXJuIHRydWVcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKGlzRGVmKHRhZykpIHtcXG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XFxuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAvLyB2LWh0bWwgYW5kIGRvbVByb3BzOiBpbm5lckhUTUxcXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xcbiAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XFxuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gICAgICAgICAgICAgIGlmICggdHJ1ZSAmJlxcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxcbiAgICAgICAgICAgICAgKSB7XFxuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XFxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZlciBpbm5lckhUTUw6ICcsIGkpO1xcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgYW5kIGNvbXBhcmUgY2hpbGRyZW4gbGlzdHNcXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XFxuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcXG4gICAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpKSB7XFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXFxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICAgICAgICAgICAgICBpZiAoIHRydWUgJiZcXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXFxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcXG4gICAgICAgICAgICAgICkge1xcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XFxuICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcXG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcXG4gICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcXG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcXG4gICAgICAgICAgICBicmVha1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xcbiAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xcbiAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcXG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XFxuICAgIH1cXG4gICAgcmV0dXJuIHRydWVcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUsIGluVlByZSkge1xcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xcbiAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcXG4gICAgICAgICFpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBpblZQcmUpICYmXFxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcXG4gICAgICApXFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSkge1xcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcXG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxcbiAgICAgIHJldHVyblxcbiAgICB9XFxuXFxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XFxuXFxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcXG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XFxuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXFxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBudWxsLCBudWxsLCByZW1vdmVPbmx5KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcXG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcXG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcXG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XFxuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XFxuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXFxuICAgICAgICAgICAgfSBlbHNlIGlmICh0cnVlKSB7XFxuICAgICAgICAgICAgICB3YXJuKFxcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXFxuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXFxuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXFxuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcXG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcXG4gICAgICAgIHZhciBwYXJlbnRFbG0gPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcXG5cXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgbm9kZVxcbiAgICAgICAgY3JlYXRlRWxtKFxcbiAgICAgICAgICB2bm9kZSxcXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSxcXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXFxuICAgICAgICApO1xcblxcbiAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XFxuICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XFxuICAgICAgICAgIHZhciBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XFxuICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xcbiAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcXG4gICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAvLyAjNjUxM1xcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cXG4gICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGRpcmVjdGl2ZXMgdGhhdCB1c2VzIHRoZSBcXFwiaW5zZXJ0ZWRcXFwiIGhvb2suXFxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcXG4gICAgICAgICAgICAgIGlmIChpbnNlcnQubWVyZ2VkKSB7XFxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGF0IGluZGV4IDEgdG8gYXZvaWQgcmUtaW52b2tpbmcgY29tcG9uZW50IG1vdW50ZWQgaG9va1xcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcXG4gICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2kkMl0oKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICByZWdpc3RlclJlZihhbmNlc3Rvcik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXFxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtKSkge1xcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBbb2xkVm5vZGVdLCAwLCAwKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xcbiAgICByZXR1cm4gdm5vZGUuZWxtXFxuICB9XFxufVxcblxcbi8qICAqL1xcblxcbnZhciBkaXJlY3RpdmVzID0ge1xcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcXG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcXG4gIH1cXG59O1xcblxcbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcXG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcXG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XFxuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcXG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XFxuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xcblxcbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XFxuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcXG5cXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XFxuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcXG4gICAgaWYgKCFvbGREaXIpIHtcXG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcXG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XFxuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXFxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xcbiAgICAgIGRpci5vbGRBcmcgPSBvbGREaXIuYXJnO1xcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcXG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcXG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcXG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcXG4gICAgICB9XFxuICAgIH07XFxuICAgIGlmIChpc0NyZWF0ZSkge1xcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY2FsbEluc2VydCgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XFxuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgaWYgKCFpc0NyZWF0ZSkge1xcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XFxuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcXG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbn1cXG5cXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcblxcbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXFxuICBkaXJzLFxcbiAgdm1cXG4pIHtcXG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcbiAgaWYgKCFkaXJzKSB7XFxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxcbiAgICByZXR1cm4gcmVzXFxuICB9XFxuICB2YXIgaSwgZGlyO1xcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcXG4gICAgZGlyID0gZGlyc1tpXTtcXG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XFxuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXFxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xcbiAgICB9XFxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcXG4gIH1cXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxcbiAgcmV0dXJuIHJlc1xcbn1cXG5cXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcXG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFxcXCIuXFxcIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxcbn1cXG5cXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XFxuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XFxuICBpZiAoZm4pIHtcXG4gICAgdHJ5IHtcXG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFxcXCJkaXJlY3RpdmUgXFxcIiArIChkaXIubmFtZSkgKyBcXFwiIFxcXCIgKyBob29rICsgXFxcIiBob29rXFxcIikpO1xcbiAgICB9XFxuICB9XFxufVxcblxcbnZhciBiYXNlTW9kdWxlcyA9IFtcXG4gIHJlZixcXG4gIGRpcmVjdGl2ZXNcXG5dO1xcblxcbi8qICAqL1xcblxcbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcXG4gIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcXG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XFxuICAgIHJldHVyblxcbiAgfVxcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xcbiAgICByZXR1cm5cXG4gIH1cXG4gIHZhciBrZXksIGN1ciwgb2xkO1xcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcXG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XFxuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcXG4gIH1cXG5cXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XFxuICAgIGN1ciA9IGF0dHJzW2tleV07XFxuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XFxuICAgIGlmIChvbGQgIT09IGN1cikge1xcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XFxuICAgIH1cXG4gIH1cXG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXFxuICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gIGlmICgoaXNJRSB8fCBpc0VkZ2UpICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xcbiAgfVxcbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcXG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcXG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XFxuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xcbiAgaWYgKGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcXG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xcbiAgfSBlbHNlIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcXG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cXG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XFxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gdGVjaG5pY2FsbHkgYWxsb3dmdWxsc2NyZWVuIGlzIGEgYm9vbGVhbiBhdHRyaWJ1dGUgZm9yIDxpZnJhbWU+LFxcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXFxcInRydWVcXFwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xcbiAgICAgIHZhbHVlID0ga2V5ID09PSAnYWxsb3dmdWxsc2NyZWVuJyAmJiBlbC50YWdOYW1lID09PSAnRU1CRUQnXFxuICAgICAgICA/ICd0cnVlJ1xcbiAgICAgICAgOiBrZXk7XFxuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xcbiAgICB9XFxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBjb252ZXJ0RW51bWVyYXRlZFZhbHVlKGtleSwgdmFsdWUpKTtcXG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XFxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBiYXNlU2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcXG4gIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXFxuICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcXG4gICAgLy8gaW1tZWRpYXRlbHkuXFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgICBpZiAoXFxuICAgICAgaXNJRSAmJiAhaXNJRTkgJiZcXG4gICAgICBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmXFxuICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmIHZhbHVlICE9PSAnJyAmJiAhZWwuX19pZXBoXFxuICAgICkge1xcbiAgICAgIHZhciBibG9ja2VyID0gZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xcbiAgICAgIH07XFxuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcXG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcXG4gICAgICBlbC5fX2llcGggPSB0cnVlOyAvKiBJRSBwbGFjZWhvbGRlciBwYXRjaGVkICovXFxuICAgIH1cXG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xcbiAgfVxcbn1cXG5cXG52YXIgYXR0cnMgPSB7XFxuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xcbn07XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xcbiAgaWYgKFxcbiAgICBpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXFxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxcbiAgICAgIGlzVW5kZWYob2xkRGF0YSkgfHwgKFxcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJlxcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxcbiAgICAgIClcXG4gICAgKVxcbiAgKSB7XFxuICAgIHJldHVyblxcbiAgfVxcblxcbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xcblxcbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcXG4gIGlmIChpc0RlZih0cmFuc2l0aW9uQ2xhc3MpKSB7XFxuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xcbiAgfVxcblxcbiAgLy8gc2V0IHRoZSBjbGFzc1xcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcXG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcXG4gIH1cXG59XFxuXFxudmFyIGtsYXNzID0ge1xcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3NcXG59O1xcblxcbi8qICAqL1xcblxcbnZhciB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXFxcdykuK1xcXFwtXyRcXFxcXV0vO1xcblxcbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyAoZXhwKSB7XFxuICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcXG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xcbiAgdmFyIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcXG4gIHZhciBpblJlZ2V4ID0gZmFsc2U7XFxuICB2YXIgY3VybHkgPSAwO1xcbiAgdmFyIHNxdWFyZSA9IDA7XFxuICB2YXIgcGFyZW4gPSAwO1xcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XFxuICB2YXIgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycztcXG5cXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcXG4gICAgcHJldiA9IGM7XFxuICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcXG4gICAgaWYgKGluU2luZ2xlKSB7XFxuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XFxuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcXG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cXG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XFxuICAgICAgaWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1QykgeyBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7IH1cXG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XFxuICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cXG4gICAgfSBlbHNlIGlmIChcXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcXG4gICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcXG4gICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cXG4gICAgKSB7XFxuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxcbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XFxuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcHVzaEZpbHRlcigpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBzd2l0Y2ggKGMpIHtcXG4gICAgICAgIGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFxcXCJcXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIChcXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAgICAgICAgIC8vIF1cXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcXG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cXG4gICAgICB9XFxuICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xcbiAgICAgICAgdmFyIGogPSBpIC0gMTtcXG4gICAgICAgIHZhciBwID0gKHZvaWQgMCk7XFxuICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XFxuICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xcbiAgICAgICAgICBpZiAocCAhPT0gJyAnKSB7IGJyZWFrIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XFxuICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcXG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XFxuICAgIHB1c2hGaWx0ZXIoKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xcbiAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcXG4gIH1cXG5cXG4gIGlmIChmaWx0ZXJzKSB7XFxuICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBleHByZXNzaW9uXFxufVxcblxcbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XFxuICB2YXIgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XFxuICBpZiAoaSA8IDApIHtcXG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcXG4gICAgcmV0dXJuIChcXFwiX2YoXFxcXFxcXCJcXFwiICsgZmlsdGVyICsgXFxcIlxcXFxcXFwiKShcXFwiICsgZXhwICsgXFxcIilcXFwiKVxcbiAgfSBlbHNlIHtcXG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XFxuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcXG4gICAgcmV0dXJuIChcXFwiX2YoXFxcXFxcXCJcXFwiICsgbmFtZSArIFxcXCJcXFxcXFxcIikoXFxcIiArIGV4cCArIChhcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJncykpXFxuICB9XFxufVxcblxcbi8qICAqL1xcblxcblxcblxcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXFxuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZywgcmFuZ2UpIHtcXG4gIGNvbnNvbGUuZXJyb3IoKFxcXCJbVnVlIGNvbXBpbGVyXTogXFxcIiArIG1zZykpO1xcbn1cXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXFxuXFxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXFxuICBtb2R1bGVzLFxcbiAga2V5XFxuKSB7XFxuICByZXR1cm4gbW9kdWxlc1xcbiAgICA/IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtW2tleV07IH0pLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfSlcXG4gICAgOiBbXVxcbn1cXG5cXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XFxuICAoZWwucHJvcHMgfHwgKGVsLnByb3BzID0gW10pKS5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSwgZHluYW1pYzogZHluYW1pYyB9LCByYW5nZSkpO1xcbiAgZWwucGxhaW4gPSBmYWxzZTtcXG59XFxuXFxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSwgZHluYW1pYykge1xcbiAgdmFyIGF0dHJzID0gZHluYW1pY1xcbiAgICA/IChlbC5keW5hbWljQXR0cnMgfHwgKGVsLmR5bmFtaWNBdHRycyA9IFtdKSlcXG4gICAgOiAoZWwuYXR0cnMgfHwgKGVsLmF0dHJzID0gW10pKTtcXG4gIGF0dHJzLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XFxuICBlbC5wbGFpbiA9IGZhbHNlO1xcbn1cXG5cXG4vLyBhZGQgYSByYXcgYXR0ciAodXNlIHRoaXMgaW4gcHJlVHJhbnNmb3JtcylcXG5mdW5jdGlvbiBhZGRSYXdBdHRyIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlKSB7XFxuICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xcbiAgZWwuYXR0cnNMaXN0LnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0sIHJhbmdlKSk7XFxufVxcblxcbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXFxuICBlbCxcXG4gIG5hbWUsXFxuICByYXdOYW1lLFxcbiAgdmFsdWUsXFxuICBhcmcsXFxuICBpc0R5bmFtaWNBcmcsXFxuICBtb2RpZmllcnMsXFxuICByYW5nZVxcbikge1xcbiAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHtcXG4gICAgbmFtZTogbmFtZSxcXG4gICAgcmF3TmFtZTogcmF3TmFtZSxcXG4gICAgdmFsdWU6IHZhbHVlLFxcbiAgICBhcmc6IGFyZyxcXG4gICAgaXNEeW5hbWljQXJnOiBpc0R5bmFtaWNBcmcsXFxuICAgIG1vZGlmaWVyczogbW9kaWZpZXJzXFxuICB9LCByYW5nZSkpO1xcbiAgZWwucGxhaW4gPSBmYWxzZTtcXG59XFxuXFxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyTWFya2VyIChzeW1ib2wsIG5hbWUsIGR5bmFtaWMpIHtcXG4gIHJldHVybiBkeW5hbWljXFxuICAgID8gKFxcXCJfcChcXFwiICsgbmFtZSArIFxcXCIsXFxcXFxcXCJcXFwiICsgc3ltYm9sICsgXFxcIlxcXFxcXFwiKVxcXCIpXFxuICAgIDogc3ltYm9sICsgbmFtZSAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxcbn1cXG5cXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcXG4gIGVsLFxcbiAgbmFtZSxcXG4gIHZhbHVlLFxcbiAgbW9kaWZpZXJzLFxcbiAgaW1wb3J0YW50LFxcbiAgd2FybixcXG4gIHJhbmdlLFxcbiAgZHluYW1pY1xcbikge1xcbiAgbW9kaWZpZXJzID0gbW9kaWZpZXJzIHx8IGVtcHR5T2JqZWN0O1xcbiAgLy8gd2FybiBwcmV2ZW50IGFuZCBwYXNzaXZlIG1vZGlmaWVyXFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gIGlmIChcXG4gICAgIHRydWUgJiYgd2FybiAmJlxcbiAgICBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxcbiAgKSB7XFxuICAgIHdhcm4oXFxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFxcXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xcbiAgICAgICdQYXNzaXZlIGhhbmRsZXIgY2FuXFxcXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nLFxcbiAgICAgIHJhbmdlXFxuICAgICk7XFxuICB9XFxuXFxuICAvLyBub3JtYWxpemUgY2xpY2sucmlnaHQgYW5kIGNsaWNrLm1pZGRsZSBzaW5jZSB0aGV5IGRvbid0IGFjdHVhbGx5IGZpcmVcXG4gIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXFxuICAvLyB0aGUgb25seSB0YXJnZXQgZW52cyB0aGF0IGhhdmUgcmlnaHQvbWlkZGxlIGNsaWNrcy5cXG4gIGlmIChtb2RpZmllcnMucmlnaHQpIHtcXG4gICAgaWYgKGR5bmFtaWMpIHtcXG4gICAgICBuYW1lID0gXFxcIihcXFwiICsgbmFtZSArIFxcXCIpPT09J2NsaWNrJz8nY29udGV4dG1lbnUnOihcXFwiICsgbmFtZSArIFxcXCIpXFxcIjtcXG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XFxuICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XFxuICAgICAgZGVsZXRlIG1vZGlmaWVycy5yaWdodDtcXG4gICAgfVxcbiAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XFxuICAgIGlmIChkeW5hbWljKSB7XFxuICAgICAgbmFtZSA9IFxcXCIoXFxcIiArIG5hbWUgKyBcXFwiKT09PSdjbGljayc/J21vdXNldXAnOihcXFwiICsgbmFtZSArIFxcXCIpXFxcIjtcXG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XFxuICAgICAgbmFtZSA9ICdtb3VzZXVwJztcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxcbiAgaWYgKG1vZGlmaWVycy5jYXB0dXJlKSB7XFxuICAgIGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcXG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignIScsIG5hbWUsIGR5bmFtaWMpO1xcbiAgfVxcbiAgaWYgKG1vZGlmaWVycy5vbmNlKSB7XFxuICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcXG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignficsIG5hbWUsIGR5bmFtaWMpO1xcbiAgfVxcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICBpZiAobW9kaWZpZXJzLnBhc3NpdmUpIHtcXG4gICAgZGVsZXRlIG1vZGlmaWVycy5wYXNzaXZlO1xcbiAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCcmJywgbmFtZSwgZHluYW1pYyk7XFxuICB9XFxuXFxuICB2YXIgZXZlbnRzO1xcbiAgaWYgKG1vZGlmaWVycy5uYXRpdmUpIHtcXG4gICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XFxuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xcbiAgfSBlbHNlIHtcXG4gICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XFxuICB9XFxuXFxuICB2YXIgbmV3SGFuZGxlciA9IHJhbmdlU2V0SXRlbSh7IHZhbHVlOiB2YWx1ZS50cmltKCksIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpO1xcbiAgaWYgKG1vZGlmaWVycyAhPT0gZW1wdHlPYmplY3QpIHtcXG4gICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XFxuICB9XFxuXFxuICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcXG4gIH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcXG4gICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XFxuICB9IGVsc2Uge1xcbiAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xcbiAgfVxcblxcbiAgZWwucGxhaW4gPSBmYWxzZTtcXG59XFxuXFxuZnVuY3Rpb24gZ2V0UmF3QmluZGluZ0F0dHIgKFxcbiAgZWwsXFxuICBuYW1lXFxuKSB7XFxuICByZXR1cm4gZWwucmF3QXR0cnNNYXBbJzonICsgbmFtZV0gfHxcXG4gICAgZWwucmF3QXR0cnNNYXBbJ3YtYmluZDonICsgbmFtZV0gfHxcXG4gICAgZWwucmF3QXR0cnNNYXBbbmFtZV1cXG59XFxuXFxuZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIgKFxcbiAgZWwsXFxuICBuYW1lLFxcbiAgZ2V0U3RhdGljXFxuKSB7XFxuICB2YXIgZHluYW1pY1ZhbHVlID1cXG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHxcXG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XFxuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcXG4gICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpXFxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcXG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XFxuICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XFxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxcbiAgICB9XFxuICB9XFxufVxcblxcbi8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcXG4vLyBkb2Vzbid0IGdldCBwcm9jZXNzZWQgYnkgcHJvY2Vzc0F0dHJzLlxcbi8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xcbi8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChcXG4gIGVsLFxcbiAgbmFtZSxcXG4gIHJlbW92ZUZyb21NYXBcXG4pIHtcXG4gIHZhciB2YWw7XFxuICBpZiAoKHZhbCA9IGVsLmF0dHJzTWFwW25hbWVdKSAhPSBudWxsKSB7XFxuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XFxuICAgICAgICBicmVha1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgaWYgKHJlbW92ZUZyb21NYXApIHtcXG4gICAgZGVsZXRlIGVsLmF0dHJzTWFwW25hbWVdO1xcbiAgfVxcbiAgcmV0dXJuIHZhbFxcbn1cXG5cXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleCAoXFxuICBlbCxcXG4gIG5hbWVcXG4pIHtcXG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICB2YXIgYXR0ciA9IGxpc3RbaV07XFxuICAgIGlmIChuYW1lLnRlc3QoYXR0ci5uYW1lKSkge1xcbiAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xcbiAgICAgIHJldHVybiBhdHRyXFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gcmFuZ2VTZXRJdGVtIChcXG4gIGl0ZW0sXFxuICByYW5nZVxcbikge1xcbiAgaWYgKHJhbmdlKSB7XFxuICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XFxuICAgICAgaXRlbS5zdGFydCA9IHJhbmdlLnN0YXJ0O1xcbiAgICB9XFxuICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xcbiAgICAgIGl0ZW0uZW5kID0gcmFuZ2UuZW5kO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gaXRlbVxcbn1cXG5cXG4vKiAgKi9cXG5cXG4vKipcXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXFxuICovXFxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxcbiAgZWwsXFxuICB2YWx1ZSxcXG4gIG1vZGlmaWVyc1xcbikge1xcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcXG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcXG5cXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XFxuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcXG4gIGlmICh0cmltKSB7XFxuICAgIHZhbHVlRXhwcmVzc2lvbiA9XFxuICAgICAgXFxcIih0eXBlb2YgXFxcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcXFwiID09PSAnc3RyaW5nJ1xcXCIgK1xcbiAgICAgIFxcXCI/IFxcXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXFxcIi50cmltKClcXFwiICtcXG4gICAgICBcXFwiOiBcXFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFxcXCIpXFxcIjtcXG4gIH1cXG4gIGlmIChudW1iZXIpIHtcXG4gICAgdmFsdWVFeHByZXNzaW9uID0gXFxcIl9uKFxcXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcXFwiKVxcXCI7XFxuICB9XFxuICB2YXIgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xcblxcbiAgZWwubW9kZWwgPSB7XFxuICAgIHZhbHVlOiAoXFxcIihcXFwiICsgdmFsdWUgKyBcXFwiKVxcXCIpLFxcbiAgICBleHByZXNzaW9uOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSksXFxuICAgIGNhbGxiYWNrOiAoXFxcImZ1bmN0aW9uIChcXFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFxcXCIpIHtcXFwiICsgYXNzaWdubWVudCArIFxcXCJ9XFxcIilcXG4gIH07XFxufVxcblxcbi8qKlxcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxcbiAqL1xcbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcXG4gIHZhbHVlLFxcbiAgYXNzaWdubWVudFxcbikge1xcbiAgdmFyIHJlcyA9IHBhcnNlTW9kZWwodmFsdWUpO1xcbiAgaWYgKHJlcy5rZXkgPT09IG51bGwpIHtcXG4gICAgcmV0dXJuICh2YWx1ZSArIFxcXCI9XFxcIiArIGFzc2lnbm1lbnQpXFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gKFxcXCIkc2V0KFxcXCIgKyAocmVzLmV4cCkgKyBcXFwiLCBcXFwiICsgKHJlcy5rZXkpICsgXFxcIiwgXFxcIiArIGFzc2lnbm1lbnQgKyBcXFwiKVxcXCIpXFxuICB9XFxufVxcblxcbi8qKlxcbiAqIFBhcnNlIGEgdi1tb2RlbCBleHByZXNzaW9uIGludG8gYSBiYXNlIHBhdGggYW5kIGEgZmluYWwga2V5IHNlZ21lbnQuXFxuICogSGFuZGxlcyBib3RoIGRvdC1wYXRoIGFuZCBwb3NzaWJsZSBzcXVhcmUgYnJhY2tldHMuXFxuICpcXG4gKiBQb3NzaWJsZSBjYXNlczpcXG4gKlxcbiAqIC0gdGVzdFxcbiAqIC0gdGVzdFtrZXldXFxuICogLSB0ZXN0W3Rlc3QxW2tleV1dXFxuICogLSB0ZXN0W1xcXCJhXFxcIl1ba2V5XVxcbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxcbiAqIC0gdGVzdC54eHguYVtcXFwiYXNhXFxcIl1bdGVzdDFba2V5XV1cXG4gKlxcbiAqL1xcblxcbnZhciBsZW4sIHN0ciwgY2hyLCBpbmRleCQxLCBleHByZXNzaW9uUG9zLCBleHByZXNzaW9uRW5kUG9zO1xcblxcblxcblxcbmZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xcbiAgLy8gRml4IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvcHVsbC83NzMwXFxuICAvLyBhbGxvdyB2LW1vZGVsPVxcXCJvYmoudmFsIFxcXCIgKHRyYWlsaW5nIHdoaXRlc3BhY2UpXFxuICB2YWwgPSB2YWwudHJpbSgpO1xcbiAgbGVuID0gdmFsLmxlbmd0aDtcXG5cXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcXG4gICAgaW5kZXgkMSA9IHZhbC5sYXN0SW5kZXhPZignLicpO1xcbiAgICBpZiAoaW5kZXgkMSA+IC0xKSB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIGV4cDogdmFsLnNsaWNlKDAsIGluZGV4JDEpLFxcbiAgICAgICAga2V5OiAnXFxcIicgKyB2YWwuc2xpY2UoaW5kZXgkMSArIDEpICsgJ1xcXCInXFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBleHA6IHZhbCxcXG4gICAgICAgIGtleTogbnVsbFxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgc3RyID0gdmFsO1xcbiAgaW5kZXgkMSA9IGV4cHJlc3Npb25Qb3MgPSBleHByZXNzaW9uRW5kUG9zID0gMDtcXG5cXG4gIHdoaWxlICghZW9mKCkpIHtcXG4gICAgY2hyID0gbmV4dCgpO1xcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XFxuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XFxuICAgICAgcGFyc2VCcmFja2V0KGNocik7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiB7XFxuICAgIGV4cDogdmFsLnNsaWNlKDAsIGV4cHJlc3Npb25Qb3MpLFxcbiAgICBrZXk6IHZhbC5zbGljZShleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gbmV4dCAoKSB7XFxuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxcbn1cXG5cXG5mdW5jdGlvbiBlb2YgKCkge1xcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXFxufVxcblxcbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xcbiAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4MjdcXG59XFxuXFxuZnVuY3Rpb24gcGFyc2VCcmFja2V0IChjaHIpIHtcXG4gIHZhciBpbkJyYWNrZXQgPSAxO1xcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XFxuICB3aGlsZSAoIWVvZigpKSB7XFxuICAgIGNociA9IG5leHQoKTtcXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XFxuICAgICAgY29udGludWVcXG4gICAgfVxcbiAgICBpZiAoY2hyID09PSAweDVCKSB7IGluQnJhY2tldCsrOyB9XFxuICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cXG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xcbiAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleCQxO1xcbiAgICAgIGJyZWFrXFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xcbiAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xcbiAgd2hpbGUgKCFlb2YoKSkge1xcbiAgICBjaHIgPSBuZXh0KCk7XFxuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XFxuICAgICAgYnJlYWtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vKiAgKi9cXG5cXG52YXIgd2FybiQxO1xcblxcbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxcbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xcblxcbmZ1bmN0aW9uIG1vZGVsIChcXG4gIGVsLFxcbiAgZGlyLFxcbiAgX3dhcm5cXG4pIHtcXG4gIHdhcm4kMSA9IF93YXJuO1xcbiAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xcbiAgdmFyIG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XFxuICB2YXIgdGFnID0gZWwudGFnO1xcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xcblxcbiAgaWYgKHRydWUpIHtcXG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cXFwiZmlsZVxcXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xcbiAgICAvLyB2YWx1ZSB3aWxsIHRocm93IGFuIGVycm9yLlxcbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xcbiAgICAgIHdhcm4kMShcXG4gICAgICAgIFxcXCI8XFxcIiArIChlbC50YWcpICsgXFxcIiB2LW1vZGVsPVxcXFxcXFwiXFxcIiArIHZhbHVlICsgXFxcIlxcXFxcXFwiIHR5cGU9XFxcXFxcXCJmaWxlXFxcXFxcXCI+OlxcXFxuXFxcIiArXFxuICAgICAgICBcXFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cXFwiLFxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxcbiAgICAgICk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGlmIChlbC5jb21wb25lbnQpIHtcXG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxcbiAgICByZXR1cm4gZmFsc2VcXG4gIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcXG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcXG4gICAgZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XFxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcXG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcXG4gIH0gZWxzZSBpZiAoIWNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcXG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxcbiAgICByZXR1cm4gZmFsc2VcXG4gIH0gZWxzZSBpZiAodHJ1ZSkge1xcbiAgICB3YXJuJDEoXFxuICAgICAgXFxcIjxcXFwiICsgKGVsLnRhZykgKyBcXFwiIHYtbW9kZWw9XFxcXFxcXCJcXFwiICsgdmFsdWUgKyBcXFwiXFxcXFxcXCI+OiBcXFwiICtcXG4gICAgICBcXFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcXFwiICtcXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcXFwncyByZWNvbW1lbmRlZCB0byAnICtcXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nLFxcbiAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cXG4gICAgKTtcXG4gIH1cXG5cXG4gIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxcbiAgcmV0dXJuIHRydWVcXG59XFxuXFxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXFxuICBlbCxcXG4gIHZhbHVlLFxcbiAgbW9kaWZpZXJzXFxuKSB7XFxuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XFxuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcXG4gIHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xcbiAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XFxuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXFxuICAgIFxcXCJBcnJheS5pc0FycmF5KFxcXCIgKyB2YWx1ZSArIFxcXCIpXFxcIiArXFxuICAgIFxcXCI/X2koXFxcIiArIHZhbHVlICsgXFxcIixcXFwiICsgdmFsdWVCaW5kaW5nICsgXFxcIik+LTFcXFwiICsgKFxcbiAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xcbiAgICAgICAgPyAoXFxcIjooXFxcIiArIHZhbHVlICsgXFxcIilcXFwiKVxcbiAgICAgICAgOiAoXFxcIjpfcShcXFwiICsgdmFsdWUgKyBcXFwiLFxcXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXFxcIilcXFwiKVxcbiAgICApXFxuICApO1xcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsXFxuICAgIFxcXCJ2YXIgJCRhPVxcXCIgKyB2YWx1ZSArIFxcXCIsXFxcIiArXFxuICAgICAgICAnJCRlbD0kZXZlbnQudGFyZ2V0LCcgK1xcbiAgICAgICAgXFxcIiQkYz0kJGVsLmNoZWNrZWQ/KFxcXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXFxcIik6KFxcXCIgKyBmYWxzZVZhbHVlQmluZGluZyArIFxcXCIpO1xcXCIgK1xcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcXG4gICAgICBcXFwidmFyICQkdj1cXFwiICsgKG51bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nKSArIFxcXCIsXFxcIiArXFxuICAgICAgICAgICckJGk9X2koJCRhLCQkdik7JyArXFxuICAgICAgXFxcImlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJihcXFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLmNvbmNhdChbJCR2XSknKSkgKyBcXFwiKX1cXFwiICtcXG4gICAgICBcXFwiZWxzZXskJGk+LTEmJihcXFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSknKSkgKyBcXFwiKX1cXFwiICtcXG4gICAgXFxcIn1lbHNle1xcXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSkgKyBcXFwifVxcXCIsXFxuICAgIG51bGwsIHRydWVcXG4gICk7XFxufVxcblxcbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxcbiAgZWwsXFxuICB2YWx1ZSxcXG4gIG1vZGlmaWVyc1xcbikge1xcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XFxuICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyAoXFxcIl9uKFxcXCIgKyB2YWx1ZUJpbmRpbmcgKyBcXFwiKVxcXCIpIDogdmFsdWVCaW5kaW5nO1xcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCAoXFxcIl9xKFxcXCIgKyB2YWx1ZSArIFxcXCIsXFxcIiArIHZhbHVlQmluZGluZyArIFxcXCIpXFxcIikpO1xcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcXG59XFxuXFxuZnVuY3Rpb24gZ2VuU2VsZWN0IChcXG4gIGVsLFxcbiAgdmFsdWUsXFxuICBtb2RpZmllcnNcXG4pIHtcXG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcXG4gIHZhciBzZWxlY3RlZFZhbCA9IFxcXCJBcnJheS5wcm90b3R5cGUuZmlsdGVyXFxcIiArXFxuICAgIFxcXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVxcXCIgK1xcbiAgICBcXFwiLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXFxcXFxcXCJfdmFsdWVcXFxcXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1xcXCIgK1xcbiAgICBcXFwicmV0dXJuIFxcXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXFxcIn0pXFxcIjtcXG5cXG4gIHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XFxuICB2YXIgY29kZSA9IFxcXCJ2YXIgJCRzZWxlY3RlZFZhbCA9IFxcXCIgKyBzZWxlY3RlZFZhbCArIFxcXCI7XFxcIjtcXG4gIGNvZGUgPSBjb2RlICsgXFxcIiBcXFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KSk7XFxuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XFxufVxcblxcbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXFxuICBlbCxcXG4gIHZhbHVlLFxcbiAgbW9kaWZpZXJzXFxuKSB7XFxuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XFxuXFxuICAvLyB3YXJuIGlmIHYtYmluZDp2YWx1ZSBjb25mbGljdHMgd2l0aCB2LW1vZGVsXFxuICAvLyBleGNlcHQgZm9yIGlucHV0cyB3aXRoIHYtYmluZDp0eXBlXFxuICBpZiAodHJ1ZSkge1xcbiAgICB2YXIgdmFsdWUkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XFxuICAgIHZhciB0eXBlQmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dHlwZSddIHx8IGVsLmF0dHJzTWFwWyc6dHlwZSddO1xcbiAgICBpZiAodmFsdWUkMSAmJiAhdHlwZUJpbmRpbmcpIHtcXG4gICAgICB2YXIgYmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSA/ICd2LWJpbmQ6dmFsdWUnIDogJzp2YWx1ZSc7XFxuICAgICAgd2FybiQxKFxcbiAgICAgICAgYmluZGluZyArIFxcXCI9XFxcXFxcXCJcXFwiICsgdmFsdWUkMSArIFxcXCJcXFxcXFxcIiBjb25mbGljdHMgd2l0aCB2LW1vZGVsIG9uIHRoZSBzYW1lIGVsZW1lbnQgXFxcIiArXFxuICAgICAgICAnYmVjYXVzZSB0aGUgbGF0dGVyIGFscmVhZHkgZXhwYW5kcyB0byBhIHZhbHVlIGJpbmRpbmcgaW50ZXJuYWxseScsXFxuICAgICAgICBlbC5yYXdBdHRyc01hcFtiaW5kaW5nXVxcbiAgICAgICk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XFxuICB2YXIgbGF6eSA9IHJlZi5sYXp5O1xcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XFxuICB2YXIgdHJpbSA9IHJlZi50cmltO1xcbiAgdmFyIG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcXG4gIHZhciBldmVudCA9IGxhenlcXG4gICAgPyAnY2hhbmdlJ1xcbiAgICA6IHR5cGUgPT09ICdyYW5nZSdcXG4gICAgICA/IFJBTkdFX1RPS0VOXFxuICAgICAgOiAnaW5wdXQnO1xcblxcbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcXG4gIGlmICh0cmltKSB7XFxuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFxcXCIkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKVxcXCI7XFxuICB9XFxuICBpZiAobnVtYmVyKSB7XFxuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFxcXCJfbihcXFwiICsgdmFsdWVFeHByZXNzaW9uICsgXFxcIilcXFwiO1xcbiAgfVxcblxcbiAgdmFyIGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcXG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xcbiAgICBjb2RlID0gXFxcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcXFwiICsgY29kZTtcXG4gIH1cXG5cXG4gIGFkZFByb3AoZWwsICd2YWx1ZScsIChcXFwiKFxcXCIgKyB2YWx1ZSArIFxcXCIpXFxcIikpO1xcbiAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xcbiAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XFxuICAgIGFkZEhhbmRsZXIoZWwsICdibHVyJywgJyRmb3JjZVVwZGF0ZSgpJyk7XFxuICB9XFxufVxcblxcbi8qICAqL1xcblxcbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXFxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXFxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XFxuICAgIHZhciBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XFxuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XFxuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XFxuICB9XFxuICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxcbiAgLy8gYWZ0ZXIgMi41LiBLZWVwaW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGggZ2VuZXJhdGVkIGNvZGUgZnJvbSA8IDIuNFxcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xcbiAgICBvbi5jaGFuZ2UgPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbi5jaGFuZ2UgfHwgW10pO1xcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xcbiAgfVxcbn1cXG5cXG52YXIgdGFyZ2V0JDE7XFxuXFxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIkMSAoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpIHtcXG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXFxuICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xcbiAgICB2YXIgcmVzID0gaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XFxuICAgICAgcmVtb3ZlJDIoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vLyAjOTQ0NjogRmlyZWZveCA8PSA1MyAoaW4gcGFydGljdWxhciwgRVNSIDUyKSBoYXMgaW5jb3JyZWN0IEV2ZW50LnRpbWVTdGFtcFxcbi8vIGltcGxlbWVudGF0aW9uIGFuZCBkb2VzIG5vdCBmaXJlIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbiwgc29cXG4vLyBzYWZlIHRvIGV4Y2x1ZGUuXFxudmFyIHVzZU1pY3JvdGFza0ZpeCA9IGlzVXNpbmdNaWNyb1Rhc2sgJiYgIShpc0ZGICYmIE51bWJlcihpc0ZGWzFdKSA8PSA1Myk7XFxuXFxuZnVuY3Rpb24gYWRkJDEgKFxcbiAgbmFtZSxcXG4gIGhhbmRsZXIsXFxuICBjYXB0dXJlLFxcbiAgcGFzc2l2ZVxcbikge1xcbiAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxcbiAgLy8gYXR0YWNoZWQgdG8gb3V0ZXIgZWxlbWVudCBkdXJpbmcgcGF0Y2gsIGFuZCB0cmlnZ2VyZWQgYWdhaW4uIFRoaXNcXG4gIC8vIGhhcHBlbnMgYmVjYXVzZSBicm93c2VycyBmaXJlIG1pY3JvdGFzayB0aWNrcyBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLlxcbiAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxcbiAgLy8gYW5kIHRoZSBoYW5kbGVyIHdvdWxkIG9ubHkgZmlyZSBpZiB0aGUgZXZlbnQgcGFzc2VkIHRvIGl0IHdhcyBmaXJlZFxcbiAgLy8gQUZURVIgaXQgd2FzIGF0dGFjaGVkLlxcbiAgaWYgKHVzZU1pY3JvdGFza0ZpeCkge1xcbiAgICB2YXIgYXR0YWNoZWRUaW1lc3RhbXAgPSBjdXJyZW50Rmx1c2hUaW1lc3RhbXA7XFxuICAgIHZhciBvcmlnaW5hbCA9IGhhbmRsZXI7XFxuICAgIGhhbmRsZXIgPSBvcmlnaW5hbC5fd3JhcHBlciA9IGZ1bmN0aW9uIChlKSB7XFxuICAgICAgaWYgKFxcbiAgICAgICAgLy8gbm8gYnViYmxpbmcsIHNob3VsZCBhbHdheXMgZmlyZS5cXG4gICAgICAgIC8vIHRoaXMgaXMganVzdCBhIHNhZmV0eSBuZXQgaW4gY2FzZSBldmVudC50aW1lU3RhbXAgaXMgdW5yZWxpYWJsZSBpblxcbiAgICAgICAgLy8gY2VydGFpbiB3ZWlyZCBlbnZpcm9ubWVudHMuLi5cXG4gICAgICAgIGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQgfHxcXG4gICAgICAgIC8vIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGhhbmRsZXIgYXR0YWNobWVudFxcbiAgICAgICAgZS50aW1lU3RhbXAgPj0gYXR0YWNoZWRUaW1lc3RhbXAgfHxcXG4gICAgICAgIC8vIGJhaWwgZm9yIGVudmlyb25tZW50cyB0aGF0IGhhdmUgYnVnZ3kgZXZlbnQudGltZVN0YW1wIGltcGxlbWVudGF0aW9uc1xcbiAgICAgICAgLy8gIzk0NjIgaU9TIDkgYnVnOiBldmVudC50aW1lU3RhbXAgaXMgMCBhZnRlciBoaXN0b3J5LnB1c2hTdGF0ZVxcbiAgICAgICAgLy8gIzk2ODEgUXRXZWJFbmdpbmUgZXZlbnQudGltZVN0YW1wIGlzIG5lZ2F0aXZlIHZhbHVlXFxuICAgICAgICBlLnRpbWVTdGFtcCA8PSAwIHx8XFxuICAgICAgICAvLyAjOTQ0OCBiYWlsIGlmIGV2ZW50IGlzIGZpcmVkIGluIGFub3RoZXIgZG9jdW1lbnQgaW4gYSBtdWx0aS1wYWdlXFxuICAgICAgICAvLyBlbGVjdHJvbi9udy5qcyBhcHAsIHNpbmNlIGV2ZW50LnRpbWVTdGFtcCB3aWxsIGJlIHVzaW5nIGEgZGlmZmVyZW50XFxuICAgICAgICAvLyBzdGFydGluZyByZWZlcmVuY2VcXG4gICAgICAgIGUudGFyZ2V0Lm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50XFxuICAgICAgKSB7XFxuICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKVxcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXFxuICAgIG5hbWUsXFxuICAgIGhhbmRsZXIsXFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxcbiAgICAgID8geyBjYXB0dXJlOiBjYXB0dXJlLCBwYXNzaXZlOiBwYXNzaXZlIH1cXG4gICAgICA6IGNhcHR1cmVcXG4gICk7XFxufVxcblxcbmZ1bmN0aW9uIHJlbW92ZSQyIChcXG4gIG5hbWUsXFxuICBoYW5kbGVyLFxcbiAgY2FwdHVyZSxcXG4gIF90YXJnZXRcXG4pIHtcXG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxcbiAgICBuYW1lLFxcbiAgICBoYW5kbGVyLl93cmFwcGVyIHx8IGhhbmRsZXIsXFxuICAgIGNhcHR1cmVcXG4gICk7XFxufVxcblxcbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XFxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XFxuICAgIHJldHVyblxcbiAgfVxcbiAgdmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcXG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XFxuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcXG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XFxuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIGNyZWF0ZU9uY2VIYW5kbGVyJDEsIHZub2RlLmNvbnRleHQpO1xcbiAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XFxufVxcblxcbnZhciBldmVudHMgPSB7XFxuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXFxufTtcXG5cXG4vKiAgKi9cXG5cXG52YXIgc3ZnQ29udGFpbmVyO1xcblxcbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcXG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcXG4gICAgcmV0dXJuXFxuICB9XFxuICB2YXIga2V5LCBjdXI7XFxuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcXG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XFxuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcXG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XFxuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xcbiAgfVxcblxcbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcXG4gICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xcbiAgICAgIGVsbVtrZXldID0gJyc7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZvciAoa2V5IGluIHByb3BzKSB7XFxuICAgIGN1ciA9IHByb3BzW2tleV07XFxuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcXG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxcbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxcbiAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcXG4gICAgICAvLyByZXBsYWNlZCBieSBpbm5lckhUTUwvdGV4dENvbnRlbnQgcmV0YWlucyBpdHMgcGFyZW50Tm9kZSBwcm9wZXJ0eVxcbiAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcXG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScgJiYgZWxtLnRhZ05hbWUgIT09ICdQUk9HUkVTUycpIHtcXG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxcbiAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHN0ckN1cikpIHtcXG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnaW5uZXJIVE1MJyAmJiBpc1NWRyhlbG0udGFnTmFtZSkgJiYgaXNVbmRlZihlbG0uaW5uZXJIVE1MKSkge1xcbiAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBpbm5lckhUTUwgZm9yIFNWRyBlbGVtZW50c1xcbiAgICAgIHN2Z0NvbnRhaW5lciA9IHN2Z0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG4gICAgICBzdmdDb250YWluZXIuaW5uZXJIVE1MID0gXFxcIjxzdmc+XFxcIiArIGN1ciArIFxcXCI8L3N2Zz5cXFwiO1xcbiAgICAgIHZhciBzdmcgPSBzdmdDb250YWluZXIuZmlyc3RDaGlsZDtcXG4gICAgICB3aGlsZSAoZWxtLmZpcnN0Q2hpbGQpIHtcXG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uZmlyc3RDaGlsZCk7XFxuICAgICAgfVxcbiAgICAgIHdoaWxlIChzdmcuZmlyc3RDaGlsZCkge1xcbiAgICAgICAgZWxtLmFwcGVuZENoaWxkKHN2Zy5maXJzdENoaWxkKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoXFxuICAgICAgLy8gc2tpcCB0aGUgdXBkYXRlIGlmIG9sZCBhbmQgbmV3IFZET00gc3RhdGUgaXMgdGhlIHNhbWUuXFxuICAgICAgLy8gYHZhbHVlYCBpcyBoYW5kbGVkIHNlcGFyYXRlbHkgYmVjYXVzZSB0aGUgRE9NIHZhbHVlIG1heSBiZSB0ZW1wb3JhcmlseVxcbiAgICAgIC8vIG91dCBvZiBzeW5jIHdpdGggVkRPTSBzdGF0ZSBkdWUgdG8gZm9jdXMsIGNvbXBvc2l0aW9uIGFuZCBtb2RpZmllcnMuXFxuICAgICAgLy8gVGhpcyAgIzQ1MjEgYnkgc2tpcHBpbmcgdGhlIHVubmVjZXNhcnJ5IGBjaGVja2VkYCB1cGRhdGUuXFxuICAgICAgY3VyICE9PSBvbGRQcm9wc1trZXldXFxuICAgICkge1xcbiAgICAgIC8vIHNvbWUgcHJvcGVydHkgdXBkYXRlcyBjYW4gdGhyb3dcXG4gICAgICAvLyBlLmcuIGB2YWx1ZWAgb24gPHByb2dyZXNzPiB3LyBub24tZmluaXRlIHZhbHVlXFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGVsbVtrZXldID0gY3VyO1xcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXFxuXFxuXFxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcXG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxcbiAgICBlbG0udGFnTmFtZSA9PT0gJ09QVElPTicgfHxcXG4gICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcXG4gICAgaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBjaGVja1ZhbClcXG4gICkpXFxufVxcblxcbmZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5IChlbG0sIGNoZWNrVmFsKSB7XFxuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXFxuICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcXG4gIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcXG4gIC8vICM2MTU3XFxuICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcXG4gIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XFxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXFxufVxcblxcbmZ1bmN0aW9uIGlzRGlydHlXaXRoTW9kaWZpZXJzIChlbG0sIG5ld1ZhbCkge1xcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXFxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSkge1xcbiAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcXG4gICAgfVxcbiAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcXG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXFxufVxcblxcbnZhciBkb21Qcm9wcyA9IHtcXG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXFxufTtcXG5cXG4vKiAgKi9cXG5cXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcXG4gIHZhciByZXMgPSB7fTtcXG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcXFwpKS9nO1xcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcXG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xcbiAgICBpZiAoaXRlbSkge1xcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcXG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XFxuICAgIH1cXG4gIH0pO1xcbiAgcmV0dXJuIHJlc1xcbn0pO1xcblxcbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XFxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XFxuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcXG4gICAgOiBzdHlsZVxcbn1cXG5cXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcXG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcXG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcXG4gIH1cXG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxcbiAgfVxcbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxcbn1cXG5cXG4vKipcXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXFxuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcXG4gKi9cXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcXG4gIHZhciByZXMgPSB7fTtcXG4gIHZhciBzdHlsZURhdGE7XFxuXFxuICBpZiAoY2hlY2tDaGlsZCkge1xcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XFxuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcXG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xcbiAgICAgIGlmIChcXG4gICAgICAgIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSAmJlxcbiAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpXFxuICAgICAgKSB7XFxuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XFxuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XFxuICB9XFxuXFxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XFxuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiByZXNcXG59XFxuXFxuLyogICovXFxuXFxudmFyIGNzc1ZhclJFID0gL14tLS87XFxudmFyIGltcG9ydGFudFJFID0gL1xcXFxzKiFpbXBvcnRhbnQkLztcXG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XFxuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XFxuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShoeXBoZW5hdGUobmFtZSksIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcXG4gIH0gZWxzZSB7XFxuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xcbiAgICAgIC8vIFN1cHBvcnQgdmFsdWVzIGFycmF5IGNyZWF0ZWQgYnkgYXV0b3ByZWZpeGVyLCBlLmcuXFxuICAgICAgLy8ge2Rpc3BsYXk6IFtcXFwiLXdlYmtpdC1ib3hcXFwiLCBcXFwiLW1zLWZsZXhib3hcXFwiLCBcXFwiZmxleFxcXCJdfVxcbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcXG4gICAgfVxcbiAgfVxcbn07XFxuXFxudmFyIHZlbmRvck5hbWVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XFxuXFxudmFyIGVtcHR5U3R5bGU7XFxudmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XFxuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XFxuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gZW1wdHlTdHlsZSkpIHtcXG4gICAgcmV0dXJuIHByb3BcXG4gIH1cXG4gIHZhciBjYXBOYW1lID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBuYW1lID0gdmVuZG9yTmFtZXNbaV0gKyBjYXBOYW1lO1xcbiAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XFxuICAgICAgcmV0dXJuIG5hbWVcXG4gICAgfVxcbiAgfVxcbn0pO1xcblxcbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcXG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcXG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcXG5cXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXFxuICApIHtcXG4gICAgcmV0dXJuXFxuICB9XFxuXFxuICB2YXIgY3VyLCBuYW1lO1xcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xcbiAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcXG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xcblxcbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcXG5cXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcXG5cXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcXG4gIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtlbHkgd2FudHNcXG4gIC8vIHRvIG11dGF0ZSBpdC5cXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxcbiAgICA/IGV4dGVuZCh7fSwgc3R5bGUpXFxuICAgIDogc3R5bGU7XFxuXFxuICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XFxuXFxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcXG4gICAgaWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XFxuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xcbiAgICB9XFxuICB9XFxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcXG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XFxuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XFxuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG52YXIgc3R5bGUgPSB7XFxuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxcbn07XFxuXFxuLyogICovXFxuXFxudmFyIHdoaXRlc3BhY2VSRSA9IC9cXFxccysvO1xcblxcbi8qKlxcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxcbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxcbiAqL1xcbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcXG4gICAgcmV0dXJuXFxuICB9XFxuXFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xcbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XFxuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICB2YXIgY3VyID0gXFxcIiBcXFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcXFwiIFxcXCI7XFxuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xcbiAgICB9XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxcbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxcbiAqL1xcbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcXG4gICAgcmV0dXJuXFxuICB9XFxuXFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xcbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XFxuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xcbiAgICB9XFxuICAgIGlmICghZWwuY2xhc3NMaXN0Lmxlbmd0aCkge1xcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgdmFyIGN1ciA9IFxcXCIgXFxcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXFxcIiBcXFwiO1xcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XFxuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xcbiAgICB9XFxuICAgIGN1ciA9IGN1ci50cmltKCk7XFxuICAgIGlmIChjdXIpIHtcXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZiQkMSkge1xcbiAgaWYgKCFkZWYkJDEpIHtcXG4gICAgcmV0dXJuXFxuICB9XFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xcbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XFxuICAgIHZhciByZXMgPSB7fTtcXG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XFxuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XFxuICAgIH1cXG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcXG4gICAgcmV0dXJuIHJlc1xcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmJCQxID09PSAnc3RyaW5nJykge1xcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxcbiAgfVxcbn1cXG5cXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcXG4gIHJldHVybiB7XFxuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXFxcIi1lbnRlclxcXCIpLFxcbiAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXFxcIi1lbnRlci10b1xcXCIpLFxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFxcXCItZW50ZXItYWN0aXZlXFxcIiksXFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXFxcIi1sZWF2ZVxcXCIpLFxcbiAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXFxcIi1sZWF2ZS10b1xcXCIpLFxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFxcXCItbGVhdmUtYWN0aXZlXFxcIilcXG4gIH1cXG59KTtcXG5cXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XFxudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XFxudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xcblxcbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XFxudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcXG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xcbmlmIChoYXNUcmFuc2l0aW9uKSB7XFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXFxuICApIHtcXG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XFxuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcXG4gIH1cXG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxcbiAgKSB7XFxuICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcXG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcXG4gIH1cXG59XFxuXFxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXFxudmFyIHJhZiA9IGluQnJvd3NlclxcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXFxuICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcXG4gICAgOiBzZXRUaW1lb3V0XFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcXG5cXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XFxuICByYWYoZnVuY3Rpb24gKCkge1xcbiAgICByYWYoZm4pO1xcbiAgfSk7XFxufVxcblxcbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XFxuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xcbiAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XFxuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcXG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcXG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcXG4gIH1cXG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xcbn1cXG5cXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxcbiAgZWwsXFxuICBleHBlY3RlZFR5cGUsXFxuICBjYlxcbikge1xcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcXG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XFxuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcXG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XFxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XFxuICB2YXIgZW5kZWQgPSAwO1xcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xcbiAgICBjYigpO1xcbiAgfTtcXG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XFxuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcXG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcXG4gICAgICAgIGVuZCgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcXG4gICAgICBlbmQoKTtcXG4gICAgfVxcbiAgfSwgdGltZW91dCArIDEpO1xcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xcbn1cXG5cXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxcXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XFxuXFxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcXG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XFxuICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXFxuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XFxuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXSB8fCAnJykuc3BsaXQoJywgJyk7XFxuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcXG4gIHZhciBhbmltYXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXSB8fCAnJykuc3BsaXQoJywgJyk7XFxuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xcblxcbiAgdmFyIHR5cGU7XFxuICB2YXIgdGltZW91dCA9IDA7XFxuICB2YXIgcHJvcENvdW50ID0gMDtcXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XFxuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XFxuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xcbiAgICB9XFxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XFxuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XFxuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XFxuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcXG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcXG4gICAgICAgID8gVFJBTlNJVElPTlxcbiAgICAgICAgOiBBTklNQVRJT05cXG4gICAgICA6IG51bGw7XFxuICAgIHByb3BDb3VudCA9IHR5cGVcXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxcbiAgICAgIDogMDtcXG4gIH1cXG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxcbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXFxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xcbiAgcmV0dXJuIHtcXG4gICAgdHlwZTogdHlwZSxcXG4gICAgdGltZW91dDogdGltZW91dCxcXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xcbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XFxuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcXG4gIH1cXG5cXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XFxuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXFxuICB9KSlcXG59XFxuXFxuLy8gT2xkIHZlcnNpb25zIG9mIENocm9taXVtIChiZWxvdyA2MS4wLjMxNjMuMTAwKSBmb3JtYXRzIGZsb2F0aW5nIHBvaW50ZXIgbnVtYmVyc1xcbi8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cXG4vLyBJZiBjb21tYSBpcyBub3QgcmVwbGFjZWQgd2l0aCBhIGRvdCwgdGhlIGlucHV0IHdpbGwgYmUgcm91bmRlZCBkb3duIChpLmUuIGFjdGluZ1xcbi8vIGFzIGEgZmxvb3IgZnVuY3Rpb24pIGNhdXNpbmcgdW5leHBlY3RlZCBiZWhhdmlvcnNcXG5mdW5jdGlvbiB0b01zIChzKSB7XFxuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoJywnLCAnLicpKSAqIDEwMDBcXG59XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XFxuICB2YXIgZWwgPSB2bm9kZS5lbG07XFxuXFxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xcbiAgICBlbC5fbGVhdmVDYigpO1xcbiAgfVxcblxcbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcXG4gICAgcmV0dXJuXFxuICB9XFxuXFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcXG4gICAgcmV0dXJuXFxuICB9XFxuXFxuICB2YXIgY3NzID0gZGF0YS5jc3M7XFxuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcXG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XFxuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XFxuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcXG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XFxuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcXG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XFxuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XFxuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XFxuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcXG5cXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxcbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcXG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcXG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcXG4gICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XFxuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xcbiAgfVxcblxcbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xcblxcbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xcbiAgICByZXR1cm5cXG4gIH1cXG5cXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcXG4gICAgPyBhcHBlYXJDbGFzc1xcbiAgICA6IGVudGVyQ2xhc3M7XFxuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXFxuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcXG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xcbiAgICA/IGFwcGVhclRvQ2xhc3NcXG4gICAgOiBlbnRlclRvQ2xhc3M7XFxuXFxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxcbiAgICA6IGJlZm9yZUVudGVyO1xcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXFxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcXG4gICAgOiBlbnRlcjtcXG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXFxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXFxuICAgIDogYWZ0ZXJFbnRlcjtcXG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXFxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XFxuXFxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcXG4gICAgICA6IGR1cmF0aW9uXFxuICApO1xcblxcbiAgaWYgKCB0cnVlICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XFxuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XFxuICB9XFxuXFxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XFxuXFxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoZXhwZWN0c0NTUykge1xcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XFxuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XFxuICAgIH1cXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XFxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xcbiAgICAgIH1cXG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XFxuICAgIH1cXG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xcbiAgfSk7XFxuXFxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcXG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxcbiAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxcbiAgICAgICkge1xcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XFxuICAgICAgfVxcbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXFxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcXG4gIGlmIChleHBlY3RzQ1NTKSB7XFxuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XFxuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XFxuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcXG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XFxuICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcXG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XFxuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxuXFxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XFxuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XFxuICB9XFxuXFxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcXG4gICAgY2IoKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xcblxcbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcXG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcXG4gICAgZWwuX2VudGVyQ2IoKTtcXG4gIH1cXG5cXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcXG4gIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XFxuICAgIHJldHVybiBybSgpXFxuICB9XFxuXFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcXG4gICAgcmV0dXJuXFxuICB9XFxuXFxuICB2YXIgY3NzID0gZGF0YS5jc3M7XFxuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcXG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XFxuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcXG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcXG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcXG5cXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XFxuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xcblxcbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxcbiAgICBpc09iamVjdChkdXJhdGlvbilcXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXFxuICAgICAgOiBkdXJhdGlvblxcbiAgKTtcXG5cXG4gIGlmICggdHJ1ZSAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XFxuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XFxuICB9XFxuXFxuICB2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XFxuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcXG4gICAgfVxcbiAgICBpZiAoZXhwZWN0c0NTUykge1xcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcXG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xcbiAgICB9XFxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcXG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcXG4gICAgICB9XFxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJtKCk7XFxuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcXG4gICAgfVxcbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XFxuICB9KTtcXG5cXG4gIGlmIChkZWxheUxlYXZlKSB7XFxuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcXG4gIH0gZWxzZSB7XFxuICAgIHBlcmZvcm1MZWF2ZSgpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcXG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XFxuICAgICAgcmV0dXJuXFxuICAgIH1cXG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdyAmJiBlbC5wYXJlbnROb2RlKSB7XFxuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xcbiAgICB9XFxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcXG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcXG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XFxuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XFxuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xcbiAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XFxuICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xcbiAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcXG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XFxuICAgICAgY2IoKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XFxuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcXG4gICAgd2FybihcXG4gICAgICBcXFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFxcXCIgKyBuYW1lICsgXFxcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcXFwiICtcXG4gICAgICBcXFwiZ290IFxcXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcXFwiLlxcXCIsXFxuICAgICAgdm5vZGUuY29udGV4dFxcbiAgICApO1xcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XFxuICAgIHdhcm4oXFxuICAgICAgXFxcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcXFwiICsgbmFtZSArIFxcXCIgZHVyYXRpb24gaXMgTmFOIC0gXFxcIiArXFxuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxcbiAgICAgIHZub2RlLmNvbnRleHRcXG4gICAgKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcXG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxcbn1cXG5cXG4vKipcXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcXG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXFxuICovXFxuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcXG4gIGlmIChpc1VuZGVmKGZuKSkge1xcbiAgICByZXR1cm4gZmFsc2VcXG4gIH1cXG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XFxuICAgIC8vIGludm9rZXJcXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxcbiAgICAgICAgPyBpbnZva2VyRm5zWzBdXFxuICAgICAgICA6IGludm9rZXJGbnNcXG4gICAgKVxcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcXG4gIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcXG4gICAgZW50ZXIodm5vZGUpO1xcbiAgfVxcbn1cXG5cXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcXG4gIGNyZWF0ZTogX2VudGVyLFxcbiAgYWN0aXZhdGU6IF9lbnRlcixcXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcm0oKTtcXG4gICAgfVxcbiAgfVxcbn0gOiB7fTtcXG5cXG52YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xcbiAgYXR0cnMsXFxuICBrbGFzcyxcXG4gIGV2ZW50cyxcXG4gIGRvbVByb3BzLFxcbiAgc3R5bGUsXFxuICB0cmFuc2l0aW9uXFxuXTtcXG5cXG4vKiAgKi9cXG5cXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxcbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XFxuXFxudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XFxuXFxuLyoqXFxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXFxuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cXG4gKi9cXG5cXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG5pZiAoaXNJRTkpIHtcXG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XFxuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XFxuICAgIH1cXG4gIH0pO1xcbn1cXG5cXG52YXIgZGlyZWN0aXZlID0ge1xcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XFxuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XFxuICAgICAgLy8gIzY5MDNcXG4gICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XFxuICAgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XFxuICAgICAgfVxcbiAgICAgIGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcXG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XFxuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcXG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcXG4gICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcXG4gICAgICAgIC8vIGZpcmVzIFxcXCJjaGFuZ2VcXFwiIGluc3RlYWQgb2YgXFxcImlucHV0XFxcIiBvbiBhdXRvY29tcGxldGUuXFxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgICAgICAgaWYgKGlzSUU5KSB7XFxuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9LFxcblxcbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XFxuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XFxuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cXG4gICAgICB2YXIgcHJldk9wdGlvbnMgPSBlbC5fdk9wdGlvbnM7XFxuICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XFxuICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pOyB9KSkge1xcbiAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXFxuICAgICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcXG4gICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucyk7IH0pXFxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xcbiAgICAgICAgaWYgKG5lZWRSZXNldCkge1xcbiAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufTtcXG5cXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XFxuICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XFxuICAgIH0sIDApO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBhY3R1YWxseVNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcXG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XFxuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XFxuICAgICB0cnVlICYmIHdhcm4oXFxuICAgICAgXFxcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFxcXFxcIlxcXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFxcXCJcXFxcXFxcIj4gXFxcIiArXFxuICAgICAgXFxcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFxcXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxcbiAgICAgIHZtXFxuICAgICk7XFxuICAgIHJldHVyblxcbiAgfVxcbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XFxuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XFxuICAgIGlmIChpc011bHRpcGxlKSB7XFxuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XFxuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcXG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcXG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XFxuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuXFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICBpZiAoIWlzTXVsdGlwbGUpIHtcXG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xcbiAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoZnVuY3Rpb24gKG8pIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHZhbHVlKTsgfSlcXG59XFxuXFxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxcbiAgICA/IG9wdGlvbi5fdmFsdWVcXG4gICAgOiBvcHRpb24udmFsdWVcXG59XFxuXFxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XFxuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xcbn1cXG5cXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XFxuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxcbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cXG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XFxufVxcblxcbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XFxuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XFxuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcXG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XFxufVxcblxcbi8qICAqL1xcblxcbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcXG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxcbiAgICA6IHZub2RlXFxufVxcblxcbnZhciBzaG93ID0ge1xcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcXG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xcblxcbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cXG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XFxuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxKSB7XFxuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcXG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XFxuICAgIH1cXG4gIH0sXFxuXFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcXG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XFxuXFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHsgcmV0dXJuIH1cXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcXG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcXG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcXG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xcbiAgICAgIGlmICh2YWx1ZSkge1xcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcXG4gICAgfVxcbiAgfSxcXG5cXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcXG4gICAgZWwsXFxuICAgIGJpbmRpbmcsXFxuICAgIHZub2RlLFxcbiAgICBvbGRWbm9kZSxcXG4gICAgaXNEZXN0cm95XFxuICApIHtcXG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcXG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xcbiAgICB9XFxuICB9XFxufTtcXG5cXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xcbiAgbW9kZWw6IGRpcmVjdGl2ZSxcXG4gIHNob3c6IHNob3dcXG59O1xcblxcbi8qICAqL1xcblxcbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XFxuICBuYW1lOiBTdHJpbmcsXFxuICBhcHBlYXI6IEJvb2xlYW4sXFxuICBjc3M6IEJvb2xlYW4sXFxuICBtb2RlOiBTdHJpbmcsXFxuICB0eXBlOiBTdHJpbmcsXFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXFxufTtcXG5cXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cXG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcXG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XFxuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XFxuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gdm5vZGVcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XFxuICB2YXIgZGF0YSA9IHt9O1xcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xcbiAgLy8gcHJvcHNcXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XFxuICB9XFxuICAvLyBldmVudHMuXFxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XFxuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcXG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcXG4gIH1cXG4gIHJldHVybiBkYXRhXFxufVxcblxcbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xcbiAgaWYgKC9cXFxcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XFxuICAgIHJldHVybiBoKCdrZWVwLWFsaXZlJywge1xcbiAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxcbiAgICB9KVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcXG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xcbiAgICAgIHJldHVybiB0cnVlXFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXFxufVxcblxcbnZhciBpc05vdFRleHROb2RlID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKTsgfTtcXG5cXG52YXIgaXNWU2hvd0RpcmVjdGl2ZSA9IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfTtcXG5cXG52YXIgVHJhbnNpdGlvbiA9IHtcXG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXFxuICBhYnN0cmFjdDogdHJ1ZSxcXG5cXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xcbiAgICBpZiAoIWNoaWxkcmVuKSB7XFxuICAgICAgcmV0dXJuXFxuICAgIH1cXG5cXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoaXNOb3RUZXh0Tm9kZSk7XFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xcbiAgICAgIHJldHVyblxcbiAgICB9XFxuXFxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcXG4gICAgaWYgKCB0cnVlICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcXG4gICAgICB3YXJuKFxcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXFxuICAgICAgICB0aGlzLiRwYXJlbnRcXG4gICAgICApO1xcbiAgICB9XFxuXFxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xcblxcbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxcbiAgICBpZiAoIHRydWUgJiZcXG4gICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXFxuICAgICkge1xcbiAgICAgIHdhcm4oXFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXFxuICAgICAgICB0aGlzLiRwYXJlbnRcXG4gICAgICApO1xcbiAgICB9XFxuXFxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xcblxcbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXFxuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxcbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcXG4gICAgICByZXR1cm4gcmF3Q2hpbGRcXG4gICAgfVxcblxcbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gICAgaWYgKCFjaGlsZCkge1xcbiAgICAgIHJldHVybiByYXdDaGlsZFxcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XFxuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxcbiAgICB9XFxuXFxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXFxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxcbiAgICB2YXIgaWQgPSBcXFwiX190cmFuc2l0aW9uLVxcXCIgKyAodGhpcy5fdWlkKSArIFxcXCItXFxcIjtcXG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxcbiAgICAgICAgPyBpZCArICdjb21tZW50J1xcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcXG4gICAgICAgIDogY2hpbGQua2V5O1xcblxcbiAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcXG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcXG5cXG4gICAgLy8gbWFyayB2LXNob3dcXG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXFxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoaXNWU2hvd0RpcmVjdGl2ZSkpIHtcXG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xcbiAgICB9XFxuXFxuICAgIGlmIChcXG4gICAgICBvbGRDaGlsZCAmJlxcbiAgICAgIG9sZENoaWxkLmRhdGEgJiZcXG4gICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpICYmXFxuICAgICAgLy8gIzY2ODcgY29tcG9uZW50IHJvb3QgaXMgYSBjb21tZW50IG5vZGVcXG4gICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmIG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZS5pc0NvbW1lbnQpXFxuICAgICkge1xcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XFxuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxcbiAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXFxuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcXG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcXG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXFxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xcbiAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcXG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXFxuICAgICAgICB9XFxuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XFxuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XFxuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gcmF3Q2hpbGRcXG4gIH1cXG59O1xcblxcbi8qICAqL1xcblxcbnZhciBwcm9wcyA9IGV4dGVuZCh7XFxuICB0YWc6IFN0cmluZyxcXG4gIG1vdmVDbGFzczogU3RyaW5nXFxufSwgdHJhbnNpdGlvblByb3BzKTtcXG5cXG5kZWxldGUgcHJvcHMubW9kZTtcXG5cXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xcbiAgcHJvcHM6IHByb3BzLFxcblxcbiAgYmVmb3JlTW91bnQ6IGZ1bmN0aW9uIGJlZm9yZU1vdW50ICgpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgIHZhciB1cGRhdGUgPSB0aGlzLl91cGRhdGU7XFxuICAgIHRoaXMuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XFxuICAgICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHRoaXMkMSk7XFxuICAgICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xcbiAgICAgIHRoaXMkMS5fX3BhdGNoX18oXFxuICAgICAgICB0aGlzJDEuX3Zub2RlLFxcbiAgICAgICAgdGhpcyQxLmtlcHQsXFxuICAgICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXFxuICAgICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcXG4gICAgICApO1xcbiAgICAgIHRoaXMkMS5fdm5vZGUgPSB0aGlzJDEua2VwdDtcXG4gICAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcXG4gICAgICB1cGRhdGUuY2FsbCh0aGlzJDEsIHZub2RlLCBoeWRyYXRpbmcpO1xcbiAgICB9O1xcbiAgfSxcXG5cXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XFxuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XFxuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XFxuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcXG5cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XFxuICAgICAgaWYgKGMudGFnKSB7XFxuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XFxuICAgICAgICB9IGVsc2UgaWYgKHRydWUpIHtcXG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XFxuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xcbiAgICAgICAgICB3YXJuKChcXFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcXFwiICsgbmFtZSArIFxcXCI+XFxcIikpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XFxuICAgICAgdmFyIGtlcHQgPSBbXTtcXG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XFxuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XFxuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XFxuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XFxuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxcbiAgfSxcXG5cXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcXG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcXG4gICAgICByZXR1cm5cXG4gICAgfVxcblxcbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXFxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcXG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcXG5cXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXFxuICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXFxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxcbiAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcXG5cXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcXG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcXG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcXG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xcbiAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcXG4gICAgICAgICAgICByZXR1cm5cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XFxuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcXG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcXG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9LFxcblxcbiAgbWV0aG9kczoge1xcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2VcXG4gICAgICB9XFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXFxuICAgICAgfVxcbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcXG4gICAgICAvLyBpcyBhcHBsaWVkLlxcbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcXG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xcbiAgICAgIH1cXG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcXG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcXG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcXG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XFxuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXFxuICAgIH1cXG4gIH1cXG59O1xcblxcbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XFxuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcXG4gIH1cXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XFxuICAgIGMuZWxtLl9lbnRlckNiKCk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XFxuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxufVxcblxcbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcXG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XFxuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XFxuICBpZiAoZHggfHwgZHkpIHtcXG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcXG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcXG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFxcXCJ0cmFuc2xhdGUoXFxcIiArIGR4ICsgXFxcInB4LFxcXCIgKyBkeSArIFxcXCJweClcXFwiO1xcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XFxuICB9XFxufVxcblxcbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XFxuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcXG59O1xcblxcbi8qICAqL1xcblxcbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcXG5WdWUuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XFxuVnVlLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcXG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XFxuVnVlLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XFxuVnVlLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcXG5cXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcXG5leHRlbmQoVnVlLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcXG5leHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcXG5cXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXFxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XFxuXFxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxcbiAgZWwsXFxuICBoeWRyYXRpbmdcXG4pIHtcXG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXFxufTtcXG5cXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXFxuaWYgKGluQnJvd3Nlcikge1xcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcXG4gICAgICBpZiAoZGV2dG9vbHMpIHtcXG4gICAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUpO1xcbiAgICAgIH0gZWxzZSBpZiAoXFxuICAgICAgICB0cnVlXFxuICAgICAgKSB7XFxuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcXG4gICAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcXFxuJyArXFxuICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJ1xcbiAgICAgICAgKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKCB0cnVlICYmXFxuICAgICAgY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXFxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXFxuICAgICkge1xcbiAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxcbiAgICAgICAgXFxcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXFxcblxcXCIgK1xcbiAgICAgICAgXFxcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXFxcblxcXCIgK1xcbiAgICAgICAgXFxcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXFxcIlxcbiAgICAgICk7XFxuICAgIH1cXG4gIH0sIDApO1xcbn1cXG5cXG4vKiAgKi9cXG5cXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xcXFx7XFxcXHsoKD86LnxcXFxccj9cXFxcbikrPylcXFxcfVxcXFx9L2c7XFxudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXFxcXVxcXFwvXFxcXFxcXFxdL2c7XFxuXFxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcXG4gIHZhciBvcGVuID0gZGVsaW1pdGVyc1swXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcXFxcXCQmJyk7XFxuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFxcXFxcJCYnKTtcXG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxcbn0pO1xcblxcblxcblxcbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXFxuICB0ZXh0LFxcbiAgZGVsaW1pdGVyc1xcbikge1xcbiAgdmFyIHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XFxuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcXG4gICAgcmV0dXJuXFxuICB9XFxuICB2YXIgdG9rZW5zID0gW107XFxuICB2YXIgcmF3VG9rZW5zID0gW107XFxuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcXG4gIHZhciBtYXRjaCwgaW5kZXgsIHRva2VuVmFsdWU7XFxuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcXG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcXG4gICAgLy8gcHVzaCB0ZXh0IHRva2VuXFxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xcbiAgICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKTtcXG4gICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XFxuICAgIH1cXG4gICAgLy8gdGFnIHRva2VuXFxuICAgIHZhciBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcXG4gICAgdG9rZW5zLnB1c2goKFxcXCJfcyhcXFwiICsgZXhwICsgXFxcIilcXFwiKSk7XFxuICAgIHJhd1Rva2Vucy5wdXNoKHsgJ0BiaW5kaW5nJzogZXhwIH0pO1xcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcXG4gIH1cXG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xcbiAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgpKTtcXG4gICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xcbiAgfVxcbiAgcmV0dXJuIHtcXG4gICAgZXhwcmVzc2lvbjogdG9rZW5zLmpvaW4oJysnKSxcXG4gICAgdG9rZW5zOiByYXdUb2tlbnNcXG4gIH1cXG59XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcXG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xcbiAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XFxuICBpZiAoIHRydWUgJiYgc3RhdGljQ2xhc3MpIHtcXG4gICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcXG4gICAgaWYgKHJlcykge1xcbiAgICAgIHdhcm4oXFxuICAgICAgICBcXFwiY2xhc3M9XFxcXFxcXCJcXFwiICsgc3RhdGljQ2xhc3MgKyBcXFwiXFxcXFxcXCI6IFxcXCIgK1xcbiAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXFxuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XFxcInt7IHZhbCB9fVxcXCI+LCB1c2UgPGRpdiA6Y2xhc3M9XFxcInZhbFxcXCI+LicsXFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnY2xhc3MnXVxcbiAgICAgICk7XFxuICAgIH1cXG4gIH1cXG4gIGlmIChzdGF0aWNDbGFzcykge1xcbiAgICBlbC5zdGF0aWNDbGFzcyA9IEpTT04uc3RyaW5naWZ5KHN0YXRpY0NsYXNzKTtcXG4gIH1cXG4gIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcXG4gIGlmIChjbGFzc0JpbmRpbmcpIHtcXG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBnZW5EYXRhIChlbCkge1xcbiAgdmFyIGRhdGEgPSAnJztcXG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xcbiAgICBkYXRhICs9IFxcXCJzdGF0aWNDbGFzczpcXFwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFxcXCIsXFxcIjtcXG4gIH1cXG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcXG4gICAgZGF0YSArPSBcXFwiY2xhc3M6XFxcIiArIChlbC5jbGFzc0JpbmRpbmcpICsgXFxcIixcXFwiO1xcbiAgfVxcbiAgcmV0dXJuIGRhdGFcXG59XFxuXFxudmFyIGtsYXNzJDEgPSB7XFxuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxcbiAgZ2VuRGF0YTogZ2VuRGF0YVxcbn07XFxuXFxuLyogICovXFxuXFxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XFxuICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcXG4gIGlmIChzdGF0aWNTdHlsZSkge1xcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gICAgaWYgKHRydWUpIHtcXG4gICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xcbiAgICAgIGlmIChyZXMpIHtcXG4gICAgICAgIHdhcm4oXFxuICAgICAgICAgIFxcXCJzdHlsZT1cXFxcXFxcIlxcXCIgKyBzdGF0aWNTdHlsZSArIFxcXCJcXFxcXFxcIjogXFxcIiArXFxuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcXG4gICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBzdHlsZT1cXFwie3sgdmFsIH19XFxcIj4sIHVzZSA8ZGl2IDpzdHlsZT1cXFwidmFsXFxcIj4uJyxcXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3N0eWxlJ11cXG4gICAgICAgICk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcXG4gIH1cXG5cXG4gIHZhciBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcXG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcXG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBnZW5EYXRhJDEgKGVsKSB7XFxuICB2YXIgZGF0YSA9ICcnO1xcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XFxuICAgIGRhdGEgKz0gXFxcInN0YXRpY1N0eWxlOlxcXCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXFxcIixcXFwiO1xcbiAgfVxcbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xcbiAgICBkYXRhICs9IFxcXCJzdHlsZTooXFxcIiArIChlbC5zdHlsZUJpbmRpbmcpICsgXFxcIiksXFxcIjtcXG4gIH1cXG4gIHJldHVybiBkYXRhXFxufVxcblxcbnZhciBzdHlsZSQxID0ge1xcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxcbiAgZ2VuRGF0YTogZ2VuRGF0YSQxXFxufTtcXG5cXG4vKiAgKi9cXG5cXG52YXIgZGVjb2RlcjtcXG5cXG52YXIgaGUgPSB7XFxuICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZSAoaHRtbCkge1xcbiAgICBkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xcbiAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudFxcbiAgfVxcbn07XFxuXFxuLyogICovXFxuXFxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxcbiAgJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsZnJhbWUsaHIsaW1nLGlucHV0LGlzaW5kZXgsa2V5Z2VuLCcgK1xcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xcbik7XFxuXFxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXFxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxcbnZhciBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xcbik7XFxuXFxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxcbnZhciBpc05vblBocmFzaW5nVGFnID0gbWFrZU1hcChcXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXFxuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xcbiAgJ2gxLGgyLGgzLGg0LGg1LGg2LGhlYWQsaGVhZGVyLGhncm91cCxocixodG1sLGxlZ2VuZCxsaSxtZW51aXRlbSxtZXRhLCcgK1xcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcXG4gICd0aXRsZSx0cix0cmFjaydcXG4pO1xcblxcbi8qKlxcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGl0J3MgbW9zdGx5IHZlbmRvciBjb2RlLlxcbiAqL1xcblxcbi8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xcbnZhciBhdHRyaWJ1dGUgPSAvXlxcXFxzKihbXlxcXFxzXFxcIic8PlxcXFwvPV0rKSg/OlxcXFxzKig9KVxcXFxzKig/OlxcXCIoW15cXFwiXSopXFxcIit8JyhbXiddKiknK3woW15cXFxcc1xcXCInPTw+YF0rKSkpPy87XFxudmFyIGR5bmFtaWNBcmdBdHRyaWJ1dGUgPSAvXlxcXFxzKigoPzp2LVtcXFxcdy1dKzp8QHw6fCMpXFxcXFtbXj1dK1xcXFxdW15cXFxcc1xcXCInPD5cXFxcLz1dKikoPzpcXFxccyooPSlcXFxccyooPzpcXFwiKFteXFxcIl0qKVxcXCIrfCcoW14nXSopJyt8KFteXFxcXHNcXFwiJz08PmBdKykpKT8vO1xcbnZhciBuY25hbWUgPSBcXFwiW2EtekEtWl9dW1xcXFxcXFxcLVxcXFxcXFxcLjAtOV9hLXpBLVpcXFwiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFxcXCJdKlxcXCI7XFxudmFyIHFuYW1lQ2FwdHVyZSA9IFxcXCIoKD86XFxcIiArIG5jbmFtZSArIFxcXCJcXFxcXFxcXDopP1xcXCIgKyBuY25hbWUgKyBcXFwiKVxcXCI7XFxudmFyIHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoKFxcXCJePFxcXCIgKyBxbmFtZUNhcHR1cmUpKTtcXG52YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxcXHMqKFxcXFwvPyk+LztcXG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgoXFxcIl48XFxcXFxcXFwvXFxcIiArIHFuYW1lQ2FwdHVyZSArIFxcXCJbXj5dKj5cXFwiKSk7XFxudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcXG4vLyAjNzI5ODogZXNjYXBlIC0gdG8gYXZvaWQgYmVpbmcgcGFzZWQgYXMgSFRNTCBjb21tZW50IHdoZW4gaW5saW5lZCBpbiBwYWdlXFxudmFyIGNvbW1lbnQgPSAvXjwhXFxcXC0tLztcXG52YXIgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcXFxbLztcXG5cXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XFxudmFyIHJlQ2FjaGUgPSB7fTtcXG5cXG52YXIgZGVjb2RpbmdNYXAgPSB7XFxuICAnJmx0Oyc6ICc8JyxcXG4gICcmZ3Q7JzogJz4nLFxcbiAgJyZxdW90Oyc6ICdcXFwiJyxcXG4gICcmYW1wOyc6ICcmJyxcXG4gICcmIzEwOyc6ICdcXFxcbicsXFxuICAnJiM5Oyc6ICdcXFxcdCcsXFxuICAnJiMzOTsnOiBcXFwiJ1xcXCJcXG59O1xcbnZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5KTsvZztcXG52YXIgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMzOXwjMTB8IzkpOy9nO1xcblxcbi8vICM1OTkyXFxudmFyIGlzSWdub3JlTmV3bGluZVRhZyA9IG1ha2VNYXAoJ3ByZSx0ZXh0YXJlYScsIHRydWUpO1xcbnZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcXFxuJzsgfTtcXG5cXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcXG4gIHZhciByZSA9IHNob3VsZERlY29kZU5ld2xpbmVzID8gZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgOiBlbmNvZGVkQXR0cjtcXG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcXG59XFxuXFxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XFxuICB2YXIgc3RhY2sgPSBbXTtcXG4gIHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XFxuICB2YXIgY2FuQmVMZWZ0T3BlblRhZyQkMSA9IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyB8fCBubztcXG4gIHZhciBpbmRleCA9IDA7XFxuICB2YXIgbGFzdCwgbGFzdFRhZztcXG4gIHdoaWxlIChodG1sKSB7XFxuICAgIGxhc3QgPSBodG1sO1xcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxcbiAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xcbiAgICAgIHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XFxuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcXG4gICAgICAgIC8vIENvbW1lbnQ6XFxuICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XFxuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcXG5cXG4gICAgICAgICAgaWYgKGNvbW1lbnRFbmQgPj0gMCkge1xcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XFxuICAgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgY29tbWVudEVuZCksIGluZGV4LCBpbmRleCArIGNvbW1lbnRFbmQgKyAzKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XFxuICAgICAgICAgICAgY29udGludWVcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XFxuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcXG4gICAgICAgICAgdmFyIGNvbmRpdGlvbmFsRW5kID0gaHRtbC5pbmRleE9mKCddPicpO1xcblxcbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xcbiAgICAgICAgICAgIGFkdmFuY2UoY29uZGl0aW9uYWxFbmQgKyAyKTtcXG4gICAgICAgICAgICBjb250aW51ZVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBEb2N0eXBlOlxcbiAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XFxuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XFxuICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XFxuICAgICAgICAgIGNvbnRpbnVlXFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBFbmQgdGFnOlxcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xcbiAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XFxuICAgICAgICAgIHZhciBjdXJJbmRleCA9IGluZGV4O1xcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XFxuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xcbiAgICAgICAgICBjb250aW51ZVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gU3RhcnQgdGFnOlxcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XFxuICAgICAgICBpZiAoc3RhcnRUYWdNYXRjaCkge1xcbiAgICAgICAgICBoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcXG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFydFRhZ01hdGNoLnRhZ05hbWUsIGh0bWwpKSB7XFxuICAgICAgICAgICAgYWR2YW5jZSgxKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBjb250aW51ZVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0ID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcXG4gICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XFxuICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcXG4gICAgICAgIHdoaWxlIChcXG4gICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QpICYmXFxuICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0KSAmJlxcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QpICYmXFxuICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0KVxcbiAgICAgICAgKSB7XFxuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XFxuICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcXG4gICAgICAgICAgaWYgKG5leHQgPCAwKSB7IGJyZWFrIH1cXG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xcbiAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XFxuICAgICAgICB0ZXh0ID0gaHRtbDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRleHQpIHtcXG4gICAgICAgIGFkdmFuY2UodGV4dC5sZW5ndGgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XFxuICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQsIGluZGV4IC0gdGV4dC5sZW5ndGgsIGluZGV4KTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XFxuICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxcXFxcc1xcXFxcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZyArICdbXj5dKj4pJywgJ2knKSk7XFxuICAgICAgdmFyIHJlc3QkMSA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcXG4gICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcXG4gICAgICAgICAgdGV4dCA9IHRleHRcXG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFxcLS0oW1xcXFxzXFxcXFNdKj8pLS0+L2csICckMScpIC8vICM3Mjk4XFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFxcXFtDREFUQVxcXFxbKFtcXFxcc1xcXFxTXSo/KV1dPi9nLCAnJDEnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhY2tlZFRhZywgdGV4dCkpIHtcXG4gICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xcbiAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuICcnXFxuICAgICAgfSk7XFxuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0JDEubGVuZ3RoO1xcbiAgICAgIGh0bWwgPSByZXN0JDE7XFxuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcXG4gICAgfVxcblxcbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcXG4gICAgICBpZiAoIHRydWUgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcXG4gICAgICAgIG9wdGlvbnMud2FybigoXFxcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcXFxcXCJcXFwiICsgaHRtbCArIFxcXCJcXFxcXFxcIlxcXCIpLCB7IHN0YXJ0OiBpbmRleCArIGh0bWwubGVuZ3RoIH0pO1xcbiAgICAgIH1cXG4gICAgICBicmVha1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcXG4gIHBhcnNlRW5kVGFnKCk7XFxuXFxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XFxuICAgIGluZGV4ICs9IG47XFxuICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcgKCkge1xcbiAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XFxuICAgIGlmIChzdGFydCkge1xcbiAgICAgIHZhciBtYXRjaCA9IHtcXG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxcbiAgICAgICAgYXR0cnM6IFtdLFxcbiAgICAgICAgc3RhcnQ6IGluZGV4XFxuICAgICAgfTtcXG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XFxuICAgICAgdmFyIGVuZCwgYXR0cjtcXG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goZHluYW1pY0FyZ0F0dHJpYnV0ZSkgfHwgaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xcbiAgICAgICAgYXR0ci5zdGFydCA9IGluZGV4O1xcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XFxuICAgICAgICBhdHRyLmVuZCA9IGluZGV4O1xcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGVuZCkge1xcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcXG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XFxuICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcXG4gICAgICAgIHJldHVybiBtYXRjaFxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcgKG1hdGNoKSB7XFxuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcXG4gICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xcblxcbiAgICBpZiAoZXhwZWN0SFRNTCkge1xcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xcbiAgICAgICAgcGFyc2VFbmRUYWcobGFzdFRhZyk7XFxuICAgICAgfVxcbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcXG4gICAgICAgIHBhcnNlRW5kVGFnKHRhZ05hbWUpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8ICEhdW5hcnlTbGFzaDtcXG5cXG4gICAgdmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XFxuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcXG4gICAgICB2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xcbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xcbiAgICAgIHZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IHRhZ05hbWUgPT09ICdhJyAmJiBhcmdzWzFdID09PSAnaHJlZidcXG4gICAgICAgID8gb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWZcXG4gICAgICAgIDogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcztcXG4gICAgICBhdHRyc1tpXSA9IHtcXG4gICAgICAgIG5hbWU6IGFyZ3NbMV0sXFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cih2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpXFxuICAgICAgfTtcXG4gICAgICBpZiAoIHRydWUgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xcbiAgICAgICAgYXR0cnNbaV0uc3RhcnQgPSBhcmdzLnN0YXJ0ICsgYXJnc1swXS5tYXRjaCgvXlxcXFxzKi8pLmxlbmd0aDtcXG4gICAgICAgIGF0dHJzW2ldLmVuZCA9IGFyZ3MuZW5kO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoIXVuYXJ5KSB7XFxuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMsIHN0YXJ0OiBtYXRjaC5zdGFydCwgZW5kOiBtYXRjaC5lbmQgfSk7XFxuICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XFxuICAgIH1cXG5cXG4gICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcXG4gICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XFxuICAgIHZhciBwb3MsIGxvd2VyQ2FzZWRUYWdOYW1lO1xcbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBzdGFydCA9IGluZGV4OyB9XFxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxcblxcbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxcbiAgICBpZiAodGFnTmFtZSkge1xcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XFxuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xcbiAgICAgICAgICBicmVha1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxcbiAgICAgIHBvcyA9IDA7XFxuICAgIH1cXG5cXG4gICAgaWYgKHBvcyA+PSAwKSB7XFxuICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcXG4gICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xcbiAgICAgICAgaWYgKCB0cnVlICYmXFxuICAgICAgICAgIChpID4gcG9zIHx8ICF0YWdOYW1lKSAmJlxcbiAgICAgICAgICBvcHRpb25zLndhcm5cXG4gICAgICAgICkge1xcbiAgICAgICAgICBvcHRpb25zLndhcm4oXFxuICAgICAgICAgICAgKFxcXCJ0YWcgPFxcXCIgKyAoc3RhY2tbaV0udGFnKSArIFxcXCI+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLlxcXCIpLFxcbiAgICAgICAgICAgIHsgc3RhcnQ6IHN0YWNrW2ldLnN0YXJ0LCBlbmQ6IHN0YWNrW2ldLmVuZCB9XFxuICAgICAgICAgICk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcXG4gICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXFxuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xcbiAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xcbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XFxuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcXG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XFxuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcXG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcXG4gICAgICB9XFxuICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XFxuICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLyogICovXFxuXFxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcXG52YXIgZGlyUkUgPSAvXnYtfF5AfF46LztcXG52YXIgZm9yQWxpYXNSRSA9IC8oW1xcXFxzXFxcXFNdKj8pXFxcXHMrKD86aW58b2YpXFxcXHMrKFtcXFxcc1xcXFxTXSopLztcXG52YXIgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcXFx9XFxcXF1dKikoPzosKFteLFxcXFx9XFxcXF1dKikpPyQvO1xcbnZhciBzdHJpcFBhcmVuc1JFID0gL15cXFxcKHxcXFxcKSQvZztcXG52YXIgZHluYW1pY0FyZ1JFID0gL15cXFxcWy4qXFxcXF0kLztcXG5cXG52YXIgYXJnUkUgPSAvOiguKikkLztcXG52YXIgYmluZFJFID0gL146fF5cXFxcLnxedi1iaW5kOi87XFxudmFyIG1vZGlmaWVyUkUgPSAvXFxcXC5bXi5cXFxcXV0rKD89W15cXFxcXV0qJCkvZztcXG5cXG52YXIgc2xvdFJFID0gL152LXNsb3QoOnwkKXxeIy87XFxuXFxudmFyIGxpbmVCcmVha1JFID0gL1tcXFxcclxcXFxuXS87XFxudmFyIHdoaXRlc3BhY2VSRSQxID0gL1xcXFxzKy9nO1xcblxcbnZhciBpbnZhbGlkQXR0cmlidXRlUkUgPSAvW1xcXFxzXFxcIic8PlxcXFwvPV0vO1xcblxcbnZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGhlLmRlY29kZSk7XFxuXFxudmFyIGVtcHR5U2xvdFNjb3BlVG9rZW4gPSBcXFwiX2VtcHR5X1xcXCI7XFxuXFxuLy8gY29uZmlndXJhYmxlIHN0YXRlXFxudmFyIHdhcm4kMjtcXG52YXIgZGVsaW1pdGVycztcXG52YXIgdHJhbnNmb3JtcztcXG52YXIgcHJlVHJhbnNmb3JtcztcXG52YXIgcG9zdFRyYW5zZm9ybXM7XFxudmFyIHBsYXRmb3JtSXNQcmVUYWc7XFxudmFyIHBsYXRmb3JtTXVzdFVzZVByb3A7XFxudmFyIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xcbnZhciBtYXliZUNvbXBvbmVudDtcXG5cXG5mdW5jdGlvbiBjcmVhdGVBU1RFbGVtZW50IChcXG4gIHRhZyxcXG4gIGF0dHJzLFxcbiAgcGFyZW50XFxuKSB7XFxuICByZXR1cm4ge1xcbiAgICB0eXBlOiAxLFxcbiAgICB0YWc6IHRhZyxcXG4gICAgYXR0cnNMaXN0OiBhdHRycyxcXG4gICAgYXR0cnNNYXA6IG1ha2VBdHRyc01hcChhdHRycyksXFxuICAgIHJhd0F0dHJzTWFwOiB7fSxcXG4gICAgcGFyZW50OiBwYXJlbnQsXFxuICAgIGNoaWxkcmVuOiBbXVxcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cXG4gKi9cXG5mdW5jdGlvbiBwYXJzZSAoXFxuICB0ZW1wbGF0ZSxcXG4gIG9wdGlvbnNcXG4pIHtcXG4gIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcXG5cXG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xcbiAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XFxuICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xcbiAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XFxuICBtYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcXG5cXG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcXG4gIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcXG4gIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xcblxcbiAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcXG5cXG4gIHZhciBzdGFjayA9IFtdO1xcbiAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcXG4gIHZhciB3aGl0ZXNwYWNlT3B0aW9uID0gb3B0aW9ucy53aGl0ZXNwYWNlO1xcbiAgdmFyIHJvb3Q7XFxuICB2YXIgY3VycmVudFBhcmVudDtcXG4gIHZhciBpblZQcmUgPSBmYWxzZTtcXG4gIHZhciBpblByZSA9IGZhbHNlO1xcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xcblxcbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZywgcmFuZ2UpIHtcXG4gICAgaWYgKCF3YXJuZWQpIHtcXG4gICAgICB3YXJuZWQgPSB0cnVlO1xcbiAgICAgIHdhcm4kMihtc2csIHJhbmdlKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gY2xvc2VFbGVtZW50IChlbGVtZW50KSB7XFxuICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xcbiAgICBpZiAoIWluVlByZSAmJiAhZWxlbWVudC5wcm9jZXNzZWQpIHtcXG4gICAgICBlbGVtZW50ID0gcHJvY2Vzc0VsZW1lbnQoZWxlbWVudCwgb3B0aW9ucyk7XFxuICAgIH1cXG4gICAgLy8gdHJlZSBtYW5hZ2VtZW50XFxuICAgIGlmICghc3RhY2subGVuZ3RoICYmIGVsZW1lbnQgIT09IHJvb3QpIHtcXG4gICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcXG4gICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xcbiAgICAgICAgaWYgKHRydWUpIHtcXG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XFxuICAgICAgICB9XFxuICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XFxuICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXFxuICAgICAgICAgIGJsb2NrOiBlbGVtZW50XFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2UgaWYgKHRydWUpIHtcXG4gICAgICAgIHdhcm5PbmNlKFxcbiAgICAgICAgICBcXFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXFxcIiArXFxuICAgICAgICAgIFxcXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFxcXCIgK1xcbiAgICAgICAgICBcXFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXFxcIixcXG4gICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XFxuICAgICAgICApO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcXG4gICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XFxuICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHtcXG4gICAgICAgICAgLy8gc2NvcGVkIHNsb3RcXG4gICAgICAgICAgLy8ga2VlcCBpdCBpbiB0aGUgY2hpbGRyZW4gbGlzdCBzbyB0aGF0IHYtZWxzZSgtaWYpIGNvbmRpdGlvbnMgY2FuXFxuICAgICAgICAgIC8vIGZpbmQgaXQgYXMgdGhlIHByZXYgbm9kZS5cXG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1xcXCJkZWZhdWx0XFxcIidcXG4gICAgICAgICAgOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XFxuICAgICAgICB9XFxuICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XFxuICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8vIGZpbmFsIGNoaWxkcmVuIGNsZWFudXBcXG4gICAgLy8gZmlsdGVyIG91dCBzY29wZWQgc2xvdHNcXG4gICAgZWxlbWVudC5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAhKGMpLnNsb3RTY29wZTsgfSk7XFxuICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG5vZGUgYWdhaW5cXG4gICAgdHJpbUVuZGluZ1doaXRlc3BhY2UoZWxlbWVudCk7XFxuXFxuICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxcbiAgICBpZiAoZWxlbWVudC5wcmUpIHtcXG4gICAgICBpblZQcmUgPSBmYWxzZTtcXG4gICAgfVxcbiAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcXG4gICAgICBpblByZSA9IGZhbHNlO1xcbiAgICB9XFxuICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgcG9zdFRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHRyaW1FbmRpbmdXaGl0ZXNwYWNlIChlbCkge1xcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlXFxuICAgIGlmICghaW5QcmUpIHtcXG4gICAgICB2YXIgbGFzdE5vZGU7XFxuICAgICAgd2hpbGUgKFxcbiAgICAgICAgKGxhc3ROb2RlID0gZWwuY2hpbGRyZW5bZWwuY2hpbGRyZW4ubGVuZ3RoIC0gMV0pICYmXFxuICAgICAgICBsYXN0Tm9kZS50eXBlID09PSAzICYmXFxuICAgICAgICBsYXN0Tm9kZS50ZXh0ID09PSAnICdcXG4gICAgICApIHtcXG4gICAgICAgIGVsLmNoaWxkcmVuLnBvcCgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XFxuICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcXG4gICAgICB3YXJuT25jZShcXG4gICAgICAgIFxcXCJDYW5ub3QgdXNlIDxcXFwiICsgKGVsLnRhZykgKyBcXFwiPiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5IFxcXCIgK1xcbiAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJyxcXG4gICAgICAgIHsgc3RhcnQ6IGVsLnN0YXJ0IH1cXG4gICAgICApO1xcbiAgICB9XFxuICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xcbiAgICAgIHdhcm5PbmNlKFxcbiAgICAgICAgJ0Nhbm5vdCB1c2Ugdi1mb3Igb24gc3RhdGVmdWwgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlICcgK1xcbiAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJyxcXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXFxuICAgICAgKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XFxuICAgIHdhcm46IHdhcm4kMixcXG4gICAgZXhwZWN0SFRNTDogb3B0aW9ucy5leHBlY3RIVE1MLFxcbiAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXFxuICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxcbiAgICBvdXRwdXRTb3VyY2VSYW5nZTogb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSxcXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSwgc3RhcnQkMSwgZW5kKSB7XFxuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxcbiAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxcbiAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XFxuXFxuICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcXG4gICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlQVNURWxlbWVudCh0YWcsIGF0dHJzLCBjdXJyZW50UGFyZW50KTtcXG4gICAgICBpZiAobnMpIHtcXG4gICAgICAgIGVsZW1lbnQubnMgPSBucztcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRydWUpIHtcXG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XFxuICAgICAgICAgIGVsZW1lbnQuc3RhcnQgPSBzdGFydCQxO1xcbiAgICAgICAgICBlbGVtZW50LmVuZCA9IGVuZDtcXG4gICAgICAgICAgZWxlbWVudC5yYXdBdHRyc01hcCA9IGVsZW1lbnQuYXR0cnNMaXN0LnJlZHVjZShmdW5jdGlvbiAoY3VtdWxhdGVkLCBhdHRyKSB7XFxuICAgICAgICAgICAgY3VtdWxhdGVkW2F0dHIubmFtZV0gPSBhdHRyO1xcbiAgICAgICAgICAgIHJldHVybiBjdW11bGF0ZWRcXG4gICAgICAgICAgfSwge30pO1xcbiAgICAgICAgfVxcbiAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xcbiAgICAgICAgICBpZiAoaW52YWxpZEF0dHJpYnV0ZVJFLnRlc3QoYXR0ci5uYW1lKSkge1xcbiAgICAgICAgICAgIHdhcm4kMihcXG4gICAgICAgICAgICAgIFxcXCJJbnZhbGlkIGR5bmFtaWMgYXJndW1lbnQgZXhwcmVzc2lvbjogYXR0cmlidXRlIG5hbWVzIGNhbm5vdCBjb250YWluIFxcXCIgK1xcbiAgICAgICAgICAgICAgXFxcInNwYWNlcywgcXVvdGVzLCA8LCA+LCAvIG9yID0uXFxcIixcXG4gICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGF0dHIuc3RhcnQgKyBhdHRyLm5hbWUuaW5kZXhPZihcXFwiW1xcXCIpLFxcbiAgICAgICAgICAgICAgICBlbmQ6IGF0dHIuc3RhcnQgKyBhdHRyLm5hbWUubGVuZ3RoXFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xcbiAgICAgICAgIHRydWUgJiYgd2FybiQyKFxcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXFxuICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xcbiAgICAgICAgICBcXFwiPFxcXCIgKyB0YWcgKyBcXFwiPlxcXCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nLFxcbiAgICAgICAgICB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH1cXG4gICAgICAgICk7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBlbGVtZW50ID0gcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWluVlByZSkge1xcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcXG4gICAgICAgIGlmIChlbGVtZW50LnByZSkge1xcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcXG4gICAgICAgIGluUHJlID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgICAgaWYgKGluVlByZSkge1xcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xcbiAgICAgIH0gZWxzZSBpZiAoIWVsZW1lbnQucHJvY2Vzc2VkKSB7XFxuICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXNcXG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XFxuICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XFxuICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFyb290KSB7XFxuICAgICAgICByb290ID0gZWxlbWVudDtcXG4gICAgICAgIGlmICh0cnVlKSB7XFxuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXVuYXJ5KSB7XFxuICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcXG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIGVuZDogZnVuY3Rpb24gZW5kICh0YWcsIHN0YXJ0LCBlbmQkMSkge1xcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XFxuICAgICAgLy8gcG9wIHN0YWNrXFxuICAgICAgc3RhY2subGVuZ3RoIC09IDE7XFxuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xcbiAgICAgIGlmICggdHJ1ZSAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XFxuICAgICAgICBlbGVtZW50LmVuZCA9IGVuZCQxO1xcbiAgICAgIH1cXG4gICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XFxuICAgIH0sXFxuXFxuICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCwgc3RhcnQsIGVuZCkge1xcbiAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xcbiAgICAgICAgaWYgKHRydWUpIHtcXG4gICAgICAgICAgaWYgKHRleHQgPT09IHRlbXBsYXRlKSB7XFxuICAgICAgICAgICAgd2Fybk9uY2UoXFxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJyxcXG4gICAgICAgICAgICAgIHsgc3RhcnQ6IHN0YXJ0IH1cXG4gICAgICAgICAgICApO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XFxuICAgICAgICAgICAgd2Fybk9uY2UoXFxuICAgICAgICAgICAgICAoXFxcInRleHQgXFxcXFxcXCJcXFwiICsgdGV4dCArIFxcXCJcXFxcXFxcIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXFxcIiksXFxuICAgICAgICAgICAgICB7IHN0YXJ0OiBzdGFydCB9XFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuXFxuICAgICAgfVxcbiAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgICAgIGlmIChpc0lFICYmXFxuICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxcbiAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxcbiAgICAgICkge1xcbiAgICAgICAgcmV0dXJuXFxuICAgICAgfVxcbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XFxuICAgICAgaWYgKGluUHJlIHx8IHRleHQudHJpbSgpKSB7XFxuICAgICAgICB0ZXh0ID0gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dCk7XFxuICAgICAgfSBlbHNlIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XFxuICAgICAgICAvLyByZW1vdmUgdGhlIHdoaXRlc3BhY2Utb25seSBub2RlIHJpZ2h0IGFmdGVyIGFuIG9wZW5pbmcgdGFnXFxuICAgICAgICB0ZXh0ID0gJyc7XFxuICAgICAgfSBlbHNlIGlmICh3aGl0ZXNwYWNlT3B0aW9uKSB7XFxuICAgICAgICBpZiAod2hpdGVzcGFjZU9wdGlvbiA9PT0gJ2NvbmRlbnNlJykge1xcbiAgICAgICAgICAvLyBpbiBjb25kZW5zZSBtb2RlLCByZW1vdmUgdGhlIHdoaXRlc3BhY2Ugbm9kZSBpZiBpdCBjb250YWluc1xcbiAgICAgICAgICAvLyBsaW5lIGJyZWFrLCBvdGhlcndpc2UgY29uZGVuc2UgdG8gYSBzaW5nbGUgc3BhY2VcXG4gICAgICAgICAgdGV4dCA9IGxpbmVCcmVha1JFLnRlc3QodGV4dCkgPyAnJyA6ICcgJztcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRleHQgPSAnICc7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRleHQgPSBwcmVzZXJ2ZVdoaXRlc3BhY2UgPyAnICcgOiAnJztcXG4gICAgICB9XFxuICAgICAgaWYgKHRleHQpIHtcXG4gICAgICAgIGlmICghaW5QcmUgJiYgd2hpdGVzcGFjZU9wdGlvbiA9PT0gJ2NvbmRlbnNlJykge1xcbiAgICAgICAgICAvLyBjb25kZW5zZSBjb25zZWN1dGl2ZSB3aGl0ZXNwYWNlcyBpbnRvIHNpbmdsZSBzcGFjZVxcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHdoaXRlc3BhY2VSRSQxLCAnICcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIHJlcztcXG4gICAgICAgIHZhciBjaGlsZDtcXG4gICAgICAgIGlmICghaW5WUHJlICYmIHRleHQgIT09ICcgJyAmJiAocmVzID0gcGFyc2VUZXh0KHRleHQsIGRlbGltaXRlcnMpKSkge1xcbiAgICAgICAgICBjaGlsZCA9IHtcXG4gICAgICAgICAgICB0eXBlOiAyLFxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHJlcy5leHByZXNzaW9uLFxcbiAgICAgICAgICAgIHRva2VuczogcmVzLnRva2VucyxcXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XFxuICAgICAgICAgIH07XFxuICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fCAhY2hpbGRyZW4ubGVuZ3RoIHx8IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xcbiAgICAgICAgICBjaGlsZCA9IHtcXG4gICAgICAgICAgICB0eXBlOiAzLFxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChjaGlsZCkge1xcbiAgICAgICAgICBpZiAoIHRydWUgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xcbiAgICAgICAgICAgIGNoaWxkLnN0YXJ0ID0gc3RhcnQ7XFxuICAgICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgY29tbWVudDogZnVuY3Rpb24gY29tbWVudCAodGV4dCwgc3RhcnQsIGVuZCkge1xcbiAgICAgIC8vIGFkZGluZyBhbnl0aW5nIGFzIGEgc2libGluZyB0byB0aGUgcm9vdCBub2RlIGlzIGZvcmJpZGRlblxcbiAgICAgIC8vIGNvbW1lbnRzIHNob3VsZCBzdGlsbCBiZSBhbGxvd2VkLCBidXQgaWdub3JlZFxcbiAgICAgIGlmIChjdXJyZW50UGFyZW50KSB7XFxuICAgICAgICB2YXIgY2hpbGQgPSB7XFxuICAgICAgICAgIHR5cGU6IDMsXFxuICAgICAgICAgIHRleHQ6IHRleHQsXFxuICAgICAgICAgIGlzQ29tbWVudDogdHJ1ZVxcbiAgICAgICAgfTtcXG4gICAgICAgIGlmICggdHJ1ZSAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XFxuICAgICAgICAgIGNoaWxkLnN0YXJ0ID0gc3RhcnQ7XFxuICAgICAgICAgIGNoaWxkLmVuZCA9IGVuZDtcXG4gICAgICAgIH1cXG4gICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChjaGlsZCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9KTtcXG4gIHJldHVybiByb290XFxufVxcblxcbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XFxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xcbiAgICBlbC5wcmUgPSB0cnVlO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XFxuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcXG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcXG4gIGlmIChsZW4pIHtcXG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobGVuKTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xcbiAgICAgIGF0dHJzW2ldID0ge1xcbiAgICAgICAgbmFtZTogbGlzdFtpXS5uYW1lLFxcbiAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGxpc3RbaV0udmFsdWUpXFxuICAgICAgfTtcXG4gICAgICBpZiAobGlzdFtpXS5zdGFydCAhPSBudWxsKSB7XFxuICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGxpc3RbaV0uc3RhcnQ7XFxuICAgICAgICBhdHRyc1tpXS5lbmQgPSBsaXN0W2ldLmVuZDtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXFxuICAgIGVsLnBsYWluID0gdHJ1ZTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gcHJvY2Vzc0VsZW1lbnQgKFxcbiAgZWxlbWVudCxcXG4gIG9wdGlvbnNcXG4pIHtcXG4gIHByb2Nlc3NLZXkoZWxlbWVudCk7XFxuXFxuICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxcbiAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXFxuICBlbGVtZW50LnBsYWluID0gKFxcbiAgICAhZWxlbWVudC5rZXkgJiZcXG4gICAgIWVsZW1lbnQuc2NvcGVkU2xvdHMgJiZcXG4gICAgIWVsZW1lbnQuYXR0cnNMaXN0Lmxlbmd0aFxcbiAgKTtcXG5cXG4gIHByb2Nlc3NSZWYoZWxlbWVudCk7XFxuICBwcm9jZXNzU2xvdENvbnRlbnQoZWxlbWVudCk7XFxuICBwcm9jZXNzU2xvdE91dGxldChlbGVtZW50KTtcXG4gIHByb2Nlc3NDb21wb25lbnQoZWxlbWVudCk7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcXG4gICAgZWxlbWVudCA9IHRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcXG4gIH1cXG4gIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcXG4gIHJldHVybiBlbGVtZW50XFxufVxcblxcbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XFxuICB2YXIgZXhwID0gZ2V0QmluZGluZ0F0dHIoZWwsICdrZXknKTtcXG4gIGlmIChleHApIHtcXG4gICAgaWYgKHRydWUpIHtcXG4gICAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XFxuICAgICAgICB3YXJuJDIoXFxuICAgICAgICAgIFxcXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXFxcIixcXG4gICAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGVsLmZvcikge1xcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gZWwuaXRlcmF0b3IyIHx8IGVsLml0ZXJhdG9yMTtcXG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XFxuICAgICAgICBpZiAoaXRlcmF0b3IgJiYgaXRlcmF0b3IgPT09IGV4cCAmJiBwYXJlbnQgJiYgcGFyZW50LnRhZyA9PT0gJ3RyYW5zaXRpb24tZ3JvdXAnKSB7XFxuICAgICAgICAgIHdhcm4kMihcXG4gICAgICAgICAgICBcXFwiRG8gbm90IHVzZSB2LWZvciBpbmRleCBhcyBrZXkgb24gPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuLCBcXFwiICtcXG4gICAgICAgICAgICBcXFwidGhpcyBpcyB0aGUgc2FtZSBhcyBub3QgdXNpbmcga2V5cy5cXFwiLFxcbiAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JyksXFxuICAgICAgICAgICAgdHJ1ZSAvKiB0aXAgKi9cXG4gICAgICAgICAgKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgZWwua2V5ID0gZXhwO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBwcm9jZXNzUmVmIChlbCkge1xcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XFxuICBpZiAocmVmKSB7XFxuICAgIGVsLnJlZiA9IHJlZjtcXG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcXG4gIHZhciBleHA7XFxuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xcbiAgICB2YXIgcmVzID0gcGFyc2VGb3IoZXhwKTtcXG4gICAgaWYgKHJlcykge1xcbiAgICAgIGV4dGVuZChlbCwgcmVzKTtcXG4gICAgfSBlbHNlIGlmICh0cnVlKSB7XFxuICAgICAgd2FybiQyKFxcbiAgICAgICAgKFxcXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFxcXCIgKyBleHApLFxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cXG4gICAgICApO1xcbiAgICB9XFxuICB9XFxufVxcblxcblxcblxcbmZ1bmN0aW9uIHBhcnNlRm9yIChleHApIHtcXG4gIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xcbiAgaWYgKCFpbk1hdGNoKSB7IHJldHVybiB9XFxuICB2YXIgcmVzID0ge307XFxuICByZXMuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XFxuICB2YXIgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKS5yZXBsYWNlKHN0cmlwUGFyZW5zUkUsICcnKTtcXG4gIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XFxuICBpZiAoaXRlcmF0b3JNYXRjaCkge1xcbiAgICByZXMuYWxpYXMgPSBhbGlhcy5yZXBsYWNlKGZvckl0ZXJhdG9yUkUsICcnKS50cmltKCk7XFxuICAgIHJlcy5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcXG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcXG4gICAgICByZXMuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIHJlcy5hbGlhcyA9IGFsaWFzO1xcbiAgfVxcbiAgcmV0dXJuIHJlc1xcbn1cXG5cXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XFxuICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcXG4gIGlmIChleHApIHtcXG4gICAgZWwuaWYgPSBleHA7XFxuICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XFxuICAgICAgZXhwOiBleHAsXFxuICAgICAgYmxvY2s6IGVsXFxuICAgIH0pO1xcbiAgfSBlbHNlIHtcXG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XFxuICAgICAgZWwuZWxzZSA9IHRydWU7XFxuICAgIH1cXG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcXG4gICAgaWYgKGVsc2VpZikge1xcbiAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XFxuICB2YXIgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xcbiAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XFxuICAgICAgZXhwOiBlbC5lbHNlaWYsXFxuICAgICAgYmxvY2s6IGVsXFxuICAgIH0pO1xcbiAgfSBlbHNlIGlmICh0cnVlKSB7XFxuICAgIHdhcm4kMihcXG4gICAgICBcXFwidi1cXFwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cXFwiJyArIGVsLmVsc2VpZiArICdcXFwiJykgOiAnZWxzZScpICsgXFxcIiBcXFwiICtcXG4gICAgICBcXFwidXNlZCBvbiBlbGVtZW50IDxcXFwiICsgKGVsLnRhZykgKyBcXFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cXFwiLFxcbiAgICAgIGVsLnJhd0F0dHJzTWFwW2VsLmVsc2VpZiA/ICd2LWVsc2UtaWYnIDogJ3YtZWxzZSddXFxuICAgICk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcXG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xcbiAgd2hpbGUgKGktLSkge1xcbiAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGlmICggdHJ1ZSAmJiBjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcXG4gICAgICAgIHdhcm4kMihcXG4gICAgICAgICAgXFxcInRleHQgXFxcXFxcXCJcXFwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFxcXCJcXFxcXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFxcXCIgK1xcbiAgICAgICAgICBcXFwid2lsbCBiZSBpZ25vcmVkLlxcXCIsXFxuICAgICAgICAgIGNoaWxkcmVuW2ldXFxuICAgICAgICApO1xcbiAgICAgIH1cXG4gICAgICBjaGlsZHJlbi5wb3AoKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcXG4gICAgZWwuaWZDb25kaXRpb25zID0gW107XFxuICB9XFxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xcbn1cXG5cXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcXG4gIHZhciBvbmNlJCQxID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Ytb25jZScpO1xcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xcbiAgICBlbC5vbmNlID0gdHJ1ZTtcXG4gIH1cXG59XFxuXFxuLy8gaGFuZGxlIGNvbnRlbnQgYmVpbmcgcGFzc2VkIHRvIGEgY29tcG9uZW50IGFzIHNsb3QsXFxuLy8gZS5nLiA8dGVtcGxhdGUgc2xvdD1cXFwieHh4XFxcIj4sIDxkaXYgc2xvdC1zY29wZT1cXFwieHh4XFxcIj5cXG5mdW5jdGlvbiBwcm9jZXNzU2xvdENvbnRlbnQgKGVsKSB7XFxuICB2YXIgc2xvdFNjb3BlO1xcbiAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xcbiAgICBzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICAgIGlmICggdHJ1ZSAmJiBzbG90U2NvcGUpIHtcXG4gICAgICB3YXJuJDIoXFxuICAgICAgICBcXFwidGhlIFxcXFxcXFwic2NvcGVcXFxcXFxcIiBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBzbG90cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhbmQgXFxcIiArXFxuICAgICAgICBcXFwicmVwbGFjZWQgYnkgXFxcXFxcXCJzbG90LXNjb3BlXFxcXFxcXCIgc2luY2UgMi41LiBUaGUgbmV3IFxcXFxcXFwic2xvdC1zY29wZVxcXFxcXFwiIGF0dHJpYnV0ZSBcXFwiICtcXG4gICAgICAgIFxcXCJjYW4gYWxzbyBiZSB1c2VkIG9uIHBsYWluIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIDx0ZW1wbGF0ZT4gdG8gXFxcIiArXFxuICAgICAgICBcXFwiZGVub3RlIHNjb3BlZCBzbG90cy5cXFwiLFxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Njb3BlJ10sXFxuICAgICAgICB0cnVlXFxuICAgICAgKTtcXG4gICAgfVxcbiAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGUgfHwgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKTtcXG4gIH0gZWxzZSBpZiAoKHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJykpKSB7XFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgICBpZiAoIHRydWUgJiYgZWwuYXR0cnNNYXBbJ3YtZm9yJ10pIHtcXG4gICAgICB3YXJuJDIoXFxuICAgICAgICBcXFwiQW1iaWd1b3VzIGNvbWJpbmVkIHVzYWdlIG9mIHNsb3Qtc2NvcGUgYW5kIHYtZm9yIG9uIDxcXFwiICsgKGVsLnRhZykgKyBcXFwiPiBcXFwiICtcXG4gICAgICAgIFxcXCIodi1mb3IgdGFrZXMgaGlnaGVyIHByaW9yaXR5KS4gVXNlIGEgd3JhcHBlciA8dGVtcGxhdGU+IGZvciB0aGUgXFxcIiArXFxuICAgICAgICBcXFwic2NvcGVkIHNsb3QgdG8gbWFrZSBpdCBjbGVhcmVyLlxcXCIsXFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnc2xvdC1zY29wZSddLFxcbiAgICAgICAgdHJ1ZVxcbiAgICAgICk7XFxuICAgIH1cXG4gICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlO1xcbiAgfVxcblxcbiAgLy8gc2xvdD1cXFwieHh4XFxcIlxcbiAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcXG4gIGlmIChzbG90VGFyZ2V0KSB7XFxuICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXFxcIlxcXCInID8gJ1xcXCJkZWZhdWx0XFxcIicgOiBzbG90VGFyZ2V0O1xcbiAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9ICEhKGVsLmF0dHJzTWFwWyc6c2xvdCddIHx8IGVsLmF0dHJzTWFwWyd2LWJpbmQ6c2xvdCddKTtcXG4gICAgLy8gcHJlc2VydmUgc2xvdCBhcyBhbiBhdHRyaWJ1dGUgZm9yIG5hdGl2ZSBzaGFkb3cgRE9NIGNvbXBhdFxcbiAgICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzLlxcbiAgICBpZiAoZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5zbG90U2NvcGUpIHtcXG4gICAgICBhZGRBdHRyKGVsLCAnc2xvdCcsIHNsb3RUYXJnZXQsIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAnc2xvdCcpKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gMi42IHYtc2xvdCBzeW50YXhcXG4gIHtcXG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xcbiAgICAgIC8vIHYtc2xvdCBvbiA8dGVtcGxhdGU+XFxuICAgICAgdmFyIHNsb3RCaW5kaW5nID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XFxuICAgICAgaWYgKHNsb3RCaW5kaW5nKSB7XFxuICAgICAgICBpZiAodHJ1ZSkge1xcbiAgICAgICAgICBpZiAoZWwuc2xvdFRhcmdldCB8fCBlbC5zbG90U2NvcGUpIHtcXG4gICAgICAgICAgICB3YXJuJDIoXFxuICAgICAgICAgICAgICBcXFwiVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5cXFwiLFxcbiAgICAgICAgICAgICAgZWxcXG4gICAgICAgICAgICApO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChlbC5wYXJlbnQgJiYgIW1heWJlQ29tcG9uZW50KGVsLnBhcmVudCkpIHtcXG4gICAgICAgICAgICB3YXJuJDIoXFxuICAgICAgICAgICAgICBcXFwiPHRlbXBsYXRlIHYtc2xvdD4gY2FuIG9ubHkgYXBwZWFyIGF0IHRoZSByb290IGxldmVsIGluc2lkZSBcXFwiICtcXG4gICAgICAgICAgICAgIFxcXCJ0aGUgcmVjZWl2aW5nIHRoZSBjb21wb25lbnRcXFwiLFxcbiAgICAgICAgICAgICAgZWxcXG4gICAgICAgICAgICApO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgcmVmID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmcpO1xcbiAgICAgICAgdmFyIG5hbWUgPSByZWYubmFtZTtcXG4gICAgICAgIHZhciBkeW5hbWljID0gcmVmLmR5bmFtaWM7XFxuICAgICAgICBlbC5zbG90VGFyZ2V0ID0gbmFtZTtcXG4gICAgICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYztcXG4gICAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47IC8vIGZvcmNlIGl0IGludG8gYSBzY29wZWQgc2xvdCBmb3IgcGVyZlxcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyB2LXNsb3Qgb24gY29tcG9uZW50LCBkZW5vdGVzIGRlZmF1bHQgc2xvdFxcbiAgICAgIHZhciBzbG90QmluZGluZyQxID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XFxuICAgICAgaWYgKHNsb3RCaW5kaW5nJDEpIHtcXG4gICAgICAgIGlmICh0cnVlKSB7XFxuICAgICAgICAgIGlmICghbWF5YmVDb21wb25lbnQoZWwpKSB7XFxuICAgICAgICAgICAgd2FybiQyKFxcbiAgICAgICAgICAgICAgXFxcInYtc2xvdCBjYW4gb25seSBiZSB1c2VkIG9uIGNvbXBvbmVudHMgb3IgPHRlbXBsYXRlPi5cXFwiLFxcbiAgICAgICAgICAgICAgc2xvdEJpbmRpbmckMVxcbiAgICAgICAgICAgICk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKGVsLnNsb3RTY29wZSB8fCBlbC5zbG90VGFyZ2V0KSB7XFxuICAgICAgICAgICAgd2FybiQyKFxcbiAgICAgICAgICAgICAgXFxcIlVuZXhwZWN0ZWQgbWl4ZWQgdXNhZ2Ugb2YgZGlmZmVyZW50IHNsb3Qgc3ludGF4ZXMuXFxcIixcXG4gICAgICAgICAgICAgIGVsXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcXG4gICAgICAgICAgICB3YXJuJDIoXFxuICAgICAgICAgICAgICBcXFwiVG8gYXZvaWQgc2NvcGUgYW1iaWd1aXR5LCB0aGUgZGVmYXVsdCBzbG90IHNob3VsZCBhbHNvIHVzZSBcXFwiICtcXG4gICAgICAgICAgICAgIFxcXCI8dGVtcGxhdGU+IHN5bnRheCB3aGVuIHRoZXJlIGFyZSBvdGhlciBuYW1lZCBzbG90cy5cXFwiLFxcbiAgICAgICAgICAgICAgc2xvdEJpbmRpbmckMVxcbiAgICAgICAgICAgICk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIC8vIGFkZCB0aGUgY29tcG9uZW50J3MgY2hpbGRyZW4gdG8gaXRzIGRlZmF1bHQgc2xvdFxcbiAgICAgICAgdmFyIHNsb3RzID0gZWwuc2NvcGVkU2xvdHMgfHwgKGVsLnNjb3BlZFNsb3RzID0ge30pO1xcbiAgICAgICAgdmFyIHJlZiQxID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmckMSk7XFxuICAgICAgICB2YXIgbmFtZSQxID0gcmVmJDEubmFtZTtcXG4gICAgICAgIHZhciBkeW5hbWljJDEgPSByZWYkMS5keW5hbWljO1xcbiAgICAgICAgdmFyIHNsb3RDb250YWluZXIgPSBzbG90c1tuYW1lJDFdID0gY3JlYXRlQVNURWxlbWVudCgndGVtcGxhdGUnLCBbXSwgZWwpO1xcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0ID0gbmFtZSQxO1xcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0RHluYW1pYyA9IGR5bmFtaWMkMTtcXG4gICAgICAgIHNsb3RDb250YWluZXIuY2hpbGRyZW4gPSBlbC5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcXG4gICAgICAgICAgaWYgKCFjLnNsb3RTY29wZSkge1xcbiAgICAgICAgICAgIGMucGFyZW50ID0gc2xvdENvbnRhaW5lcjtcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIHNsb3RDb250YWluZXIuc2xvdFNjb3BlID0gc2xvdEJpbmRpbmckMS52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuO1xcbiAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuIGFzIHRoZXkgYXJlIHJldHVybmVkIGZyb20gc2NvcGVkU2xvdHMgbm93XFxuICAgICAgICBlbC5jaGlsZHJlbiA9IFtdO1xcbiAgICAgICAgLy8gbWFyayBlbCBub24tcGxhaW4gc28gZGF0YSBnZXRzIGdlbmVyYXRlZFxcbiAgICAgICAgZWwucGxhaW4gPSBmYWxzZTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZ2V0U2xvdE5hbWUgKGJpbmRpbmcpIHtcXG4gIHZhciBuYW1lID0gYmluZGluZy5uYW1lLnJlcGxhY2Uoc2xvdFJFLCAnJyk7XFxuICBpZiAoIW5hbWUpIHtcXG4gICAgaWYgKGJpbmRpbmcubmFtZVswXSAhPT0gJyMnKSB7XFxuICAgICAgbmFtZSA9ICdkZWZhdWx0JztcXG4gICAgfSBlbHNlIGlmICh0cnVlKSB7XFxuICAgICAgd2FybiQyKFxcbiAgICAgICAgXFxcInYtc2xvdCBzaG9ydGhhbmQgc3ludGF4IHJlcXVpcmVzIGEgc2xvdCBuYW1lLlxcXCIsXFxuICAgICAgICBiaW5kaW5nXFxuICAgICAgKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpXFxuICAgIC8vIGR5bmFtaWMgW25hbWVdXFxuICAgID8geyBuYW1lOiBuYW1lLnNsaWNlKDEsIC0xKSwgZHluYW1pYzogdHJ1ZSB9XFxuICAgIC8vIHN0YXRpYyBuYW1lXFxuICAgIDogeyBuYW1lOiAoXFxcIlxcXFxcXFwiXFxcIiArIG5hbWUgKyBcXFwiXFxcXFxcXCJcXFwiKSwgZHluYW1pYzogZmFsc2UgfVxcbn1cXG5cXG4vLyBoYW5kbGUgPHNsb3QvPiBvdXRsZXRzXFxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RPdXRsZXQgKGVsKSB7XFxuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcXG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcXG4gICAgaWYgKCB0cnVlICYmIGVsLmtleSkge1xcbiAgICAgIHdhcm4kMihcXG4gICAgICAgIFxcXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFxcXCIgK1xcbiAgICAgICAgXFxcImFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIFxcXCIgK1xcbiAgICAgICAgXFxcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlxcXCIsXFxuICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpXFxuICAgICAgKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xcbiAgdmFyIGJpbmRpbmc7XFxuICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XFxuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XFxuICB9XFxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcXG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XFxuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcXG4gIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBzeW5jR2VuLCBpc0R5bmFtaWM7XFxuICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XFxuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcXG4gICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcXG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcXG4gICAgICAvLyBtb2RpZmllcnNcXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lLnJlcGxhY2UoZGlyUkUsICcnKSk7XFxuICAgICAgLy8gc3VwcG9ydCAuZm9vIHNob3J0aGFuZCBzeW50YXggZm9yIHRoZSAucHJvcCBtb2RpZmllclxcbiAgICAgIGlmIChtb2RpZmllcnMpIHtcXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHsgLy8gdi1iaW5kXFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xcbiAgICAgICAgaXNEeW5hbWljID0gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSk7XFxuICAgICAgICBpZiAoaXNEeW5hbWljKSB7XFxuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChcXG4gICAgICAgICAgIHRydWUgJiZcXG4gICAgICAgICAgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMFxcbiAgICAgICAgKSB7XFxuICAgICAgICAgIHdhcm4kMihcXG4gICAgICAgICAgICAoXFxcIlRoZSB2YWx1ZSBmb3IgYSB2LWJpbmQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgZW1wdHkuIEZvdW5kIGluIFxcXFxcXFwidi1iaW5kOlxcXCIgKyBuYW1lICsgXFxcIlxcXFxcXFwiXFxcIilcXG4gICAgICAgICAgKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChtb2RpZmllcnMpIHtcXG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wICYmICFpc0R5bmFtaWMpIHtcXG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XFxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwgJiYgIWlzRHluYW1pYykge1xcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcXG4gICAgICAgICAgICBzeW5jR2VuID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIFxcXCIkZXZlbnRcXFwiKTtcXG4gICAgICAgICAgICBpZiAoIWlzRHluYW1pYykge1xcbiAgICAgICAgICAgICAgYWRkSGFuZGxlcihcXG4gICAgICAgICAgICAgICAgZWwsXFxuICAgICAgICAgICAgICAgIChcXFwidXBkYXRlOlxcXCIgKyAoY2FtZWxpemUobmFtZSkpKSxcXG4gICAgICAgICAgICAgICAgc3luY0dlbixcXG4gICAgICAgICAgICAgICAgbnVsbCxcXG4gICAgICAgICAgICAgICAgZmFsc2UsXFxuICAgICAgICAgICAgICAgIHdhcm4kMixcXG4gICAgICAgICAgICAgICAgbGlzdFtpXVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIGlmIChoeXBoZW5hdGUobmFtZSkgIT09IGNhbWVsaXplKG5hbWUpKSB7XFxuICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoXFxuICAgICAgICAgICAgICAgICAgZWwsXFxuICAgICAgICAgICAgICAgICAgKFxcXCJ1cGRhdGU6XFxcIiArIChoeXBoZW5hdGUobmFtZSkpKSxcXG4gICAgICAgICAgICAgICAgICBzeW5jR2VuLFxcbiAgICAgICAgICAgICAgICAgIG51bGwsXFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXFxuICAgICAgICAgICAgICAgICAgd2FybiQyLFxcbiAgICAgICAgICAgICAgICAgIGxpc3RbaV1cXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgLy8gaGFuZGxlciB3LyBkeW5hbWljIGV2ZW50IG5hbWVcXG4gICAgICAgICAgICAgIGFkZEhhbmRsZXIoXFxuICAgICAgICAgICAgICAgIGVsLFxcbiAgICAgICAgICAgICAgICAoXFxcIlxcXFxcXFwidXBkYXRlOlxcXFxcXFwiKyhcXFwiICsgbmFtZSArIFxcXCIpXFxcIiksXFxuICAgICAgICAgICAgICAgIHN5bmNHZW4sXFxuICAgICAgICAgICAgICAgIG51bGwsXFxuICAgICAgICAgICAgICAgIGZhbHNlLFxcbiAgICAgICAgICAgICAgICB3YXJuJDIsXFxuICAgICAgICAgICAgICAgIGxpc3RbaV0sXFxuICAgICAgICAgICAgICAgIHRydWUgLy8gZHluYW1pY1xcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcm9wKSB8fCAoXFxuICAgICAgICAgICFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpXFxuICAgICAgICApKSB7XFxuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUsIGxpc3RbaV0sIGlzRHluYW1pYyk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XFxuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcXG4gICAgICAgIGlmIChpc0R5bmFtaWMpIHtcXG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xcbiAgICAgICAgfVxcbiAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgZmFsc2UsIHdhcm4kMiwgbGlzdFtpXSwgaXNEeW5hbWljKTtcXG4gICAgICB9IGVsc2UgeyAvLyBub3JtYWwgZGlyZWN0aXZlc1xcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xcbiAgICAgICAgLy8gcGFyc2UgYXJnXFxuICAgICAgICB2YXIgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcXG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcXG4gICAgICAgIGlzRHluYW1pYyA9IGZhbHNlO1xcbiAgICAgICAgaWYgKGFyZykge1xcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XFxuICAgICAgICAgIGlmIChkeW5hbWljQXJnUkUudGVzdChhcmcpKSB7XFxuICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDEsIC0xKTtcXG4gICAgICAgICAgICBpc0R5bmFtaWMgPSB0cnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIGlzRHluYW1pYywgbW9kaWZpZXJzLCBsaXN0W2ldKTtcXG4gICAgICAgIGlmICggdHJ1ZSAmJiBuYW1lID09PSAnbW9kZWwnKSB7XFxuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxcbiAgICAgIGlmICh0cnVlKSB7XFxuICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcXG4gICAgICAgIGlmIChyZXMpIHtcXG4gICAgICAgICAgd2FybiQyKFxcbiAgICAgICAgICAgIG5hbWUgKyBcXFwiPVxcXFxcXFwiXFxcIiArIHZhbHVlICsgXFxcIlxcXFxcXFwiOiBcXFwiICtcXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcXG4gICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGlkPVxcXCJ7eyB2YWwgfX1cXFwiPiwgdXNlIDxkaXYgOmlkPVxcXCJ2YWxcXFwiPi4nLFxcbiAgICAgICAgICAgIGxpc3RbaV1cXG4gICAgICAgICAgKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpLCBsaXN0W2ldKTtcXG4gICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXFxuICAgICAgLy8gZXZlbiBpbW1lZGlhdGVseSBhZnRlciBlbGVtZW50IGNyZWF0aW9uXFxuICAgICAgaWYgKCFlbC5jb21wb25lbnQgJiZcXG4gICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxcbiAgICAgICAgICBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcXG4gICAgICAgIGFkZFByb3AoZWwsIG5hbWUsICd0cnVlJywgbGlzdFtpXSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGNoZWNrSW5Gb3IgKGVsKSB7XFxuICB2YXIgcGFyZW50ID0gZWw7XFxuICB3aGlsZSAocGFyZW50KSB7XFxuICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICByZXR1cm4gdHJ1ZVxcbiAgICB9XFxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XFxuICB9XFxuICByZXR1cm4gZmFsc2VcXG59XFxuXFxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcXG4gIHZhciBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XFxuICBpZiAobWF0Y2gpIHtcXG4gICAgdmFyIHJldCA9IHt9O1xcbiAgICBtYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldFttLnNsaWNlKDEpXSA9IHRydWU7IH0pO1xcbiAgICByZXR1cm4gcmV0XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcXG4gIHZhciBtYXAgPSB7fTtcXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIGlmIChcXG4gICAgICAgdHJ1ZSAmJlxcbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXFxuICAgICkge1xcbiAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUsIGF0dHJzW2ldKTtcXG4gICAgfVxcbiAgICBtYXBbYXR0cnNbaV0ubmFtZV0gPSBhdHRyc1tpXS52YWx1ZTtcXG4gIH1cXG4gIHJldHVybiBtYXBcXG59XFxuXFxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVxcXCJ4L3RlbXBsYXRlXFxcIikgb3Igc3R5bGUsIGRvIG5vdCBkZWNvZGUgY29udGVudFxcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcXG4gIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xcbn1cXG5cXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcXG4gIHJldHVybiAoXFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXFxuICAgICAgIWVsLmF0dHJzTWFwLnR5cGUgfHxcXG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xcbiAgICApKVxcbiAgKVxcbn1cXG5cXG52YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXFxcZCsvO1xcbnZhciBpZU5TUHJlZml4ID0gL15OU1xcXFxkKzovO1xcblxcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXFxuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcXG4gIHZhciByZXMgPSBbXTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcXG4gICAgaWYgKCFpZU5TQnVnLnRlc3QoYXR0ci5uYW1lKSkge1xcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcXG4gICAgICByZXMucHVzaChhdHRyKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHJlc1xcbn1cXG5cXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwgKGVsLCB2YWx1ZSkge1xcbiAgdmFyIF9lbCA9IGVsO1xcbiAgd2hpbGUgKF9lbCkge1xcbiAgICBpZiAoX2VsLmZvciAmJiBfZWwuYWxpYXMgPT09IHZhbHVlKSB7XFxuICAgICAgd2FybiQyKFxcbiAgICAgICAgXFxcIjxcXFwiICsgKGVsLnRhZykgKyBcXFwiIHYtbW9kZWw9XFxcXFxcXCJcXFwiICsgdmFsdWUgKyBcXFwiXFxcXFxcXCI+OiBcXFwiICtcXG4gICAgICAgIFxcXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXFxcIiArXFxuICAgICAgICBcXFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXFxcIiArXFxuICAgICAgICBcXFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXFxcIiArXFxuICAgICAgICBcXFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXFxcIixcXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cXG4gICAgICApO1xcbiAgICB9XFxuICAgIF9lbCA9IF9lbC5wYXJlbnQ7XFxuICB9XFxufVxcblxcbi8qICAqL1xcblxcbmZ1bmN0aW9uIHByZVRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XFxuICBpZiAoZWwudGFnID09PSAnaW5wdXQnKSB7XFxuICAgIHZhciBtYXAgPSBlbC5hdHRyc01hcDtcXG4gICAgaWYgKCFtYXBbJ3YtbW9kZWwnXSkge1xcbiAgICAgIHJldHVyblxcbiAgICB9XFxuXFxuICAgIHZhciB0eXBlQmluZGluZztcXG4gICAgaWYgKG1hcFsnOnR5cGUnXSB8fCBtYXBbJ3YtYmluZDp0eXBlJ10pIHtcXG4gICAgICB0eXBlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHlwZScpO1xcbiAgICB9XFxuICAgIGlmICghbWFwLnR5cGUgJiYgIXR5cGVCaW5kaW5nICYmIG1hcFsndi1iaW5kJ10pIHtcXG4gICAgICB0eXBlQmluZGluZyA9IFxcXCIoXFxcIiArIChtYXBbJ3YtYmluZCddKSArIFxcXCIpLnR5cGVcXFwiO1xcbiAgICB9XFxuXFxuICAgIGlmICh0eXBlQmluZGluZykge1xcbiAgICAgIHZhciBpZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJywgdHJ1ZSk7XFxuICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IChcXFwiJiYoXFxcIiArIGlmQ29uZGl0aW9uICsgXFxcIilcXFwiKSA6IFxcXCJcXFwiO1xcbiAgICAgIHZhciBoYXNFbHNlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScsIHRydWUpICE9IG51bGw7XFxuICAgICAgdmFyIGVsc2VJZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnLCB0cnVlKTtcXG4gICAgICAvLyAxLiBjaGVja2JveFxcbiAgICAgIHZhciBicmFuY2gwID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcXG4gICAgICAvLyBwcm9jZXNzIGZvciBvbiB0aGUgbWFpbiBub2RlXFxuICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcXG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDAsICd0eXBlJywgJ2NoZWNrYm94Jyk7XFxuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMCwgb3B0aW9ucyk7XFxuICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxcbiAgICAgIGJyYW5jaDAuaWYgPSBcXFwiKFxcXCIgKyB0eXBlQmluZGluZyArIFxcXCIpPT09J2NoZWNrYm94J1xcXCIgKyBpZkNvbmRpdGlvbkV4dHJhO1xcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcXG4gICAgICAgIGV4cDogYnJhbmNoMC5pZixcXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXFxuICAgICAgfSk7XFxuICAgICAgLy8gMi4gYWRkIHJhZGlvIGVsc2UtaWYgY29uZGl0aW9uXFxuICAgICAgdmFyIGJyYW5jaDEgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xcbiAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMSwgJ3YtZm9yJywgdHJ1ZSk7XFxuICAgICAgYWRkUmF3QXR0cihicmFuY2gxLCAndHlwZScsICdyYWRpbycpO1xcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDEsIG9wdGlvbnMpO1xcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcXG4gICAgICAgIGV4cDogXFxcIihcXFwiICsgdHlwZUJpbmRpbmcgKyBcXFwiKT09PSdyYWRpbydcXFwiICsgaWZDb25kaXRpb25FeHRyYSxcXG4gICAgICAgIGJsb2NrOiBicmFuY2gxXFxuICAgICAgfSk7XFxuICAgICAgLy8gMy4gb3RoZXJcXG4gICAgICB2YXIgYnJhbmNoMiA9IGNsb25lQVNURWxlbWVudChlbCk7XFxuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gyLCAndi1mb3InLCB0cnVlKTtcXG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDIsICc6dHlwZScsIHR5cGVCaW5kaW5nKTtcXG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gyLCBvcHRpb25zKTtcXG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XFxuICAgICAgICBleHA6IGlmQ29uZGl0aW9uLFxcbiAgICAgICAgYmxvY2s6IGJyYW5jaDJcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAoaGFzRWxzZSkge1xcbiAgICAgICAgYnJhbmNoMC5lbHNlID0gdHJ1ZTtcXG4gICAgICB9IGVsc2UgaWYgKGVsc2VJZkNvbmRpdGlvbikge1xcbiAgICAgICAgYnJhbmNoMC5lbHNlaWYgPSBlbHNlSWZDb25kaXRpb247XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBicmFuY2gwXFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gY2xvbmVBU1RFbGVtZW50IChlbCkge1xcbiAgcmV0dXJuIGNyZWF0ZUFTVEVsZW1lbnQoZWwudGFnLCBlbC5hdHRyc0xpc3Quc2xpY2UoKSwgZWwucGFyZW50KVxcbn1cXG5cXG52YXIgbW9kZWwkMSA9IHtcXG4gIHByZVRyYW5zZm9ybU5vZGU6IHByZVRyYW5zZm9ybU5vZGVcXG59O1xcblxcbnZhciBtb2R1bGVzJDEgPSBbXFxuICBrbGFzcyQxLFxcbiAgc3R5bGUkMSxcXG4gIG1vZGVsJDFcXG5dO1xcblxcbi8qICAqL1xcblxcbmZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcXG4gIGlmIChkaXIudmFsdWUpIHtcXG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFxcXCJfcyhcXFwiICsgKGRpci52YWx1ZSkgKyBcXFwiKVxcXCIpLCBkaXIpO1xcbiAgfVxcbn1cXG5cXG4vKiAgKi9cXG5cXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XFxuICBpZiAoZGlyLnZhbHVlKSB7XFxuICAgIGFkZFByb3AoZWwsICdpbm5lckhUTUwnLCAoXFxcIl9zKFxcXCIgKyAoZGlyLnZhbHVlKSArIFxcXCIpXFxcIiksIGRpcik7XFxuICB9XFxufVxcblxcbnZhciBkaXJlY3RpdmVzJDEgPSB7XFxuICBtb2RlbDogbW9kZWwsXFxuICB0ZXh0OiB0ZXh0LFxcbiAgaHRtbDogaHRtbFxcbn07XFxuXFxuLyogICovXFxuXFxudmFyIGJhc2VPcHRpb25zID0ge1xcbiAgZXhwZWN0SFRNTDogdHJ1ZSxcXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcXG4gIGlzUHJlVGFnOiBpc1ByZVRhZyxcXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXFxuICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXFxuICBjYW5CZUxlZnRPcGVuVGFnOiBjYW5CZUxlZnRPcGVuVGFnLFxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcXG4gIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxcbiAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXFxufTtcXG5cXG4vKiAgKi9cXG5cXG52YXIgaXNTdGF0aWNLZXk7XFxudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcXG5cXG52YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xcblxcbi8qKlxcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXFxuICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXFxuICpcXG4gKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcXG4gKlxcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cXG4gKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XFxuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXFxuICovXFxuZnVuY3Rpb24gb3B0aW1pemUgKHJvb3QsIG9wdGlvbnMpIHtcXG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxcbiAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XFxuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XFxuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxcbiAgbWFya1N0YXRpYyQxKHJvb3QpO1xcbiAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxcbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcXG59XFxuXFxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XFxuICByZXR1cm4gbWFrZU1hcChcXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMsc3RhcnQsZW5kLHJhd0F0dHJzTWFwJyArXFxuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxcbiAgKVxcbn1cXG5cXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcXG4gIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XFxuICBpZiAobm9kZS50eXBlID09PSAxKSB7XFxuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xcbiAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXFxuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcXG4gICAgaWYgKFxcbiAgICAgICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXFxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcXG4gICAgKSB7XFxuICAgICAgcmV0dXJuXFxuICAgIH1cXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XFxuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcXG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XFxuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XFxuICAgICAgICB2YXIgYmxvY2sgPSBub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrO1xcbiAgICAgICAgbWFya1N0YXRpYyQxKGJsb2NrKTtcXG4gICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XFxuICAgICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xcbiAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XFxuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XFxuICAgIH1cXG4gICAgLy8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcXG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxcbiAgICBpZiAobm9kZS5zdGF0aWMgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgIShcXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xcbiAgICApKSB7XFxuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcXG4gICAgICByZXR1cm5cXG4gICAgfSBlbHNlIHtcXG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcXG4gICAgfVxcbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcXG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcXG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrLCBpc0luRm9yKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcXG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxcbiAgICByZXR1cm4gZmFsc2VcXG4gIH1cXG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxcbiAgICByZXR1cm4gdHJ1ZVxcbiAgfVxcbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcXG4gICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xcbiAgICAhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXFxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXFxuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XFxuICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcXG4gICkpXFxufVxcblxcbmZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XFxuICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcXG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xcbiAgICBpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcXG4gICAgICByZXR1cm4gZmFsc2VcXG4gICAgfVxcbiAgICBpZiAobm9kZS5mb3IpIHtcXG4gICAgICByZXR1cm4gdHJ1ZVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gZmFsc2VcXG59XFxuXFxuLyogICovXFxuXFxudmFyIGZuRXhwUkUgPSAvXihbXFxcXHckX10rfFxcXFwoW14pXSo/XFxcXCkpXFxcXHMqPT58XmZ1bmN0aW9uXFxcXHMqKD86W1xcXFx3JF0rKT9cXFxccypcXFxcKC87XFxudmFyIGZuSW52b2tlUkUgPSAvXFxcXChbXildKj9cXFxcKTsqJC87XFxudmFyIHNpbXBsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXFxcdyRdKig/OlxcXFwuW0EtWmEtel8kXVtcXFxcdyRdKnxcXFxcWydbXiddKj8nXXxcXFxcW1xcXCJbXlxcXCJdKj9cXFwiXXxcXFxcW1xcXFxkK118XFxcXFtbQS1aYS16XyRdW1xcXFx3JF0qXSkqJC87XFxuXFxuLy8gS2V5Ym9hcmRFdmVudC5rZXlDb2RlIGFsaWFzZXNcXG52YXIga2V5Q29kZXMgPSB7XFxuICBlc2M6IDI3LFxcbiAgdGFiOiA5LFxcbiAgZW50ZXI6IDEzLFxcbiAgc3BhY2U6IDMyLFxcbiAgdXA6IDM4LFxcbiAgbGVmdDogMzcsXFxuICByaWdodDogMzksXFxuICBkb3duOiA0MCxcXG4gICdkZWxldGUnOiBbOCwgNDZdXFxufTtcXG5cXG4vLyBLZXlib2FyZEV2ZW50LmtleSBhbGlhc2VzXFxudmFyIGtleU5hbWVzID0ge1xcbiAgLy8gIzc4ODA6IElFMTEgYW5kIEVkZ2UgdXNlIGBFc2NgIGZvciBFc2NhcGUga2V5IG5hbWUuXFxuICBlc2M6IFsnRXNjJywgJ0VzY2FwZSddLFxcbiAgdGFiOiAnVGFiJyxcXG4gIGVudGVyOiAnRW50ZXInLFxcbiAgLy8gIzkxMTI6IElFMTEgdXNlcyBgU3BhY2ViYXJgIGZvciBTcGFjZSBrZXkgbmFtZS5cXG4gIHNwYWNlOiBbJyAnLCAnU3BhY2ViYXInXSxcXG4gIC8vICM3ODA2OiBJRTExIHVzZXMga2V5IG5hbWVzIHdpdGhvdXQgYEFycm93YCBwcmVmaXggZm9yIGFycm93IGtleXMuXFxuICB1cDogWydVcCcsICdBcnJvd1VwJ10sXFxuICBsZWZ0OiBbJ0xlZnQnLCAnQXJyb3dMZWZ0J10sXFxuICByaWdodDogWydSaWdodCcsICdBcnJvd1JpZ2h0J10sXFxuICBkb3duOiBbJ0Rvd24nLCAnQXJyb3dEb3duJ10sXFxuICAvLyAjOTExMjogSUUxMSB1c2VzIGBEZWxgIGZvciBEZWxldGUga2V5IG5hbWUuXFxuICAnZGVsZXRlJzogWydCYWNrc3BhY2UnLCAnRGVsZXRlJywgJ0RlbCddXFxufTtcXG5cXG4vLyAjNDg2ODogbW9kaWZpZXJzIHRoYXQgcHJldmVudCB0aGUgZXhlY3V0aW9uIG9mIHRoZSBsaXN0ZW5lclxcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXFxudmFyIGdlbkd1YXJkID0gZnVuY3Rpb24gKGNvbmRpdGlvbikgeyByZXR1cm4gKFxcXCJpZihcXFwiICsgY29uZGl0aW9uICsgXFxcIilyZXR1cm4gbnVsbDtcXFwiKTsgfTtcXG5cXG52YXIgbW9kaWZpZXJDb2RlID0ge1xcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxcbiAgcHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXFxuICBzZWxmOiBnZW5HdWFyZChcXFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcXFwiKSxcXG4gIGN0cmw6IGdlbkd1YXJkKFxcXCIhJGV2ZW50LmN0cmxLZXlcXFwiKSxcXG4gIHNoaWZ0OiBnZW5HdWFyZChcXFwiISRldmVudC5zaGlmdEtleVxcXCIpLFxcbiAgYWx0OiBnZW5HdWFyZChcXFwiISRldmVudC5hbHRLZXlcXFwiKSxcXG4gIG1ldGE6IGdlbkd1YXJkKFxcXCIhJGV2ZW50Lm1ldGFLZXlcXFwiKSxcXG4gIGxlZnQ6IGdlbkd1YXJkKFxcXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFxcXCIpLFxcbiAgbWlkZGxlOiBnZW5HdWFyZChcXFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcXFwiKSxcXG4gIHJpZ2h0OiBnZW5HdWFyZChcXFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcXFwiKVxcbn07XFxuXFxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxcbiAgZXZlbnRzLFxcbiAgaXNOYXRpdmVcXG4pIHtcXG4gIHZhciBwcmVmaXggPSBpc05hdGl2ZSA/ICduYXRpdmVPbjonIDogJ29uOic7XFxuICB2YXIgc3RhdGljSGFuZGxlcnMgPSBcXFwiXFxcIjtcXG4gIHZhciBkeW5hbWljSGFuZGxlcnMgPSBcXFwiXFxcIjtcXG4gIGZvciAodmFyIG5hbWUgaW4gZXZlbnRzKSB7XFxuICAgIHZhciBoYW5kbGVyQ29kZSA9IGdlbkhhbmRsZXIoZXZlbnRzW25hbWVdKTtcXG4gICAgaWYgKGV2ZW50c1tuYW1lXSAmJiBldmVudHNbbmFtZV0uZHluYW1pYykge1xcbiAgICAgIGR5bmFtaWNIYW5kbGVycyArPSBuYW1lICsgXFxcIixcXFwiICsgaGFuZGxlckNvZGUgKyBcXFwiLFxcXCI7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3RhdGljSGFuZGxlcnMgKz0gXFxcIlxcXFxcXFwiXFxcIiArIG5hbWUgKyBcXFwiXFxcXFxcXCI6XFxcIiArIGhhbmRsZXJDb2RlICsgXFxcIixcXFwiO1xcbiAgICB9XFxuICB9XFxuICBzdGF0aWNIYW5kbGVycyA9IFxcXCJ7XFxcIiArIChzdGF0aWNIYW5kbGVycy5zbGljZSgwLCAtMSkpICsgXFxcIn1cXFwiO1xcbiAgaWYgKGR5bmFtaWNIYW5kbGVycykge1xcbiAgICByZXR1cm4gcHJlZml4ICsgXFxcIl9kKFxcXCIgKyBzdGF0aWNIYW5kbGVycyArIFxcXCIsW1xcXCIgKyAoZHluYW1pY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcXFwiXSlcXFwiXFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gcHJlZml4ICsgc3RhdGljSGFuZGxlcnNcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZ2VuSGFuZGxlciAoaGFuZGxlcikge1xcbiAgaWYgKCFoYW5kbGVyKSB7XFxuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xcbiAgfVxcblxcbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcXG4gICAgcmV0dXJuIChcXFwiW1xcXCIgKyAoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIoaGFuZGxlcik7IH0pLmpvaW4oJywnKSkgKyBcXFwiXVxcXCIpXFxuICB9XFxuXFxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XFxuICB2YXIgaXNGdW5jdGlvbkV4cHJlc3Npb24gPSBmbkV4cFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XFxuICB2YXIgaXNGdW5jdGlvbkludm9jYXRpb24gPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlLnJlcGxhY2UoZm5JbnZva2VSRSwgJycpKTtcXG5cXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcXG4gICAgaWYgKGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvbikge1xcbiAgICAgIHJldHVybiBoYW5kbGVyLnZhbHVlXFxuICAgIH1cXG4gICAgcmV0dXJuIChcXFwiZnVuY3Rpb24oJGV2ZW50KXtcXFwiICsgKGlzRnVuY3Rpb25JbnZvY2F0aW9uID8gKFxcXCJyZXR1cm4gXFxcIiArIChoYW5kbGVyLnZhbHVlKSkgOiBoYW5kbGVyLnZhbHVlKSArIFxcXCJ9XFxcIikgLy8gaW5saW5lIHN0YXRlbWVudFxcbiAgfSBlbHNlIHtcXG4gICAgdmFyIGNvZGUgPSAnJztcXG4gICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xcbiAgICB2YXIga2V5cyA9IFtdO1xcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcXG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcXG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcXG4gICAgICAgIC8vIGxlZnQvcmlnaHRcXG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XFxuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZXhhY3QnKSB7XFxuICAgICAgICB2YXIgbW9kaWZpZXJzID0gKGhhbmRsZXIubW9kaWZpZXJzKTtcXG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBnZW5HdWFyZChcXG4gICAgICAgICAgWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ11cXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gIW1vZGlmaWVyc1trZXlNb2RpZmllcl07IH0pXFxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuIChcXFwiJGV2ZW50LlxcXCIgKyBrZXlNb2RpZmllciArIFxcXCJLZXlcXFwiKTsgfSlcXG4gICAgICAgICAgICAuam9pbignfHwnKVxcbiAgICAgICAgKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xcbiAgICB9XFxuICAgIC8vIE1ha2Ugc3VyZSBtb2RpZmllcnMgbGlrZSBwcmV2ZW50IGFuZCBzdG9wIGdldCBleGVjdXRlZCBhZnRlciBrZXkgZmlsdGVyaW5nXFxuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcXG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcXG4gICAgfVxcbiAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcXG4gICAgICA/IChcXFwicmV0dXJuIFxcXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcXFwiKCRldmVudClcXFwiKVxcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cXG4gICAgICAgID8gKFxcXCJyZXR1cm4gKFxcXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcXFwiKSgkZXZlbnQpXFxcIilcXG4gICAgICAgIDogaXNGdW5jdGlvbkludm9jYXRpb25cXG4gICAgICAgICAgPyAoXFxcInJldHVybiBcXFwiICsgKGhhbmRsZXIudmFsdWUpKVxcbiAgICAgICAgICA6IGhhbmRsZXIudmFsdWU7XFxuICAgIHJldHVybiAoXFxcImZ1bmN0aW9uKCRldmVudCl7XFxcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFxcXCJ9XFxcIilcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZ2VuS2V5RmlsdGVyIChrZXlzKSB7XFxuICByZXR1cm4gKFxcbiAgICAvLyBtYWtlIHN1cmUgdGhlIGtleSBmaWx0ZXJzIG9ubHkgYXBwbHkgdG8gS2V5Ym9hcmRFdmVudHNcXG4gICAgLy8gIzk0NDE6IGNhbid0IHVzZSAna2V5Q29kZScgaW4gJGV2ZW50IGJlY2F1c2UgQ2hyb21lIGF1dG9maWxsIGZpcmVzIGZha2VcXG4gICAgLy8ga2V5IGV2ZW50cyB0aGF0IGRvIG5vdCBoYXZlIGtleUNvZGUgcHJvcGVydHkuLi5cXG4gICAgXFxcImlmKCEkZXZlbnQudHlwZS5pbmRleE9mKCdrZXknKSYmXFxcIiArXFxuICAgIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFxcXCIpcmV0dXJuIG51bGw7XFxcIlxcbiAgKVxcbn1cXG5cXG5mdW5jdGlvbiBnZW5GaWx0ZXJDb2RlIChrZXkpIHtcXG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcXG4gIGlmIChrZXlWYWwpIHtcXG4gICAgcmV0dXJuIChcXFwiJGV2ZW50LmtleUNvZGUhPT1cXFwiICsga2V5VmFsKVxcbiAgfVxcbiAgdmFyIGtleUNvZGUgPSBrZXlDb2Rlc1trZXldO1xcbiAgdmFyIGtleU5hbWUgPSBrZXlOYW1lc1trZXldO1xcbiAgcmV0dXJuIChcXG4gICAgXFxcIl9rKCRldmVudC5rZXlDb2RlLFxcXCIgK1xcbiAgICAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyBcXFwiLFxcXCIgK1xcbiAgICAoSlNPTi5zdHJpbmdpZnkoa2V5Q29kZSkpICsgXFxcIixcXFwiICtcXG4gICAgXFxcIiRldmVudC5rZXksXFxcIiArXFxuICAgIFxcXCJcXFwiICsgKEpTT04uc3RyaW5naWZ5KGtleU5hbWUpKSArXFxuICAgIFxcXCIpXFxcIlxcbiAgKVxcbn1cXG5cXG4vKiAgKi9cXG5cXG5mdW5jdGlvbiBvbiAoZWwsIGRpcikge1xcbiAgaWYgKCB0cnVlICYmIGRpci5tb2RpZmllcnMpIHtcXG4gICAgd2FybihcXFwidi1vbiB3aXRob3V0IGFyZ3VtZW50IGRvZXMgbm90IHN1cHBvcnQgbW9kaWZpZXJzLlxcXCIpO1xcbiAgfVxcbiAgZWwud3JhcExpc3RlbmVycyA9IGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXFxcIl9nKFxcXCIgKyBjb2RlICsgXFxcIixcXFwiICsgKGRpci52YWx1ZSkgKyBcXFwiKVxcXCIpOyB9O1xcbn1cXG5cXG4vKiAgKi9cXG5cXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcXG4gIGVsLndyYXBEYXRhID0gZnVuY3Rpb24gKGNvZGUpIHtcXG4gICAgcmV0dXJuIChcXFwiX2IoXFxcIiArIGNvZGUgKyBcXFwiLCdcXFwiICsgKGVsLnRhZykgKyBcXFwiJyxcXFwiICsgKGRpci52YWx1ZSkgKyBcXFwiLFxcXCIgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJykgKyBcXFwiKVxcXCIpXFxuICB9O1xcbn1cXG5cXG4vKiAgKi9cXG5cXG52YXIgYmFzZURpcmVjdGl2ZXMgPSB7XFxuICBvbjogb24sXFxuICBiaW5kOiBiaW5kJDEsXFxuICBjbG9hazogbm9vcFxcbn07XFxuXFxuLyogICovXFxuXFxuXFxuXFxuXFxuXFxudmFyIENvZGVnZW5TdGF0ZSA9IGZ1bmN0aW9uIENvZGVnZW5TdGF0ZSAob3B0aW9ucykge1xcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcXG4gIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcXG4gIHRoaXMudHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xcbiAgdGhpcy5kYXRhR2VuRm5zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdnZW5EYXRhJyk7XFxuICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XFxuICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcXG4gIHRoaXMubWF5YmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuICEhZWwuY29tcG9uZW50IHx8ICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7IH07XFxuICB0aGlzLm9uY2VJZCA9IDA7XFxuICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xcbiAgdGhpcy5wcmUgPSBmYWxzZTtcXG59O1xcblxcblxcblxcbmZ1bmN0aW9uIGdlbmVyYXRlIChcXG4gIGFzdCxcXG4gIG9wdGlvbnNcXG4pIHtcXG4gIHZhciBzdGF0ZSA9IG5ldyBDb2RlZ2VuU3RhdGUob3B0aW9ucyk7XFxuICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSkgOiAnX2MoXFxcImRpdlxcXCIpJztcXG4gIHJldHVybiB7XFxuICAgIHJlbmRlcjogKFxcXCJ3aXRoKHRoaXMpe3JldHVybiBcXFwiICsgY29kZSArIFxcXCJ9XFxcIiksXFxuICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGUuc3RhdGljUmVuZGVyRm5zXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGdlbkVsZW1lbnQgKGVsLCBzdGF0ZSkge1xcbiAgaWYgKGVsLnBhcmVudCkge1xcbiAgICBlbC5wcmUgPSBlbC5wcmUgfHwgZWwucGFyZW50LnByZTtcXG4gIH1cXG5cXG4gIGlmIChlbC5zdGF0aWNSb290ICYmICFlbC5zdGF0aWNQcm9jZXNzZWQpIHtcXG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXFxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcXG4gICAgcmV0dXJuIGdlbk9uY2UoZWwsIHN0YXRlKVxcbiAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcXG4gIH0gZWxzZSBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XFxuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXFxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCAmJiAhc3RhdGUucHJlKSB7XFxuICAgIHJldHVybiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd2b2lkIDAnXFxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XFxuICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcXG4gIH0gZWxzZSB7XFxuICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XFxuICAgIHZhciBjb2RlO1xcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XFxuICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsLCBzdGF0ZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIGRhdGE7XFxuICAgICAgaWYgKCFlbC5wbGFpbiB8fCAoZWwucHJlICYmIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSkpIHtcXG4gICAgICAgIGRhdGEgPSBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcXG4gICAgICBjb2RlID0gXFxcIl9jKCdcXFwiICsgKGVsLnRhZykgKyBcXFwiJ1xcXCIgKyAoZGF0YSA/IChcXFwiLFxcXCIgKyBkYXRhKSA6ICcnKSArIChjaGlsZHJlbiA/IChcXFwiLFxcXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcXFwiKVxcXCI7XFxuICAgIH1cXG4gICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgY29kZSA9IHN0YXRlLnRyYW5zZm9ybXNbaV0oZWwsIGNvZGUpO1xcbiAgICB9XFxuICAgIHJldHVybiBjb2RlXFxuICB9XFxufVxcblxcbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XFxuZnVuY3Rpb24gZ2VuU3RhdGljIChlbCwgc3RhdGUpIHtcXG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XFxuICAvLyBTb21lIGVsZW1lbnRzICh0ZW1wbGF0ZXMpIG5lZWQgdG8gYmVoYXZlIGRpZmZlcmVudGx5IGluc2lkZSBvZiBhIHYtcHJlXFxuICAvLyBub2RlLiAgQWxsIHByZSBub2RlcyBhcmUgc3RhdGljIHJvb3RzLCBzbyB3ZSBjYW4gdXNlIHRoaXMgYXMgYSBsb2NhdGlvbiB0b1xcbiAgLy8gd3JhcCBhIHN0YXRlIGNoYW5nZSBhbmQgcmVzZXQgaXQgdXBvbiBleGl0aW5nIHRoZSBwcmUgbm9kZS5cXG4gIHZhciBvcmlnaW5hbFByZVN0YXRlID0gc3RhdGUucHJlO1xcbiAgaWYgKGVsLnByZSkge1xcbiAgICBzdGF0ZS5wcmUgPSBlbC5wcmU7XFxuICB9XFxuICBzdGF0ZS5zdGF0aWNSZW5kZXJGbnMucHVzaCgoXFxcIndpdGgodGhpcyl7cmV0dXJuIFxcXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFxcXCJ9XFxcIikpO1xcbiAgc3RhdGUucHJlID0gb3JpZ2luYWxQcmVTdGF0ZTtcXG4gIHJldHVybiAoXFxcIl9tKFxcXCIgKyAoc3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpICsgKGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnKSArIFxcXCIpXFxcIilcXG59XFxuXFxuLy8gdi1vbmNlXFxuZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XFxuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcXG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcXG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcXG4gICAgdmFyIGtleSA9ICcnO1xcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xcbiAgICB3aGlsZSAocGFyZW50KSB7XFxuICAgICAgaWYgKHBhcmVudC5mb3IpIHtcXG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XFxuICAgICAgICBicmVha1xcbiAgICAgIH1cXG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xcbiAgICB9XFxuICAgIGlmICgha2V5KSB7XFxuICAgICAgIHRydWUgJiYgc3RhdGUud2FybihcXG4gICAgICAgIFxcXCJ2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gXFxcIixcXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW9uY2UnXVxcbiAgICAgICk7XFxuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxcbiAgICB9XFxuICAgIHJldHVybiAoXFxcIl9vKFxcXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFxcXCIsXFxcIiArIChzdGF0ZS5vbmNlSWQrKykgKyBcXFwiLFxcXCIgKyBrZXkgKyBcXFwiKVxcXCIpXFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZ2VuSWYgKFxcbiAgZWwsXFxuICBzdGF0ZSxcXG4gIGFsdEdlbixcXG4gIGFsdEVtcHR5XFxuKSB7XFxuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxcbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpXFxufVxcblxcbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoXFxuICBjb25kaXRpb25zLFxcbiAgc3RhdGUsXFxuICBhbHRHZW4sXFxuICBhbHRFbXB0eVxcbikge1xcbiAgaWYgKCFjb25kaXRpb25zLmxlbmd0aCkge1xcbiAgICByZXR1cm4gYWx0RW1wdHkgfHwgJ19lKCknXFxuICB9XFxuXFxuICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcXG4gICAgcmV0dXJuIChcXFwiKFxcXCIgKyAoY29uZGl0aW9uLmV4cCkgKyBcXFwiKT9cXFwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcXFwiOlxcXCIgKyAoZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMsIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KSkpXFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gKFxcXCJcXFwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXFxuICB9XFxuXFxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXFxuICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xcbiAgICByZXR1cm4gYWx0R2VuXFxuICAgICAgPyBhbHRHZW4oZWwsIHN0YXRlKVxcbiAgICAgIDogZWwub25jZVxcbiAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcXG4gICAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGdlbkZvciAoXFxuICBlbCxcXG4gIHN0YXRlLFxcbiAgYWx0R2VuLFxcbiAgYWx0SGVscGVyXFxuKSB7XFxuICB2YXIgZXhwID0gZWwuZm9yO1xcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XFxuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFxcXCIsXFxcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcXFwiLFxcXCIgKyAoZWwuaXRlcmF0b3IyKSkgOiAnJztcXG5cXG4gIGlmICggdHJ1ZSAmJlxcbiAgICBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkgJiZcXG4gICAgZWwudGFnICE9PSAnc2xvdCcgJiZcXG4gICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXFxuICAgICFlbC5rZXlcXG4gICkge1xcbiAgICBzdGF0ZS53YXJuKFxcbiAgICAgIFxcXCI8XFxcIiArIChlbC50YWcpICsgXFxcIiB2LWZvcj1cXFxcXFxcIlxcXCIgKyBhbGlhcyArIFxcXCIgaW4gXFxcIiArIGV4cCArIFxcXCJcXFxcXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFxcXCIgK1xcbiAgICAgIFxcXCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcXFwiICtcXG4gICAgICBcXFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cXFwiLFxcbiAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddLFxcbiAgICAgIHRydWUgLyogdGlwICovXFxuICAgICk7XFxuICB9XFxuXFxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cXG4gIHJldHVybiAoYWx0SGVscGVyIHx8ICdfbCcpICsgXFxcIigoXFxcIiArIGV4cCArIFxcXCIpLFxcXCIgK1xcbiAgICBcXFwiZnVuY3Rpb24oXFxcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXFxcIil7XFxcIiArXFxuICAgICAgXFxcInJldHVybiBcXFwiICsgKChhbHRHZW4gfHwgZ2VuRWxlbWVudCkoZWwsIHN0YXRlKSkgK1xcbiAgICAnfSknXFxufVxcblxcbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwsIHN0YXRlKSB7XFxuICB2YXIgZGF0YSA9ICd7JztcXG5cXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXFxuICAvLyBkaXJlY3RpdmVzIG1heSBtdXRhdGUgdGhlIGVsJ3Mgb3RoZXIgcHJvcGVydGllcyBiZWZvcmUgdGhleSBhcmUgZ2VuZXJhdGVkLlxcbiAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsLCBzdGF0ZSk7XFxuICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cXG5cXG4gIC8vIGtleVxcbiAgaWYgKGVsLmtleSkge1xcbiAgICBkYXRhICs9IFxcXCJrZXk6XFxcIiArIChlbC5rZXkpICsgXFxcIixcXFwiO1xcbiAgfVxcbiAgLy8gcmVmXFxuICBpZiAoZWwucmVmKSB7XFxuICAgIGRhdGEgKz0gXFxcInJlZjpcXFwiICsgKGVsLnJlZikgKyBcXFwiLFxcXCI7XFxuICB9XFxuICBpZiAoZWwucmVmSW5Gb3IpIHtcXG4gICAgZGF0YSArPSBcXFwicmVmSW5Gb3I6dHJ1ZSxcXFwiO1xcbiAgfVxcbiAgLy8gcHJlXFxuICBpZiAoZWwucHJlKSB7XFxuICAgIGRhdGEgKz0gXFxcInByZTp0cnVlLFxcXCI7XFxuICB9XFxuICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXFxcImlzXFxcIiBhdHRyaWJ1dGVcXG4gIGlmIChlbC5jb21wb25lbnQpIHtcXG4gICAgZGF0YSArPSBcXFwidGFnOlxcXFxcXFwiXFxcIiArIChlbC50YWcpICsgXFxcIlxcXFxcXFwiLFxcXCI7XFxuICB9XFxuICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XFxuICAgIGRhdGEgKz0gc3RhdGUuZGF0YUdlbkZuc1tpXShlbCk7XFxuICB9XFxuICAvLyBhdHRyaWJ1dGVzXFxuICBpZiAoZWwuYXR0cnMpIHtcXG4gICAgZGF0YSArPSBcXFwiYXR0cnM6XFxcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXFxcIixcXFwiO1xcbiAgfVxcbiAgLy8gRE9NIHByb3BzXFxuICBpZiAoZWwucHJvcHMpIHtcXG4gICAgZGF0YSArPSBcXFwiZG9tUHJvcHM6XFxcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXFxcIixcXFwiO1xcbiAgfVxcbiAgLy8gZXZlbnQgaGFuZGxlcnNcXG4gIGlmIChlbC5ldmVudHMpIHtcXG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSkpICsgXFxcIixcXFwiO1xcbiAgfVxcbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUpKSArIFxcXCIsXFxcIjtcXG4gIH1cXG4gIC8vIHNsb3QgdGFyZ2V0XFxuICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzXFxuICBpZiAoZWwuc2xvdFRhcmdldCAmJiAhZWwuc2xvdFNjb3BlKSB7XFxuICAgIGRhdGEgKz0gXFxcInNsb3Q6XFxcIiArIChlbC5zbG90VGFyZ2V0KSArIFxcXCIsXFxcIjtcXG4gIH1cXG4gIC8vIHNjb3BlZCBzbG90c1xcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XFxuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLCBlbC5zY29wZWRTbG90cywgc3RhdGUpKSArIFxcXCIsXFxcIjtcXG4gIH1cXG4gIC8vIGNvbXBvbmVudCB2LW1vZGVsXFxuICBpZiAoZWwubW9kZWwpIHtcXG4gICAgZGF0YSArPSBcXFwibW9kZWw6e3ZhbHVlOlxcXCIgKyAoZWwubW9kZWwudmFsdWUpICsgXFxcIixjYWxsYmFjazpcXFwiICsgKGVsLm1vZGVsLmNhbGxiYWNrKSArIFxcXCIsZXhwcmVzc2lvbjpcXFwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXFxcIn0sXFxcIjtcXG4gIH1cXG4gIC8vIGlubGluZS10ZW1wbGF0ZVxcbiAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XFxuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XFxuICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xcbiAgICAgIGRhdGEgKz0gaW5saW5lVGVtcGxhdGUgKyBcXFwiLFxcXCI7XFxuICAgIH1cXG4gIH1cXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xcbiAgLy8gdi1iaW5kIGR5bmFtaWMgYXJndW1lbnQgd3JhcFxcbiAgLy8gdi1iaW5kIHdpdGggZHluYW1pYyBhcmd1bWVudHMgbXVzdCBiZSBhcHBsaWVkIHVzaW5nIHRoZSBzYW1lIHYtYmluZCBvYmplY3RcXG4gIC8vIG1lcmdlIGhlbHBlciBzbyB0aGF0IGNsYXNzL3N0eWxlL211c3RVc2VQcm9wIGF0dHJzIGFyZSBoYW5kbGVkIGNvcnJlY3RseS5cXG4gIGlmIChlbC5keW5hbWljQXR0cnMpIHtcXG4gICAgZGF0YSA9IFxcXCJfYihcXFwiICsgZGF0YSArIFxcXCIsXFxcXFxcXCJcXFwiICsgKGVsLnRhZykgKyBcXFwiXFxcXFxcXCIsXFxcIiArIChnZW5Qcm9wcyhlbC5keW5hbWljQXR0cnMpKSArIFxcXCIpXFxcIjtcXG4gIH1cXG4gIC8vIHYtYmluZCBkYXRhIHdyYXBcXG4gIGlmIChlbC53cmFwRGF0YSkge1xcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XFxuICB9XFxuICAvLyB2LW9uIGRhdGEgd3JhcFxcbiAgaWYgKGVsLndyYXBMaXN0ZW5lcnMpIHtcXG4gICAgZGF0YSA9IGVsLndyYXBMaXN0ZW5lcnMoZGF0YSk7XFxuICB9XFxuICByZXR1cm4gZGF0YVxcbn1cXG5cXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCwgc3RhdGUpIHtcXG4gIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcXG4gIGlmICghZGlycykgeyByZXR1cm4gfVxcbiAgdmFyIHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xcbiAgdmFyIGhhc1J1bnRpbWUgPSBmYWxzZTtcXG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIGRpciA9IGRpcnNbaV07XFxuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcXG4gICAgdmFyIGdlbiA9IHN0YXRlLmRpcmVjdGl2ZXNbZGlyLm5hbWVdO1xcbiAgICBpZiAoZ2VuKSB7XFxuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXFxuICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCBzdGF0ZS53YXJuKTtcXG4gICAgfVxcbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcXG4gICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcXG4gICAgICByZXMgKz0gXFxcIntuYW1lOlxcXFxcXFwiXFxcIiArIChkaXIubmFtZSkgKyBcXFwiXFxcXFxcXCIscmF3TmFtZTpcXFxcXFxcIlxcXCIgKyAoZGlyLnJhd05hbWUpICsgXFxcIlxcXFxcXFwiXFxcIiArIChkaXIudmFsdWUgPyAoXFxcIix2YWx1ZTooXFxcIiArIChkaXIudmFsdWUpICsgXFxcIiksZXhwcmVzc2lvbjpcXFwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFxcXCIsYXJnOlxcXCIgKyAoZGlyLmlzRHluYW1pY0FyZyA/IGRpci5hcmcgOiAoXFxcIlxcXFxcXFwiXFxcIiArIChkaXIuYXJnKSArIFxcXCJcXFxcXFxcIlxcXCIpKSkgOiAnJykgKyAoZGlyLm1vZGlmaWVycyA/IChcXFwiLG1vZGlmaWVyczpcXFwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcXFwifSxcXFwiO1xcbiAgICB9XFxuICB9XFxuICBpZiAoaGFzUnVudGltZSkge1xcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XFxuICB2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XFxuICBpZiAoIHRydWUgJiYgKFxcbiAgICBlbC5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgYXN0LnR5cGUgIT09IDFcXG4gICkpIHtcXG4gICAgc3RhdGUud2FybihcXG4gICAgICAnSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJyxcXG4gICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XFxuICAgICk7XFxuICB9XFxuICBpZiAoYXN0ICYmIGFzdC50eXBlID09PSAxKSB7XFxuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xcbiAgICByZXR1cm4gKFxcXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XFxcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFxcXCJ9LHN0YXRpY1JlbmRlckZuczpbXFxcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFxcXCJmdW5jdGlvbigpe1xcXCIgKyBjb2RlICsgXFxcIn1cXFwiKTsgfSkuam9pbignLCcpKSArIFxcXCJdfVxcXCIpXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChcXG4gIGVsLFxcbiAgc2xvdHMsXFxuICBzdGF0ZVxcbikge1xcbiAgLy8gYnkgZGVmYXVsdCBzY29wZWQgc2xvdHMgYXJlIGNvbnNpZGVyZWQgXFxcInN0YWJsZVxcXCIsIHRoaXMgYWxsb3dzIGNoaWxkXFxuICAvLyBjb21wb25lbnRzIHdpdGggb25seSBzY29wZWQgc2xvdHMgdG8gc2tpcCBmb3JjZWQgdXBkYXRlcyBmcm9tIHBhcmVudC5cXG4gIC8vIGJ1dCBpbiBzb21lIGNhc2VzIHdlIGhhdmUgdG8gYmFpbC1vdXQgb2YgdGhpcyBvcHRpbWl6YXRpb25cXG4gIC8vIGZvciBleGFtcGxlIGlmIHRoZSBzbG90IGNvbnRhaW5zIGR5bmFtaWMgbmFtZXMsIGhhcyB2LWlmIG9yIHYtZm9yIG9uIHRoZW0uLi5cXG4gIHZhciBuZWVkc0ZvcmNlVXBkYXRlID0gZWwuZm9yIHx8IE9iamVjdC5rZXlzKHNsb3RzKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgdmFyIHNsb3QgPSBzbG90c1trZXldO1xcbiAgICByZXR1cm4gKFxcbiAgICAgIHNsb3Quc2xvdFRhcmdldER5bmFtaWMgfHxcXG4gICAgICBzbG90LmlmIHx8XFxuICAgICAgc2xvdC5mb3IgfHxcXG4gICAgICBjb250YWluc1Nsb3RDaGlsZChzbG90KSAvLyBpcyBwYXNzaW5nIGRvd24gc2xvdCBmcm9tIHBhcmVudCB3aGljaCBtYXkgYmUgZHluYW1pY1xcbiAgICApXFxuICB9KTtcXG5cXG4gIC8vICM5NTM0OiBpZiBhIGNvbXBvbmVudCB3aXRoIHNjb3BlZCBzbG90cyBpcyBpbnNpZGUgYSBjb25kaXRpb25hbCBicmFuY2gsXFxuICAvLyBpdCdzIHBvc3NpYmxlIGZvciB0aGUgc2FtZSBjb21wb25lbnQgdG8gYmUgcmV1c2VkIGJ1dCB3aXRoIGRpZmZlcmVudFxcbiAgLy8gY29tcGlsZWQgc2xvdCBjb250ZW50LiBUbyBhdm9pZCB0aGF0LCB3ZSBnZW5lcmF0ZSBhIHVuaXF1ZSBrZXkgYmFzZWQgb25cXG4gIC8vIHRoZSBnZW5lcmF0ZWQgY29kZSBvZiBhbGwgdGhlIHNsb3QgY29udGVudHMuXFxuICB2YXIgbmVlZHNLZXkgPSAhIWVsLmlmO1xcblxcbiAgLy8gT1Igd2hlbiBpdCBpcyBpbnNpZGUgYW5vdGhlciBzY29wZWQgc2xvdCBvciB2LWZvciAodGhlIHJlYWN0aXZpdHkgbWF5IGJlXFxuICAvLyBkaXNjb25uZWN0ZWQgZHVlIHRvIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUgdmFyaWFibGUpXFxuICAvLyAjOTQzOCwgIzk1MDZcXG4gIC8vIFRPRE86IHRoaXMgY2FuIGJlIGZ1cnRoZXIgb3B0aW1pemVkIGJ5IHByb3Blcmx5IGFuYWx5emluZyBpbi1zY29wZSBiaW5kaW5nc1xcbiAgLy8gYW5kIHNraXAgZm9yY2UgdXBkYXRpbmcgb25lcyB0aGF0IGRvIG5vdCBhY3R1YWxseSB1c2Ugc2NvcGUgdmFyaWFibGVzLlxcbiAgaWYgKCFuZWVkc0ZvcmNlVXBkYXRlKSB7XFxuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XFxuICAgIHdoaWxlIChwYXJlbnQpIHtcXG4gICAgICBpZiAoXFxuICAgICAgICAocGFyZW50LnNsb3RTY29wZSAmJiBwYXJlbnQuc2xvdFNjb3BlICE9PSBlbXB0eVNsb3RTY29wZVRva2VuKSB8fFxcbiAgICAgICAgcGFyZW50LmZvclxcbiAgICAgICkge1xcbiAgICAgICAgbmVlZHNGb3JjZVVwZGF0ZSA9IHRydWU7XFxuICAgICAgICBicmVha1xcbiAgICAgIH1cXG4gICAgICBpZiAocGFyZW50LmlmKSB7XFxuICAgICAgICBuZWVkc0tleSA9IHRydWU7XFxuICAgICAgfVxcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBnZW5lcmF0ZWRTbG90cyA9IE9iamVjdC5rZXlzKHNsb3RzKVxcbiAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGdlblNjb3BlZFNsb3Qoc2xvdHNba2V5XSwgc3RhdGUpOyB9KVxcbiAgICAuam9pbignLCcpO1xcblxcbiAgcmV0dXJuIChcXFwic2NvcGVkU2xvdHM6X3UoW1xcXCIgKyBnZW5lcmF0ZWRTbG90cyArIFxcXCJdXFxcIiArIChuZWVkc0ZvcmNlVXBkYXRlID8gXFxcIixudWxsLHRydWVcXFwiIDogXFxcIlxcXCIpICsgKCFuZWVkc0ZvcmNlVXBkYXRlICYmIG5lZWRzS2V5ID8gKFxcXCIsbnVsbCxmYWxzZSxcXFwiICsgKGhhc2goZ2VuZXJhdGVkU2xvdHMpKSkgOiBcXFwiXFxcIikgKyBcXFwiKVxcXCIpXFxufVxcblxcbmZ1bmN0aW9uIGhhc2goc3RyKSB7XFxuICB2YXIgaGFzaCA9IDUzODE7XFxuICB2YXIgaSA9IHN0ci5sZW5ndGg7XFxuICB3aGlsZShpKSB7XFxuICAgIGhhc2ggPSAoaGFzaCAqIDMzKSBeIHN0ci5jaGFyQ29kZUF0KC0taSk7XFxuICB9XFxuICByZXR1cm4gaGFzaCA+Pj4gMFxcbn1cXG5cXG5mdW5jdGlvbiBjb250YWluc1Nsb3RDaGlsZCAoZWwpIHtcXG4gIGlmIChlbC50eXBlID09PSAxKSB7XFxuICAgIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xcbiAgICAgIHJldHVybiB0cnVlXFxuICAgIH1cXG4gICAgcmV0dXJuIGVsLmNoaWxkcmVuLnNvbWUoY29udGFpbnNTbG90Q2hpbGQpXFxuICB9XFxuICByZXR1cm4gZmFsc2VcXG59XFxuXFxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoXFxuICBlbCxcXG4gIHN0YXRlXFxuKSB7XFxuICB2YXIgaXNMZWdhY3lTeW50YXggPSBlbC5hdHRyc01hcFsnc2xvdC1zY29wZSddO1xcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCAmJiAhaXNMZWdhY3lTeW50YXgpIHtcXG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdCwgXFxcIm51bGxcXFwiKVxcbiAgfVxcbiAgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XFxuICAgIHJldHVybiBnZW5Gb3IoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90KVxcbiAgfVxcbiAgdmFyIHNsb3RTY29wZSA9IGVsLnNsb3RTY29wZSA9PT0gZW1wdHlTbG90U2NvcGVUb2tlblxcbiAgICA/IFxcXCJcXFwiXFxuICAgIDogU3RyaW5nKGVsLnNsb3RTY29wZSk7XFxuICB2YXIgZm4gPSBcXFwiZnVuY3Rpb24oXFxcIiArIHNsb3RTY29wZSArIFxcXCIpe1xcXCIgK1xcbiAgICBcXFwicmV0dXJuIFxcXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXFxuICAgICAgPyBlbC5pZiAmJiBpc0xlZ2FjeVN5bnRheFxcbiAgICAgICAgPyAoXFxcIihcXFwiICsgKGVsLmlmKSArIFxcXCIpP1xcXCIgKyAoZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJykgKyBcXFwiOnVuZGVmaW5lZFxcXCIpXFxuICAgICAgICA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCdcXG4gICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcXFwifVxcXCI7XFxuICAvLyByZXZlcnNlIHByb3h5IHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXFxuICB2YXIgcmV2ZXJzZVByb3h5ID0gc2xvdFNjb3BlID8gXFxcIlxcXCIgOiBcXFwiLHByb3h5OnRydWVcXFwiO1xcbiAgcmV0dXJuIChcXFwie2tleTpcXFwiICsgKGVsLnNsb3RUYXJnZXQgfHwgXFxcIlxcXFxcXFwiZGVmYXVsdFxcXFxcXFwiXFxcIikgKyBcXFwiLGZuOlxcXCIgKyBmbiArIHJldmVyc2VQcm94eSArIFxcXCJ9XFxcIilcXG59XFxuXFxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKFxcbiAgZWwsXFxuICBzdGF0ZSxcXG4gIGNoZWNrU2tpcCxcXG4gIGFsdEdlbkVsZW1lbnQsXFxuICBhbHRHZW5Ob2RlXFxuKSB7XFxuICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcXG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcXG4gICAgdmFyIGVsJDEgPSBjaGlsZHJlblswXTtcXG4gICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXFxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcXG4gICAgICBlbCQxLmZvciAmJlxcbiAgICAgIGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXFxuICAgICAgZWwkMS50YWcgIT09ICdzbG90J1xcbiAgICApIHtcXG4gICAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXBcXG4gICAgICAgID8gc3RhdGUubWF5YmVDb21wb25lbnQoZWwkMSkgPyBcXFwiLDFcXFwiIDogXFxcIiwwXFxcIlxcbiAgICAgICAgOiBcXFwiXFxcIjtcXG4gICAgICByZXR1cm4gKFxcXCJcXFwiICsgKChhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsJDEsIHN0YXRlKSkgKyBub3JtYWxpemF0aW9uVHlwZSlcXG4gICAgfVxcbiAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUkMSA9IGNoZWNrU2tpcFxcbiAgICAgID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIHN0YXRlLm1heWJlQ29tcG9uZW50KVxcbiAgICAgIDogMDtcXG4gICAgdmFyIGdlbiA9IGFsdEdlbk5vZGUgfHwgZ2VuTm9kZTtcXG4gICAgcmV0dXJuIChcXFwiW1xcXCIgKyAoY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBnZW4oYywgc3RhdGUpOyB9KS5qb2luKCcsJykpICsgXFxcIl1cXFwiICsgKG5vcm1hbGl6YXRpb25UeXBlJDEgPyAoXFxcIixcXFwiICsgbm9ybWFsaXphdGlvblR5cGUkMSkgOiAnJykpXFxuICB9XFxufVxcblxcbi8vIGRldGVybWluZSB0aGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgZm9yIHRoZSBjaGlsZHJlbiBhcnJheS5cXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcXG4vLyAyOiBmdWxsIG5vcm1hbGl6YXRpb24gbmVlZGVkXFxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKFxcbiAgY2hpbGRyZW4sXFxuICBtYXliZUNvbXBvbmVudFxcbikge1xcbiAgdmFyIHJlcyA9IDA7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBlbCA9IGNoaWxkcmVuW2ldO1xcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xcbiAgICAgIGNvbnRpbnVlXFxuICAgIH1cXG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcXG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XFxuICAgICAgcmVzID0gMjtcXG4gICAgICBicmVha1xcbiAgICB9XFxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcXG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcXG4gICAgICByZXMgPSAxO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gcmVzXFxufVxcblxcbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcXG4gIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcXG59XFxuXFxuZnVuY3Rpb24gZ2VuTm9kZSAobm9kZSwgc3RhdGUpIHtcXG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcXG4gICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSwgc3RhdGUpXFxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMyAmJiBub2RlLmlzQ29tbWVudCkge1xcbiAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIGdlblRleHQobm9kZSlcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xcbiAgcmV0dXJuIChcXFwiX3YoXFxcIiArICh0ZXh0LnR5cGUgPT09IDJcXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxcbiAgICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKSkgKyBcXFwiKVxcXCIpXFxufVxcblxcbmZ1bmN0aW9uIGdlbkNvbW1lbnQgKGNvbW1lbnQpIHtcXG4gIHJldHVybiAoXFxcIl9lKFxcXCIgKyAoSlNPTi5zdHJpbmdpZnkoY29tbWVudC50ZXh0KSkgKyBcXFwiKVxcXCIpXFxufVxcblxcbmZ1bmN0aW9uIGdlblNsb3QgKGVsLCBzdGF0ZSkge1xcbiAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1xcXCJkZWZhdWx0XFxcIic7XFxuICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xcbiAgdmFyIHJlcyA9IFxcXCJfdChcXFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXFxcIixcXFwiICsgY2hpbGRyZW4pIDogJycpO1xcbiAgdmFyIGF0dHJzID0gZWwuYXR0cnMgfHwgZWwuZHluYW1pY0F0dHJzXFxuICAgID8gZ2VuUHJvcHMoKGVsLmF0dHJzIHx8IFtdKS5jb25jYXQoZWwuZHluYW1pY0F0dHJzIHx8IFtdKS5tYXAoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuICh7XFxuICAgICAgICAvLyBzbG90IHByb3BzIGFyZSBjYW1lbGl6ZWRcXG4gICAgICAgIG5hbWU6IGNhbWVsaXplKGF0dHIubmFtZSksXFxuICAgICAgICB2YWx1ZTogYXR0ci52YWx1ZSxcXG4gICAgICAgIGR5bmFtaWM6IGF0dHIuZHluYW1pY1xcbiAgICAgIH0pOyB9KSlcXG4gICAgOiBudWxsO1xcbiAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XFxuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xcbiAgICByZXMgKz0gXFxcIixudWxsXFxcIjtcXG4gIH1cXG4gIGlmIChhdHRycykge1xcbiAgICByZXMgKz0gXFxcIixcXFwiICsgYXR0cnM7XFxuICB9XFxuICBpZiAoYmluZCQkMSkge1xcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFxcXCIsXFxcIiArIGJpbmQkJDE7XFxuICB9XFxuICByZXR1cm4gcmVzICsgJyknXFxufVxcblxcbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcXG5mdW5jdGlvbiBnZW5Db21wb25lbnQgKFxcbiAgY29tcG9uZW50TmFtZSxcXG4gIGVsLFxcbiAgc3RhdGVcXG4pIHtcXG4gIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XFxuICByZXR1cm4gKFxcXCJfYyhcXFwiICsgY29tcG9uZW50TmFtZSArIFxcXCIsXFxcIiArIChnZW5EYXRhJDIoZWwsIHN0YXRlKSkgKyAoY2hpbGRyZW4gPyAoXFxcIixcXFwiICsgY2hpbGRyZW4pIDogJycpICsgXFxcIilcXFwiKVxcbn1cXG5cXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcXG4gIHZhciBzdGF0aWNQcm9wcyA9IFxcXCJcXFwiO1xcbiAgdmFyIGR5bmFtaWNQcm9wcyA9IFxcXCJcXFwiO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xcbiAgICB2YXIgdmFsdWUgPSB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMocHJvcC52YWx1ZSk7XFxuICAgIGlmIChwcm9wLmR5bmFtaWMpIHtcXG4gICAgICBkeW5hbWljUHJvcHMgKz0gKHByb3AubmFtZSkgKyBcXFwiLFxcXCIgKyB2YWx1ZSArIFxcXCIsXFxcIjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdGF0aWNQcm9wcyArPSBcXFwiXFxcXFxcXCJcXFwiICsgKHByb3AubmFtZSkgKyBcXFwiXFxcXFxcXCI6XFxcIiArIHZhbHVlICsgXFxcIixcXFwiO1xcbiAgICB9XFxuICB9XFxuICBzdGF0aWNQcm9wcyA9IFxcXCJ7XFxcIiArIChzdGF0aWNQcm9wcy5zbGljZSgwLCAtMSkpICsgXFxcIn1cXFwiO1xcbiAgaWYgKGR5bmFtaWNQcm9wcykge1xcbiAgICByZXR1cm4gKFxcXCJfZChcXFwiICsgc3RhdGljUHJvcHMgKyBcXFwiLFtcXFwiICsgKGR5bmFtaWNQcm9wcy5zbGljZSgwLCAtMSkpICsgXFxcIl0pXFxcIilcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBzdGF0aWNQcm9wc1xcbiAgfVxcbn1cXG5cXG4vLyAjMzg5NSwgIzQyNjhcXG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcXG4gIHJldHVybiB0ZXh0XFxuICAgIC5yZXBsYWNlKC9cXFxcdTIwMjgvZywgJ1xcXFxcXFxcdTIwMjgnKVxcbiAgICAucmVwbGFjZSgvXFxcXHUyMDI5L2csICdcXFxcXFxcXHUyMDI5JylcXG59XFxuXFxuLyogICovXFxuXFxuXFxuXFxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2VcXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXFxudmFyIHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcXFxcXGInICsgKFxcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXFxuICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXFxuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxcXFxcYnxcXFxcXFxcXGInKSArICdcXFxcXFxcXGInKTtcXG5cXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xcbnZhciB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXFxcXFxiJyArIChcXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXFxuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxcXFxccypcXFxcXFxcXChbXlxcXFxcXFxcKV0qXFxcXFxcXFwpfFxcXFxcXFxcYicpICsgJ1xcXFxcXFxccypcXFxcXFxcXChbXlxcXFxcXFxcKV0qXFxcXFxcXFwpJyk7XFxuXFxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xcbnZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXFxcXF18XFxcXFxcXFwuKSonfFxcXCIoPzpbXlxcXCJcXFxcXFxcXF18XFxcXFxcXFwuKSpcXFwifGAoPzpbXmBcXFxcXFxcXF18XFxcXFxcXFwuKSpcXFxcJFxcXFx7fFxcXFx9KD86W15gXFxcXFxcXFxdfFxcXFxcXFxcLikqYHxgKD86W15gXFxcXFxcXFxdfFxcXFxcXFxcLikqYC9nO1xcblxcbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXFxuZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QsIHdhcm4pIHtcXG4gIGlmIChhc3QpIHtcXG4gICAgY2hlY2tOb2RlKGFzdCwgd2Fybik7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgd2Fybikge1xcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xcbiAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcXG4gICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcXG4gICAgICAgIGlmICh2YWx1ZSkge1xcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBub2RlLnJhd0F0dHJzTWFwW25hbWVdO1xcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xcbiAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIChcXFwidi1mb3I9XFxcXFxcXCJcXFwiICsgdmFsdWUgKyBcXFwiXFxcXFxcXCJcXFwiKSwgd2FybiwgcmFuZ2UpO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXFxcIj1cXFxcXFxcIlxcXCIgKyB2YWx1ZSArIFxcXCJcXFxcXFxcIlxcXCIpLCB3YXJuLCByYW5nZSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFxcXCI9XFxcXFxcXCJcXFwiICsgdmFsdWUgKyBcXFwiXFxcXFxcXCJcXFwiKSwgd2FybiwgcmFuZ2UpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgd2Fybik7XFxuICAgICAgfVxcbiAgICB9XFxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIHdhcm4sIG5vZGUpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBjaGVja0V2ZW50IChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XFxuICB2YXIgc3RpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcXG4gIHZhciBrZXl3b3JkTWF0Y2ggPSBzdGlwcGVkLm1hdGNoKHVuYXJ5T3BlcmF0b3JzUkUpO1xcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdGlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XFxuICAgIHdhcm4oXFxuICAgICAgXFxcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogXFxcIiArXFxuICAgICAgXFxcIlxcXFxcXFwiXFxcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXFxcIlxcXFxcXFwiIGluIGV4cHJlc3Npb24gXFxcIiArICh0ZXh0LnRyaW0oKSksXFxuICAgICAgcmFuZ2VcXG4gICAgKTtcXG4gIH1cXG4gIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIHdhcm4sIHJhbmdlKTtcXG59XFxuXFxuZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIHdhcm4sIHJhbmdlKSB7XFxuICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIHdhcm4sIHJhbmdlKTtcXG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XFxuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIHdhcm4sIHJhbmdlKTtcXG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xcbn1cXG5cXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKFxcbiAgaWRlbnQsXFxuICB0eXBlLFxcbiAgdGV4dCxcXG4gIHdhcm4sXFxuICByYW5nZVxcbikge1xcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycpIHtcXG4gICAgdHJ5IHtcXG4gICAgICBuZXcgRnVuY3Rpb24oKFxcXCJ2YXIgXFxcIiArIGlkZW50ICsgXFxcIj1fXFxcIikpO1xcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgd2FybigoXFxcImludmFsaWQgXFxcIiArIHR5cGUgKyBcXFwiIFxcXFxcXFwiXFxcIiArIGlkZW50ICsgXFxcIlxcXFxcXFwiIGluIGV4cHJlc3Npb246IFxcXCIgKyAodGV4dC50cmltKCkpKSwgcmFuZ2UpO1xcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xcbiAgdHJ5IHtcXG4gICAgbmV3IEZ1bmN0aW9uKChcXFwicmV0dXJuIFxcXCIgKyBleHApKTtcXG4gIH0gY2F0Y2ggKGUpIHtcXG4gICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcXG4gICAgaWYgKGtleXdvcmRNYXRjaCkge1xcbiAgICAgIHdhcm4oXFxuICAgICAgICBcXFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFxcXCIgK1xcbiAgICAgICAgXFxcIlxcXFxcXFwiXFxcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXFxcIlxcXFxcXFwiXFxcXG4gIFJhdyBleHByZXNzaW9uOiBcXFwiICsgKHRleHQudHJpbSgpKSxcXG4gICAgICAgIHJhbmdlXFxuICAgICAgKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB3YXJuKFxcbiAgICAgICAgXFxcImludmFsaWQgZXhwcmVzc2lvbjogXFxcIiArIChlLm1lc3NhZ2UpICsgXFxcIiBpblxcXFxuXFxcXG5cXFwiICtcXG4gICAgICAgIFxcXCIgICAgXFxcIiArIGV4cCArIFxcXCJcXFxcblxcXFxuXFxcIiArXFxuICAgICAgICBcXFwiICBSYXcgZXhwcmVzc2lvbjogXFxcIiArICh0ZXh0LnRyaW0oKSkgKyBcXFwiXFxcXG5cXFwiLFxcbiAgICAgICAgcmFuZ2VcXG4gICAgICApO1xcbiAgICB9XFxuICB9XFxufVxcblxcbi8qICAqL1xcblxcbnZhciByYW5nZSA9IDI7XFxuXFxuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUgKFxcbiAgc291cmNlLFxcbiAgc3RhcnQsXFxuICBlbmRcXG4pIHtcXG4gIGlmICggc3RhcnQgPT09IHZvaWQgMCApIHN0YXJ0ID0gMDtcXG4gIGlmICggZW5kID09PSB2b2lkIDAgKSBlbmQgPSBzb3VyY2UubGVuZ3RoO1xcblxcbiAgdmFyIGxpbmVzID0gc291cmNlLnNwbGl0KC9cXFxccj9cXFxcbi8pO1xcbiAgdmFyIGNvdW50ID0gMDtcXG4gIHZhciByZXMgPSBbXTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcXG4gICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XFxuICAgICAgZm9yICh2YXIgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xcbiAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKSB7IGNvbnRpbnVlIH1cXG4gICAgICAgIHJlcy5wdXNoKChcXFwiXFxcIiArIChqICsgMSkgKyAocmVwZWF0JDEoXFxcIiBcXFwiLCAzIC0gU3RyaW5nKGogKyAxKS5sZW5ndGgpKSArIFxcXCJ8ICBcXFwiICsgKGxpbmVzW2pdKSkpO1xcbiAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XFxuICAgICAgICBpZiAoaiA9PT0gaSkge1xcbiAgICAgICAgICAvLyBwdXNoIHVuZGVybGluZVxcbiAgICAgICAgICB2YXIgcGFkID0gc3RhcnQgLSAoY291bnQgLSBsaW5lTGVuZ3RoKSArIDE7XFxuICAgICAgICAgIHZhciBsZW5ndGggPSBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydDtcXG4gICAgICAgICAgcmVzLnB1c2goXFxcIiAgIHwgIFxcXCIgKyByZXBlYXQkMShcXFwiIFxcXCIsIHBhZCkgKyByZXBlYXQkMShcXFwiXlxcXCIsIGxlbmd0aCkpO1xcbiAgICAgICAgfSBlbHNlIGlmIChqID4gaSkge1xcbiAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcXG4gICAgICAgICAgICB2YXIgbGVuZ3RoJDEgPSBNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgcmVzLnB1c2goXFxcIiAgIHwgIFxcXCIgKyByZXBlYXQkMShcXFwiXlxcXCIsIGxlbmd0aCQxKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIDE7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGJyZWFrXFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiByZXMuam9pbignXFxcXG4nKVxcbn1cXG5cXG5mdW5jdGlvbiByZXBlYXQkMSAoc3RyLCBuKSB7XFxuICB2YXIgcmVzdWx0ID0gJyc7XFxuICBpZiAobiA+IDApIHtcXG4gICAgd2hpbGUgKHRydWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxcbiAgICAgIGlmIChuICYgMSkgeyByZXN1bHQgKz0gc3RyOyB9XFxuICAgICAgbiA+Pj49IDE7XFxuICAgICAgaWYgKG4gPD0gMCkgeyBicmVhayB9XFxuICAgICAgc3RyICs9IHN0cjtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdFxcbn1cXG5cXG4vKiAgKi9cXG5cXG5cXG5cXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XFxuICB0cnkge1xcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXFxuICB9IGNhdGNoIChlcnIpIHtcXG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcXG4gICAgcmV0dXJuIG5vb3BcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiAoY29tcGlsZSkge1xcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcXG5cXG4gIHJldHVybiBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxcbiAgICB0ZW1wbGF0ZSxcXG4gICAgb3B0aW9ucyxcXG4gICAgdm1cXG4gICkge1xcbiAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcXG4gICAgdmFyIHdhcm4kJDEgPSBvcHRpb25zLndhcm4gfHwgd2FybjtcXG4gICAgZGVsZXRlIG9wdGlvbnMud2FybjtcXG5cXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICAgIGlmICh0cnVlKSB7XFxuICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxcbiAgICAgIHRyeSB7XFxuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XFxuICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcXG4gICAgICAgICAgd2FybiQkMShcXG4gICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXFxuICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXFxuICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xcbiAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcXG4gICAgICAgICAgKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLy8gY2hlY2sgY2FjaGVcXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xcbiAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxcbiAgICAgIDogdGVtcGxhdGU7XFxuICAgIGlmIChjYWNoZVtrZXldKSB7XFxuICAgICAgcmV0dXJuIGNhY2hlW2tleV1cXG4gICAgfVxcblxcbiAgICAvLyBjb21waWxlXFxuICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xcblxcbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xcbiAgICBpZiAodHJ1ZSkge1xcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcXG4gICAgICAgICAgY29tcGlsZWQuZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICB3YXJuJCQxKFxcbiAgICAgICAgICAgICAgXFxcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXFxcblxcXFxuXFxcIiArIChlLm1zZykgKyBcXFwiXFxcXG5cXFxcblxcXCIgK1xcbiAgICAgICAgICAgICAgZ2VuZXJhdGVDb2RlRnJhbWUodGVtcGxhdGUsIGUuc3RhcnQsIGUuZW5kKSxcXG4gICAgICAgICAgICAgIHZtXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB3YXJuJCQxKFxcbiAgICAgICAgICAgIFxcXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxcXG5cXFxcblxcXCIgKyB0ZW1wbGF0ZSArIFxcXCJcXFxcblxcXFxuXFxcIiArXFxuICAgICAgICAgICAgY29tcGlsZWQuZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gKFxcXCItIFxcXCIgKyBlKTsgfSkuam9pbignXFxcXG4nKSArICdcXFxcbicsXFxuICAgICAgICAgICAgdm1cXG4gICAgICAgICAgKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcXG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XFxuICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gdGlwKGUubXNnLCB2bSk7IH0pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xcbiAgICB2YXIgcmVzID0ge307XFxuICAgIHZhciBmbkdlbkVycm9ycyA9IFtdO1xcbiAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XFxuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XFxuICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uKGNvZGUsIGZuR2VuRXJyb3JzKVxcbiAgICB9KTtcXG5cXG4gICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXFxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXFxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuICAgIGlmICh0cnVlKSB7XFxuICAgICAgaWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcXG4gICAgICAgIHdhcm4kJDEoXFxuICAgICAgICAgIFxcXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmVuZGVyIGZ1bmN0aW9uOlxcXFxuXFxcXG5cXFwiICtcXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcXG4gICAgICAgICAgICB2YXIgZXJyID0gcmVmLmVycjtcXG4gICAgICAgICAgICB2YXIgY29kZSA9IHJlZi5jb2RlO1xcblxcbiAgICAgICAgICAgIHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFxcXCIgaW5cXFxcblxcXFxuXFxcIiArIGNvZGUgKyBcXFwiXFxcXG5cXFwiKTtcXG4gICAgICAgIH0pLmpvaW4oJ1xcXFxuJyksXFxuICAgICAgICAgIHZtXFxuICAgICAgICApO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXFxuICB9XFxufVxcblxcbi8qICAqL1xcblxcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcXG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVDb21waWxlciAoYmFzZU9wdGlvbnMpIHtcXG4gICAgZnVuY3Rpb24gY29tcGlsZSAoXFxuICAgICAgdGVtcGxhdGUsXFxuICAgICAgb3B0aW9uc1xcbiAgICApIHtcXG4gICAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XFxuICAgICAgdmFyIGVycm9ycyA9IFtdO1xcbiAgICAgIHZhciB0aXBzID0gW107XFxuXFxuICAgICAgdmFyIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XFxuICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xcbiAgICAgIH07XFxuXFxuICAgICAgaWYgKG9wdGlvbnMpIHtcXG4gICAgICAgIGlmICggdHJ1ZSAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XFxuICAgICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxcbiAgICAgICAgICB2YXIgbGVhZGluZ1NwYWNlTGVuZ3RoID0gdGVtcGxhdGUubWF0Y2goL15cXFxccyovKVswXS5sZW5ndGg7XFxuXFxuICAgICAgICAgIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XFxuICAgICAgICAgICAgdmFyIGRhdGEgPSB7IG1zZzogbXNnIH07XFxuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XFxuICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xcbiAgICAgICAgICAgICAgICBkYXRhLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQgKyBsZWFkaW5nU3BhY2VMZW5ndGg7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcXG4gICAgICAgICAgICAgICAgZGF0YS5lbmQgPSByYW5nZS5lbmQgKyBsZWFkaW5nU3BhY2VMZW5ndGg7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKGRhdGEpO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcXG4gICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcXG4gICAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPVxcbiAgICAgICAgICAgIChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXFxuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XFxuICAgICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxcbiAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyB8fCBudWxsKSxcXG4gICAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcXG4gICAgICAgICAgKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcXG4gICAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XFxuICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgZmluYWxPcHRpb25zLndhcm4gPSB3YXJuO1xcblxcbiAgICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLnRyaW0oKSwgZmluYWxPcHRpb25zKTtcXG4gICAgICBpZiAodHJ1ZSkge1xcbiAgICAgICAgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCwgd2Fybik7XFxuICAgICAgfVxcbiAgICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcXG4gICAgICBjb21waWxlZC50aXBzID0gdGlwcztcXG4gICAgICByZXR1cm4gY29tcGlsZWRcXG4gICAgfVxcblxcbiAgICByZXR1cm4ge1xcbiAgICAgIGNvbXBpbGU6IGNvbXBpbGUsXFxuICAgICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuKGNvbXBpbGUpXFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLyogICovXFxuXFxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxcbi8vIHBhcnNlci9vcHRpbWl6ZXIvY29kZWdlbiwgZS5nIHRoZSBTU1Igb3B0aW1pemluZyBjb21waWxlci5cXG4vLyBIZXJlIHdlIGp1c3QgZXhwb3J0IGEgZGVmYXVsdCBjb21waWxlciB1c2luZyB0aGUgZGVmYXVsdCBwYXJ0cy5cXG52YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxcbiAgdGVtcGxhdGUsXFxuICBvcHRpb25zXFxuKSB7XFxuICB2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcXG4gIGlmIChvcHRpb25zLm9wdGltaXplICE9PSBmYWxzZSkge1xcbiAgICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xcbiAgfVxcbiAgdmFyIGNvZGUgPSBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpO1xcbiAgcmV0dXJuIHtcXG4gICAgYXN0OiBhc3QsXFxuICAgIHJlbmRlcjogY29kZS5yZW5kZXIsXFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcXG4gIH1cXG59KTtcXG5cXG4vKiAgKi9cXG5cXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XFxudmFyIGNvbXBpbGUgPSByZWYkMS5jb21waWxlO1xcbnZhciBjb21waWxlVG9GdW5jdGlvbnMgPSByZWYkMS5jb21waWxlVG9GdW5jdGlvbnM7XFxuXFxuLyogICovXFxuXFxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcXG52YXIgZGl2O1xcbmZ1bmN0aW9uIGdldFNob3VsZERlY29kZSAoaHJlZikge1xcbiAgZGl2ID0gZGl2IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xcbiAgZGl2LmlubmVySFRNTCA9IGhyZWYgPyBcXFwiPGEgaHJlZj1cXFxcXFxcIlxcXFxuXFxcXFxcXCIvPlxcXCIgOiBcXFwiPGRpdiBhPVxcXFxcXFwiXFxcXG5cXFxcXFxcIi8+XFxcIjtcXG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoJyYjMTA7JykgPiAwXFxufVxcblxcbi8vICMzNjYzOiBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKGZhbHNlKSA6IGZhbHNlO1xcbi8vICM2ODI4OiBjaHJvbWUgZW5jb2RlcyBjb250ZW50IGluIGFbaHJlZl1cXG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKHRydWUpIDogZmFsc2U7XFxuXFxuLyogICovXFxuXFxudmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcXG4gIHZhciBlbCA9IHF1ZXJ5KGlkKTtcXG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcXG59KTtcXG5cXG52YXIgbW91bnQgPSBWdWUucHJvdG90eXBlLiRtb3VudDtcXG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcXG4gIGVsLFxcbiAgaHlkcmF0aW5nXFxuKSB7XFxuICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcXG5cXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcXG4gICAgIHRydWUgJiYgd2FybihcXG4gICAgICBcXFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXFxcIlxcbiAgICApO1xcbiAgICByZXR1cm4gdGhpc1xcbiAgfVxcblxcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcXG4gICAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcXG4gICAgaWYgKHRlbXBsYXRlKSB7XFxuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XFxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgICAgICAgICBpZiAoIHRydWUgJiYgIXRlbXBsYXRlKSB7XFxuICAgICAgICAgICAgd2FybihcXG4gICAgICAgICAgICAgIChcXFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFxcXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxcbiAgICAgICAgICAgICAgdGhpc1xcbiAgICAgICAgICAgICk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XFxuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKHRydWUpIHtcXG4gICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB0aGlzXFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKGVsKSB7XFxuICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xcbiAgICB9XFxuICAgIGlmICh0ZW1wbGF0ZSkge1xcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgICAgIGlmICggdHJ1ZSAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xcbiAgICAgICAgbWFyaygnY29tcGlsZScpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgcmVmID0gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCB7XFxuICAgICAgICBvdXRwdXRTb3VyY2VSYW5nZTogXFxcImRldmVsb3BtZW50XFxcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXFxuICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnMsXFxuICAgICAgICBjb21tZW50czogb3B0aW9ucy5jb21tZW50c1xcbiAgICAgIH0sIHRoaXMpO1xcbiAgICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xcbiAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xcblxcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcbiAgICAgIGlmICggdHJ1ZSAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcXG4gICAgICAgIG1lYXN1cmUoKFxcXCJ2dWUgXFxcIiArICh0aGlzLl9uYW1lKSArIFxcXCIgY29tcGlsZVxcXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZylcXG59O1xcblxcbi8qKlxcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXFxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXFxuICovXFxuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xcbiAgaWYgKGVsLm91dGVySFRNTCkge1xcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MXFxuICB9IGVsc2Uge1xcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxcbiAgfVxcbn1cXG5cXG5WdWUuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcXG5cXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9IChWdWUpO1xcblxcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLy4uLy4uL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanNcXFwiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi8uLi8uLi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzXFxcIikuc2V0SW1tZWRpYXRlKSlcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3Z1ZWRyYWdnYWJsZS9kaXN0L3Z1ZWRyYWdnYWJsZS5jb21tb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy92dWVkcmFnZ2FibGUvZGlzdC92dWVkcmFnZ2FibGUuY29tbW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIm1vZHVsZS5leHBvcnRzID1cXG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXFxuLyoqKioqKi8gXFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxcbi8qKioqKiovIFxcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxcbi8qKioqKiovIFxcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxcbi8qKioqKiovIFxcdFxcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XFxuLyoqKioqKi8gXFx0XFx0XFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XFxuLyoqKioqKi8gXFx0XFx0fVxcbi8qKioqKiovIFxcdFxcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXFxuLyoqKioqKi8gXFx0XFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xcbi8qKioqKiovIFxcdFxcdFxcdGk6IG1vZHVsZUlkLFxcbi8qKioqKiovIFxcdFxcdFxcdGw6IGZhbHNlLFxcbi8qKioqKiovIFxcdFxcdFxcdGV4cG9ydHM6IHt9XFxuLyoqKioqKi8gXFx0XFx0fTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxcbi8qKioqKiovIFxcdFxcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0XFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxcbi8qKioqKiovIFxcdFxcdG1vZHVsZS5sID0gdHJ1ZTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXFxuLyoqKioqKi8gXFx0XFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xcbi8qKioqKiovIFxcdH1cXG4vKioqKioqL1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XFxuLyoqKioqKi8gXFx0XFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xcbi8qKioqKiovIFxcdFxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xcbi8qKioqKiovIFxcdFxcdH1cXG4vKioqKioqLyBcXHR9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcXG4vKioqKioqLyBcXHRcXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcXG4vKioqKioqLyBcXHRcXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcXG4vKioqKioqLyBcXHRcXHR9XFxuLyoqKioqKi8gXFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcXG4vKioqKioqLyBcXHR9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XFxuLyoqKioqKi8gXFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XFxuLyoqKioqKi8gXFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXFxuLyoqKioqKi8gXFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XFxuLyoqKioqKi8gXFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XFxuLyoqKioqKi8gXFx0XFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XFxuLyoqKioqKi8gXFx0XFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcXG4vKioqKioqLyBcXHRcXHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xcbi8qKioqKiovIFxcdFxcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XFxuLyoqKioqKi8gXFx0XFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcXG4vKioqKioqLyBcXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XFxuLyoqKioqKi8gXFx0XFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xcbi8qKioqKiovIFxcdFxcdHJldHVybiBucztcXG4vKioqKioqLyBcXHR9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcXG4vKioqKioqLyBcXHRcXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cXG4vKioqKioqLyBcXHRcXHRcXHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxcbi8qKioqKiovIFxcdFxcdFxcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XFxuLyoqKioqKi8gXFx0XFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xcbi8qKioqKiovIFxcdFxcdHJldHVybiBnZXR0ZXI7XFxuLyoqKioqKi8gXFx0fTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXFxcIlxcXCI7XFxuLyoqKioqKi9cXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xcbi8qKioqKiovIFxcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFxcXCJmYjE1XFxcIik7XFxuLyoqKioqKi8gfSlcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qKioqKiovICh7XFxuXFxuLyoqKi8gXFxcIjAyZjRcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNDU4OFxcXCIpO1xcbnZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiYmUxM1xcXCIpO1xcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcXG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XFxuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XFxuICAgIHZhciBsID0gcy5sZW5ndGg7XFxuICAgIHZhciBhLCBiO1xcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XFxuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XFxuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXFxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcXG4gIH07XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiMDM5MFxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgYXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIwMmY0XFxcIikodHJ1ZSk7XFxuXFxuIC8vIGBBZHZhbmNlU3RyaW5nSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFkdmFuY2VzdHJpbmdpbmRleFxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFMsIGluZGV4LCB1bmljb2RlKSB7XFxuICByZXR1cm4gaW5kZXggKyAodW5pY29kZSA/IGF0KFMsIGluZGV4KS5sZW5ndGggOiAxKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIwN2UzXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiMGJmYlxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4vLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFnc1xcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcImNiN2NcXFwiKTtcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciB0aGF0ID0gYW5PYmplY3QodGhpcyk7XFxuICB2YXIgcmVzdWx0ID0gJyc7XFxuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XFxuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcXG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiMGZjOVxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIzYTM4XFxcIik7XFxudmFyIG1heCA9IE1hdGgubWF4O1xcbnZhciBtaW4gPSBNYXRoLm1pbjtcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XFxuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XFxuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIxNjU0XFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciAkYXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI3MWMxXFxcIikodHJ1ZSk7XFxuXFxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxcbl9fd2VicGFja19yZXF1aXJlX18oXFxcIjMwZjFcXFwiKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcXG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcXG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxcbn0sIGZ1bmN0aW9uICgpIHtcXG4gIHZhciBPID0gdGhpcy5fdDtcXG4gIHZhciBpbmRleCA9IHRoaXMuX2k7XFxuICB2YXIgcG9pbnQ7XFxuICBpZiAoaW5kZXggPj0gTy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcXG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcXG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIxNjkxXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xcbm1vZHVsZS5leHBvcnRzID0gKFxcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcXG4pLnNwbGl0KCcsJyk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjFhZjZcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG4vLyAyMi4xLjIuMiAvIDE1LjQuMy4yIEFycmF5LmlzQXJyYXkoYXJnKVxcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNjNiNlxcXCIpO1xcblxcbiRleHBvcnQoJGV4cG9ydC5TLCAnQXJyYXknLCB7IGlzQXJyYXk6IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjkwMDNcXFwiKSB9KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiMWJjM1xcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcImY3NzJcXFwiKTtcXG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcXG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XFxuICB2YXIgZm4sIHZhbDtcXG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XFxuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XFxuICB0aHJvdyBUeXBlRXJyb3IoXFxcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVxcXCIpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjFlYzlcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJmNzcyXFxcIik7XFxudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiZTUzZFxcXCIpLmRvY3VtZW50O1xcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxcbnZhciBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIyMGZkXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJkOWY2XFxcIik7XFxudmFyIGNyZWF0ZURlc2MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJhZWJkXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcXG4gIGlmIChpbmRleCBpbiBvYmplY3QpICRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcXG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjIxNGZcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiYjBjNVxcXCIpO1xcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjJhYmFcXFwiKTtcXG52YXIgaGlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjMyZTlcXFwiKTtcXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI3OWU1XFxcIik7XFxudmFyIGRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJiZTEzXFxcIik7XFxudmFyIHdrcyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjJiNGNcXFwiKTtcXG52YXIgcmVnZXhwRXhlYyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjUyMGFcXFwiKTtcXG5cXG52YXIgU1BFQ0lFUyA9IHdrcygnc3BlY2llcycpO1xcblxcbnZhciBSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XFxuICAvLyAjcmVwbGFjZSBuZWVkcyBidWlsdC1pbiBzdXBwb3J0IGZvciBuYW1lZCBncm91cHMuXFxuICAvLyAjbWF0Y2ggd29ya3MgZmluZSBiZWNhdXNlIGl0IGp1c3QgcmV0dXJuIHRoZSBleGVjIHJlc3VsdHMsIGV2ZW4gaWYgaXQgaGFzXFxuICAvLyBhIFxcXCJncm9wc1xcXCIgcHJvcGVydHkuXFxuICB2YXIgcmUgPSAvLi87XFxuICByZS5leGVjID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgcmVzdWx0ID0gW107XFxuICAgIHJlc3VsdC5ncm91cHMgPSB7IGE6ICc3JyB9O1xcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfTtcXG4gIHJldHVybiAnJy5yZXBsYWNlKHJlLCAnJDxhPicpICE9PSAnNyc7XFxufSk7XFxuXFxudmFyIFNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQyA9IChmdW5jdGlvbiAoKSB7XFxuICAvLyBDaHJvbWUgNTEgaGFzIGEgYnVnZ3kgXFxcInNwbGl0XFxcIiBpbXBsZW1lbnRhdGlvbiB3aGVuIFJlZ0V4cCNleGVjICE9PSBuYXRpdmVFeGVjXFxuICB2YXIgcmUgPSAvKD86KS87XFxuICB2YXIgb3JpZ2luYWxFeGVjID0gcmUuZXhlYztcXG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvcmlnaW5hbEV4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcXG4gIHZhciByZXN1bHQgPSAnYWInLnNwbGl0KHJlKTtcXG4gIHJldHVybiByZXN1bHQubGVuZ3RoID09PSAyICYmIHJlc3VsdFswXSA9PT0gJ2EnICYmIHJlc3VsdFsxXSA9PT0gJ2InO1xcbn0pKCk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBsZW5ndGgsIGV4ZWMpIHtcXG4gIHZhciBTWU1CT0wgPSB3a3MoS0VZKTtcXG5cXG4gIHZhciBERUxFR0FURVNfVE9fU1lNQk9MID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gICAgLy8gU3RyaW5nIG1ldGhvZHMgY2FsbCBzeW1ib2wtbmFtZWQgUmVnRXAgbWV0aG9kc1xcbiAgICB2YXIgTyA9IHt9O1xcbiAgICBPW1NZTUJPTF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9O1xcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xcbiAgfSk7XFxuXFxuICB2YXIgREVMRUdBVEVTX1RPX0VYRUMgPSBERUxFR0FURVNfVE9fU1lNQk9MID8gIWZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gICAgLy8gU3ltYm9sLW5hbWVkIFJlZ0V4cCBtZXRob2RzIGNhbGwgLmV4ZWNcXG4gICAgdmFyIGV4ZWNDYWxsZWQgPSBmYWxzZTtcXG4gICAgdmFyIHJlID0gL2EvO1xcbiAgICByZS5leGVjID0gZnVuY3Rpb24gKCkgeyBleGVjQ2FsbGVkID0gdHJ1ZTsgcmV0dXJuIG51bGw7IH07XFxuICAgIGlmIChLRVkgPT09ICdzcGxpdCcpIHtcXG4gICAgICAvLyBSZWdFeHBbQEBzcGxpdF0gZG9lc24ndCBjYWxsIHRoZSByZWdleCdzIGV4ZWMgbWV0aG9kLCBidXQgZmlyc3QgY3JlYXRlc1xcbiAgICAgIC8vIGEgbmV3IG9uZS4gV2UgbmVlZCB0byByZXR1cm4gdGhlIHBhdGNoZWQgcmVnZXggd2hlbiBjcmVhdGluZyB0aGUgbmV3IG9uZS5cXG4gICAgICByZS5jb25zdHJ1Y3RvciA9IHt9O1xcbiAgICAgIHJlLmNvbnN0cnVjdG9yW1NQRUNJRVNdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmU7IH07XFxuICAgIH1cXG4gICAgcmVbU1lNQk9MXSgnJyk7XFxuICAgIHJldHVybiAhZXhlY0NhbGxlZDtcXG4gIH0pIDogdW5kZWZpbmVkO1xcblxcbiAgaWYgKFxcbiAgICAhREVMRUdBVEVTX1RPX1NZTUJPTCB8fFxcbiAgICAhREVMRUdBVEVTX1RPX0VYRUMgfHxcXG4gICAgKEtFWSA9PT0gJ3JlcGxhY2UnICYmICFSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUykgfHxcXG4gICAgKEtFWSA9PT0gJ3NwbGl0JyAmJiAhU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDKVxcbiAgKSB7XFxuICAgIHZhciBuYXRpdmVSZWdFeHBNZXRob2QgPSAvLi9bU1lNQk9MXTtcXG4gICAgdmFyIGZucyA9IGV4ZWMoXFxuICAgICAgZGVmaW5lZCxcXG4gICAgICBTWU1CT0wsXFxuICAgICAgJydbS0VZXSxcXG4gICAgICBmdW5jdGlvbiBtYXliZUNhbGxOYXRpdmUobmF0aXZlTWV0aG9kLCByZWdleHAsIHN0ciwgYXJnMiwgZm9yY2VTdHJpbmdNZXRob2QpIHtcXG4gICAgICAgIGlmIChyZWdleHAuZXhlYyA9PT0gcmVnZXhwRXhlYykge1xcbiAgICAgICAgICBpZiAoREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZm9yY2VTdHJpbmdNZXRob2QpIHtcXG4gICAgICAgICAgICAvLyBUaGUgbmF0aXZlIFN0cmluZyBtZXRob2QgYWxyZWFkeSBkZWxlZ2F0ZXMgdG8gQEBtZXRob2QgKHRoaXNcXG4gICAgICAgICAgICAvLyBwb2x5ZmlsbGVkIGZ1bmN0aW9uKSwgbGVhc2luZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXFxuICAgICAgICAgICAgLy8gV2UgYXZvaWQgaXQgYnkgZGlyZWN0bHkgY2FsbGluZyB0aGUgbmF0aXZlIEBAbWV0aG9kIG1ldGhvZC5cXG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlUmVnRXhwTWV0aG9kLmNhbGwocmVnZXhwLCBzdHIsIGFyZzIpIH07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG5hdGl2ZU1ldGhvZC5jYWxsKHN0ciwgcmVnZXhwLCBhcmcyKSB9O1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UgfTtcXG4gICAgICB9XFxuICAgICk7XFxuICAgIHZhciBzdHJmbiA9IGZuc1swXTtcXG4gICAgdmFyIHJ4Zm4gPSBmbnNbMV07XFxuXFxuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyZm4pO1xcbiAgICBoaWRlKFJlZ0V4cC5wcm90b3R5cGUsIFNZTUJPTCwgbGVuZ3RoID09IDJcXG4gICAgICAvLyAyMS4yLjUuOCBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV0oc3RyaW5nLCByZXBsYWNlVmFsdWUpXFxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcXG4gICAgICA/IGZ1bmN0aW9uIChzdHJpbmcsIGFyZykgeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcywgYXJnKTsgfVxcbiAgICAgIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxcbiAgICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcXG4gICAgICA6IGZ1bmN0aW9uIChzdHJpbmcpIHsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMpOyB9XFxuICAgICk7XFxuICB9XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiMjMwZVxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcImQzZjRcXFwiKTtcXG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI3NzI2XFxcIikuZG9jdW1lbnQ7XFxuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXFxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjIzYzZcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG4vLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxcbnZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIyZDk1XFxcIik7XFxudmFyIFRBRyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjJiNGNcXFwiKSgndG9TdHJpbmdUYWcnKTtcXG4vLyBFUzMgd3JvbmcgaGVyZVxcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xcblxcbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXFxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XFxuICB0cnkge1xcbiAgICByZXR1cm4gaXRba2V5XTtcXG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxcbn07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHZhciBPLCBULCBCO1xcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXFxuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxcbiAgICA6IEFSRyA/IGNvZihPKVxcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXFxuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjI0MWVcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG4vLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXFxudmFyIGRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIyNWViXFxcIik7XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjI1ZWJcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG4vLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXFxcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcXFwiICsgaXQpO1xcbiAgcmV0dXJuIGl0O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjI5NGNcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XFxuICB0cnkge1xcbiAgICByZXR1cm4gISFleGVjKCk7XFxuICB9IGNhdGNoIChlKSB7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjJhYmFcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNzcyNlxcXCIpO1xcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMzJlOVxcXCIpO1xcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI2OWE4XFxcIik7XFxudmFyIFNSQyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcImNhNWFcXFwiKSgnc3JjJyk7XFxudmFyICR0b1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcImZhNWJcXFwiKTtcXG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcXG52YXIgVFBMID0gKCcnICsgJHRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpO1xcblxcbl9fd2VicGFja19yZXF1aXJlX18oXFxcIjgzNzhcXFwiKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xcbn07XFxuXFxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsLCBzYWZlKSB7XFxuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcXG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XFxuICBpZiAoT1trZXldID09PSB2YWwpIHJldHVybjtcXG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcXG4gIGlmIChPID09PSBnbG9iYWwpIHtcXG4gICAgT1trZXldID0gdmFsO1xcbiAgfSBlbHNlIGlmICghc2FmZSkge1xcbiAgICBkZWxldGUgT1trZXldO1xcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcXG4gIH0gZWxzZSBpZiAoT1trZXldKSB7XFxuICAgIE9ba2V5XSA9IHZhbDtcXG4gIH0gZWxzZSB7XFxuICAgIGhpZGUoTywga2V5LCB2YWwpO1xcbiAgfVxcbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcXG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiMmI0Y1xcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBzdG9yZSA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjU1MzdcXFwiKSgnd2tzJyk7XFxudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcImNhNWFcXFwiKTtcXG52YXIgU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNzcyNlxcXCIpLlN5bWJvbDtcXG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcXG5cXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XFxuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cXG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcXG59O1xcblxcbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjJkMDBcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIyZDk1XFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiMmZkYlxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG4vLyAyMS4xLjMuNyBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKVxcblxcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNWNhMVxcXCIpO1xcbnZhciBjb250ZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiZDJjOFxcXCIpO1xcbnZhciBJTkNMVURFUyA9ICdpbmNsdWRlcyc7XFxuXFxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI1MTQ3XFxcIikoSU5DTFVERVMpLCAnU3RyaW5nJywge1xcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xcbiAgICByZXR1cm4gISF+Y29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIElOQ0xVREVTKVxcbiAgICAgIC5pbmRleE9mKHNlYXJjaFN0cmluZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xcbiAgfVxcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIzMGYxXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBMSUJSQVJZID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiYjhlM1xcXCIpO1xcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNjNiNlxcXCIpO1xcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjkxMzhcXFwiKTtcXG52YXIgaGlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjM1ZThcXFwiKTtcXG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNDgxYlxcXCIpO1xcbnZhciAkaXRlckNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjhmNjBcXFwiKTtcXG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI0NWYyXFxcIik7XFxudmFyIGdldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNTNlMlxcXCIpO1xcbnZhciBJVEVSQVRPUiA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjUxNjhcXFwiKSgnaXRlcmF0b3InKTtcXG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcXG52YXIgRkZfSVRFUkFUT1IgPSAnQEBpdGVyYXRvcic7XFxudmFyIEtFWVMgPSAna2V5cyc7XFxudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xcblxcbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcXG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcXG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xcbiAgICBpZiAoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pIHJldHVybiBwcm90b1traW5kXTtcXG4gICAgc3dpdGNoIChraW5kKSB7XFxuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcXG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcXG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcXG4gIH07XFxuICB2YXIgVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcXG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XFxuICB2YXIgcHJvdG8gPSBCYXNlLnByb3RvdHlwZTtcXG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XFxuICB2YXIgJGVudHJpZXMgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkO1xcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XFxuICAvLyBGaXggbmF0aXZlXFxuICBpZiAoJGFueU5hdGl2ZSkge1xcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XFxuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XFxuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xcbiAgICAgIGlmICghTElCUkFSWSAmJiB0eXBlb2YgSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcXG4gICAgfVxcbiAgfVxcbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcXG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XFxuICB9XFxuICAvLyBEZWZpbmUgaXRlcmF0b3JcXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xcbiAgfVxcbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XFxuICBJdGVyYXRvcnNbVEFHXSA9IHJldHVyblRoaXM7XFxuICBpZiAoREVGQVVMVCkge1xcbiAgICBtZXRob2RzID0ge1xcbiAgICAgIHZhbHVlczogREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXFxuICAgICAgZW50cmllczogJGVudHJpZXNcXG4gICAgfTtcXG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XFxuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XFxuICB9XFxuICByZXR1cm4gbWV0aG9kcztcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIzMmE2XFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXFxudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMjQxZVxcXCIpO1xcbnZhciAka2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcImMzYTFcXFwiKTtcXG5cXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJjZTdlXFxcIikoJ2tleXMnLCBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCkge1xcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcXG4gIH07XFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjMyZTlcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgZFAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI4NmNjXFxcIik7XFxudmFyIGNyZWF0ZURlc2MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI0NjMwXFxcIik7XFxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI5ZTFlXFxcIikgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XFxuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XFxuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xcbiAgcmV0dXJuIG9iamVjdDtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIzMmZjXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiZTUzZFxcXCIpLmRvY3VtZW50O1xcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIzMzVjXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcXG52YXIgY29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNmI0Y1xcXCIpO1xcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiMzU1ZFxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbmV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIzNWU4XFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGRQID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiZDlmNlxcXCIpO1xcbnZhciBjcmVhdGVEZXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiYWViZFxcXCIpO1xcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiOGU2MFxcXCIpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcXG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcXG4gIHJldHVybiBvYmplY3Q7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiMzZjM1xcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xcbnZhciBJT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMzM1Y1xcXCIpO1xcbnZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMjVlYlxcXCIpO1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiMzcwMlxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcXG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNDgxYlxcXCIpO1xcbnZhciBJVEVSQVRPUiA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjUxNjhcXFwiKSgnaXRlcmF0b3InKTtcXG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIzYTM4XFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuLy8gNy4xLjQgVG9JbnRlZ2VyXFxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XFxudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiNDBjM1xcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXFxudmFyIGNvZiA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjZiNGNcXFwiKTtcXG52YXIgVEFHID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNTE2OFxcXCIpKCd0b1N0cmluZ1RhZycpO1xcbi8vIEVTMyB3cm9uZyBoZXJlXFxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XFxuXFxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcXG4gIHRyeSB7XFxuICAgIHJldHVybiBpdFtrZXldO1xcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XFxufTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xcbiAgdmFyIE8sIFQsIEI7XFxuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXFxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXFxuICAgIDogQVJHID8gY29mKE8pXFxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiNDU4OFxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbi8vIDcuMS40IFRvSW50ZWdlclxcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjQ1ZjJcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgZGVmID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiZDlmNlxcXCIpLmY7XFxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjA3ZTNcXFwiKTtcXG52YXIgVEFHID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNTE2OFxcXCIpKCd0b1N0cmluZ1RhZycpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcXG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiNDYzMFxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcXG4gIHJldHVybiB7XFxuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXFxuICAgIHZhbHVlOiB2YWx1ZVxcbiAgfTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI0NjlmXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNmMxY1xcXCIpO1xcbl9fd2VicGFja19yZXF1aXJlX18oXFxcIjE2NTRcXFwiKTtcXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjdkN2JcXFwiKTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiNDgxYlxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbm1vZHVsZS5leHBvcnRzID0ge307XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjRhYTZcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcImRjNjJcXFwiKTtcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiNGJmOFxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcXG52YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcImJlMTNcXFwiKTtcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiNGVlMVxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBJVEVSQVRPUiA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjUxNjhcXFwiKSgnaXRlcmF0b3InKTtcXG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XFxuXFxudHJ5IHtcXG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcXG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uICgpIHsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXFxuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xcbn0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIHNraXBDbG9zaW5nKSB7XFxuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcXG4gIHZhciBzYWZlID0gZmFsc2U7XFxuICB0cnkge1xcbiAgICB2YXIgYXJyID0gWzddO1xcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcXG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geyBkb25lOiBzYWZlID0gdHJ1ZSB9OyB9O1xcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcjsgfTtcXG4gICAgZXhlYyhhcnIpO1xcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XFxuICByZXR1cm4gc2FmZTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI1MGVkXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcXG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lIH07XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiNTE0N1xcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBNQVRDSCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjJiNGNcXFwiKSgnbWF0Y2gnKTtcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcXG4gIHZhciByZSA9IC8uLztcXG4gIHRyeSB7XFxuICAgICcvLi8nW0tFWV0ocmUpO1xcbiAgfSBjYXRjaCAoZSkge1xcbiAgICB0cnkge1xcbiAgICAgIHJlW01BVENIXSA9IGZhbHNlO1xcbiAgICAgIHJldHVybiAhJy8uLydbS0VZXShyZSk7XFxuICAgIH0gY2F0Y2ggKGYpIHsgLyogZW1wdHkgKi8gfVxcbiAgfSByZXR1cm4gdHJ1ZTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI1MTY4XFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIHN0b3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiZGJkYlxcXCIpKCd3a3MnKTtcXG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNjJhMFxcXCIpO1xcbnZhciBTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJlNTNkXFxcIikuU3ltYm9sO1xcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xcblxcbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcXG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxcbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xcbn07XFxuXFxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiNTE3NlxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNTFiNlxcXCIpO1xcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI1MWI2XFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiYTNjM1xcXCIpO1xcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNTg0YVxcXCIpLk9iamVjdC5hc3NpZ247XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjUyMGFcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFxudmFyIHJlZ2V4cEZsYWdzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMGJmYlxcXCIpO1xcblxcbnZhciBuYXRpdmVFeGVjID0gUmVnRXhwLnByb3RvdHlwZS5leGVjO1xcbi8vIFRoaXMgYWx3YXlzIHJlZmVycyB0byB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlIHRoZVxcbi8vIFN0cmluZyNyZXBsYWNlIHBvbHlmaWxsIHVzZXMgLi9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljLmpzLFxcbi8vIHdoaWNoIGxvYWRzIHRoaXMgZmlsZSBiZWZvcmUgcGF0Y2hpbmcgdGhlIG1ldGhvZC5cXG52YXIgbmF0aXZlUmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcXG5cXG52YXIgcGF0Y2hlZEV4ZWMgPSBuYXRpdmVFeGVjO1xcblxcbnZhciBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XFxuXFxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IChmdW5jdGlvbiAoKSB7XFxuICB2YXIgcmUxID0gL2EvLFxcbiAgICAgIHJlMiA9IC9iKi9nO1xcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMSwgJ2EnKTtcXG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTIsICdhJyk7XFxuICByZXR1cm4gcmUxW0xBU1RfSU5ERVhdICE9PSAwIHx8IHJlMltMQVNUX0lOREVYXSAhPT0gMDtcXG59KSgpO1xcblxcbi8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwLCBjb3BpZWQgZnJvbSBlczUtc2hpbSdzIFN0cmluZyNzcGxpdCBwYXRjaC5cXG52YXIgTlBDR19JTkNMVURFRCA9IC8oKT8/Ly5leGVjKCcnKVsxXSAhPT0gdW5kZWZpbmVkO1xcblxcbnZhciBQQVRDSCA9IFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyB8fCBOUENHX0lOQ0xVREVEO1xcblxcbmlmIChQQVRDSCkge1xcbiAgcGF0Y2hlZEV4ZWMgPSBmdW5jdGlvbiBleGVjKHN0cikge1xcbiAgICB2YXIgcmUgPSB0aGlzO1xcbiAgICB2YXIgbGFzdEluZGV4LCByZUNvcHksIG1hdGNoLCBpO1xcblxcbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xcbiAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14nICsgcmUuc291cmNlICsgJyQoPyFcXFxcXFxcXHMpJywgcmVnZXhwRmxhZ3MuY2FsbChyZSkpO1xcbiAgICB9XFxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcpIGxhc3RJbmRleCA9IHJlW0xBU1RfSU5ERVhdO1xcblxcbiAgICBtYXRjaCA9IG5hdGl2ZUV4ZWMuY2FsbChyZSwgc3RyKTtcXG5cXG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyAmJiBtYXRjaCkge1xcbiAgICAgIHJlW0xBU1RfSU5ERVhdID0gcmUuZ2xvYmFsID8gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggOiBsYXN0SW5kZXg7XFxuICAgIH1cXG4gICAgaWYgKE5QQ0dfSU5DTFVERUQgJiYgbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xcbiAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgXFxuICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJyB3b3JrIGZvciAvKC4/KT8vXFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xcbiAgICAgIG5hdGl2ZVJlcGxhY2UuY2FsbChtYXRjaFswXSwgcmVDb3B5LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xcbiAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpIG1hdGNoW2ldID0gdW5kZWZpbmVkO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBtYXRjaDtcXG4gIH07XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0gcGF0Y2hlZEV4ZWM7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjUzZTJcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG4vLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIwN2UzXFxcIik7XFxudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMjQxZVxcXCIpO1xcbnZhciBJRV9QUk9UTyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjU1NTlcXFwiKSgnSUVfUFJPVE8nKTtcXG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xcblxcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XFxuICBPID0gdG9PYmplY3QoTyk7XFxuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcXG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI1NDliXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBjdHggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJkODY0XFxcIik7XFxudmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI2M2I2XFxcIik7XFxudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMjQxZVxcXCIpO1xcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiYjBkY1xcXCIpO1xcbnZhciBpc0FycmF5SXRlciA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjM3MDJcXFwiKTtcXG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJiNDQ3XFxcIik7XFxudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMjBmZFxcXCIpO1xcbnZhciBnZXRJdGVyRm4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI3Y2Q2XFxcIik7XFxuXFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNGVlMVxcXCIpKGZ1bmN0aW9uIChpdGVyKSB7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XFxuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXFxuICBmcm9tOiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZSAvKiAsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkICovKSB7XFxuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcXG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5O1xcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XFxuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XFxuICAgIHZhciBpbmRleCA9IDA7XFxuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XFxuICAgIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XFxuICAgIGlmIChtYXBwaW5nKSBtYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcXG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKSB7XFxuICAgICAgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQygpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4KyspIHtcXG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xcbiAgICAgIGZvciAocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcXG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XFxuICAgIHJldHVybiByZXN1bHQ7XFxuICB9XFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjU0YTFcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI2YzFjXFxcIik7XFxuX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMTY1NFxcXCIpO1xcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiOTVkNVxcXCIpO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI1NTM3XFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGNvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI4Mzc4XFxcIik7XFxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjc3MjZcXFwiKTtcXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XFxudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xcblxcbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XFxuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcXG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XFxuICB2ZXJzaW9uOiBjb3JlLnZlcnNpb24sXFxuICBtb2RlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIyZDAwXFxcIikgPyAncHVyZScgOiAnZ2xvYmFsJyxcXG4gIGNvcHlyaWdodDogJ8KpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjU1NTlcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiZGJkYlxcXCIpKCdrZXlzJyk7XFxudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjYyYTBcXFwiKTtcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcXG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiNTg0YVxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbnZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjYuNScgfTtcXG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI1YjRlXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXFxudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjM2YzNcXFwiKTtcXG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJiNDQ3XFxcIik7XFxudmFyIHRvQWJzb2x1dGVJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjBmYzlcXFwiKTtcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XFxuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XFxuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XFxuICAgIHZhciB2YWx1ZTtcXG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXFxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XFxuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcXG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcXG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xcbiAgfTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI1Y2ExXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjc3MjZcXFwiKTtcXG52YXIgY29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjgzNzhcXFwiKTtcXG52YXIgaGlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjMyZTlcXFwiKTtcXG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIyYWJhXFxcIik7XFxudmFyIGN0eCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjliNDNcXFwiKTtcXG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XFxuXFxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XFxuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcXG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XFxuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcXG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XFxuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KTtcXG4gIHZhciBrZXksIG93biwgb3V0LCBleHA7XFxuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XFxuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcXG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxcbiAgICBpZiAodGFyZ2V0KSByZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTtcXG4gICAgLy8gZXhwb3J0XFxuICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBoaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcXG4gICAgaWYgKElTX1BST1RPICYmIGV4cFByb3RvW2tleV0gIT0gb3V0KSBleHBQcm90b1trZXldID0gb3V0O1xcbiAgfVxcbn07XFxuZ2xvYmFsLmNvcmUgPSBjb3JlO1xcbi8vIHR5cGUgYml0bWFwXFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXFxuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xcbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiNWQ3M1xcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNDY5ZlxcXCIpO1xcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI1ZjFiXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMjNjNlxcXCIpO1xcbnZhciBidWlsdGluRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcXG5cXG4gLy8gYFJlZ0V4cEV4ZWNgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cGV4ZWNcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChSLCBTKSB7XFxuICB2YXIgZXhlYyA9IFIuZXhlYztcXG4gIGlmICh0eXBlb2YgZXhlYyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICB2YXIgcmVzdWx0ID0gZXhlYy5jYWxsKFIsIFMpO1xcbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ29iamVjdCcpIHtcXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWdFeHAgZXhlYyBtZXRob2QgcmV0dXJuZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gYW4gT2JqZWN0IG9yIG51bGwnKTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfVxcbiAgaWYgKGNsYXNzb2YoUikgIT09ICdSZWdFeHAnKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZ0V4cCNleGVjIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgcmVjZWl2ZXInKTtcXG4gIH1cXG4gIHJldHVybiBidWlsdGluRXhlYy5jYWxsKFIsIFMpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjYyNmFcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xcbnZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIyZDk1XFxcIik7XFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI2MmEwXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxudmFyIGlkID0gMDtcXG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI2M2I2XFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcImU1M2RcXFwiKTtcXG52YXIgY29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjU4NGFcXFwiKTtcXG52YXIgY3R4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiZDg2NFxcXCIpO1xcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMzVlOFxcXCIpO1xcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIwN2UzXFxcIik7XFxudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xcblxcbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XFxuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcXG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcXG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcXG4gIHZhciBJU19XUkFQID0gdHlwZSAmICRleHBvcnQuVztcXG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XFxuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV07XFxuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcXG4gIHZhciBrZXksIG93biwgb3V0O1xcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcXG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcXG4gICAgaWYgKG93biAmJiBoYXMoZXhwb3J0cywga2V5KSkgY29udGludWU7XFxuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XFxuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uIChDKSB7XFxuICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBDKSB7XFxuICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDKCk7XFxuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XFxuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XFxuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xcbiAgICAgIHJldHVybiBGO1xcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcXG4gICAgaWYgKElTX1BST1RPKSB7XFxuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXFxuICAgICAgaWYgKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0pIGhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcXG4gICAgfVxcbiAgfVxcbn07XFxuLy8gdHlwZSBiaXRtYXBcXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXFxuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXFxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI2NzYyXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L0FycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNWNhMVxcXCIpO1xcbnZhciAkaW5jbHVkZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJjMzY2XFxcIikodHJ1ZSk7XFxuXFxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcXG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcXG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xcbiAgfVxcbn0pO1xcblxcbl9fd2VicGFja19yZXF1aXJlX18oXFxcIjljNmNcXFwiKSgnaW5jbHVkZXMnKTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiNjgyMVxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xcbnZhciBJT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNjI2YVxcXCIpO1xcbnZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiYmUxM1xcXCIpO1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiNjlhOFxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcXG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjZhOTlcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG4vLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJkM2Y0XFxcIik7XFxuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2VcXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xcbiAgdmFyIGZuLCB2YWw7XFxuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcXG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xcbiAgdGhyb3cgVHlwZUVycm9yKFxcXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcXFwiKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI2YjRjXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiNmMxY1xcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbl9fd2VicGFja19yZXF1aXJlX18oXFxcImMzNjdcXFwiKTtcXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiZTUzZFxcXCIpO1xcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMzVlOFxcXCIpO1xcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI0ODFiXFxcIik7XFxudmFyIFRPX1NUUklOR19UQUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI1MTY4XFxcIikoJ3RvU3RyaW5nVGFnJyk7XFxuXFxudmFyIERPTUl0ZXJhYmxlcyA9ICgnQ1NTUnVsZUxpc3QsQ1NTU3R5bGVEZWNsYXJhdGlvbixDU1NWYWx1ZUxpc3QsQ2xpZW50UmVjdExpc3QsRE9NUmVjdExpc3QsRE9NU3RyaW5nTGlzdCwnICtcXG4gICdET01Ub2tlbkxpc3QsRGF0YVRyYW5zZmVySXRlbUxpc3QsRmlsZUxpc3QsSFRNTEFsbENvbGxlY3Rpb24sSFRNTENvbGxlY3Rpb24sSFRNTEZvcm1FbGVtZW50LEhUTUxTZWxlY3RFbGVtZW50LCcgK1xcbiAgJ01lZGlhTGlzdCxNaW1lVHlwZUFycmF5LE5hbWVkTm9kZU1hcCxOb2RlTGlzdCxQYWludFJlcXVlc3RMaXN0LFBsdWdpbixQbHVnaW5BcnJheSxTVkdMZW5ndGhMaXN0LFNWR051bWJlckxpc3QsJyArXFxuICAnU1ZHUGF0aFNlZ0xpc3QsU1ZHUG9pbnRMaXN0LFNWR1N0cmluZ0xpc3QsU1ZHVHJhbnNmb3JtTGlzdCxTb3VyY2VCdWZmZXJMaXN0LFN0eWxlU2hlZXRMaXN0LFRleHRUcmFja0N1ZUxpc3QsJyArXFxuICAnVGV4dFRyYWNrTGlzdCxUb3VjaExpc3QnKS5zcGxpdCgnLCcpO1xcblxcbmZvciAodmFyIGkgPSAwOyBpIDwgRE9NSXRlcmFibGVzLmxlbmd0aDsgaSsrKSB7XFxuICB2YXIgTkFNRSA9IERPTUl0ZXJhYmxlc1tpXTtcXG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcXG4gIGlmIChwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xcbiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xcbn1cXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiNzFjMVxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIzYTM4XFxcIik7XFxudmFyIGRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIyNWViXFxcIik7XFxuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XFxuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcXG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcXG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcXG4gICAgdmFyIGEsIGI7XFxuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcXG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcXG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xcbiAgfTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI3NzI2XFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcXG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcXG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjc3NGVcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcImQyZDVcXFwiKTtcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiNzdmMVxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI0NTg4XFxcIik7XFxudmFyIG1heCA9IE1hdGgubWF4O1xcbnZhciBtaW4gPSBNYXRoLm1pbjtcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XFxuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XFxuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI3OTRiXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSAhX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiOGU2MFxcXCIpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIyOTRjXFxcIikoZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIxZWM5XFxcIikoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiNzlhYVxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XFxuICByZXR1cm4gaXQ7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiNzllNVxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcXG4gIHRyeSB7XFxuICAgIHJldHVybiAhIWV4ZWMoKTtcXG4gIH0gY2F0Y2ggKGUpIHtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiN2NkNlxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNDBjM1xcXCIpO1xcbnZhciBJVEVSQVRPUiA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjUxNjhcXFwiKSgnaXRlcmF0b3InKTtcXG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNDgxYlxcXCIpO1xcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNTg0YVxcXCIpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XFxuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXFxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI3ZDdiXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiZTRhZVxcXCIpO1xcbnZhciBnZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI3Y2Q2XFxcIik7XFxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI1ODRhXFxcIikuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHZhciBpdGVyRm4gPSBnZXQoaXQpO1xcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XFxuICByZXR1cm4gYW5PYmplY3QoaXRlckZuLmNhbGwoaXQpKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI3ZTkwXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGRQID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiZDlmNlxcXCIpO1xcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcImU0YWVcXFwiKTtcXG52YXIgZ2V0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcImMzYTFcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjhlNjBcXFwiKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XFxuICBhbk9iamVjdChPKTtcXG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcXG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcXG4gIHZhciBpID0gMDtcXG4gIHZhciBQO1xcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XFxuICByZXR1cm4gTztcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI4Mzc4XFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxudmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNi41JyB9O1xcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjg0MzZcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiODZjY1xcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcImNiN2NcXFwiKTtcXG52YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJjNjlhXFxcIik7XFxudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNmE5OVxcXCIpO1xcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcXG5cXG5leHBvcnRzLmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI5ZTFlXFxcIikgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XFxuICBhbk9iamVjdChPKTtcXG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcXG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XFxuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cXG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XFxuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcXG4gIHJldHVybiBPO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjhhYWVcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIzMmE2XFxcIik7XFxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI1ODRhXFxcIikuT2JqZWN0LmtleXM7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjhlNjBcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG4vLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XFxubW9kdWxlLmV4cG9ydHMgPSAhX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMjk0Y1xcXCIpKGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI4ZjYwXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBjcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJhMTU5XFxcIik7XFxudmFyIGRlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJhZWJkXFxcIik7XFxudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNDVmMlxcXCIpO1xcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xcblxcbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXFxuX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMzVlOFxcXCIpKEl0ZXJhdG9yUHJvdG90eXBlLCBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI1MTY4XFxcIikoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XFxuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcXG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjkwMDNcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG4vLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxcbnZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI2YjRjXFxcIik7XFxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XFxuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5JztcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI5MTM4XFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIzNWU4XFxcIik7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjkzMDZcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxcbnZhciBnZXRLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiYzNhMVxcXCIpO1xcbnZhciBnT1BTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiOWFhOVxcXCIpO1xcbnZhciBwSUUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIzNTVkXFxcIik7XFxudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMjQxZVxcXCIpO1xcbnZhciBJT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMzM1Y1xcXCIpO1xcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcXG5cXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1ZylcXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjI5NGNcXFwiKShmdW5jdGlvbiAoKSB7XFxuICB2YXIgQSA9IHt9O1xcbiAgdmFyIEIgPSB7fTtcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxcbiAgdmFyIFMgPSBTeW1ib2woKTtcXG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcXG4gIEFbU10gPSA3O1xcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBCW2tdID0gazsgfSk7XFxuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcXG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXFxuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XFxuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XFxuICB2YXIgaW5kZXggPSAxO1xcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XFxuICB2YXIgaXNFbnVtID0gcElFLmY7XFxuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XFxuICAgIHZhciBTID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XFxuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcXG4gICAgdmFyIGogPSAwO1xcbiAgICB2YXIga2V5O1xcbiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTtcXG4gIH0gcmV0dXJuIFQ7XFxufSA6ICRhc3NpZ247XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjk0MjdcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjYzYjZcXFwiKTtcXG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgY3JlYXRlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJhMTU5XFxcIikgfSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjk1ZDVcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjQwYzNcXFwiKTtcXG52YXIgSVRFUkFUT1IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI1MTY4XFxcIikoJ2l0ZXJhdG9yJyk7XFxudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjQ4MWJcXFwiKTtcXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjU4NGFcXFwiKS5pc0l0ZXJhYmxlID0gZnVuY3Rpb24gKGl0KSB7XFxuICB2YXIgTyA9IE9iamVjdChpdCk7XFxuICByZXR1cm4gT1tJVEVSQVRPUl0gIT09IHVuZGVmaW5lZFxcbiAgICB8fCAnQEBpdGVyYXRvcicgaW4gT1xcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXFxuICAgIHx8IEl0ZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eShjbGFzc29mKE8pKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCI5YWE5XFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiOWI0M1xcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xcbnZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJkOGU4XFxcIik7XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xcbiAgYUZ1bmN0aW9uKGZuKTtcXG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcXG4gIHN3aXRjaCAobGVuZ3RoKSB7XFxuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XFxuICAgIH07XFxuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XFxuICAgIH07XFxuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XFxuICAgIH07XFxuICB9XFxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XFxuICB9O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjljNmNcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG4vLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXFxudmFyIFVOU0NPUEFCTEVTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMmI0Y1xcXCIpKCd1bnNjb3BhYmxlcycpO1xcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xcbmlmIChBcnJheVByb3RvW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIF9fd2VicGFja19yZXF1aXJlX18oXFxcIjMyZTlcXFwiKShBcnJheVByb3RvLCBVTlNDT1BBQkxFUywge30pO1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiOWRlZlxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbi8vIDcuMS4xNSBUb0xlbmd0aFxcbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI0NTg4XFxcIik7XFxudmFyIG1pbiA9IE1hdGgubWluO1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIjllMWVcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG4vLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XFxubW9kdWxlLmV4cG9ydHMgPSAhX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNzllNVxcXCIpKGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCJhMTU5XFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXFxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiZTRhZVxcXCIpO1xcbnZhciBkUHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI3ZTkwXFxcIik7XFxudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMTY5MVxcXCIpO1xcbnZhciBJRV9QUk9UTyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjU1NTlcXFwiKSgnSUVfUFJPVE8nKTtcXG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XFxudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xcblxcbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcXG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXFxuICB2YXIgaWZyYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMWVjOVxcXCIpKCdpZnJhbWUnKTtcXG4gIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xcbiAgdmFyIGx0ID0gJzwnO1xcbiAgdmFyIGd0ID0gJz4nO1xcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XFxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIzMmZjXFxcIikuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcXG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XFxuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XFxuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcXG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XFxuICByZXR1cm4gY3JlYXRlRGljdCgpO1xcbn07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XFxuICB2YXIgcmVzdWx0O1xcbiAgaWYgKE8gIT09IG51bGwpIHtcXG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcXG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XFxuICAgIC8vIGFkZCBcXFwiX19wcm90b19fXFxcIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcXG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCJhMzUyXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBzb3J0YWJsZWpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9zb3J0YWJsZWpzL1NvcnRhYmxlLmpzXFxcIik7XFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcImEzYzNcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG4vLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNjNiNlxcXCIpO1xcblxcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjkzMDZcXFwiKSB9KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiYTQ4MVxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJjYjdjXFxcIik7XFxudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNGJmOFxcXCIpO1xcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjlkZWZcXFwiKTtcXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNDU4OFxcXCIpO1xcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIwMzkwXFxcIik7XFxudmFyIHJlZ0V4cEV4ZWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI1ZjFiXFxcIik7XFxudmFyIG1heCA9IE1hdGgubWF4O1xcbnZhciBtaW4gPSBNYXRoLm1pbjtcXG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MUyA9IC9cXFxcJChbJCZgJ118XFxcXGRcXFxcZD98PFtePl0qPikvZztcXG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQgPSAvXFxcXCQoWyQmYCddfFxcXFxkXFxcXGQ/KS9nO1xcblxcbnZhciBtYXliZVRvU3RyaW5nID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/IGl0IDogU3RyaW5nKGl0KTtcXG59O1xcblxcbi8vIEBAcmVwbGFjZSBsb2dpY1xcbl9fd2VicGFja19yZXF1aXJlX18oXFxcIjIxNGZcXFwiKSgncmVwbGFjZScsIDIsIGZ1bmN0aW9uIChkZWZpbmVkLCBSRVBMQUNFLCAkcmVwbGFjZSwgbWF5YmVDYWxsTmF0aXZlKSB7XFxuICByZXR1cm4gW1xcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlYCBtZXRob2RcXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlXFxuICAgIGZ1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkge1xcbiAgICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcXG4gICAgICB2YXIgZm4gPSBzZWFyY2hWYWx1ZSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZWFyY2hWYWx1ZVtSRVBMQUNFXTtcXG4gICAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZFxcbiAgICAgICAgPyBmbi5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXFxuICAgICAgICA6ICRyZXBsYWNlLmNhbGwoU3RyaW5nKE8pLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTtcXG4gICAgfSxcXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXWAgbWV0aG9kXFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEByZXBsYWNlXFxuICAgIGZ1bmN0aW9uIChyZWdleHAsIHJlcGxhY2VWYWx1ZSkge1xcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoJHJlcGxhY2UsIHJlZ2V4cCwgdGhpcywgcmVwbGFjZVZhbHVlKTtcXG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XFxuXFxuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcXG4gICAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcXG4gICAgICB2YXIgZnVuY3Rpb25hbFJlcGxhY2UgPSB0eXBlb2YgcmVwbGFjZVZhbHVlID09PSAnZnVuY3Rpb24nO1xcbiAgICAgIGlmICghZnVuY3Rpb25hbFJlcGxhY2UpIHJlcGxhY2VWYWx1ZSA9IFN0cmluZyhyZXBsYWNlVmFsdWUpO1xcbiAgICAgIHZhciBnbG9iYWwgPSByeC5nbG9iYWw7XFxuICAgICAgaWYgKGdsb2JhbCkge1xcbiAgICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcXG4gICAgICAgIHJ4Lmxhc3RJbmRleCA9IDA7XFxuICAgICAgfVxcbiAgICAgIHZhciByZXN1bHRzID0gW107XFxuICAgICAgd2hpbGUgKHRydWUpIHtcXG4gICAgICAgIHZhciByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcXG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIGJyZWFrO1xcbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XFxuICAgICAgICBpZiAoIWdsb2JhbCkgYnJlYWs7XFxuICAgICAgICB2YXIgbWF0Y2hTdHIgPSBTdHJpbmcocmVzdWx0WzBdKTtcXG4gICAgICAgIGlmIChtYXRjaFN0ciA9PT0gJycpIHJ4Lmxhc3RJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCB0b0xlbmd0aChyeC5sYXN0SW5kZXgpLCBmdWxsVW5pY29kZSk7XFxuICAgICAgfVxcbiAgICAgIHZhciBhY2N1bXVsYXRlZFJlc3VsdCA9ICcnO1xcbiAgICAgIHZhciBuZXh0U291cmNlUG9zaXRpb24gPSAwO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0c1tpXTtcXG4gICAgICAgIHZhciBtYXRjaGVkID0gU3RyaW5nKHJlc3VsdFswXSk7XFxuICAgICAgICB2YXIgcG9zaXRpb24gPSBtYXgobWluKHRvSW50ZWdlcihyZXN1bHQuaW5kZXgpLCBTLmxlbmd0aCksIDApO1xcbiAgICAgICAgdmFyIGNhcHR1cmVzID0gW107XFxuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGVxdWl2YWxlbnQgdG9cXG4gICAgICAgIC8vICAgY2FwdHVyZXMgPSByZXN1bHQuc2xpY2UoMSkubWFwKG1heWJlVG9TdHJpbmcpXFxuICAgICAgICAvLyBidXQgZm9yIHNvbWUgcmVhc29uIGBuYXRpdmVTbGljZS5jYWxsKHJlc3VsdCwgMSwgcmVzdWx0Lmxlbmd0aClgIChjYWxsZWQgaW5cXG4gICAgICAgIC8vIHRoZSBzbGljZSBwb2x5ZmlsbCB3aGVuIHNsaWNpbmcgbmF0aXZlIGFycmF5cykgXFxcImRvZXNuJ3Qgd29ya1xcXCIgaW4gc2FmYXJpIDkgYW5kXFxuICAgICAgICAvLyBjYXVzZXMgYSBjcmFzaCAoaHR0cHM6Ly9wYXN0ZWJpbi5jb20vTjIxUXplUUEpIHdoZW4gdHJ5aW5nIHRvIGRlYnVnIGl0LlxcbiAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCByZXN1bHQubGVuZ3RoOyBqKyspIGNhcHR1cmVzLnB1c2gobWF5YmVUb1N0cmluZyhyZXN1bHRbal0pKTtcXG4gICAgICAgIHZhciBuYW1lZENhcHR1cmVzID0gcmVzdWx0Lmdyb3VwcztcXG4gICAgICAgIGlmIChmdW5jdGlvbmFsUmVwbGFjZSkge1xcbiAgICAgICAgICB2YXIgcmVwbGFjZXJBcmdzID0gW21hdGNoZWRdLmNvbmNhdChjYXB0dXJlcywgcG9zaXRpb24sIFMpO1xcbiAgICAgICAgICBpZiAobmFtZWRDYXB0dXJlcyAhPT0gdW5kZWZpbmVkKSByZXBsYWNlckFyZ3MucHVzaChuYW1lZENhcHR1cmVzKTtcXG4gICAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gU3RyaW5nKHJlcGxhY2VWYWx1ZS5hcHBseSh1bmRlZmluZWQsIHJlcGxhY2VyQXJncykpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgUywgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlVmFsdWUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHBvc2l0aW9uID49IG5leHRTb3VyY2VQb3NpdGlvbikge1xcbiAgICAgICAgICBhY2N1bXVsYXRlZFJlc3VsdCArPSBTLnNsaWNlKG5leHRTb3VyY2VQb3NpdGlvbiwgcG9zaXRpb24pICsgcmVwbGFjZW1lbnQ7XFxuICAgICAgICAgIG5leHRTb3VyY2VQb3NpdGlvbiA9IHBvc2l0aW9uICsgbWF0Y2hlZC5sZW5ndGg7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBhY2N1bXVsYXRlZFJlc3VsdCArIFMuc2xpY2UobmV4dFNvdXJjZVBvc2l0aW9uKTtcXG4gICAgfVxcbiAgXTtcXG5cXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2V0c3Vic3RpdHV0aW9uXFxuICBmdW5jdGlvbiBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgc3RyLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VtZW50KSB7XFxuICAgIHZhciB0YWlsUG9zID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcXG4gICAgdmFyIG0gPSBjYXB0dXJlcy5sZW5ndGg7XFxuICAgIHZhciBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQ7XFxuICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICBuYW1lZENhcHR1cmVzID0gdG9PYmplY3QobmFtZWRDYXB0dXJlcyk7XFxuICAgICAgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTO1xcbiAgICB9XFxuICAgIHJldHVybiAkcmVwbGFjZS5jYWxsKHJlcGxhY2VtZW50LCBzeW1ib2xzLCBmdW5jdGlvbiAobWF0Y2gsIGNoKSB7XFxuICAgICAgdmFyIGNhcHR1cmU7XFxuICAgICAgc3dpdGNoIChjaC5jaGFyQXQoMCkpIHtcXG4gICAgICAgIGNhc2UgJyQnOiByZXR1cm4gJyQnO1xcbiAgICAgICAgY2FzZSAnJic6IHJldHVybiBtYXRjaGVkO1xcbiAgICAgICAgY2FzZSAnYCc6IHJldHVybiBzdHIuc2xpY2UoMCwgcG9zaXRpb24pO1xcbiAgICAgICAgY2FzZSBcXFwiJ1xcXCI6IHJldHVybiBzdHIuc2xpY2UodGFpbFBvcyk7XFxuICAgICAgICBjYXNlICc8JzpcXG4gICAgICAgICAgY2FwdHVyZSA9IG5hbWVkQ2FwdHVyZXNbY2guc2xpY2UoMSwgLTEpXTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBkZWZhdWx0OiAvLyBcXFxcZFxcXFxkP1xcbiAgICAgICAgICB2YXIgbiA9ICtjaDtcXG4gICAgICAgICAgaWYgKG4gPT09IDApIHJldHVybiBtYXRjaDtcXG4gICAgICAgICAgaWYgKG4gPiBtKSB7XFxuICAgICAgICAgICAgdmFyIGYgPSBmbG9vcihuIC8gMTApO1xcbiAgICAgICAgICAgIGlmIChmID09PSAwKSByZXR1cm4gbWF0Y2g7XFxuICAgICAgICAgICAgaWYgKGYgPD0gbSkgcmV0dXJuIGNhcHR1cmVzW2YgLSAxXSA9PT0gdW5kZWZpbmVkID8gY2guY2hhckF0KDEpIDogY2FwdHVyZXNbZiAtIDFdICsgY2guY2hhckF0KDEpO1xcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBjYXB0dXJlID0gY2FwdHVyZXNbbiAtIDFdO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gY2FwdHVyZSA9PT0gdW5kZWZpbmVkID8gJycgOiBjYXB0dXJlO1xcbiAgICB9KTtcXG4gIH1cXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiYTRiYlxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiOGFhZVxcXCIpO1xcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCJhNzQ1XFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJmNDEwXFxcIik7XFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcImFhZTNcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG4vLyA3LjIuOCBJc1JlZ0V4cChhcmd1bWVudClcXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJkM2Y0XFxcIik7XFxudmFyIGNvZiA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjJkOTVcXFwiKTtcXG52YXIgTUFUQ0ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIyYjRjXFxcIikoJ21hdGNoJyk7XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHZhciBpc1JlZ0V4cDtcXG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjb2YoaXQpID09ICdSZWdFeHAnKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCJhZWJkXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xcbiAgcmV0dXJuIHtcXG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcXG4gICAgdmFsdWU6IHZhbHVlXFxuICB9O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcImIwYzVcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIHJlZ2V4cEV4ZWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI1MjBhXFxcIik7XFxuX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNWNhMVxcXCIpKHtcXG4gIHRhcmdldDogJ1JlZ0V4cCcsXFxuICBwcm90bzogdHJ1ZSxcXG4gIGZvcmNlZDogcmVnZXhwRXhlYyAhPT0gLy4vLmV4ZWNcXG59LCB7XFxuICBleGVjOiByZWdleHBFeGVjXFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcImIwZGNcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG4vLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXFxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiZTRhZVxcXCIpO1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpIHtcXG4gIHRyeSB7XFxuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XFxuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxcbiAgfSBjYXRjaCAoZSkge1xcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XFxuICAgIHRocm93IGU7XFxuICB9XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiYjQ0N1xcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbi8vIDcuMS4xNSBUb0xlbmd0aFxcbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIzYTM4XFxcIik7XFxudmFyIG1pbiA9IE1hdGgubWluO1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcImI4ZTNcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHRydWU7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcImJlMTNcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG4vLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXFxcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcXFwiICsgaXQpO1xcbiAgcmV0dXJuIGl0O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcImMzNjZcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG4vLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXFxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcXG52YXIgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNjgyMVxcXCIpO1xcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjlkZWZcXFwiKTtcXG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNzdmMVxcXCIpO1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XFxuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XFxuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcXG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcXG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcXG4gICAgdmFyIHZhbHVlO1xcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcXG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XFxuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcXG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XFxuICB9O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcImMzNjdcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIGFkZFRvVW5zY29wYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI4NDM2XFxcIik7XFxudmFyIHN0ZXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI1MGVkXFxcIik7XFxudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjQ4MWJcXFwiKTtcXG52YXIgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMzZjM1xcXCIpO1xcblxcbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjMwZjFcXFwiKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XFxuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcXG59LCBmdW5jdGlvbiAoKSB7XFxuICB2YXIgTyA9IHRoaXMuX3Q7XFxuICB2YXIga2luZCA9IHRoaXMuX2s7XFxuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XFxuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcXG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcXG4gICAgcmV0dXJuIHN0ZXAoMSk7XFxuICB9XFxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTtcXG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XFxuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XFxufSwgJ3ZhbHVlcycpO1xcblxcbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xcblxcbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcXG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcXG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcImMzYTFcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG4vLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcXG52YXIgJGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJlNmYzXFxcIik7XFxudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMTY5MVxcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XFxuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcImM2NDlcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGluc2VydE5vZGVBdDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2FtZWxpemU7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbnNvbGU7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJlbW92ZU5vZGU7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X3JlZ2V4cF9yZXBsYWNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJhNDgxXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfcmVnZXhwX3JlcGxhY2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X3JlZ2V4cF9yZXBsYWNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBGX3NvdXJjZV92dWVkcmFnZ2FibGVfbm9kZV9tb2R1bGVzX2JhYmVsX3J1bnRpbWVfY29yZWpzMl9jb3JlX2pzX29iamVjdF9jcmVhdGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjRhYTZcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgRl9zb3VyY2VfdnVlZHJhZ2dhYmxlX25vZGVfbW9kdWxlc19iYWJlbF9ydW50aW1lX2NvcmVqczJfY29yZV9qc19vYmplY3RfY3JlYXRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oRl9zb3VyY2VfdnVlZHJhZ2dhYmxlX25vZGVfbW9kdWxlc19iYWJlbF9ydW50aW1lX2NvcmVqczJfY29yZV9qc19vYmplY3RfY3JlYXRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xcblxcblxcblxcbmZ1bmN0aW9uIGdldENvbnNvbGUoKSB7XFxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgcmV0dXJuIHdpbmRvdy5jb25zb2xlO1xcbiAgfVxcblxcbiAgcmV0dXJuIGdsb2JhbC5jb25zb2xlO1xcbn1cXG5cXG52YXIgY29uc29sZSA9IGdldENvbnNvbGUoKTtcXG5cXG5mdW5jdGlvbiBjYWNoZWQoZm4pIHtcXG4gIHZhciBjYWNoZSA9IEZfc291cmNlX3Z1ZWRyYWdnYWJsZV9ub2RlX21vZHVsZXNfYmFiZWxfcnVudGltZV9jb3JlanMyX2NvcmVfanNfb2JqZWN0X2NyZWF0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQoKShudWxsKTtcXG5cXG4gIHJldHVybiBmdW5jdGlvbiBjYWNoZWRGbihzdHIpIHtcXG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XFxuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcXG4gIH07XFxufVxcblxcbnZhciByZWdleCA9IC8tKFxcXFx3KS9nO1xcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XFxuICByZXR1cm4gc3RyLnJlcGxhY2UocmVnZXgsIGZ1bmN0aW9uIChfLCBjKSB7XFxuICAgIHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogXFxcIlxcXCI7XFxuICB9KTtcXG59KTtcXG5cXG5mdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcXG4gIGlmIChub2RlLnBhcmVudEVsZW1lbnQgIT09IG51bGwpIHtcXG4gICAgbm9kZS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKG5vZGUpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBpbnNlcnROb2RlQXQoZmF0aGVyTm9kZSwgbm9kZSwgcG9zaXRpb24pIHtcXG4gIHZhciByZWZOb2RlID0gcG9zaXRpb24gPT09IDAgPyBmYXRoZXJOb2RlLmNoaWxkcmVuWzBdIDogZmF0aGVyTm9kZS5jaGlsZHJlbltwb3NpdGlvbiAtIDFdLm5leHRTaWJsaW5nO1xcbiAgZmF0aGVyTm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgcmVmTm9kZSk7XFxufVxcblxcblxcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJjOGJhXFxcIikpKVxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCJjNjlhXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSAhX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiOWUxZVxcXCIpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI3OWU1XFxcIikoZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIyMzBlXFxcIikoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiYzhiYVxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbnZhciBnO1xcblxcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXFxuZyA9IChmdW5jdGlvbigpIHtcXG5cXHRyZXR1cm4gdGhpcztcXG59KSgpO1xcblxcbnRyeSB7XFxuXFx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXFxuXFx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFxcXCJyZXR1cm4gdGhpc1xcXCIpKCk7XFxufSBjYXRjaCAoZSkge1xcblxcdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXFxuXFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFxcXCJvYmplY3RcXFwiKSBnID0gd2luZG93O1xcbn1cXG5cXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXFxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBnO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCJjOGJiXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI1NGExXFxcIik7XFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcImNhNWFcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG52YXIgaWQgPSAwO1xcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XFxuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcImNiN2NcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJkM2Y0XFxcIik7XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XFxuICByZXR1cm4gaXQ7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiY2U3ZVxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNjNiNlxcXCIpO1xcbnZhciBjb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNTg0YVxcXCIpO1xcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjI5NGNcXFwiKTtcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcXG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcXG4gIHZhciBleHAgPSB7fTtcXG4gIGV4cFtLRVldID0gZXhlYyhmbik7XFxuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCJkMmM4XFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuLy8gaGVscGVyIGZvciBTdHJpbmcje3N0YXJ0c1dpdGgsIGVuZHNXaXRoLCBpbmNsdWRlc31cXG52YXIgaXNSZWdFeHAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJhYWUzXFxcIik7XFxudmFyIGRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJiZTEzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgc2VhcmNoU3RyaW5nLCBOQU1FKSB7XFxuICBpZiAoaXNSZWdFeHAoc2VhcmNoU3RyaW5nKSkgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmcjJyArIE5BTUUgKyBcXFwiIGRvZXNuJ3QgYWNjZXB0IHJlZ2V4IVxcXCIpO1xcbiAgcmV0dXJuIFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCJkMmQ1XFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiMTY1NFxcXCIpO1xcbl9fd2VicGFja19yZXF1aXJlX18oXFxcIjU0OWJcXFwiKTtcXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjU4NGFcXFwiKS5BcnJheS5mcm9tO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCJkM2Y0XFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiZDg2NFxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xcbnZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI3OWFhXFxcIik7XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xcbiAgYUZ1bmN0aW9uKGZuKTtcXG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcXG4gIHN3aXRjaCAobGVuZ3RoKSB7XFxuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XFxuICAgIH07XFxuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XFxuICAgIH07XFxuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XFxuICAgIH07XFxuICB9XFxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XFxuICB9O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcImQ4ZThcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xcbiAgcmV0dXJuIGl0O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcImQ5ZjZcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJlNGFlXFxcIik7XFxudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNzk0YlxcXCIpO1xcbnZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjFiYzNcXFwiKTtcXG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XFxuXFxuZXhwb3J0cy5mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiOGU2MFxcXCIpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xcbiAgYW5PYmplY3QoTyk7XFxuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XFxuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcXG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcXG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XFxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XFxuICByZXR1cm4gTztcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCJkYmRiXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGNvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI1ODRhXFxcIik7XFxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcImU1M2RcXFwiKTtcXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XFxudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xcblxcbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XFxuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcXG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XFxuICB2ZXJzaW9uOiBjb3JlLnZlcnNpb24sXFxuICBtb2RlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJiOGUzXFxcIikgPyAncHVyZScgOiAnZ2xvYmFsJyxcXG4gIGNvcHlyaWdodDogJ8KpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcImRjNjJcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI5NDI3XFxcIik7XFxudmFyICRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI1ODRhXFxcIikuT2JqZWN0O1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpIHtcXG4gIHJldHVybiAkT2JqZWN0LmNyZWF0ZShQLCBEKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCJlNGFlXFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiZjc3MlxcXCIpO1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xcbiAgcmV0dXJuIGl0O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcImU1M2RcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiZTZmM1xcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIwN2UzXFxcIik7XFxudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjM2YzNcXFwiKTtcXG52YXIgYXJyYXlJbmRleE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiNWI0ZVxcXCIpKGZhbHNlKTtcXG52YXIgSUVfUFJPVE8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI1NTU5XFxcIikoJ0lFX1BST1RPJyk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcXG4gIHZhciBpID0gMDtcXG4gIHZhciByZXN1bHQgPSBbXTtcXG4gIHZhciBrZXk7XFxuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcXG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiZjQxMFxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbl9fd2VicGFja19yZXF1aXJlX18oXFxcIjFhZjZcXFwiKTtcXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjU4NGFcXFwiKS5BcnJheS5pc0FycmF5O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCJmNTU5XFxcIjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcbi8vIDIxLjEuMy4xOCBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIFssIHBvc2l0aW9uIF0pXFxuXFxudmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI1Y2ExXFxcIik7XFxudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiOWRlZlxcXCIpO1xcbnZhciBjb250ZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiZDJjOFxcXCIpO1xcbnZhciBTVEFSVFNfV0lUSCA9ICdzdGFydHNXaXRoJztcXG52YXIgJHN0YXJ0c1dpdGggPSAnJ1tTVEFSVFNfV0lUSF07XFxuXFxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCI1MTQ3XFxcIikoU1RBUlRTX1dJVEgpLCAnU3RyaW5nJywge1xcbiAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcXG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgU1RBUlRTX1dJVEgpO1xcbiAgICB2YXIgaW5kZXggPSB0b0xlbmd0aChNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdGhhdC5sZW5ndGgpKTtcXG4gICAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xcbiAgICByZXR1cm4gJHN0YXJ0c1dpdGhcXG4gICAgICA/ICRzdGFydHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBpbmRleClcXG4gICAgICA6IHRoYXQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcXG4gIH1cXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiZjc3MlxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcImZhNWJcXFwiOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjU1MzdcXFwiKSgnbmF0aXZlLWZ1bmN0aW9uLXRvLXN0cmluZycsIEZ1bmN0aW9uLnRvU3RyaW5nKTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiZmIxNVxcXCI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuXFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHZ1ZS9jbGktc2VydmljZS9saWIvY29tbWFuZHMvYnVpbGQvc2V0UHVibGljUGF0aC5qc1xcbi8vIFRoaXMgZmlsZSBpcyBpbXBvcnRlZCBpbnRvIGxpYi93YyBjbGllbnQgYnVuZGxlcy5cXG5cXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gIHZhciBzZXRQdWJsaWNQYXRoX2lcXG4gIGlmICgoc2V0UHVibGljUGF0aF9pID0gd2luZG93LmRvY3VtZW50LmN1cnJlbnRTY3JpcHQpICYmIChzZXRQdWJsaWNQYXRoX2kgPSBzZXRQdWJsaWNQYXRoX2kuc3JjLm1hdGNoKC8oLitcXFxcLylbXi9dK1xcXFwuanMoXFxcXD8uKik/JC8pKSkge1xcbiAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBzZXRQdWJsaWNQYXRoX2lbMV0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxcbiAgfVxcbn1cXG5cXG4vLyBJbmRpY2F0ZSB0byB3ZWJwYWNrIHRoYXQgdGhpcyBmaWxlIGNhbiBiZSBjb25jYXRlbmF0ZWRcXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzZXRQdWJsaWNQYXRoID0gKG51bGwpO1xcblxcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9jb3JlLWpzL29iamVjdC9hc3NpZ24uanNcXG52YXIgb2JqZWN0X2Fzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjUxNzZcXFwiKTtcXG52YXIgYXNzaWduX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKG9iamVjdF9hc3NpZ24pO1xcblxcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanNcXG52YXIgZXM2X3N0cmluZ19zdGFydHNfd2l0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcImY1NTlcXFwiKTtcXG5cXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczIvY29yZS1qcy9vYmplY3Qva2V5cy5qc1xcbnZhciBrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiYTRiYlxcXCIpO1xcbnZhciBrZXlzX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGtleXMpO1xcblxcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9jb3JlLWpzL2FycmF5L2lzLWFycmF5LmpzXFxudmFyIGlzX2FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcXFwiYTc0NVxcXCIpO1xcbnZhciBpc19hcnJheV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpc19hcnJheSk7XFxuXFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9oZWxwZXJzL2VzbS9hcnJheVdpdGhIb2xlcy5qc1xcblxcbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcXG4gIGlmIChpc19hcnJheV9kZWZhdWx0KCkoYXJyKSkgcmV0dXJuIGFycjtcXG59XFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMyL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzXFxudmFyIGdldF9pdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjVkNzNcXFwiKTtcXG52YXIgZ2V0X2l0ZXJhdG9yX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGdldF9pdGVyYXRvcik7XFxuXFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qc1xcblxcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcXG4gIHZhciBfYXJyID0gW107XFxuICB2YXIgX24gPSB0cnVlO1xcbiAgdmFyIF9kID0gZmFsc2U7XFxuICB2YXIgX2UgPSB1bmRlZmluZWQ7XFxuXFxuICB0cnkge1xcbiAgICBmb3IgKHZhciBfaSA9IGdldF9pdGVyYXRvcl9kZWZhdWx0KCkoYXJyKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcXG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xcblxcbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcXG4gICAgfVxcbiAgfSBjYXRjaCAoZXJyKSB7XFxuICAgIF9kID0gdHJ1ZTtcXG4gICAgX2UgPSBlcnI7XFxuICB9IGZpbmFsbHkge1xcbiAgICB0cnkge1xcbiAgICAgIGlmICghX24gJiYgX2lbXFxcInJldHVyblxcXCJdICE9IG51bGwpIF9pW1xcXCJyZXR1cm5cXFwiXSgpO1xcbiAgICB9IGZpbmFsbHkge1xcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBfYXJyO1xcbn1cXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMyL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlUmVzdC5qc1xcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XFxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXFxcIik7XFxufVxcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczIvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qc1xcblxcblxcblxcbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcXG59XFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzLmpzXFxudmFyIGVzN19hcnJheV9pbmNsdWRlcyA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjY3NjJcXFwiKTtcXG5cXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzXFxudmFyIGVzNl9zdHJpbmdfaW5jbHVkZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCIyZmRiXFxcIik7XFxuXFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlcy5qc1xcblxcbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcXG4gIGlmIChpc19hcnJheV9kZWZhdWx0KCkoYXJyKSkge1xcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGFycjI7XFxuICB9XFxufVxcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9jb3JlLWpzL2FycmF5L2Zyb20uanNcXG52YXIgZnJvbSA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcIjc3NGVcXFwiKTtcXG52YXIgZnJvbV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihmcm9tKTtcXG5cXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczIvY29yZS1qcy9pcy1pdGVyYWJsZS5qc1xcbnZhciBpc19pdGVyYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcImM4YmJcXFwiKTtcXG52YXIgaXNfaXRlcmFibGVfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNfaXRlcmFibGUpO1xcblxcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczIvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5LmpzXFxuXFxuXFxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XFxuICBpZiAoaXNfaXRlcmFibGVfZGVmYXVsdCgpKE9iamVjdChpdGVyKSkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcXFwiW29iamVjdCBBcmd1bWVudHNdXFxcIikgcmV0dXJuIGZyb21fZGVmYXVsdCgpKGl0ZXIpO1xcbn1cXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMyL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlU3ByZWFkLmpzXFxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcXFwiKTtcXG59XFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheS5qc1xcblxcblxcblxcbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcXG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XFxufVxcbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1xcXCJjb21tb25qc1xcXCI6XFxcInNvcnRhYmxlanNcXFwiLFxcXCJjb21tb25qczJcXFwiOlxcXCJzb3J0YWJsZWpzXFxcIixcXFwiYW1kXFxcIjpcXFwic29ydGFibGVqc1xcXCIsXFxcInJvb3RcXFwiOlxcXCJTb3J0YWJsZVxcXCJ9XFxudmFyIGV4dGVybmFsX2NvbW1vbmpzX3NvcnRhYmxlanNfY29tbW9uanMyX3NvcnRhYmxlanNfYW1kX3NvcnRhYmxlanNfcm9vdF9Tb3J0YWJsZV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxcXCJhMzUyXFxcIik7XFxudmFyIGV4dGVybmFsX2NvbW1vbmpzX3NvcnRhYmxlanNfY29tbW9uanMyX3NvcnRhYmxlanNfYW1kX3NvcnRhYmxlanNfcm9vdF9Tb3J0YWJsZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihleHRlcm5hbF9jb21tb25qc19zb3J0YWJsZWpzX2NvbW1vbmpzMl9zb3J0YWJsZWpzX2FtZF9zb3J0YWJsZWpzX3Jvb3RfU29ydGFibGVfKTtcXG5cXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3V0aWwvaGVscGVyLmpzXFxudmFyIGhlbHBlciA9IF9fd2VicGFja19yZXF1aXJlX18oXFxcImM2NDlcXFwiKTtcXG5cXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy92dWVkcmFnZ2FibGUuanNcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5mdW5jdGlvbiBidWlsZEF0dHJpYnV0ZShvYmplY3QsIHByb3BOYW1lLCB2YWx1ZSkge1xcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcXG4gICAgcmV0dXJuIG9iamVjdDtcXG4gIH1cXG5cXG4gIG9iamVjdCA9IG9iamVjdCB8fCB7fTtcXG4gIG9iamVjdFtwcm9wTmFtZV0gPSB2YWx1ZTtcXG4gIHJldHVybiBvYmplY3Q7XFxufVxcblxcbmZ1bmN0aW9uIGNvbXB1dGVWbUluZGV4KHZub2RlcywgZWxlbWVudCkge1xcbiAgcmV0dXJuIHZub2Rlcy5tYXAoZnVuY3Rpb24gKGVsdCkge1xcbiAgICByZXR1cm4gZWx0LmVsbTtcXG4gIH0pLmluZGV4T2YoZWxlbWVudCk7XFxufVxcblxcbmZ1bmN0aW9uIF9jb21wdXRlSW5kZXhlcyhzbG90cywgY2hpbGRyZW4sIGlzVHJhbnNpdGlvbiwgZm9vdGVyT2Zmc2V0KSB7XFxuICBpZiAoIXNsb3RzKSB7XFxuICAgIHJldHVybiBbXTtcXG4gIH1cXG5cXG4gIHZhciBlbG1Gcm9tTm9kZXMgPSBzbG90cy5tYXAoZnVuY3Rpb24gKGVsdCkge1xcbiAgICByZXR1cm4gZWx0LmVsbTtcXG4gIH0pO1xcbiAgdmFyIGZvb3RlckluZGV4ID0gY2hpbGRyZW4ubGVuZ3RoIC0gZm9vdGVyT2Zmc2V0O1xcblxcbiAgdmFyIHJhd0luZGV4ZXMgPSBfdG9Db25zdW1hYmxlQXJyYXkoY2hpbGRyZW4pLm1hcChmdW5jdGlvbiAoZWx0LCBpZHgpIHtcXG4gICAgcmV0dXJuIGlkeCA+PSBmb290ZXJJbmRleCA/IGVsbUZyb21Ob2Rlcy5sZW5ndGggOiBlbG1Gcm9tTm9kZXMuaW5kZXhPZihlbHQpO1xcbiAgfSk7XFxuXFxuICByZXR1cm4gaXNUcmFuc2l0aW9uID8gcmF3SW5kZXhlcy5maWx0ZXIoZnVuY3Rpb24gKGluZCkge1xcbiAgICByZXR1cm4gaW5kICE9PSAtMTtcXG4gIH0pIDogcmF3SW5kZXhlcztcXG59XFxuXFxuZnVuY3Rpb24gZW1pdChldnROYW1lLCBldnREYXRhKSB7XFxuICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gX3RoaXMuJGVtaXQoZXZ0TmFtZS50b0xvd2VyQ2FzZSgpLCBldnREYXRhKTtcXG4gIH0pO1xcbn1cXG5cXG5mdW5jdGlvbiBkZWxlZ2F0ZUFuZEVtaXQoZXZ0TmFtZSkge1xcbiAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICByZXR1cm4gZnVuY3Rpb24gKGV2dERhdGEpIHtcXG4gICAgaWYgKF90aGlzMi5yZWFsTGlzdCAhPT0gbnVsbCkge1xcbiAgICAgIF90aGlzMltcXFwib25EcmFnXFxcIiArIGV2dE5hbWVdKGV2dERhdGEpO1xcbiAgICB9XFxuXFxuICAgIGVtaXQuY2FsbChfdGhpczIsIGV2dE5hbWUsIGV2dERhdGEpO1xcbiAgfTtcXG59XFxuXFxuZnVuY3Rpb24gaXNUcmFuc2l0aW9uTmFtZShuYW1lKSB7XFxuICByZXR1cm4gW1xcXCJ0cmFuc2l0aW9uLWdyb3VwXFxcIiwgXFxcIlRyYW5zaXRpb25Hcm91cFxcXCJdLmluY2x1ZGVzKG5hbWUpO1xcbn1cXG5cXG5mdW5jdGlvbiB2dWVkcmFnZ2FibGVfaXNUcmFuc2l0aW9uKHNsb3RzKSB7XFxuICBpZiAoIXNsb3RzIHx8IHNsb3RzLmxlbmd0aCAhPT0gMSkge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICB2YXIgX3Nsb3RzID0gX3NsaWNlZFRvQXJyYXkoc2xvdHMsIDEpLFxcbiAgICAgIGNvbXBvbmVudE9wdGlvbnMgPSBfc2xvdHNbMF0uY29tcG9uZW50T3B0aW9ucztcXG5cXG4gIGlmICghY29tcG9uZW50T3B0aW9ucykge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICByZXR1cm4gaXNUcmFuc2l0aW9uTmFtZShjb21wb25lbnRPcHRpb25zLnRhZyk7XFxufVxcblxcbmZ1bmN0aW9uIGdldFNsb3Qoc2xvdCwgc2NvcGVkU2xvdCwga2V5KSB7XFxuICByZXR1cm4gc2xvdFtrZXldIHx8IChzY29wZWRTbG90W2tleV0gPyBzY29wZWRTbG90W2tleV0oKSA6IHVuZGVmaW5lZCk7XFxufVxcblxcbmZ1bmN0aW9uIGNvbXB1dGVDaGlsZHJlbkFuZE9mZnNldHMoY2hpbGRyZW4sIHNsb3QsIHNjb3BlZFNsb3QpIHtcXG4gIHZhciBoZWFkZXJPZmZzZXQgPSAwO1xcbiAgdmFyIGZvb3Rlck9mZnNldCA9IDA7XFxuICB2YXIgaGVhZGVyID0gZ2V0U2xvdChzbG90LCBzY29wZWRTbG90LCBcXFwiaGVhZGVyXFxcIik7XFxuXFxuICBpZiAoaGVhZGVyKSB7XFxuICAgIGhlYWRlck9mZnNldCA9IGhlYWRlci5sZW5ndGg7XFxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4gPyBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGhlYWRlciksIF90b0NvbnN1bWFibGVBcnJheShjaGlsZHJlbikpIDogX3RvQ29uc3VtYWJsZUFycmF5KGhlYWRlcik7XFxuICB9XFxuXFxuICB2YXIgZm9vdGVyID0gZ2V0U2xvdChzbG90LCBzY29wZWRTbG90LCBcXFwiZm9vdGVyXFxcIik7XFxuXFxuICBpZiAoZm9vdGVyKSB7XFxuICAgIGZvb3Rlck9mZnNldCA9IGZvb3Rlci5sZW5ndGg7XFxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4gPyBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGNoaWxkcmVuKSwgX3RvQ29uc3VtYWJsZUFycmF5KGZvb3RlcikpIDogX3RvQ29uc3VtYWJsZUFycmF5KGZvb3Rlcik7XFxuICB9XFxuXFxuICByZXR1cm4ge1xcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXFxuICAgIGhlYWRlck9mZnNldDogaGVhZGVyT2Zmc2V0LFxcbiAgICBmb290ZXJPZmZzZXQ6IGZvb3Rlck9mZnNldFxcbiAgfTtcXG59XFxuXFxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50QXR0cmlidXRlcygkYXR0cnMsIGNvbXBvbmVudERhdGEpIHtcXG4gIHZhciBhdHRyaWJ1dGVzID0gbnVsbDtcXG5cXG4gIHZhciB1cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobmFtZSwgdmFsdWUpIHtcXG4gICAgYXR0cmlidXRlcyA9IGJ1aWxkQXR0cmlidXRlKGF0dHJpYnV0ZXMsIG5hbWUsIHZhbHVlKTtcXG4gIH07XFxuXFxuICB2YXIgYXR0cnMgPSBrZXlzX2RlZmF1bHQoKSgkYXR0cnMpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XFxuICAgIHJldHVybiBrZXkgPT09IFxcXCJpZFxcXCIgfHwga2V5LnN0YXJ0c1dpdGgoXFxcImRhdGEtXFxcIik7XFxuICB9KS5yZWR1Y2UoZnVuY3Rpb24gKHJlcywga2V5KSB7XFxuICAgIHJlc1trZXldID0gJGF0dHJzW2tleV07XFxuICAgIHJldHVybiByZXM7XFxuICB9LCB7fSk7XFxuXFxuICB1cGRhdGUoXFxcImF0dHJzXFxcIiwgYXR0cnMpO1xcblxcbiAgaWYgKCFjb21wb25lbnREYXRhKSB7XFxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xcbiAgfVxcblxcbiAgdmFyIG9uID0gY29tcG9uZW50RGF0YS5vbixcXG4gICAgICBwcm9wcyA9IGNvbXBvbmVudERhdGEucHJvcHMsXFxuICAgICAgY29tcG9uZW50RGF0YUF0dHJzID0gY29tcG9uZW50RGF0YS5hdHRycztcXG4gIHVwZGF0ZShcXFwib25cXFwiLCBvbik7XFxuICB1cGRhdGUoXFxcInByb3BzXFxcIiwgcHJvcHMpO1xcblxcbiAgYXNzaWduX2RlZmF1bHQoKShhdHRyaWJ1dGVzLmF0dHJzLCBjb21wb25lbnREYXRhQXR0cnMpO1xcblxcbiAgcmV0dXJuIGF0dHJpYnV0ZXM7XFxufVxcblxcbnZhciBldmVudHNMaXN0ZW5lZCA9IFtcXFwiU3RhcnRcXFwiLCBcXFwiQWRkXFxcIiwgXFxcIlJlbW92ZVxcXCIsIFxcXCJVcGRhdGVcXFwiLCBcXFwiRW5kXFxcIl07XFxudmFyIGV2ZW50c1RvRW1pdCA9IFtcXFwiQ2hvb3NlXFxcIiwgXFxcIlVuY2hvb3NlXFxcIiwgXFxcIlNvcnRcXFwiLCBcXFwiRmlsdGVyXFxcIiwgXFxcIkNsb25lXFxcIl07XFxudmFyIHJlYWRvbmx5UHJvcGVydGllcyA9IFtcXFwiTW92ZVxcXCJdLmNvbmNhdChldmVudHNMaXN0ZW5lZCwgZXZlbnRzVG9FbWl0KS5tYXAoZnVuY3Rpb24gKGV2dCkge1xcbiAgcmV0dXJuIFxcXCJvblxcXCIgKyBldnQ7XFxufSk7XFxudmFyIGRyYWdnaW5nRWxlbWVudCA9IG51bGw7XFxudmFyIHZ1ZWRyYWdnYWJsZV9wcm9wcyA9IHtcXG4gIG9wdGlvbnM6IE9iamVjdCxcXG4gIGxpc3Q6IHtcXG4gICAgdHlwZTogQXJyYXksXFxuICAgIHJlcXVpcmVkOiBmYWxzZSxcXG4gICAgZGVmYXVsdDogbnVsbFxcbiAgfSxcXG4gIHZhbHVlOiB7XFxuICAgIHR5cGU6IEFycmF5LFxcbiAgICByZXF1aXJlZDogZmFsc2UsXFxuICAgIGRlZmF1bHQ6IG51bGxcXG4gIH0sXFxuICBub1RyYW5zaXRpb25PbkRyYWc6IHtcXG4gICAgdHlwZTogQm9vbGVhbixcXG4gICAgZGVmYXVsdDogZmFsc2VcXG4gIH0sXFxuICBjbG9uZToge1xcbiAgICB0eXBlOiBGdW5jdGlvbixcXG4gICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQob3JpZ2luYWwpIHtcXG4gICAgICByZXR1cm4gb3JpZ2luYWw7XFxuICAgIH1cXG4gIH0sXFxuICBlbGVtZW50OiB7XFxuICAgIHR5cGU6IFN0cmluZyxcXG4gICAgZGVmYXVsdDogXFxcImRpdlxcXCJcXG4gIH0sXFxuICB0YWc6IHtcXG4gICAgdHlwZTogU3RyaW5nLFxcbiAgICBkZWZhdWx0OiBudWxsXFxuICB9LFxcbiAgbW92ZToge1xcbiAgICB0eXBlOiBGdW5jdGlvbixcXG4gICAgZGVmYXVsdDogbnVsbFxcbiAgfSxcXG4gIGNvbXBvbmVudERhdGE6IHtcXG4gICAgdHlwZTogT2JqZWN0LFxcbiAgICByZXF1aXJlZDogZmFsc2UsXFxuICAgIGRlZmF1bHQ6IG51bGxcXG4gIH1cXG59O1xcbnZhciBkcmFnZ2FibGVDb21wb25lbnQgPSB7XFxuICBuYW1lOiBcXFwiZHJhZ2dhYmxlXFxcIixcXG4gIGluaGVyaXRBdHRyczogZmFsc2UsXFxuICBwcm9wczogdnVlZHJhZ2dhYmxlX3Byb3BzLFxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICB0cmFuc2l0aW9uTW9kZTogZmFsc2UsXFxuICAgICAgbm9uZUZ1bmN0aW9uYWxDb21wb25lbnRNb2RlOiBmYWxzZVxcbiAgICB9O1xcbiAgfSxcXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcXG4gICAgdmFyIHNsb3RzID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcXG4gICAgdGhpcy50cmFuc2l0aW9uTW9kZSA9IHZ1ZWRyYWdnYWJsZV9pc1RyYW5zaXRpb24oc2xvdHMpO1xcblxcbiAgICB2YXIgX2NvbXB1dGVDaGlsZHJlbkFuZE9mID0gY29tcHV0ZUNoaWxkcmVuQW5kT2Zmc2V0cyhzbG90cywgdGhpcy4kc2xvdHMsIHRoaXMuJHNjb3BlZFNsb3RzKSxcXG4gICAgICAgIGNoaWxkcmVuID0gX2NvbXB1dGVDaGlsZHJlbkFuZE9mLmNoaWxkcmVuLFxcbiAgICAgICAgaGVhZGVyT2Zmc2V0ID0gX2NvbXB1dGVDaGlsZHJlbkFuZE9mLmhlYWRlck9mZnNldCxcXG4gICAgICAgIGZvb3Rlck9mZnNldCA9IF9jb21wdXRlQ2hpbGRyZW5BbmRPZi5mb290ZXJPZmZzZXQ7XFxuXFxuICAgIHRoaXMuaGVhZGVyT2Zmc2V0ID0gaGVhZGVyT2Zmc2V0O1xcbiAgICB0aGlzLmZvb3Rlck9mZnNldCA9IGZvb3Rlck9mZnNldDtcXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBnZXRDb21wb25lbnRBdHRyaWJ1dGVzKHRoaXMuJGF0dHJzLCB0aGlzLmNvbXBvbmVudERhdGEpO1xcbiAgICByZXR1cm4gaCh0aGlzLmdldFRhZygpLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbik7XFxuICB9LFxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcXG4gICAgaWYgKHRoaXMubGlzdCAhPT0gbnVsbCAmJiB0aGlzLnZhbHVlICE9PSBudWxsKSB7XFxuICAgICAgaGVscGVyW1xcXCJiXFxcIiAvKiBjb25zb2xlICovXS5lcnJvcihcXFwiVmFsdWUgYW5kIGxpc3QgcHJvcHMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSEgUGxlYXNlIHNldCBvbmUgb3IgYW5vdGhlci5cXFwiKTtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5lbGVtZW50ICE9PSBcXFwiZGl2XFxcIikge1xcbiAgICAgIGhlbHBlcltcXFwiYlxcXCIgLyogY29uc29sZSAqL10ud2FybihcXFwiRWxlbWVudCBwcm9wcyBpcyBkZXByZWNhdGVkIHBsZWFzZSB1c2UgdGFnIHByb3BzIGluc3RlYWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vU29ydGFibGVKUy9WdWUuRHJhZ2dhYmxlL2Jsb2IvbWFzdGVyL2RvY3VtZW50YXRpb24vbWlncmF0ZS5tZCNlbGVtZW50LXByb3BzXFxcIik7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMub3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgaGVscGVyW1xcXCJiXFxcIiAvKiBjb25zb2xlICovXS53YXJuKFxcXCJPcHRpb25zIHByb3BzIGlzIGRlcHJlY2F0ZWQsIGFkZCBzb3J0YWJsZSBvcHRpb25zIGRpcmVjdGx5IGFzIHZ1ZS5kcmFnZ2FibGUgaXRlbSwgb3IgdXNlIHYtYmluZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Tb3J0YWJsZUpTL1Z1ZS5EcmFnZ2FibGUvYmxvYi9tYXN0ZXIvZG9jdW1lbnRhdGlvbi9taWdyYXRlLm1kI29wdGlvbnMtcHJvcHNcXFwiKTtcXG4gICAgfVxcbiAgfSxcXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XFxuICAgIHZhciBfdGhpczMgPSB0aGlzO1xcblxcbiAgICB0aGlzLm5vbmVGdW5jdGlvbmFsQ29tcG9uZW50TW9kZSA9IHRoaXMuZ2V0VGFnKCkudG9Mb3dlckNhc2UoKSAhPT0gdGhpcy4kZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAmJiAhdGhpcy5nZXRJc0Z1bmN0aW9uYWwoKTtcXG5cXG4gICAgaWYgKHRoaXMubm9uZUZ1bmN0aW9uYWxDb21wb25lbnRNb2RlICYmIHRoaXMudHJhbnNpdGlvbk1vZGUpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIlRyYW5zaXRpb24tZ3JvdXAgaW5zaWRlIGNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgYWx0ZXIgdGFnIHZhbHVlIG9yIHJlbW92ZSB0cmFuc2l0aW9uLWdyb3VwLiBDdXJyZW50IHRhZyB2YWx1ZTogXFxcIi5jb25jYXQodGhpcy5nZXRUYWcoKSkpO1xcbiAgICB9XFxuXFxuICAgIHZhciBvcHRpb25zQWRkZWQgPSB7fTtcXG4gICAgZXZlbnRzTGlzdGVuZWQuZm9yRWFjaChmdW5jdGlvbiAoZWx0KSB7XFxuICAgICAgb3B0aW9uc0FkZGVkW1xcXCJvblxcXCIgKyBlbHRdID0gZGVsZWdhdGVBbmRFbWl0LmNhbGwoX3RoaXMzLCBlbHQpO1xcbiAgICB9KTtcXG4gICAgZXZlbnRzVG9FbWl0LmZvckVhY2goZnVuY3Rpb24gKGVsdCkge1xcbiAgICAgIG9wdGlvbnNBZGRlZFtcXFwib25cXFwiICsgZWx0XSA9IGVtaXQuYmluZChfdGhpczMsIGVsdCk7XFxuICAgIH0pO1xcblxcbiAgICB2YXIgYXR0cmlidXRlcyA9IGtleXNfZGVmYXVsdCgpKHRoaXMuJGF0dHJzKS5yZWR1Y2UoZnVuY3Rpb24gKHJlcywga2V5KSB7XFxuICAgICAgcmVzW09iamVjdChoZWxwZXJbXFxcImFcXFwiIC8qIGNhbWVsaXplICovXSkoa2V5KV0gPSBfdGhpczMuJGF0dHJzW2tleV07XFxuICAgICAgcmV0dXJuIHJlcztcXG4gICAgfSwge30pO1xcblxcbiAgICB2YXIgb3B0aW9ucyA9IGFzc2lnbl9kZWZhdWx0KCkoe30sIHRoaXMub3B0aW9ucywgYXR0cmlidXRlcywgb3B0aW9uc0FkZGVkLCB7XFxuICAgICAgb25Nb3ZlOiBmdW5jdGlvbiBvbk1vdmUoZXZ0LCBvcmlnaW5hbEV2ZW50KSB7XFxuICAgICAgICByZXR1cm4gX3RoaXMzLm9uRHJhZ01vdmUoZXZ0LCBvcmlnaW5hbEV2ZW50KTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICAhKFxcXCJkcmFnZ2FibGVcXFwiIGluIG9wdGlvbnMpICYmIChvcHRpb25zLmRyYWdnYWJsZSA9IFxcXCI+KlxcXCIpO1xcbiAgICB0aGlzLl9zb3J0YWJsZSA9IG5ldyBleHRlcm5hbF9jb21tb25qc19zb3J0YWJsZWpzX2NvbW1vbmpzMl9zb3J0YWJsZWpzX2FtZF9zb3J0YWJsZWpzX3Jvb3RfU29ydGFibGVfZGVmYXVsdC5hKHRoaXMucm9vdENvbnRhaW5lciwgb3B0aW9ucyk7XFxuICAgIHRoaXMuY29tcHV0ZUluZGV4ZXMoKTtcXG4gIH0sXFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xcbiAgICBpZiAodGhpcy5fc29ydGFibGUgIT09IHVuZGVmaW5lZCkgdGhpcy5fc29ydGFibGUuZGVzdHJveSgpO1xcbiAgfSxcXG4gIGNvbXB1dGVkOiB7XFxuICAgIHJvb3RDb250YWluZXI6IGZ1bmN0aW9uIHJvb3RDb250YWluZXIoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbk1vZGUgPyB0aGlzLiRlbC5jaGlsZHJlblswXSA6IHRoaXMuJGVsO1xcbiAgICB9LFxcbiAgICByZWFsTGlzdDogZnVuY3Rpb24gcmVhbExpc3QoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMubGlzdCA/IHRoaXMubGlzdCA6IHRoaXMudmFsdWU7XFxuICAgIH1cXG4gIH0sXFxuICB3YXRjaDoge1xcbiAgICBvcHRpb25zOiB7XFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihuZXdPcHRpb25WYWx1ZSkge1xcbiAgICAgICAgdGhpcy51cGRhdGVPcHRpb25zKG5ld09wdGlvblZhbHVlKTtcXG4gICAgICB9LFxcbiAgICAgIGRlZXA6IHRydWVcXG4gICAgfSxcXG4gICAgJGF0dHJzOiB7XFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihuZXdPcHRpb25WYWx1ZSkge1xcbiAgICAgICAgdGhpcy51cGRhdGVPcHRpb25zKG5ld09wdGlvblZhbHVlKTtcXG4gICAgICB9LFxcbiAgICAgIGRlZXA6IHRydWVcXG4gICAgfSxcXG4gICAgcmVhbExpc3Q6IGZ1bmN0aW9uIHJlYWxMaXN0KCkge1xcbiAgICAgIHRoaXMuY29tcHV0ZUluZGV4ZXMoKTtcXG4gICAgfVxcbiAgfSxcXG4gIG1ldGhvZHM6IHtcXG4gICAgZ2V0SXNGdW5jdGlvbmFsOiBmdW5jdGlvbiBnZXRJc0Z1bmN0aW9uYWwoKSB7XFxuICAgICAgdmFyIGZuT3B0aW9ucyA9IHRoaXMuX3Zub2RlLmZuT3B0aW9ucztcXG4gICAgICByZXR1cm4gZm5PcHRpb25zICYmIGZuT3B0aW9ucy5mdW5jdGlvbmFsO1xcbiAgICB9LFxcbiAgICBnZXRUYWc6IGZ1bmN0aW9uIGdldFRhZygpIHtcXG4gICAgICByZXR1cm4gdGhpcy50YWcgfHwgdGhpcy5lbGVtZW50O1xcbiAgICB9LFxcbiAgICB1cGRhdGVPcHRpb25zOiBmdW5jdGlvbiB1cGRhdGVPcHRpb25zKG5ld09wdGlvblZhbHVlKSB7XFxuICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gbmV3T3B0aW9uVmFsdWUpIHtcXG4gICAgICAgIHZhciB2YWx1ZSA9IE9iamVjdChoZWxwZXJbXFxcImFcXFwiIC8qIGNhbWVsaXplICovXSkocHJvcGVydHkpO1xcblxcbiAgICAgICAgaWYgKHJlYWRvbmx5UHJvcGVydGllcy5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcXG4gICAgICAgICAgdGhpcy5fc29ydGFibGUub3B0aW9uKHZhbHVlLCBuZXdPcHRpb25WYWx1ZVtwcm9wZXJ0eV0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgZ2V0Q2hpbGRyZW5Ob2RlczogZnVuY3Rpb24gZ2V0Q2hpbGRyZW5Ob2RlcygpIHtcXG4gICAgICBpZiAodGhpcy5ub25lRnVuY3Rpb25hbENvbXBvbmVudE1vZGUpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLiRjaGlsZHJlblswXS4kc2xvdHMuZGVmYXVsdDtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHJhd05vZGVzID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcXG4gICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uTW9kZSA/IHJhd05vZGVzWzBdLmNoaWxkLiRzbG90cy5kZWZhdWx0IDogcmF3Tm9kZXM7XFxuICAgIH0sXFxuICAgIGNvbXB1dGVJbmRleGVzOiBmdW5jdGlvbiBjb21wdXRlSW5kZXhlcygpIHtcXG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XFxuICAgICAgICBfdGhpczQudmlzaWJsZUluZGV4ZXMgPSBfY29tcHV0ZUluZGV4ZXMoX3RoaXM0LmdldENoaWxkcmVuTm9kZXMoKSwgX3RoaXM0LnJvb3RDb250YWluZXIuY2hpbGRyZW4sIF90aGlzNC50cmFuc2l0aW9uTW9kZSwgX3RoaXM0LmZvb3Rlck9mZnNldCk7XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIGdldFVuZGVybHlpbmdWbTogZnVuY3Rpb24gZ2V0VW5kZXJseWluZ1ZtKGh0bWxFbHQpIHtcXG4gICAgICB2YXIgaW5kZXggPSBjb21wdXRlVm1JbmRleCh0aGlzLmdldENoaWxkcmVuTm9kZXMoKSB8fCBbXSwgaHRtbEVsdCk7XFxuXFxuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xcbiAgICAgICAgLy9FZGdlIGNhc2UgZHVyaW5nIG1vdmUgY2FsbGJhY2s6IHJlbGF0ZWQgZWxlbWVudCBtaWdodCBiZVxcbiAgICAgICAgLy9hbiBlbGVtZW50IGRpZmZlcmVudCBmcm9tIGNvbGxlY3Rpb25cXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucmVhbExpc3RbaW5kZXhdO1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBpbmRleDogaW5kZXgsXFxuICAgICAgICBlbGVtZW50OiBlbGVtZW50XFxuICAgICAgfTtcXG4gICAgfSxcXG4gICAgZ2V0VW5kZXJseWluZ1BvdGVuY2lhbERyYWdnYWJsZUNvbXBvbmVudDogZnVuY3Rpb24gZ2V0VW5kZXJseWluZ1BvdGVuY2lhbERyYWdnYWJsZUNvbXBvbmVudChfcmVmKSB7XFxuICAgICAgdmFyIHZ1ZSA9IF9yZWYuX192dWVfXztcXG5cXG4gICAgICBpZiAoIXZ1ZSB8fCAhdnVlLiRvcHRpb25zIHx8ICFpc1RyYW5zaXRpb25OYW1lKHZ1ZS4kb3B0aW9ucy5fY29tcG9uZW50VGFnKSkge1xcbiAgICAgICAgaWYgKCEoXFxcInJlYWxMaXN0XFxcIiBpbiB2dWUpICYmIHZ1ZS4kY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIFxcXCJyZWFsTGlzdFxcXCIgaW4gdnVlLiRjaGlsZHJlblswXSkgcmV0dXJuIHZ1ZS4kY2hpbGRyZW5bMF07XFxuICAgICAgICByZXR1cm4gdnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdnVlLiRwYXJlbnQ7XFxuICAgIH0sXFxuICAgIGVtaXRDaGFuZ2VzOiBmdW5jdGlvbiBlbWl0Q2hhbmdlcyhldnQpIHtcXG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcXG5cXG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XFxuICAgICAgICBfdGhpczUuJGVtaXQoXFxcImNoYW5nZVxcXCIsIGV2dCk7XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIGFsdGVyTGlzdDogZnVuY3Rpb24gYWx0ZXJMaXN0KG9uTGlzdCkge1xcbiAgICAgIGlmICh0aGlzLmxpc3QpIHtcXG4gICAgICAgIG9uTGlzdCh0aGlzLmxpc3QpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgbmV3TGlzdCA9IF90b0NvbnN1bWFibGVBcnJheSh0aGlzLnZhbHVlKTtcXG5cXG4gICAgICBvbkxpc3QobmV3TGlzdCk7XFxuICAgICAgdGhpcy4kZW1pdChcXFwiaW5wdXRcXFwiLCBuZXdMaXN0KTtcXG4gICAgfSxcXG4gICAgc3BsaWNlTGlzdDogZnVuY3Rpb24gc3BsaWNlTGlzdCgpIHtcXG4gICAgICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcXG5cXG4gICAgICB2YXIgc3BsaWNlTGlzdCA9IGZ1bmN0aW9uIHNwbGljZUxpc3QobGlzdCkge1xcbiAgICAgICAgcmV0dXJuIGxpc3Quc3BsaWNlLmFwcGx5KGxpc3QsIF90b0NvbnN1bWFibGVBcnJheShfYXJndW1lbnRzKSk7XFxuICAgICAgfTtcXG5cXG4gICAgICB0aGlzLmFsdGVyTGlzdChzcGxpY2VMaXN0KTtcXG4gICAgfSxcXG4gICAgdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKG9sZEluZGV4LCBuZXdJbmRleCkge1xcbiAgICAgIHZhciB1cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKGxpc3QpIHtcXG4gICAgICAgIHJldHVybiBsaXN0LnNwbGljZShuZXdJbmRleCwgMCwgbGlzdC5zcGxpY2Uob2xkSW5kZXgsIDEpWzBdKTtcXG4gICAgICB9O1xcblxcbiAgICAgIHRoaXMuYWx0ZXJMaXN0KHVwZGF0ZVBvc2l0aW9uKTtcXG4gICAgfSxcXG4gICAgZ2V0UmVsYXRlZENvbnRleHRGcm9tTW92ZUV2ZW50OiBmdW5jdGlvbiBnZXRSZWxhdGVkQ29udGV4dEZyb21Nb3ZlRXZlbnQoX3JlZjIpIHtcXG4gICAgICB2YXIgdG8gPSBfcmVmMi50byxcXG4gICAgICAgICAgcmVsYXRlZCA9IF9yZWYyLnJlbGF0ZWQ7XFxuICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuZ2V0VW5kZXJseWluZ1BvdGVuY2lhbERyYWdnYWJsZUNvbXBvbmVudCh0byk7XFxuXFxuICAgICAgaWYgKCFjb21wb25lbnQpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50XFxuICAgICAgICB9O1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgbGlzdCA9IGNvbXBvbmVudC5yZWFsTGlzdDtcXG4gICAgICB2YXIgY29udGV4dCA9IHtcXG4gICAgICAgIGxpc3Q6IGxpc3QsXFxuICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudFxcbiAgICAgIH07XFxuXFxuICAgICAgaWYgKHRvICE9PSByZWxhdGVkICYmIGxpc3QgJiYgY29tcG9uZW50LmdldFVuZGVybHlpbmdWbSkge1xcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gY29tcG9uZW50LmdldFVuZGVybHlpbmdWbShyZWxhdGVkKTtcXG5cXG4gICAgICAgIGlmIChkZXN0aW5hdGlvbikge1xcbiAgICAgICAgICByZXR1cm4gYXNzaWduX2RlZmF1bHQoKShkZXN0aW5hdGlvbiwgY29udGV4dCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBjb250ZXh0O1xcbiAgICB9LFxcbiAgICBnZXRWbUluZGV4OiBmdW5jdGlvbiBnZXRWbUluZGV4KGRvbUluZGV4KSB7XFxuICAgICAgdmFyIGluZGV4ZXMgPSB0aGlzLnZpc2libGVJbmRleGVzO1xcbiAgICAgIHZhciBudW1iZXJJbmRleGVzID0gaW5kZXhlcy5sZW5ndGg7XFxuICAgICAgcmV0dXJuIGRvbUluZGV4ID4gbnVtYmVySW5kZXhlcyAtIDEgPyBudW1iZXJJbmRleGVzIDogaW5kZXhlc1tkb21JbmRleF07XFxuICAgIH0sXFxuICAgIGdldENvbXBvbmVudDogZnVuY3Rpb24gZ2V0Q29tcG9uZW50KCkge1xcbiAgICAgIHJldHVybiB0aGlzLiRzbG90cy5kZWZhdWx0WzBdLmNvbXBvbmVudEluc3RhbmNlO1xcbiAgICB9LFxcbiAgICByZXNldFRyYW5zaXRpb25EYXRhOiBmdW5jdGlvbiByZXNldFRyYW5zaXRpb25EYXRhKGluZGV4KSB7XFxuICAgICAgaWYgKCF0aGlzLm5vVHJhbnNpdGlvbk9uRHJhZyB8fCAhdGhpcy50cmFuc2l0aW9uTW9kZSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmdldENoaWxkcmVuTm9kZXMoKTtcXG4gICAgICBub2Rlc1tpbmRleF0uZGF0YSA9IG51bGw7XFxuICAgICAgdmFyIHRyYW5zaXRpb25Db250YWluZXIgPSB0aGlzLmdldENvbXBvbmVudCgpO1xcbiAgICAgIHRyYW5zaXRpb25Db250YWluZXIuY2hpbGRyZW4gPSBbXTtcXG4gICAgICB0cmFuc2l0aW9uQ29udGFpbmVyLmtlcHQgPSB1bmRlZmluZWQ7XFxuICAgIH0sXFxuICAgIG9uRHJhZ1N0YXJ0OiBmdW5jdGlvbiBvbkRyYWdTdGFydChldnQpIHtcXG4gICAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmdldFVuZGVybHlpbmdWbShldnQuaXRlbSk7XFxuICAgICAgZXZ0Lml0ZW0uX3VuZGVybHlpbmdfdm1fID0gdGhpcy5jbG9uZSh0aGlzLmNvbnRleHQuZWxlbWVudCk7XFxuICAgICAgZHJhZ2dpbmdFbGVtZW50ID0gZXZ0Lml0ZW07XFxuICAgIH0sXFxuICAgIG9uRHJhZ0FkZDogZnVuY3Rpb24gb25EcmFnQWRkKGV2dCkge1xcbiAgICAgIHZhciBlbGVtZW50ID0gZXZ0Lml0ZW0uX3VuZGVybHlpbmdfdm1fO1xcblxcbiAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgT2JqZWN0KGhlbHBlcltcXFwiZFxcXCIgLyogcmVtb3ZlTm9kZSAqL10pKGV2dC5pdGVtKTtcXG4gICAgICB2YXIgbmV3SW5kZXggPSB0aGlzLmdldFZtSW5kZXgoZXZ0Lm5ld0luZGV4KTtcXG4gICAgICB0aGlzLnNwbGljZUxpc3QobmV3SW5kZXgsIDAsIGVsZW1lbnQpO1xcbiAgICAgIHRoaXMuY29tcHV0ZUluZGV4ZXMoKTtcXG4gICAgICB2YXIgYWRkZWQgPSB7XFxuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxcbiAgICAgICAgbmV3SW5kZXg6IG5ld0luZGV4XFxuICAgICAgfTtcXG4gICAgICB0aGlzLmVtaXRDaGFuZ2VzKHtcXG4gICAgICAgIGFkZGVkOiBhZGRlZFxcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBvbkRyYWdSZW1vdmU6IGZ1bmN0aW9uIG9uRHJhZ1JlbW92ZShldnQpIHtcXG4gICAgICBPYmplY3QoaGVscGVyW1xcXCJjXFxcIiAvKiBpbnNlcnROb2RlQXQgKi9dKSh0aGlzLnJvb3RDb250YWluZXIsIGV2dC5pdGVtLCBldnQub2xkSW5kZXgpO1xcblxcbiAgICAgIGlmIChldnQucHVsbE1vZGUgPT09IFxcXCJjbG9uZVxcXCIpIHtcXG4gICAgICAgIE9iamVjdChoZWxwZXJbXFxcImRcXFwiIC8qIHJlbW92ZU5vZGUgKi9dKShldnQuY2xvbmUpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgb2xkSW5kZXggPSB0aGlzLmNvbnRleHQuaW5kZXg7XFxuICAgICAgdGhpcy5zcGxpY2VMaXN0KG9sZEluZGV4LCAxKTtcXG4gICAgICB2YXIgcmVtb3ZlZCA9IHtcXG4gICAgICAgIGVsZW1lbnQ6IHRoaXMuY29udGV4dC5lbGVtZW50LFxcbiAgICAgICAgb2xkSW5kZXg6IG9sZEluZGV4XFxuICAgICAgfTtcXG4gICAgICB0aGlzLnJlc2V0VHJhbnNpdGlvbkRhdGEob2xkSW5kZXgpO1xcbiAgICAgIHRoaXMuZW1pdENoYW5nZXMoe1xcbiAgICAgICAgcmVtb3ZlZDogcmVtb3ZlZFxcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBvbkRyYWdVcGRhdGU6IGZ1bmN0aW9uIG9uRHJhZ1VwZGF0ZShldnQpIHtcXG4gICAgICBPYmplY3QoaGVscGVyW1xcXCJkXFxcIiAvKiByZW1vdmVOb2RlICovXSkoZXZ0Lml0ZW0pO1xcbiAgICAgIE9iamVjdChoZWxwZXJbXFxcImNcXFwiIC8qIGluc2VydE5vZGVBdCAqL10pKGV2dC5mcm9tLCBldnQuaXRlbSwgZXZ0Lm9sZEluZGV4KTtcXG4gICAgICB2YXIgb2xkSW5kZXggPSB0aGlzLmNvbnRleHQuaW5kZXg7XFxuICAgICAgdmFyIG5ld0luZGV4ID0gdGhpcy5nZXRWbUluZGV4KGV2dC5uZXdJbmRleCk7XFxuICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbihvbGRJbmRleCwgbmV3SW5kZXgpO1xcbiAgICAgIHZhciBtb3ZlZCA9IHtcXG4gICAgICAgIGVsZW1lbnQ6IHRoaXMuY29udGV4dC5lbGVtZW50LFxcbiAgICAgICAgb2xkSW5kZXg6IG9sZEluZGV4LFxcbiAgICAgICAgbmV3SW5kZXg6IG5ld0luZGV4XFxuICAgICAgfTtcXG4gICAgICB0aGlzLmVtaXRDaGFuZ2VzKHtcXG4gICAgICAgIG1vdmVkOiBtb3ZlZFxcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICB1cGRhdGVQcm9wZXJ0eTogZnVuY3Rpb24gdXBkYXRlUHJvcGVydHkoZXZ0LCBwcm9wZXJ0eU5hbWUpIHtcXG4gICAgICBldnQuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSAmJiAoZXZ0W3Byb3BlcnR5TmFtZV0gKz0gdGhpcy5oZWFkZXJPZmZzZXQpO1xcbiAgICB9LFxcbiAgICBjb21wdXRlRnV0dXJlSW5kZXg6IGZ1bmN0aW9uIGNvbXB1dGVGdXR1cmVJbmRleChyZWxhdGVkQ29udGV4dCwgZXZ0KSB7XFxuICAgICAgaWYgKCFyZWxhdGVkQ29udGV4dC5lbGVtZW50KSB7XFxuICAgICAgICByZXR1cm4gMDtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGRvbUNoaWxkcmVuID0gX3RvQ29uc3VtYWJsZUFycmF5KGV2dC50by5jaGlsZHJlbikuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xcbiAgICAgICAgcmV0dXJuIGVsLnN0eWxlW1xcXCJkaXNwbGF5XFxcIl0gIT09IFxcXCJub25lXFxcIjtcXG4gICAgICB9KTtcXG5cXG4gICAgICB2YXIgY3VycmVudERPTUluZGV4ID0gZG9tQ2hpbGRyZW4uaW5kZXhPZihldnQucmVsYXRlZCk7XFxuICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHJlbGF0ZWRDb250ZXh0LmNvbXBvbmVudC5nZXRWbUluZGV4KGN1cnJlbnRET01JbmRleCk7XFxuICAgICAgdmFyIGRyYWdnZWRJbkxpc3QgPSBkb21DaGlsZHJlbi5pbmRleE9mKGRyYWdnaW5nRWxlbWVudCkgIT09IC0xO1xcbiAgICAgIHJldHVybiBkcmFnZ2VkSW5MaXN0IHx8ICFldnQud2lsbEluc2VydEFmdGVyID8gY3VycmVudEluZGV4IDogY3VycmVudEluZGV4ICsgMTtcXG4gICAgfSxcXG4gICAgb25EcmFnTW92ZTogZnVuY3Rpb24gb25EcmFnTW92ZShldnQsIG9yaWdpbmFsRXZlbnQpIHtcXG4gICAgICB2YXIgb25Nb3ZlID0gdGhpcy5tb3ZlO1xcblxcbiAgICAgIGlmICghb25Nb3ZlIHx8ICF0aGlzLnJlYWxMaXN0KSB7XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHJlbGF0ZWRDb250ZXh0ID0gdGhpcy5nZXRSZWxhdGVkQ29udGV4dEZyb21Nb3ZlRXZlbnQoZXZ0KTtcXG4gICAgICB2YXIgZHJhZ2dlZENvbnRleHQgPSB0aGlzLmNvbnRleHQ7XFxuICAgICAgdmFyIGZ1dHVyZUluZGV4ID0gdGhpcy5jb21wdXRlRnV0dXJlSW5kZXgocmVsYXRlZENvbnRleHQsIGV2dCk7XFxuXFxuICAgICAgYXNzaWduX2RlZmF1bHQoKShkcmFnZ2VkQ29udGV4dCwge1xcbiAgICAgICAgZnV0dXJlSW5kZXg6IGZ1dHVyZUluZGV4XFxuICAgICAgfSk7XFxuXFxuICAgICAgdmFyIHNlbmRFdnQgPSBhc3NpZ25fZGVmYXVsdCgpKHt9LCBldnQsIHtcXG4gICAgICAgIHJlbGF0ZWRDb250ZXh0OiByZWxhdGVkQ29udGV4dCxcXG4gICAgICAgIGRyYWdnZWRDb250ZXh0OiBkcmFnZ2VkQ29udGV4dFxcbiAgICAgIH0pO1xcblxcbiAgICAgIHJldHVybiBvbk1vdmUoc2VuZEV2dCwgb3JpZ2luYWxFdmVudCk7XFxuICAgIH0sXFxuICAgIG9uRHJhZ0VuZDogZnVuY3Rpb24gb25EcmFnRW5kKCkge1xcbiAgICAgIHRoaXMuY29tcHV0ZUluZGV4ZXMoKTtcXG4gICAgICBkcmFnZ2luZ0VsZW1lbnQgPSBudWxsO1xcbiAgICB9XFxuICB9XFxufTtcXG5cXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgXFxcIlZ1ZVxcXCIgaW4gd2luZG93KSB7XFxuICB3aW5kb3cuVnVlLmNvbXBvbmVudChcXFwiZHJhZ2dhYmxlXFxcIiwgZHJhZ2dhYmxlQ29tcG9uZW50KTtcXG59XFxuXFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdnVlZHJhZ2dhYmxlID0gKGRyYWdnYWJsZUNvbXBvbmVudCk7XFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHZ1ZS9jbGktc2VydmljZS9saWIvY29tbWFuZHMvYnVpbGQvZW50cnktbGliLmpzXFxuXFxuXFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZW50cnlfbGliID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcXFwiZGVmYXVsdFxcXCJdID0gKHZ1ZWRyYWdnYWJsZSk7XFxuXFxuXFxuXFxuLyoqKi8gfSlcXG5cXG4vKioqKioqLyB9KVtcXFwiZGVmYXVsdFxcXCJdO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZ1ZWRyYWdnYWJsZS5jb21tb24uanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZWRyYWdnYWJsZS9kaXN0L3Z1ZWRyYWdnYWJsZS5jb21tb24uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCJ2YXIgZztcXG5cXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxcbmcgPSAoZnVuY3Rpb24oKSB7XFxuXFx0cmV0dXJuIHRoaXM7XFxufSkoKTtcXG5cXG50cnkge1xcblxcdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxcblxcdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcXFwicmV0dXJuIHRoaXNcXFwiKSgpO1xcbn0gY2F0Y2ggKGUpIHtcXG5cXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxcblxcdGlmICh0eXBlb2Ygd2luZG93ID09PSBcXFwib2JqZWN0XFxcIikgZyA9IHdpbmRvdztcXG59XFxuXFxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXFxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxcblxcbm1vZHVsZS5leHBvcnRzID0gZztcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvanMvYXBwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9qcy9hcHAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIGV4cG9ydHMgcHJvdmlkZWQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kdWVsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tb2R1ZWxzICovIFxcXCIuL3NyYy9qcy9tb2R1ZWxzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tb2R1bGVzX29ubG9hZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tb2R1bGVzL29ubG9hZCAqLyBcXFwiLi9zcmMvanMvbW9kdWxlcy9vbmxvYWQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbXBvbmVudHNfZm9ybV9TZWxlY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29tcG9uZW50cy9mb3JtL1NlbGVjdCAqLyBcXFwiLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL1NlbGVjdC52dWVcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbXBvbmVudHNfZm9ybV9NdWx0aVNlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb21wb25lbnRzL2Zvcm0vTXVsdGlTZWxlY3QgKi8gXFxcIi4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9NdWx0aVNlbGVjdC52dWVcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbXBvbmVudHNfZm9ybV9GaWxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbXBvbmVudHMvZm9ybS9GaWxlICovIFxcXCIuL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vRmlsZS52dWVcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbXBvbmVudHNfTG9naW5Gb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbXBvbmVudHMvTG9naW5Gb3JtICovIFxcXCIuL3NyYy9qcy9jb21wb25lbnRzL0xvZ2luRm9ybS52dWVcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbXBvbmVudHNfZm9ybV9JbWFnZUl0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbXBvbmVudHMvZm9ybS9JbWFnZUl0ZXJhdG9yICovIFxcXCIuL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vSW1hZ2VJdGVyYXRvci52dWVcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdmVlX3ZhbGlkYXRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB2ZWUtdmFsaWRhdGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3ZlZS12YWxpZGF0ZS9kaXN0L3ZlZS12YWxpZGF0ZS5lc20uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdmVlX3ZhbGlkYXRlX2Rpc3RfbG9jYWxlX3J1X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB2ZWUtdmFsaWRhdGUvZGlzdC9sb2NhbGUvcnUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3ZlZS12YWxpZGF0ZS9kaXN0L2xvY2FsZS9ydS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2ZWVfdmFsaWRhdGVfZGlzdF9sb2NhbGVfcnVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih2ZWVfdmFsaWRhdGVfZGlzdF9sb2NhbGVfcnVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdnVlICovIFxcXCIuL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuZXNtLmpzXFxcIik7XFxuLy8gVnVlIG1haW4gZmlsZVxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbndpbmRvdy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XFxuICBPYmplY3QoX21vZHVlbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwibWFpblxcXCJdKSgpO1xcbiAgT2JqZWN0KF9tb2R1bGVzX29ubG9hZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJvbmxvYWRcXFwiXSkoKTtcXG59OyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tdXNlLXNlY3Rpb24tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT5cXG5cXG5cXG52dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcXFwiZGVmYXVsdFxcXCJdLnVzZSh2ZWVfdmFsaWRhdGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcXFwiZGVmYXVsdFxcXCJdLCB7XFxuICBjbGFzc2VzOiB0cnVlLFxcbiAgY2xhc3NOYW1lczoge1xcbiAgICB2YWxpZDogJ2lzLXZhbGlkJyxcXG4gICAgaW52YWxpZDogJ2lzLWludmFsaWQnXFxuICB9XFxufSk7XFxudmVlX3ZhbGlkYXRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXFxcIlZhbGlkYXRvclxcXCJdLmxvY2FsaXplKCdydScsIHZlZV92YWxpZGF0ZV9kaXN0X2xvY2FsZV9ydV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fX2RlZmF1bHQuYSk7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPlxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1jb21wb25lbnQtc2VjdGlvbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPlxcblxcbnZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1xcXCJkZWZhdWx0XFxcIl0uY29tcG9uZW50KCdzZWxlY3Qtc2luZ2xlJywgX2NvbXBvbmVudHNfZm9ybV9TZWxlY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVmYXVsdFxcXCJdKTtcXG52dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcXFwiZGVmYXVsdFxcXCJdLmNvbXBvbmVudCgnc2VsZWN0LW11bHRpJywgX2NvbXBvbmVudHNfZm9ybV9NdWx0aVNlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJkZWZhdWx0XFxcIl0pO1xcbnZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1xcXCJkZWZhdWx0XFxcIl0uY29tcG9uZW50KCdsb2dpbi1mb3JtJywgX2NvbXBvbmVudHNfTG9naW5Gb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcImRlZmF1bHRcXFwiXSk7XFxudnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXFxcImRlZmF1bHRcXFwiXS5jb21wb25lbnQoJ2Zvcm0tZmlsZScsIF9jb21wb25lbnRzX2Zvcm1fRmlsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJkZWZhdWx0XFxcIl0pO1xcbnZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1xcXCJkZWZhdWx0XFxcIl0uY29tcG9uZW50KCdpbWFnZS1pdGVyYXRvcicsIF9jb21wb25lbnRzX2Zvcm1fSW1hZ2VJdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1xcXCJkZWZhdWx0XFxcIl0pOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT5cXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1NYWluLWluc3RhbmNlLW9mLVZ1ZS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT5cXG5cXG52YXIgYXBwID0gbmV3IHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1xcXCJkZWZhdWx0XFxcIl0oe1xcbiAgZWw6ICcjYXBwJ1xcbn0pOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tSW5zdGFuY2VzLW9mLVZ1ZS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT5cXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvanMvYXBwLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvanMvY29tcG9uZW50cy9Mb2dpbkZvcm0udnVlXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9qcy9jb21wb25lbnRzL0xvZ2luRm9ybS52dWUgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfTG9naW5Gb3JtX3Z1ZV92dWVfdHlwZV90ZW1wbGF0ZV9pZF9iMzk3YWI5ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vTG9naW5Gb3JtLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1iMzk3YWI5ZSYgKi8gXFxcIi4vc3JjL2pzL2NvbXBvbmVudHMvTG9naW5Gb3JtLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1iMzk3YWI5ZSZcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX0xvZ2luRm9ybV92dWVfdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL0xvZ2luRm9ybS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmICovIFxcXCIuL3NyYy9qcy9jb21wb25lbnRzL0xvZ2luRm9ybS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXFxcIik7XFxuLyogZW1wdHkvdW51c2VkIGhhcm1vbnkgc3RhciByZWV4cG9ydCAqLy8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3J1bnRpbWVfY29tcG9uZW50Tm9ybWFsaXplcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuXFxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xcblxcbnZhciBjb21wb25lbnQgPSBPYmplY3QoX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9ydW50aW1lX2NvbXBvbmVudE5vcm1hbGl6ZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVmYXVsdFxcXCJdKShcXG4gIF9Mb2dpbkZvcm1fdnVlX3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0sXFxuICBfTG9naW5Gb3JtX3Z1ZV92dWVfdHlwZV90ZW1wbGF0ZV9pZF9iMzk3YWI5ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwicmVuZGVyXFxcIl0sXFxuICBfTG9naW5Gb3JtX3Z1ZV92dWVfdHlwZV90ZW1wbGF0ZV9pZF9iMzk3YWI5ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwic3RhdGljUmVuZGVyRm5zXFxcIl0sXFxuICBmYWxzZSxcXG4gIG51bGwsXFxuICBudWxsLFxcbiAgbnVsbFxcbiAgXFxuKVxcblxcbi8qIGhvdCByZWxvYWQgKi9cXG5pZiAoZmFsc2UpIHsgdmFyIGFwaTsgfVxcbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFxcXCJzcmMvanMvY29tcG9uZW50cy9Mb2dpbkZvcm0udnVlXFxcIlxcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcXFwiZGVmYXVsdFxcXCJdID0gKGNvbXBvbmVudC5leHBvcnRzKTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9Mb2dpbkZvcm0udnVlP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvanMvY29tcG9uZW50cy9Mb2dpbkZvcm0udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2pzL2NvbXBvbmVudHMvTG9naW5Gb3JtLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyYgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19iYWJlbF9sb2FkZXJfbGliX2luZGV4X2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfTG9naW5Gb3JtX3Z1ZV92dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Mb2dpbkZvcm0udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8hLi9zcmMvanMvY29tcG9uZW50cy9Mb2dpbkZvcm0udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxcXCIpO1xcbi8qIGVtcHR5L3VudXNlZCBoYXJtb255IHN0YXIgcmVleHBvcnQgKi8gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1xcXCJkZWZhdWx0XFxcIl0gPSAoX25vZGVfbW9kdWxlc19iYWJlbF9sb2FkZXJfbGliX2luZGV4X2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfTG9naW5Gb3JtX3Z1ZV92dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKTsgXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvTG9naW5Gb3JtLnZ1ZT9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2pzL2NvbXBvbmVudHMvTG9naW5Gb3JtLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1iMzk3YWI5ZSZcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9qcy9jb21wb25lbnRzL0xvZ2luRm9ybS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YjM5N2FiOWUmICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfdGVtcGxhdGVMb2FkZXJfanNfdnVlX2xvYWRlcl9vcHRpb25zX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfTG9naW5Gb3JtX3Z1ZV92dWVfdHlwZV90ZW1wbGF0ZV9pZF9iMzk3YWI5ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0xvZ2luRm9ybS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YjM5N2FiOWUmICovIFxcXCIuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8hLi9zcmMvanMvY29tcG9uZW50cy9Mb2dpbkZvcm0udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWIzOTdhYjllJlxcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicmVuZGVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfdGVtcGxhdGVMb2FkZXJfanNfdnVlX2xvYWRlcl9vcHRpb25zX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfTG9naW5Gb3JtX3Z1ZV92dWVfdHlwZV90ZW1wbGF0ZV9pZF9iMzk3YWI5ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwicmVuZGVyXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwic3RhdGljUmVuZGVyRm5zXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfdGVtcGxhdGVMb2FkZXJfanNfdnVlX2xvYWRlcl9vcHRpb25zX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfTG9naW5Gb3JtX3Z1ZV92dWVfdHlwZV90ZW1wbGF0ZV9pZF9iMzk3YWI5ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwic3RhdGljUmVuZGVyRm5zXFxcIl07IH0pO1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL0xvZ2luRm9ybS52dWU/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vRmlsZS52dWVcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9GaWxlLnZ1ZSAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9GaWxlX3Z1ZV92dWVfdHlwZV90ZW1wbGF0ZV9pZF81MTkxYzE4Yl9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vRmlsZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NTE5MWMxOGImICovIFxcXCIuL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vRmlsZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NTE5MWMxOGImXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9GaWxlX3Z1ZV92dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vRmlsZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmICovIFxcXCIuL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vRmlsZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXFxcIik7XFxuLyogZW1wdHkvdW51c2VkIGhhcm1vbnkgc3RhciByZWV4cG9ydCAqLy8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3J1bnRpbWVfY29tcG9uZW50Tm9ybWFsaXplcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuXFxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xcblxcbnZhciBjb21wb25lbnQgPSBPYmplY3QoX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9ydW50aW1lX2NvbXBvbmVudE5vcm1hbGl6ZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVmYXVsdFxcXCJdKShcXG4gIF9GaWxlX3Z1ZV92dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdLFxcbiAgX0ZpbGVfdnVlX3Z1ZV90eXBlX3RlbXBsYXRlX2lkXzUxOTFjMThiX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJyZW5kZXJcXFwiXSxcXG4gIF9GaWxlX3Z1ZV92dWVfdHlwZV90ZW1wbGF0ZV9pZF81MTkxYzE4Yl9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwic3RhdGljUmVuZGVyRm5zXFxcIl0sXFxuICBmYWxzZSxcXG4gIG51bGwsXFxuICBudWxsLFxcbiAgbnVsbFxcbiAgXFxuKVxcblxcbi8qIGhvdCByZWxvYWQgKi9cXG5pZiAoZmFsc2UpIHsgdmFyIGFwaTsgfVxcbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFxcXCJzcmMvanMvY29tcG9uZW50cy9mb3JtL0ZpbGUudnVlXFxcIlxcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcXFwiZGVmYXVsdFxcXCJdID0gKGNvbXBvbmVudC5leHBvcnRzKTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL0ZpbGUudnVlP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL0ZpbGUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9GaWxlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyYgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19iYWJlbF9sb2FkZXJfbGliX2luZGV4X2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfRmlsZV92dWVfdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAtIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vRmlsZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmICovIFxcXCIuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPyEuL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vRmlsZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXFxcIik7XFxuLyogZW1wdHkvdW51c2VkIGhhcm1vbnkgc3RhciByZWV4cG9ydCAqLyAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9IChfbm9kZV9tb2R1bGVzX2JhYmVsX2xvYWRlcl9saWJfaW5kZXhfanNfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19GaWxlX3Z1ZV92dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKTsgXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9GaWxlLnZ1ZT9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9GaWxlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01MTkxYzE4YiZcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vRmlsZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NTE5MWMxOGImICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfdGVtcGxhdGVMb2FkZXJfanNfdnVlX2xvYWRlcl9vcHRpb25zX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfRmlsZV92dWVfdnVlX3R5cGVfdGVtcGxhdGVfaWRfNTE5MWMxOGJfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAtIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9GaWxlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01MTkxYzE4YiYgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPyEuL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vRmlsZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NTE5MWMxOGImXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJyZW5kZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc190ZW1wbGF0ZUxvYWRlcl9qc192dWVfbG9hZGVyX29wdGlvbnNfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19GaWxlX3Z1ZV92dWVfdHlwZV90ZW1wbGF0ZV9pZF81MTkxYzE4Yl9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwicmVuZGVyXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwic3RhdGljUmVuZGVyRm5zXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfdGVtcGxhdGVMb2FkZXJfanNfdnVlX2xvYWRlcl9vcHRpb25zX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfRmlsZV92dWVfdnVlX3R5cGVfdGVtcGxhdGVfaWRfNTE5MWMxOGJfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInN0YXRpY1JlbmRlckZuc1xcXCJdOyB9KTtcXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL0ZpbGUudnVlP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL0ltYWdlSXRlcmF0b3IudnVlXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vSW1hZ2VJdGVyYXRvci52dWUgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfSW1hZ2VJdGVyYXRvcl92dWVfdnVlX3R5cGVfdGVtcGxhdGVfaWRfOWQ5MDQxMmNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL0ltYWdlSXRlcmF0b3IudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTlkOTA0MTJjJiAqLyBcXFwiLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL0ltYWdlSXRlcmF0b3IudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTlkOTA0MTJjJlxcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfSW1hZ2VJdGVyYXRvcl92dWVfdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL0ltYWdlSXRlcmF0b3IudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJiAqLyBcXFwiLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL0ltYWdlSXRlcmF0b3IudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxcXCIpO1xcbi8qIGVtcHR5L3VudXNlZCBoYXJtb255IHN0YXIgcmVleHBvcnQgKi8vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9ydW50aW1lX2NvbXBvbmVudE5vcm1hbGl6ZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1xcXCIpO1xcblxcblxcblxcblxcblxcbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cXG5cXG52YXIgY29tcG9uZW50ID0gT2JqZWN0KF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfcnVudGltZV9jb21wb25lbnROb3JtYWxpemVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkoXFxuICBfSW1hZ2VJdGVyYXRvcl92dWVfdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSxcXG4gIF9JbWFnZUl0ZXJhdG9yX3Z1ZV92dWVfdHlwZV90ZW1wbGF0ZV9pZF85ZDkwNDEyY19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwicmVuZGVyXFxcIl0sXFxuICBfSW1hZ2VJdGVyYXRvcl92dWVfdnVlX3R5cGVfdGVtcGxhdGVfaWRfOWQ5MDQxMmNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInN0YXRpY1JlbmRlckZuc1xcXCJdLFxcbiAgZmFsc2UsXFxuICBudWxsLFxcbiAgbnVsbCxcXG4gIG51bGxcXG4gIFxcbilcXG5cXG4vKiBob3QgcmVsb2FkICovXFxuaWYgKGZhbHNlKSB7IHZhciBhcGk7IH1cXG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcXFwic3JjL2pzL2NvbXBvbmVudHMvZm9ybS9JbWFnZUl0ZXJhdG9yLnZ1ZVxcXCJcXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9IChjb21wb25lbnQuZXhwb3J0cyk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9JbWFnZUl0ZXJhdG9yLnZ1ZT9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9JbWFnZUl0ZXJhdG9yLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vSW1hZ2VJdGVyYXRvci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfYmFiZWxfbG9hZGVyX2xpYl9pbmRleF9qc19ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX0ltYWdlSXRlcmF0b3JfdnVlX3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0ltYWdlSXRlcmF0b3IudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8hLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL0ltYWdlSXRlcmF0b3IudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxcXCIpO1xcbi8qIGVtcHR5L3VudXNlZCBoYXJtb255IHN0YXIgcmVleHBvcnQgKi8gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1xcXCJkZWZhdWx0XFxcIl0gPSAoX25vZGVfbW9kdWxlc19iYWJlbF9sb2FkZXJfbGliX2luZGV4X2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfSW1hZ2VJdGVyYXRvcl92dWVfdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSk7IFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vSW1hZ2VJdGVyYXRvci52dWU/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vSW1hZ2VJdGVyYXRvci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9OWQ5MDQxMmMmXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL0ltYWdlSXRlcmF0b3IudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTlkOTA0MTJjJiAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3RlbXBsYXRlTG9hZGVyX2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX0ltYWdlSXRlcmF0b3JfdnVlX3Z1ZV90eXBlX3RlbXBsYXRlX2lkXzlkOTA0MTJjX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vSW1hZ2VJdGVyYXRvci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9OWQ5MDQxMmMmICovIFxcXCIuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8hLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL0ltYWdlSXRlcmF0b3IudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTlkOTA0MTJjJlxcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicmVuZGVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfdGVtcGxhdGVMb2FkZXJfanNfdnVlX2xvYWRlcl9vcHRpb25zX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfSW1hZ2VJdGVyYXRvcl92dWVfdnVlX3R5cGVfdGVtcGxhdGVfaWRfOWQ5MDQxMmNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInJlbmRlclxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInN0YXRpY1JlbmRlckZuc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3RlbXBsYXRlTG9hZGVyX2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX0ltYWdlSXRlcmF0b3JfdnVlX3Z1ZV90eXBlX3RlbXBsYXRlX2lkXzlkOTA0MTJjX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJzdGF0aWNSZW5kZXJGbnNcXFwiXTsgfSk7XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9JbWFnZUl0ZXJhdG9yLnZ1ZT9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9NdWx0aVNlbGVjdC52dWVcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vTXVsdGlTZWxlY3QudnVlICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9NdWx0aVNlbGVjdF92dWVfdnVlX3R5cGVfdGVtcGxhdGVfaWRfYTQwMWU3NTRfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL011bHRpU2VsZWN0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1hNDAxZTc1NCYgKi8gXFxcIi4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9NdWx0aVNlbGVjdC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YTQwMWU3NTQmXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9NdWx0aVNlbGVjdF92dWVfdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL011bHRpU2VsZWN0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyYgKi8gXFxcIi4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9NdWx0aVNlbGVjdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXFxcIik7XFxuLyogZW1wdHkvdW51c2VkIGhhcm1vbnkgc3RhciByZWV4cG9ydCAqLy8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3J1bnRpbWVfY29tcG9uZW50Tm9ybWFsaXplcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuXFxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xcblxcbnZhciBjb21wb25lbnQgPSBPYmplY3QoX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9ydW50aW1lX2NvbXBvbmVudE5vcm1hbGl6ZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVmYXVsdFxcXCJdKShcXG4gIF9NdWx0aVNlbGVjdF92dWVfdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSxcXG4gIF9NdWx0aVNlbGVjdF92dWVfdnVlX3R5cGVfdGVtcGxhdGVfaWRfYTQwMWU3NTRfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInJlbmRlclxcXCJdLFxcbiAgX011bHRpU2VsZWN0X3Z1ZV92dWVfdHlwZV90ZW1wbGF0ZV9pZF9hNDAxZTc1NF9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwic3RhdGljUmVuZGVyRm5zXFxcIl0sXFxuICBmYWxzZSxcXG4gIG51bGwsXFxuICBudWxsLFxcbiAgbnVsbFxcbiAgXFxuKVxcblxcbi8qIGhvdCByZWxvYWQgKi9cXG5pZiAoZmFsc2UpIHsgdmFyIGFwaTsgfVxcbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFxcXCJzcmMvanMvY29tcG9uZW50cy9mb3JtL011bHRpU2VsZWN0LnZ1ZVxcXCJcXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9IChjb21wb25lbnQuZXhwb3J0cyk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9NdWx0aVNlbGVjdC52dWU/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vTXVsdGlTZWxlY3QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vTXVsdGlTZWxlY3QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJiAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19iYWJlbF9sb2FkZXJfbGliX2luZGV4X2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfTXVsdGlTZWxlY3RfdnVlX3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL011bHRpU2VsZWN0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyYgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/IS4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9NdWx0aVNlbGVjdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXFxcIik7XFxuLyogZW1wdHkvdW51c2VkIGhhcm1vbnkgc3RhciByZWV4cG9ydCAqLyAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9IChfbm9kZV9tb2R1bGVzX2JhYmVsX2xvYWRlcl9saWJfaW5kZXhfanNfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19NdWx0aVNlbGVjdF92dWVfdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSk7IFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vTXVsdGlTZWxlY3QudnVlP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL011bHRpU2VsZWN0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1hNDAxZTc1NCZcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL011bHRpU2VsZWN0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1hNDAxZTc1NCYgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfdGVtcGxhdGVMb2FkZXJfanNfdnVlX2xvYWRlcl9vcHRpb25zX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfTXVsdGlTZWxlY3RfdnVlX3Z1ZV90eXBlX3RlbXBsYXRlX2lkX2E0MDFlNzU0X19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vTXVsdGlTZWxlY3QudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWE0MDFlNzU0JiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/IS4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9NdWx0aVNlbGVjdC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YTQwMWU3NTQmXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJyZW5kZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc190ZW1wbGF0ZUxvYWRlcl9qc192dWVfbG9hZGVyX29wdGlvbnNfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19NdWx0aVNlbGVjdF92dWVfdnVlX3R5cGVfdGVtcGxhdGVfaWRfYTQwMWU3NTRfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInJlbmRlclxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInN0YXRpY1JlbmRlckZuc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3RlbXBsYXRlTG9hZGVyX2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX011bHRpU2VsZWN0X3Z1ZV92dWVfdHlwZV90ZW1wbGF0ZV9pZF9hNDAxZTc1NF9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwic3RhdGljUmVuZGVyRm5zXFxcIl07IH0pO1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vTXVsdGlTZWxlY3QudnVlP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL1NlbGVjdC52dWVcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL1NlbGVjdC52dWUgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9TZWxlY3RfdnVlX3Z1ZV90eXBlX3RlbXBsYXRlX2lkX2I1ZjU4MTZhX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9TZWxlY3QudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWI1ZjU4MTZhJiAqLyBcXFwiLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL1NlbGVjdC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YjVmNTgxNmEmXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9TZWxlY3RfdnVlX3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9TZWxlY3QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJiAqLyBcXFwiLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL1NlbGVjdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXFxcIik7XFxuLyogZW1wdHkvdW51c2VkIGhhcm1vbnkgc3RhciByZWV4cG9ydCAqLy8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3J1bnRpbWVfY29tcG9uZW50Tm9ybWFsaXplcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuXFxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xcblxcbnZhciBjb21wb25lbnQgPSBPYmplY3QoX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9ydW50aW1lX2NvbXBvbmVudE5vcm1hbGl6ZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVmYXVsdFxcXCJdKShcXG4gIF9TZWxlY3RfdnVlX3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0sXFxuICBfU2VsZWN0X3Z1ZV92dWVfdHlwZV90ZW1wbGF0ZV9pZF9iNWY1ODE2YV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwicmVuZGVyXFxcIl0sXFxuICBfU2VsZWN0X3Z1ZV92dWVfdHlwZV90ZW1wbGF0ZV9pZF9iNWY1ODE2YV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwic3RhdGljUmVuZGVyRm5zXFxcIl0sXFxuICBmYWxzZSxcXG4gIG51bGwsXFxuICBudWxsLFxcbiAgbnVsbFxcbiAgXFxuKVxcblxcbi8qIGhvdCByZWxvYWQgKi9cXG5pZiAoZmFsc2UpIHsgdmFyIGFwaTsgfVxcbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFxcXCJzcmMvanMvY29tcG9uZW50cy9mb3JtL1NlbGVjdC52dWVcXFwiXFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1xcXCJkZWZhdWx0XFxcIl0gPSAoY29tcG9uZW50LmV4cG9ydHMpO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vU2VsZWN0LnZ1ZT9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9TZWxlY3QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL1NlbGVjdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19iYWJlbF9sb2FkZXJfbGliX2luZGV4X2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfU2VsZWN0X3Z1ZV92dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9TZWxlY3QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8hLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL1NlbGVjdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXFxcIik7XFxuLyogZW1wdHkvdW51c2VkIGhhcm1vbnkgc3RhciByZWV4cG9ydCAqLyAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9IChfbm9kZV9tb2R1bGVzX2JhYmVsX2xvYWRlcl9saWJfaW5kZXhfanNfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19TZWxlY3RfdnVlX3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pOyBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL1NlbGVjdC52dWU/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9qcy9jb21wb25lbnRzL2Zvcm0vU2VsZWN0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1iNWY1ODE2YSZcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9TZWxlY3QudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWI1ZjU4MTZhJiAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfdGVtcGxhdGVMb2FkZXJfanNfdnVlX2xvYWRlcl9vcHRpb25zX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfU2VsZWN0X3Z1ZV92dWVfdHlwZV90ZW1wbGF0ZV9pZF9iNWY1ODE2YV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1NlbGVjdC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YjVmNTgxNmEmICovIFxcXCIuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8hLi9zcmMvanMvY29tcG9uZW50cy9mb3JtL1NlbGVjdC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YjVmNTgxNmEmXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJyZW5kZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc190ZW1wbGF0ZUxvYWRlcl9qc192dWVfbG9hZGVyX29wdGlvbnNfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19TZWxlY3RfdnVlX3Z1ZV90eXBlX3RlbXBsYXRlX2lkX2I1ZjU4MTZhX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJyZW5kZXJcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJzdGF0aWNSZW5kZXJGbnNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc190ZW1wbGF0ZUxvYWRlcl9qc192dWVfbG9hZGVyX29wdGlvbnNfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19TZWxlY3RfdnVlX3Z1ZV90eXBlX3RlbXBsYXRlX2lkX2I1ZjU4MTZhX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJzdGF0aWNSZW5kZXJGbnNcXFwiXTsgfSk7XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvZm9ybS9TZWxlY3QudnVlP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvanMvbW9kdWVscy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2pzL21vZHVlbHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBtYWluICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJtYWluXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtYWluOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21vZHVsZXNfZm9ybXNfbWFpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tb2R1bGVzL2Zvcm1zL21haW4gKi8gXFxcIi4vc3JjL2pzL21vZHVsZXMvZm9ybXMvbWFpbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kdWxlc19tZW51X21haW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9kdWxlcy9tZW51L21haW4gKi8gXFxcIi4vc3JjL2pzL21vZHVsZXMvbWVudS9tYWluLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tb2R1bGVzX2hlYWRlcl9tYWluX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21vZHVsZXMvaGVhZGVyL21haW4gKi8gXFxcIi4vc3JjL2pzL21vZHVsZXMvaGVhZGVyL21haW4uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21vZHVsZXNfZmlsZW1hbmFnZXJfbWFpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tb2R1bGVzL2ZpbGVtYW5hZ2VyL21haW4gKi8gXFxcIi4vc3JjL2pzL21vZHVsZXMvZmlsZW1hbmFnZXIvbWFpbi5qc1xcXCIpO1xcbi8vIFB1cmUgSlMgbWFpbiBmaWxlXFxuXFxuXFxuXFxuXFxuXFxudmFyIG1haW4gPSBmdW5jdGlvbiBtYWluKCkge1xcbiAgT2JqZWN0KF9tb2R1bGVzX2Zvcm1zX21haW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZm9ybXNNb2R1bGVcXFwiXSkoKTtcXG4gIE9iamVjdChfbW9kdWxlc19tZW51X21haW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwibWVudU1vZHVsZVxcXCJdKSgpO1xcbiAgT2JqZWN0KF9tb2R1bGVzX2hlYWRlcl9tYWluX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImhlYWRlck1vZHVsZVxcXCJdKSgpO1xcbiAgT2JqZWN0KF9tb2R1bGVzX2ZpbGVtYW5hZ2VyX21haW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiZmlsZW1hbmFnZXJNb2R1bGVcXFwiXSkoKTtcXG59O1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL3NyYy9qcy9tb2R1ZWxzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvanMvbW9kdWxlcy9maWxlbWFuYWdlci9ldmVudHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvanMvbW9kdWxlcy9maWxlbWFuYWdlci9ldmVudHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogbGZtICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJsZm1cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxmbTsgfSk7XFxudmFyIGxmbSA9IGZ1bmN0aW9uIGxmbShvcHRpb25zLCBjYikge1xcbiAgdmFyIHJvdXRlX3ByZWZpeCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wcmVmaXggPyBvcHRpb25zLnByZWZpeCA6ICcvbGFyYXZlbC1maWxlbWFuYWdlcic7XFxuICB3aW5kb3cub3Blbihyb3V0ZV9wcmVmaXggKyAnP3R5cGU9JyArIG9wdGlvbnMudHlwZSB8fCAnZmlsZScsICdGaWxlTWFuYWdlcicsICd3aWR0aD0xMjAwLGhlaWdodD05MDAnKTtcXG4gIHdpbmRvdy5TZXRVcmwgPSBjYjtcXG59O1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL3NyYy9qcy9tb2R1bGVzL2ZpbGVtYW5hZ2VyL2V2ZW50cy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2pzL21vZHVsZXMvZmlsZW1hbmFnZXIvbGlzdGVuZXJzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2pzL21vZHVsZXMvZmlsZW1hbmFnZXIvbGlzdGVuZXJzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGxpc3RlbmVycyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwibGlzdGVuZXJzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsaXN0ZW5lcnM7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2V2ZW50cyAqLyBcXFwiLi9zcmMvanMvbW9kdWxlcy9maWxlbWFuYWdlci9ldmVudHMuanNcXFwiKTtcXG5cXG5cXG52YXIgbGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKCkge1xcbiAgbWFuYWdlck9wZW4oKTtcXG59O1xcblxcbnZhciBtYW5hZ2VyT3BlbiA9IGZ1bmN0aW9uIG1hbmFnZXJPcGVuKCkge1xcbiAgdmFyIGl0ZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmpzLW1hbmFnZXItb3BlbicpO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xcbiAgICBpdGVtc1tpXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBjb25zb2xlLmxvZyh0aGlzKTtcXG4gICAgICBjb25zb2xlLmxvZyh0aGlzLm5leHRTaWJsaW5nKTtcXG4gICAgICBPYmplY3QoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJsZm1cXFwiXSkoe1xcbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcXG4gICAgICAgIHByZWZpeDogJy9sYXJhdmVsLWZpbGVtYW5hZ2VyJ1xcbiAgICAgIH0sIGZ1bmN0aW9uICh1cmwsIHBhdGgpIHtcXG4gICAgICAgIGNvbnNvbGUubG9nKHVybCk7XFxuICAgICAgICBjb25zb2xlLmxvZyhwYXRoKTtcXG4gICAgICB9KTtcXG4gICAgICBjb25zb2xlLmxvZygxMjMpO1xcbiAgICB9KTtcXG4gIH1cXG59O1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL3NyYy9qcy9tb2R1bGVzL2ZpbGVtYW5hZ2VyL2xpc3RlbmVycy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2pzL21vZHVsZXMvZmlsZW1hbmFnZXIvbWFpbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvanMvbW9kdWxlcy9maWxlbWFuYWdlci9tYWluLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBmaWxlbWFuYWdlck1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZmlsZW1hbmFnZXJNb2R1bGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZpbGVtYW5hZ2VyTW9kdWxlOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xpc3RlbmVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9saXN0ZW5lcnMgKi8gXFxcIi4vc3JjL2pzL21vZHVsZXMvZmlsZW1hbmFnZXIvbGlzdGVuZXJzLmpzXFxcIik7XFxuXFxuXFxudmFyIGZpbGVtYW5hZ2VyTW9kdWxlID0gZnVuY3Rpb24gZmlsZW1hbmFnZXJNb2R1bGUoKSB7XFxuICBPYmplY3QoX2xpc3RlbmVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJsaXN0ZW5lcnNcXFwiXSkoKTtcXG59O1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL3NyYy9qcy9tb2R1bGVzL2ZpbGVtYW5hZ2VyL21haW4uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9qcy9tb2R1bGVzL2Zvcm1zL2V2ZW50cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9qcy9tb2R1bGVzL2Zvcm1zL2V2ZW50cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiB0YWJDaGFuZ2UgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInRhYkNoYW5nZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGFiQ2hhbmdlOyB9KTtcXG52YXIgdGFiQ2hhbmdlID0gZnVuY3Rpb24gdGFiQ2hhbmdlKCkge1xcbiAgdmFyIHRhYlRpdGxlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jb250ZW50LXdyYXBwZXJfX3RhYicpO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWJUaXRsZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgdGFiVGl0bGVzW2ldLmNsYXNzTGlzdC5yZW1vdmUoJ3RhYi1hY3RpdmUnKTtcXG4gIH1cXG5cXG4gIHRoaXMuY2xhc3NMaXN0LmFkZCgndGFiLWFjdGl2ZScpO1xcbiAgdmFyIHRhYnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY29udGVudC13cmFwcGVyX190YWItZm9ybScpO1xcblxcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRhYnMubGVuZ3RoOyBfaSsrKSB7XFxuICAgIHRhYnNbX2ldLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XFxuICB9XFxuXFxuICB2YXIgYWN0aXZlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNvbnRlbnQtd3JhcHBlcl9fdGFiLWZvcm1bZGF0YS10YWI9XFxcIicgKyB0aGlzLmRhdGFzZXQudGFiICsgJ1xcXCJdJylbMF07XFxuICBhY3RpdmUuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XFxufTtcXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvanMvbW9kdWxlcy9mb3Jtcy9ldmVudHMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9qcy9tb2R1bGVzL2Zvcm1zL2xpc3RlbmVycy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9qcy9tb2R1bGVzL2Zvcm1zL2xpc3RlbmVycy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBsaXN0ZW5lcnMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImxpc3RlbmVyc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbGlzdGVuZXJzOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ldmVudHMgKi8gXFxcIi4vc3JjL2pzL21vZHVsZXMvZm9ybXMvZXZlbnRzLmpzXFxcIik7XFxuXFxuXFxudmFyIGxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycygpIHtcXG4gIHRhYnMoKTtcXG59O1xcblxcbnZhciB0YWJzID0gZnVuY3Rpb24gdGFicygpIHtcXG4gIHZhciBpdGVtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5qcy10YWItY2hhbmdlJyk7XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XFxuICAgIGl0ZW1zW2ldLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJ0YWJDaGFuZ2VcXFwiXSk7XFxuICB9XFxufTtcXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvanMvbW9kdWxlcy9mb3Jtcy9saXN0ZW5lcnMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9qcy9tb2R1bGVzL2Zvcm1zL21haW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2pzL21vZHVsZXMvZm9ybXMvbWFpbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZm9ybXNNb2R1bGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImZvcm1zTW9kdWxlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmb3Jtc01vZHVsZTsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9saXN0ZW5lcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGlzdGVuZXJzICovIFxcXCIuL3NyYy9qcy9tb2R1bGVzL2Zvcm1zL2xpc3RlbmVycy5qc1xcXCIpO1xcblxcblxcbnZhciBmb3Jtc01vZHVsZSA9IGZ1bmN0aW9uIGZvcm1zTW9kdWxlKCkge1xcbiAgT2JqZWN0KF9saXN0ZW5lcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwibGlzdGVuZXJzXFxcIl0pKCk7XFxufTtcXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvanMvbW9kdWxlcy9mb3Jtcy9tYWluLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvanMvbW9kdWxlcy9mb3Jtcy9yZWRhY3Rvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2pzL21vZHVsZXMvZm9ybXMvcmVkYWN0b3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBDS0VkaXRvciAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiQ0tFZGl0b3JcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENLRWRpdG9yOyB9KTtcXG4vLyBvbmxvYWRcXG52YXIgQ0tFZGl0b3IgPSBmdW5jdGlvbiBDS0VkaXRvcigpIHtcXG4gIHdpbmRvdy50aW55bWNlLmluaXQoe1xcbiAgICBzZWxlY3RvcjogJy5qcy1yZWRhY3RvcidcXG4gIH0pO1xcbn07XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2pzL21vZHVsZXMvZm9ybXMvcmVkYWN0b3IuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9qcy9tb2R1bGVzL2hlYWRlci9ldmVudHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2pzL21vZHVsZXMvaGVhZGVyL2V2ZW50cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogbG9nb3V0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJsb2dvdXRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZ291dDsgfSk7XFxudmFyIGxvZ291dCA9IGZ1bmN0aW9uIGxvZ291dCgpIHtcXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2dvdXQtZm9ybScpLnN1Ym1pdCgpO1xcbn07XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2pzL21vZHVsZXMvaGVhZGVyL2V2ZW50cy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2pzL21vZHVsZXMvaGVhZGVyL2xpc3RlbmVycy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvanMvbW9kdWxlcy9oZWFkZXIvbGlzdGVuZXJzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBsaXN0ZW5lcnMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImxpc3RlbmVyc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbGlzdGVuZXJzOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ldmVudHMgKi8gXFxcIi4vc3JjL2pzL21vZHVsZXMvaGVhZGVyL2V2ZW50cy5qc1xcXCIpO1xcblxcblxcbnZhciBsaXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoKSB7XFxuICBsb2dvdXRMaXN0ZW5lcigpO1xcbn07XFxuXFxudmFyIGxvZ291dExpc3RlbmVyID0gZnVuY3Rpb24gbG9nb3V0TGlzdGVuZXIoKSB7XFxuICB2YXIgYnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnanMtbG9nb3V0JylbMF07XFxuICBpZiAoYnV0dG9uKSBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImxvZ291dFxcXCJdKTtcXG59O1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL3NyYy9qcy9tb2R1bGVzL2hlYWRlci9saXN0ZW5lcnMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9qcy9tb2R1bGVzL2hlYWRlci9tYWluLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvanMvbW9kdWxlcy9oZWFkZXIvbWFpbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGhlYWRlck1vZHVsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiaGVhZGVyTW9kdWxlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBoZWFkZXJNb2R1bGU7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbGlzdGVuZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xpc3RlbmVycyAqLyBcXFwiLi9zcmMvanMvbW9kdWxlcy9oZWFkZXIvbGlzdGVuZXJzLmpzXFxcIik7XFxuXFxuXFxudmFyIGhlYWRlck1vZHVsZSA9IGZ1bmN0aW9uIGhlYWRlck1vZHVsZSgpIHtcXG4gIE9iamVjdChfbGlzdGVuZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImxpc3RlbmVyc1xcXCJdKSgpO1xcbn07XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2pzL21vZHVsZXMvaGVhZGVyL21haW4uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9qcy9tb2R1bGVzL21lbnUvZXZlbnRzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvanMvbW9kdWxlcy9tZW51L2V2ZW50cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IG1lbnVUb2dnbGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIm1lbnVUb2dnbGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1lbnVUb2dnbGU7IH0pO1xcbnZhciBtZW51VG9nZ2xlID0gZnVuY3Rpb24gbWVudVRvZ2dsZSgpIHtcXG4gIHZhciBpZCA9IHRoaXMuZGF0YXNldC50b2dnbGU7XFxuICB2YXIgY2hpbGRyZW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuanMtbWVudS1pdGVtLXRvZ2dsZVtkYXRhLXRvZ2dsZT1cXFwiJyArIGlkICsgJ1xcXCJdJyk7XFxuICBjaGlsZHJlbi5zdHlsZS5kaXNwbGF5ID0gY2hpbGRyZW4uc3R5bGUuZGlzcGxheSA9PT0gJ2ZsZXgnID8gJ25vbmUnIDogJ2ZsZXgnO1xcbn07XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2pzL21vZHVsZXMvbWVudS9ldmVudHMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9qcy9tb2R1bGVzL21lbnUvbGlzdGVuZXJzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvanMvbW9kdWxlcy9tZW51L2xpc3RlbmVycy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGxpc3RlbmVycyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwibGlzdGVuZXJzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsaXN0ZW5lcnM7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2V2ZW50cyAqLyBcXFwiLi9zcmMvanMvbW9kdWxlcy9tZW51L2V2ZW50cy5qc1xcXCIpO1xcblxcblxcbnZhciBsaXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoKSB7XFxuICBtZW51SXRlbSgpO1xcbn07XFxuXFxudmFyIG1lbnVJdGVtID0gZnVuY3Rpb24gbWVudUl0ZW0oKSB7XFxuICB2YXIgaXRlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuanMtbWVudS1pdGVtJyk7XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XFxuICAgIGl0ZW1zW2ldLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJtZW51VG9nZ2xlXFxcIl0pO1xcbiAgfVxcbn07XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2pzL21vZHVsZXMvbWVudS9saXN0ZW5lcnMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9qcy9tb2R1bGVzL21lbnUvbWFpbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9qcy9tb2R1bGVzL21lbnUvbWFpbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBtZW51TW9kdWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJtZW51TW9kdWxlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtZW51TW9kdWxlOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xpc3RlbmVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9saXN0ZW5lcnMgKi8gXFxcIi4vc3JjL2pzL21vZHVsZXMvbWVudS9saXN0ZW5lcnMuanNcXFwiKTtcXG5cXG5cXG52YXIgbWVudU1vZHVsZSA9IGZ1bmN0aW9uIG1lbnVNb2R1bGUoKSB7XFxuICBPYmplY3QoX2xpc3RlbmVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJsaXN0ZW5lcnNcXFwiXSkoKTtcXG59O1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL3NyYy9qcy9tb2R1bGVzL21lbnUvbWFpbi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2pzL21vZHVsZXMvb25sb2FkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2pzL21vZHVsZXMvb25sb2FkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IG9ubG9hZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwib25sb2FkXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBvbmxvYWQ7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm9ybXNfcmVkYWN0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm9ybXMvcmVkYWN0b3IgKi8gXFxcIi4vc3JjL2pzL21vZHVsZXMvZm9ybXMvcmVkYWN0b3IuanNcXFwiKTtcXG5cXG5cXG52YXIgb25sb2FkID0gZnVuY3Rpb24gb25sb2FkKCkge1xcbiAgT2JqZWN0KF9mb3Jtc19yZWRhY3Rvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJDS0VkaXRvclxcXCJdKSgpO1xcbn07XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2pzL21vZHVsZXMvb25sb2FkLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDA6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogbXVsdGkgcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lIC4vc3JjL2pzL2FwcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISByZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUgKi9cXFwiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXFxcIik7XFxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9qcy9hcHAuanMgKi9cXFwiLi9zcmMvanMvYXBwLmpzXFxcIik7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vL211bHRpX3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZV8uL3NyYy9qcy9hcHAuanM/XCIpO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyB9KTsiXSwiZmlsZSI6ImFwcC5qcyJ9
